#![allow(non_snake_case)]
#![allow(non_camel_case_types)]

/// THIS FILE WAS AUTOMATICALLY GENERATED.
/// Don't edit manually, instead edit the generator.
///

use {Ip4Addr, IpPort, Message, Quaternion, ReadError, ReadErrorKind, Uuid, Vector3, Vector4,
     WriteMessageResult};

use arrayvec::ArrayVec;
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use std::io::{Read, Write};
#[derive(Clone, Debug)]
pub struct AbortXfer_XferID {
    /// TODO
    pub id: u64,
    /// TODO
    pub result: i32,
}

/// TODO:
/// /// AbortXfer
///
#[derive(Clone, Debug)]
pub struct AbortXfer {
    pub xfer_id: AbortXfer_XferID,
}


#[derive(Clone, Debug)]
pub struct AcceptCallingCard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AcceptCallingCard_TransactionBlock {
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AcceptCallingCard_FolderData {
    /// TODO
    pub folder_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AcceptCallingCard {
    pub agent_data: AcceptCallingCard_AgentData,
    pub transaction_block: AcceptCallingCard_TransactionBlock,
    pub folder_data: Vec<AcceptCallingCard_FolderData>,
}


#[derive(Clone, Debug)]
pub struct AcceptFriendship_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AcceptFriendship_TransactionBlock {
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AcceptFriendship_FolderData {
    /// TODO
    pub folder_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AcceptFriendship {
    pub agent_data: AcceptFriendship_AgentData,
    pub transaction_block: AcceptFriendship_TransactionBlock,
    pub folder_data: Vec<AcceptFriendship_FolderData>,
}


#[derive(Clone, Debug)]
pub struct ActivateGestures_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
}

#[derive(Clone, Debug)]
pub struct ActivateGestures_Data {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub gesture_flags: u32,
}

/// 		TODO:
/// 		/// Tell the database that some gestures are now active
/// /// viewer -> sim -> data
///
#[derive(Clone, Debug)]
pub struct ActivateGestures {
    pub agent_data: ActivateGestures_AgentData,
    pub data: Vec<ActivateGestures_Data>,
}


#[derive(Clone, Debug)]
pub struct ActivateGroup_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// used to switch an agent's currently active group.
/// /// viewer -> simulator -> dataserver -> AgentDataUpdate...
///
#[derive(Clone, Debug)]
pub struct ActivateGroup {
    pub agent_data: ActivateGroup_AgentData,
}


#[derive(Clone, Debug)]
pub struct AddCircuitCode_CircuitCode {
    /// TODO
    pub code: u32,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub agent_id: Uuid,
}

/// 		TODO:
/// 		/// space->sim
/// /// sim->sim
/// /// AddCircuitCode - Tells the recipient's messaging system that this code
/// /// is for a legal circuit
///
#[derive(Clone, Debug)]
pub struct AddCircuitCode {
    pub circuit_code: AddCircuitCode_CircuitCode,
}


#[derive(Clone, Debug)]
pub struct AgentAlertMessage_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentAlertMessage_AlertData {
    /// TODO
    pub modal: bool,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// Send an AlertMessage to the named agent.
/// /// usually dataserver->simulator
///
#[derive(Clone, Debug)]
pub struct AgentAlertMessage {
    pub agent_data: AgentAlertMessage_AgentData,
    pub alert_data: AgentAlertMessage_AlertData,
}


#[derive(Clone, Debug)]
pub struct AgentAnimation_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentAnimation_AnimationList {
    /// TODO
    pub anim_id: Uuid,
    /// TODO
    pub start_anim: bool,
}

#[derive(Clone, Debug)]
pub struct AgentAnimation_PhysicalAvatarEventList {
    /// TODO
    pub type_data: Vec<u8>,
}

/// 		TODO:
/// 		/// AgentAnimation - Update animation state
/// /// viewer --> simulator
///
#[derive(Clone, Debug)]
pub struct AgentAnimation {
    pub agent_data: AgentAnimation_AgentData,
    pub animation_list: Vec<AgentAnimation_AnimationList>,
    pub physical_avatar_event_list: Vec<AgentAnimation_PhysicalAvatarEventList>,
}


#[derive(Clone, Debug)]
pub struct AgentCachedTexture_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: i32,
}

#[derive(Clone, Debug)]
pub struct AgentCachedTexture_WearableData {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub texture_index: u8,
}

/// 		TODO:
/// 		/// AgentCachedTexture
/// /// viewer queries for cached textures on dataserver (via simulator)
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentCachedTexture {
    pub agent_data: AgentCachedTexture_AgentData,
    pub wearable_data: Vec<AgentCachedTexture_WearableData>,
}


#[derive(Clone, Debug)]
pub struct AgentCachedTextureResponse_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: i32,
}

#[derive(Clone, Debug)]
pub struct AgentCachedTextureResponse_WearableData {
    /// TODO
    pub texture_id: Uuid,
    /// TODO
    pub texture_index: u8,
    /// TODO
    pub host_name: Vec<u8>,
}

/// 		TODO:
/// 		/// AgentCachedTextureResponse
/// /// response to viewer queries for cached textures on dataserver (via simulator)
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentCachedTextureResponse {
    pub agent_data: AgentCachedTextureResponse_AgentData,
    pub wearable_data: Vec<AgentCachedTextureResponse_WearableData>,
}


#[derive(Clone, Debug)]
pub struct AgentDataUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub first_name: Vec<u8>,
    /// TODO
    pub last_name: Vec<u8>,
    /// TODO
    pub group_title: Vec<u8>,
    /// TODO
    pub active_group_id: Uuid,
    /// TODO
    pub group_powers: u64,
    /// TODO
    pub group_name: Vec<u8>,
}

/// 		TODO:
/// 		/// AgentDataUpdate
/// /// Updates a viewer or simulator's impression of agent-specific information.
/// /// Used, for example, when an agent's group changes.
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentDataUpdate {
    pub agent_data: AgentDataUpdate_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentDataUpdateRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
/// /// Request an AgentDataUpdate without changing any agent data.
///
#[derive(Clone, Debug)]
pub struct AgentDataUpdateRequest {
    pub agent_data: AgentDataUpdateRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentDropGroup_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// AgentDropGroup
/// /// Updates the viewer / simulator that an agent is no longer part of a group
/// /// dataserver -> simulator -> viewer
/// /// dataserver -> userserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentDropGroup {
    pub agent_data: AgentDropGroup_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentFOV_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub circuit_code: u32,
}

#[derive(Clone, Debug)]
pub struct AgentFOV_FOVBlock {
    /// TODO
    pub gen_counter: u32,
    /// TODO
    pub vertical_angle: f32,
}

/// TODO:
/// /// AgentFOV - Update to agent's field of view, angle is vertical, single F32 float in radians
///
#[derive(Clone, Debug)]
pub struct AgentFOV {
    pub agent_data: AgentFOV_AgentData,
    pub fov_block: AgentFOV_FOVBlock,
}


#[derive(Clone, Debug)]
pub struct AgentGroupDataUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentGroupDataUpdate_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub group_powers: u64,
    /// TODO
    pub accept_notices: bool,
    /// TODO
    pub group_insignia_id: Uuid,
    /// TODO
    pub contribution: i32,
    /// TODO
    pub group_name: Vec<u8>,
}

/// 		TODO:
/// 		/// AgentGroupDataUpdate
/// /// Updates a viewer or simulator's impression of the groups an agent is in.
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentGroupDataUpdate {
    pub agent_data: AgentGroupDataUpdate_AgentData,
    pub group_data: Vec<AgentGroupDataUpdate_GroupData>,
}


#[derive(Clone, Debug)]
pub struct AgentHeightWidth_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub circuit_code: u32,
}

#[derive(Clone, Debug)]
pub struct AgentHeightWidth_HeightWidthBlock {
    /// TODO
    pub gen_counter: u32,
    /// TODO
    pub height: u16,
    /// TODO
    pub width: u16,
}

/// 		TODO:
/// 		/// AgentHeightWidth - Update to height and aspect, sent as height/width to save space
/// /// Usually sent when window resized or created
///
#[derive(Clone, Debug)]
pub struct AgentHeightWidth {
    pub agent_data: AgentHeightWidth_AgentData,
    pub height_width_block: AgentHeightWidth_HeightWidthBlock,
}


#[derive(Clone, Debug)]
pub struct AgentIsNowWearing_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentIsNowWearing_WearableData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub wearable_type: u8,
}

/// 		TODO:
/// 		///
/// /// AgentIsNowWearing
/// /// (a.k.a. "Here's what I'm wearing now.")
/// /// viewer->sim->dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentIsNowWearing {
    pub agent_data: AgentIsNowWearing_AgentData,
    pub wearable_data: Vec<AgentIsNowWearing_WearableData>,
}


#[derive(Clone, Debug)]
pub struct AgentMovementComplete_AgentData {
    /// Agent id of the sender.
    pub agent_id: Uuid,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentMovementComplete_Data {
    /// Exact position of the avatar.
    pub position: Vector3<f32>,
    /// Direction in which the camera is oriented.
    pub look_at: Vector3<f32>,
    /// TODO
    pub region_handle: u64,
    /// Unix epoch timestamp.
    pub timestamp: u32,
}

#[derive(Clone, Debug)]
pub struct AgentMovementComplete_SimData {
    /// TODO
    pub channel_version: Vec<u8>,
}

/// This is one of the very first packets sent from the sim to the viewer on connection,
/// to provide the viewer with detailed information of its position.
///
#[derive(Clone, Debug)]
pub struct AgentMovementComplete {
    pub agent_data: AgentMovementComplete_AgentData,
    pub data: AgentMovementComplete_Data,
    pub sim_data: AgentMovementComplete_SimData,
}


#[derive(Clone, Debug)]
pub struct AgentPause_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: u32,
}

/// TODO:
/// /// AgentPause - viewer occasionally will block, inform simulator of this fact
///
#[derive(Clone, Debug)]
pub struct AgentPause {
    pub agent_data: AgentPause_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentQuitCopy_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentQuitCopy_FuseBlock {
    /// TODO
    pub viewer_circuit_code: u32,
}

/// TODO:
/// /// quit message sent between simulators
///
#[derive(Clone, Debug)]
pub struct AgentQuitCopy {
    pub agent_data: AgentQuitCopy_AgentData,
    pub fuse_block: AgentQuitCopy_FuseBlock,
}


#[derive(Clone, Debug)]
pub struct AgentRequestSit_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AgentRequestSit_TargetObject {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub offset: Vector3<f32>,
}

/// TODO:
/// /// AgentRequestSit - Try to sit on an object
///
#[derive(Clone, Debug)]
pub struct AgentRequestSit {
    pub agent_data: AgentRequestSit_AgentData,
    pub target_object: AgentRequestSit_TargetObject,
}


#[derive(Clone, Debug)]
pub struct AgentResume_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: u32,
}

/// TODO:
/// /// AgentResume - unblock the agent
///
#[derive(Clone, Debug)]
pub struct AgentResume {
    pub agent_data: AgentResume_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentSetAppearance_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: u32,
    /// TODO
    pub size: Vector3<f32>,
}

#[derive(Clone, Debug)]
pub struct AgentSetAppearance_WearableData {
    /// TODO
    pub cache_id: Uuid,
    /// TODO
    pub texture_index: u8,
}

#[derive(Clone, Debug)]
pub struct AgentSetAppearance_ObjectData {
    /// TODO
    pub texture_entry: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct AgentSetAppearance_VisualParam {
    /// TODO
    pub param_value: u8,
}

/// TODO:
/// /// AgentSetAppearance - Update to agent appearance
///
#[derive(Clone, Debug)]
pub struct AgentSetAppearance {
    pub agent_data: AgentSetAppearance_AgentData,
    pub wearable_data: Vec<AgentSetAppearance_WearableData>,
    pub object_data: AgentSetAppearance_ObjectData,
    pub visual_param: Vec<AgentSetAppearance_VisualParam>,
}


#[derive(Clone, Debug)]
pub struct AgentSit_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
/// /// AgentSit - Actually sit on object
///
#[derive(Clone, Debug)]
pub struct AgentSit {
    pub agent_data: AgentSit_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentThrottle_AgentData {
    /// Agent id of the client.
    pub agent_id: Uuid,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
    /// The circuit code as provided in the login response. It serves as a
    /// proof of authentication and identfies the client.
    pub circuit_code: u32,
}

#[derive(Clone, Debug)]
pub struct AgentThrottle_Throttle {
    /// Clients can set this value to 0.
    pub gen_counter: u32,
    /// Throttle values describe the maximum bits per second to be spent for various aspects of
    /// the circuit. They are provided in the form of the following sequence of 32 bit floats of
    /// little endian ordering:
    ///
    /// Resend:  traffic resending unacknowledged packets
    /// Land:    traffic for LayerData terrain
    /// Wind:    traffic for LayerData wind data
    /// Cloud:   traffic for LayerData clouds
    /// Task:    unknown
    /// Texture: traffic for textures
    /// Asset:   traffic for assets
    ///
    pub throttles: Vec<u8>,
}

/// Request peer to throttle specific aspects of networking.
///
#[derive(Clone, Debug)]
pub struct AgentThrottle {
    pub agent_data: AgentThrottle_AgentData,
    pub throttle: AgentThrottle_Throttle,
}


#[derive(Clone, Debug)]
pub struct AgentUpdate_AgentData {
    /// Agent id of the sender.
    pub agent_id: Uuid,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
    /// TODO
    pub body_rotation: Quaternion<f32>,
    /// TODO
    pub head_rotation: Quaternion<f32>,
    /// Indicates current behavior state:
    ///
    /// 0: walking
    /// 1: mouselook
    /// 2: typing
    ///
    pub state: u8,
    /// Region local center coordinates of the camera.
    pub camera_center: Vector3<f32>,
    /// Camera coordinate axis in looking _at_ direction (forward).
    /// TODO: Check how these are provided? Most likely unit distance from camera
    /// center into the direction of the coordinate axis?
    ///
    pub camera_at_axis: Vector3<f32>,
    /// Camera coordinate axis, left direction.
    pub camera_left_axis: Vector3<f32>,
    /// Camera coordinate axis, up direction.
    pub camera_up_axis: Vector3<f32>,
    /// TODO
    pub far: f32,
    /// On/off bits for movement keys which the server then feeds into the physics engine
    /// to compute actual movement of the client. The server then sends updates back to the
    /// clients (TODO: which packet?).
    ///
    /// TODO:
    ///  - If we send a flag and then stop what happens with the agent? According to what I saw
    ///    so far the agent derenders but maybe this is also due to bugs in my code.
    ///
    /// The official viewer rapidly polls for currently pressed keys, sets the flags and sends the
    /// packet, then resets the flags until the next polling interval.
    ///
    /// Flags (encoded as 32 bit integer, in the encoding column the bit number from least
    /// significant to most significant bit is listed for each flag):
    ///
    /// | Encoding | Flag            | Description
    /// | SL keybinding         |
    /// |----------|-----------------|---------------------------------------------------------------|-----------------------|
    /// | 0x0      | EMPTY           | TODO
    /// |                       | | 1        | MOVE_FWD_POS    | Move forward
    /// | W/Up arrow            | | 2        | MOVE_FWD_NEG    | Move backward
    /// | s/down arrow          | | 3        | MOVE_LEFT_POS   | Move left
    /// | shift-(a/left arrow)  | | 4        | MOVE_LEFT_NEG   | Move right
    /// | shift-(d/right arrow) | | 5        | MOVE_UP_POS     | not flying: jump; flying:
    /// move up                             | e                     | | 6        | MOVE_UP_NEG
    /// | not flying: croutch; flying: move down                        | c                     |
    /// | 7        |                 | unused
    /// |                       | | 8        |                 | unused
    /// |                       | | 9        |                 | unused
    /// |                       | | 10       |                 | unused
    /// |                       | | 11       | FAST_FWD        | OR-ed with
    /// agent_control_fwd_* if the keyboard is being used  | todo                  | | 12
    /// | FAST_LEFT       | OR-ed with agent_control_left_* if the keyboard is being used | todo
    /// | | 13       | FAST_UP         | OR-ed with agent_control_up_* if the keyboard is
    /// being used   | todo                  | | 14       | FLY             | Fly
    /// |                       | | 15       | STOP            | TODO
    /// |                       | | 16       | FINISH_ANIM     | Finish the current animation
    /// |                       | | 17       | STAND_UP        | Stand up from the ground or a
    /// prim seat                       |                       | | 18       | SIT_ON_GROUND
    /// | Sit on the ground at the current location                     |                       |
    /// | 19       | MOUSELOOK       |
    /// |                       | | 20       |                 | legacy
    /// |                       | | 21       |                 | legacy
    /// |                       | | 22       |                 | legacy
    /// |                       | | 23       |                 | legacy
    /// |                       | | 24       |                 | legacy
    /// |                       | | 25       |                 | legacy
    /// |                       | | 26       | TURN_LEFT       |
    /// |                       | | 27       | TURN_RIGHT      |
    /// |                       | | 28       | AWAY            | Set when the avatar is idled
    /// or set to away. Note that the away animation is activated separately from setting this
    /// flag. |  | | 29       | LBUTTON_DOWN    |
    /// |                       | | 30       | LBUTTON_UP      |
    /// |                       | | 31       | ML_LBUTTON_DOWN |
    /// |                       | | 32       | ML_LBUTTON_UP   |
    /// |                       |
    ///
    pub control_flags: u32,
    /// TODO: what are these?
    ///
    pub flags: u8,
}

///         Camera and movement info about an agent sent from viewer to simulator.
///
///         Sent up to 10 times per second, but must be sent at least every now and then.
///
///         TODO:
///         /// AgentUpdate - Camera info sent from viewer to simulator
/// /// or, more simply, two axes and compute cross product
/// /// Center is region local (JNC 8.16.2001)
/// /// Camera center is region local (JNC 8.29.2001)
///
#[derive(Clone, Debug)]
pub struct AgentUpdate {
    pub agent_data: AgentUpdate_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentWearablesRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// AgentWearablesRequest
/// /// (a.k.a. "Tell me what the avatar is wearing.")
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AgentWearablesRequest {
    pub agent_data: AgentWearablesRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct AgentWearablesUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub serial_num: u32,
}

#[derive(Clone, Debug)]
pub struct AgentWearablesUpdate_WearableData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub wearable_type: u8,
}

/// 		TODO:
/// 		/// AgentWearablesUpdate
/// /// (a.k.a. "Here's what your avatar should be wearing now.")
/// /// dataserver -> userserver -> viewer
/// /// reliable
/// /// NEVER from viewer to sim
///
#[derive(Clone, Debug)]
pub struct AgentWearablesUpdate {
    pub agent_data: AgentWearablesUpdate_AgentData,
    pub wearable_data: Vec<AgentWearablesUpdate_WearableData>,
}


#[derive(Clone, Debug)]
pub struct AlertMessage_AlertData {
    /// TODO
    pub message: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct AlertMessage_AlertInfo {
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub extra_params: Vec<u8>,
}

/// 		TODO:
/// 		/// AlertMessage
/// /// Specifies the text to be posted in an alert dialog
///
#[derive(Clone, Debug)]
pub struct AlertMessage {
    pub alert_data: AlertMessage_AlertData,
    pub alert_info: Vec<AlertMessage_AlertInfo>,
}


#[derive(Clone, Debug)]
pub struct AssetUploadComplete_AssetBlock {
    /// TODO
    pub uuid: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub success: bool,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AssetUploadComplete {
    pub asset_block: AssetUploadComplete_AssetBlock,
}


#[derive(Clone, Debug)]
pub struct AssetUploadRequest_AssetBlock {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub tempfile: bool,
    /// TODO
    pub store_local: bool,
    /// TODO
    pub asset_data: Vec<u8>,
}

/// TODO:
/// /// current assumes an existing UUID, need to enhance for new assets
///
#[derive(Clone, Debug)]
pub struct AssetUploadRequest {
    pub asset_block: AssetUploadRequest_AssetBlock,
}


#[derive(Clone, Debug)]
pub struct AtomicPassObject_TaskData {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub attachment_needs_save: bool,
}

/// TODO:
/// /// This message is sent how objects get passed between regions.
///
#[derive(Clone, Debug)]
pub struct AtomicPassObject {
    pub task_data: AtomicPassObject_TaskData,
}


#[derive(Clone, Debug)]
pub struct AttachedSound_DataBlock {
    /// TODO
    pub sound_id: Uuid,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub gain: f32,
    /// TODO
    pub flags: u8,
}

/// TODO:
/// /// AttachedSound - Sent by simulator to viewer to play sound attached with an object
///
#[derive(Clone, Debug)]
pub struct AttachedSound {
    pub data_block: AttachedSound_DataBlock,
}


#[derive(Clone, Debug)]
pub struct AttachedSoundGainChange_DataBlock {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub gain: f32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AttachedSoundGainChange {
    pub data_block: AttachedSoundGainChange_DataBlock,
}


#[derive(Clone, Debug)]
pub struct AvatarAnimation_Sender {
    /// TODO
    pub id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarAnimation_AnimationList {
    /// TODO
    pub anim_id: Uuid,
    /// TODO
    pub anim_sequence_id: i32,
}

#[derive(Clone, Debug)]
pub struct AvatarAnimation_AnimationSourceList {
    /// TODO
    pub object_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarAnimation_PhysicalAvatarEventList {
    /// TODO
    pub type_data: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AvatarAnimation {
    pub sender: AvatarAnimation_Sender,
    pub animation_list: Vec<AvatarAnimation_AnimationList>,
    pub animation_source_list: Vec<AvatarAnimation_AnimationSourceList>,
    pub physical_avatar_event_list: Vec<AvatarAnimation_PhysicalAvatarEventList>,
}


#[derive(Clone, Debug)]
pub struct AvatarAppearance_Sender {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub is_trial: bool,
}

#[derive(Clone, Debug)]
pub struct AvatarAppearance_ObjectData {
    /// TODO
    pub texture_entry: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct AvatarAppearance_VisualParam {
    /// TODO
    pub param_value: u8,
}

/// TODO:
/// /// AvatarAppearance - Update visual params
///
#[derive(Clone, Debug)]
pub struct AvatarAppearance {
    pub sender: AvatarAppearance_Sender,
    pub object_data: AvatarAppearance_ObjectData,
    pub visual_param: Vec<AvatarAppearance_VisualParam>,
}


#[derive(Clone, Debug)]
pub struct AvatarClassifiedReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub target_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarClassifiedReply_Data {
    /// TODO
    pub classified_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarClassifiedReply
/// /// dataserver -> simulator -> viewer
/// /// Send the header information for this avatar's classifieds
/// /// This fills in the tabs of the Classifieds panel.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarClassifiedReply {
    pub agent_data: AvatarClassifiedReply_AgentData,
    pub data: Vec<AvatarClassifiedReply_Data>,
}


#[derive(Clone, Debug)]
pub struct AvatarGroupsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub avatar_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarGroupsReply_GroupData {
    /// TODO
    pub group_powers: u64,
    /// TODO
    pub accept_notices: bool,
    /// TODO
    pub group_title: Vec<u8>,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub group_name: Vec<u8>,
    /// TODO
    pub group_insignia_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarGroupsReply_NewGroupData {
    /// TODO
    pub list_in_profile: bool,
}

/// 		TODO:
/// 		/// AvatarGroupsReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarGroupsReply {
    pub agent_data: AvatarGroupsReply_AgentData,
    pub group_data: Vec<AvatarGroupsReply_GroupData>,
    pub new_group_data: AvatarGroupsReply_NewGroupData,
}


#[derive(Clone, Debug)]
pub struct AvatarInterestsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub avatar_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarInterestsReply_PropertiesData {
    /// TODO
    pub want_to_mask: u32,
    /// TODO
    pub want_to_text: Vec<u8>,
    /// TODO
    pub skills_mask: u32,
    /// TODO
    pub skills_text: Vec<u8>,
    /// TODO
    pub languages_text: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct AvatarInterestsReply {
    pub agent_data: AvatarInterestsReply_AgentData,
    pub properties_data: AvatarInterestsReply_PropertiesData,
}


#[derive(Clone, Debug)]
pub struct AvatarInterestsUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarInterestsUpdate_PropertiesData {
    /// TODO
    pub want_to_mask: u32,
    /// TODO
    pub want_to_text: Vec<u8>,
    /// TODO
    pub skills_mask: u32,
    /// TODO
    pub skills_text: Vec<u8>,
    /// TODO
    pub languages_text: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarInterestsUpdate
/// /// viewer -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarInterestsUpdate {
    pub agent_data: AvatarInterestsUpdate_AgentData,
    pub properties_data: AvatarInterestsUpdate_PropertiesData,
}


#[derive(Clone, Debug)]
pub struct AvatarNotesReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarNotesReply_Data {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub notes: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarNotesReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarNotesReply {
    pub agent_data: AvatarNotesReply_AgentData,
    pub data: AvatarNotesReply_Data,
}


#[derive(Clone, Debug)]
pub struct AvatarNotesUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarNotesUpdate_Data {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub notes: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarNotesUpdate
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarNotesUpdate {
    pub agent_data: AvatarNotesUpdate_AgentData,
    pub data: AvatarNotesUpdate_Data,
}


#[derive(Clone, Debug)]
pub struct AvatarPickerReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarPickerReply_Data {
    /// TODO
    pub avatar_id: Uuid,
    /// TODO
    pub first_name: Vec<u8>,
    /// TODO
    pub last_name: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarPickerReply
/// /// List of names to select a person
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPickerReply {
    pub agent_data: AvatarPickerReply_AgentData,
    pub data: Vec<AvatarPickerReply_Data>,
}


#[derive(Clone, Debug)]
pub struct AvatarPickerRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarPickerRequest_Data {
    /// TODO
    pub name: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarPickerRequest
/// /// Get a list of names to select a person
/// /// viewer -> sim -> data
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPickerRequest {
    pub agent_data: AvatarPickerRequest_AgentData,
    pub data: AvatarPickerRequest_Data,
}


#[derive(Clone, Debug)]
pub struct AvatarPickerRequestBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub god_level: u8,
}

#[derive(Clone, Debug)]
pub struct AvatarPickerRequestBackend_Data {
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
/// /// backend implementation which tracks if the user is a god.
///
#[derive(Clone, Debug)]
pub struct AvatarPickerRequestBackend {
    pub agent_data: AvatarPickerRequestBackend_AgentData,
    pub data: AvatarPickerRequestBackend_Data,
}


#[derive(Clone, Debug)]
pub struct AvatarPicksReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub target_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarPicksReply_Data {
    /// TODO
    pub pick_id: Uuid,
    /// TODO
    pub pick_name: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarPicksReply
/// /// dataserver -> simulator -> viewer
/// /// Send the header information for this avatar's picks
/// /// This fills in the tabs of the Picks panel.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPicksReply {
    pub agent_data: AvatarPicksReply_AgentData,
    pub data: Vec<AvatarPicksReply_Data>,
}


#[derive(Clone, Debug)]
pub struct AvatarPropertiesReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub avatar_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarPropertiesReply_PropertiesData {
    /// TODO
    pub image_id: Uuid,
    /// TODO
    pub fl_image_id: Uuid,
    /// TODO
    pub partner_id: Uuid,
    /// TODO
    pub about_text: Vec<u8>,
    /// TODO
    pub fl_about_text: Vec<u8>,
    /// TODO
    pub born_on: Vec<u8>,
    /// TODO
    pub profile_url: Vec<u8>,
    /// TODO
    pub charter_member: Vec<u8>,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// AvatarPropertiesReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPropertiesReply {
    pub agent_data: AvatarPropertiesReply_AgentData,
    pub properties_data: AvatarPropertiesReply_PropertiesData,
}


#[derive(Clone, Debug)]
pub struct AvatarPropertiesRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub avatar_id: Uuid,
}

/// 		TODO:
/// 		/// AvatarPropertiesRequest
/// /// viewer -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPropertiesRequest {
    pub agent_data: AvatarPropertiesRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct AvatarPropertiesRequestBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub avatar_id: Uuid,
    /// TODO
    pub god_level: u8,
    /// TODO
    pub web_profiles_disabled: bool,
}

/// 		TODO:
/// 		/// AvatarPropertiesRequestBackend
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPropertiesRequestBackend {
    pub agent_data: AvatarPropertiesRequestBackend_AgentData,
}


#[derive(Clone, Debug)]
pub struct AvatarPropertiesUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarPropertiesUpdate_PropertiesData {
    /// TODO
    pub image_id: Uuid,
    /// TODO
    pub fl_image_id: Uuid,
    /// TODO
    pub about_text: Vec<u8>,
    /// TODO
    pub fl_about_text: Vec<u8>,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
    /// TODO
    pub profile_url: Vec<u8>,
}

/// 		TODO:
/// 		/// AvatarPropertiesUpdate
/// /// viewer -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarPropertiesUpdate {
    pub agent_data: AvatarPropertiesUpdate_AgentData,
    pub properties_data: AvatarPropertiesUpdate_PropertiesData,
}


#[derive(Clone, Debug)]
pub struct AvatarSitResponse_SitObject {
    /// TODO
    pub id: Uuid,
}

#[derive(Clone, Debug)]
pub struct AvatarSitResponse_SitTransform {
    /// TODO
    pub auto_pilot: bool,
    /// TODO
    pub sit_position: Vector3<f32>,
    /// TODO
    pub sit_rotation: Quaternion<f32>,
    /// TODO
    pub camera_eye_offset: Vector3<f32>,
    /// TODO
    pub camera_at_offset: Vector3<f32>,
    /// TODO
    pub force_mouselook: bool,
}

/// TODO:
/// /// AvatarSitResponse - response to a request to sit on an object
///
#[derive(Clone, Debug)]
pub struct AvatarSitResponse {
    pub sit_object: AvatarSitResponse_SitObject,
    pub sit_transform: AvatarSitResponse_SitTransform,
}


#[derive(Clone, Debug)]
pub struct AvatarTextureUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub textures_changed: bool,
}

#[derive(Clone, Debug)]
pub struct AvatarTextureUpdate_WearableData {
    /// TODO
    pub cache_id: Uuid,
    /// TODO
    pub texture_index: u8,
    /// TODO
    pub host_name: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct AvatarTextureUpdate_TextureData {
    /// TODO
    pub texture_id: Uuid,
}

/// 		TODO:
/// 		/// AvatarTextureUpdate
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct AvatarTextureUpdate {
    pub agent_data: AvatarTextureUpdate_AgentData,
    pub wearable_data: Vec<AvatarTextureUpdate_WearableData>,
    pub texture_data: Vec<AvatarTextureUpdate_TextureData>,
}


#[derive(Clone, Debug)]
pub struct BulkUpdateInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct BulkUpdateInventory_FolderData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub name: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct BulkUpdateInventory_ItemData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// 		TODO:
/// 		/// Can only fit around 7 items per packet - that's the way it goes. At
/// /// least many bulk updates can be packed.
/// /// Only from dataserver->sim->viewer
///
#[derive(Clone, Debug)]
pub struct BulkUpdateInventory {
    pub agent_data: BulkUpdateInventory_AgentData,
    pub folder_data: Vec<BulkUpdateInventory_FolderData>,
    pub item_data: Vec<BulkUpdateInventory_ItemData>,
}


#[derive(Clone, Debug)]
pub struct BuyObjectInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct BuyObjectInventory_Data {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
}

/// 		TODO:
/// 		/// buy object inventory. If the transaction succeeds, it will add
/// /// inventory to the agent, and potentially remove the original.
///
#[derive(Clone, Debug)]
pub struct BuyObjectInventory {
    pub agent_data: BuyObjectInventory_AgentData,
    pub data: BuyObjectInventory_Data,
}


#[derive(Clone, Debug)]
pub struct CameraConstraint_CameraCollidePlane {
    /// TODO
    pub plane: Vector4<f32>,
}

/// TODO:
/// /// CameraConstraint - new camera distance limit (based on collision with objects)
///
#[derive(Clone, Debug)]
pub struct CameraConstraint {
    pub camera_collide_plane: CameraConstraint_CameraCollidePlane,
}


#[derive(Clone, Debug)]
pub struct CancelAuction_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
}

/// TODO:
/// /// Tell the dataserver that an auction has been canceled.
///
#[derive(Clone, Debug)]
pub struct CancelAuction {
    pub parcel_data: Vec<CancelAuction_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct ChangeInventoryItemFlags_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChangeInventoryItemFlags_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ChangeInventoryItemFlags {
    pub agent_data: ChangeInventoryItemFlags_AgentData,
    pub inventory_data: Vec<ChangeInventoryItemFlags_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct ChangeUserRights_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChangeUserRights_Rights {
    /// TODO
    pub agent_related: Uuid,
    /// TODO
    pub related_rights: i32,
}

/// 		TODO:
/// 		/// This message is sent from the simulator to the viewer to indicate a
/// /// targets granted rights. This is only sent to the originator of the
/// /// request and the target agent if it is a modify or map
/// /// right. Adding/removing online status rights will show up as an
/// /// online/offline notification.
///
#[derive(Clone, Debug)]
pub struct ChangeUserRights {
    pub agent_data: ChangeUserRights_AgentData,
    pub rights: Vec<ChangeUserRights_Rights>,
}


#[derive(Clone, Debug)]
pub struct ChatFromSimulator_ChatData {
    /// TODO
    pub from_name: Vec<u8>,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub source_type: u8,
    /// TODO
    pub chat_type: u8,
    /// TODO
    pub audible: u8,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// ChatFromSimulator
/// /// Chat text to appear on a user's screen
/// /// Position is region local.
/// /// Viewer can optionally use position to animate
/// /// If audible is CHAT_NOT_AUDIBLE, message will not be valid
///
#[derive(Clone, Debug)]
pub struct ChatFromSimulator {
    pub chat_data: ChatFromSimulator_ChatData,
}


#[derive(Clone, Debug)]
pub struct ChatFromViewer_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChatFromViewer_ChatData {
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub type_: u8,
    /// TODO
    pub channel: i32,
}

/// 		TODO:
/// 		/// ChatFromViewer
/// /// Specifies the text to be said and the "type",
/// /// normal speech, shout, whisper.
/// /// with the specified radius
///
#[derive(Clone, Debug)]
pub struct ChatFromViewer {
    pub agent_data: ChatFromViewer_AgentData,
    pub chat_data: ChatFromViewer_ChatData,
}


#[derive(Clone, Debug)]
pub struct ChatPass_ChatData {
    /// TODO
    pub channel: i32,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub source_type: u8,
    /// TODO
    pub type_: u8,
    /// TODO
    pub radius: f32,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// ChatPass
/// /// Chat message transmission to neighbors
/// /// Chat is region local to receiving simulator.
/// /// Type is one of CHAT_TYPE_NORMAL, _WHISPER, _SHOUT
///
#[derive(Clone, Debug)]
pub struct ChatPass {
    pub chat_data: ChatPass_ChatData,
}


#[derive(Clone, Debug)]
pub struct CheckParcelAuctions_RegionData {
    /// TODO
    pub region_handle: u64,
}

/// TODO:
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct CheckParcelAuctions {
    pub region_data: Vec<CheckParcelAuctions_RegionData>,
}


#[derive(Clone, Debug)]
pub struct CheckParcelSales_RegionData {
    /// TODO
    pub region_handle: u64,
}

/// TODO:
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct CheckParcelSales {
    pub region_data: Vec<CheckParcelSales_RegionData>,
}


#[derive(Clone, Debug)]
pub struct ChildAgentAlive_AgentData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub viewer_circuit_code: u32,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// ChildAgentAlive
/// /// sent to child agents just to keep them alive
///
#[derive(Clone, Debug)]
pub struct ChildAgentAlive {
    pub agent_data: ChildAgentAlive_AgentData,
}


#[derive(Clone, Debug)]
pub struct ChildAgentDying_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// Obituary for child agents - make sure the parent know the child is dead
/// /// This way, children can be reliably restarted
///
#[derive(Clone, Debug)]
pub struct ChildAgentDying {
    pub agent_data: ChildAgentDying_AgentData,
}


#[derive(Clone, Debug)]
pub struct ChildAgentPositionUpdate_AgentData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub viewer_circuit_code: u32,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub agent_pos: Vector3<f32>,
    /// TODO
    pub agent_vel: Vector3<f32>,
    /// TODO
    pub center: Vector3<f32>,
    /// TODO
    pub size: Vector3<f32>,
    /// TODO
    pub at_axis: Vector3<f32>,
    /// TODO
    pub left_axis: Vector3<f32>,
    /// TODO
    pub up_axis: Vector3<f32>,
    /// TODO
    pub changed_grid: bool,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ChildAgentPositionUpdate {
    pub agent_data: ChildAgentPositionUpdate_AgentData,
}


#[derive(Clone, Debug)]
pub struct ChildAgentUnknown_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
/// /// This is sent if a full child agent hasn't been accepted yet
///
#[derive(Clone, Debug)]
pub struct ChildAgentUnknown {
    pub agent_data: ChildAgentUnknown_AgentData,
}


#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_AgentData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub viewer_circuit_code: u32,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub agent_pos: Vector3<f32>,
    /// TODO
    pub agent_vel: Vector3<f32>,
    /// TODO
    pub center: Vector3<f32>,
    /// TODO
    pub size: Vector3<f32>,
    /// TODO
    pub at_axis: Vector3<f32>,
    /// TODO
    pub left_axis: Vector3<f32>,
    /// TODO
    pub up_axis: Vector3<f32>,
    /// TODO
    pub changed_grid: bool,
    /// TODO
    pub far: f32,
    /// TODO
    pub aspect: f32,
    /// TODO
    pub throttles: Vec<u8>,
    /// TODO
    pub locomotion_state: u32,
    /// TODO
    pub head_rotation: Quaternion<f32>,
    /// TODO
    pub body_rotation: Quaternion<f32>,
    /// TODO
    pub control_flags: u32,
    /// TODO
    pub energy_level: f32,
    /// TODO
    pub god_level: u8,
    /// TODO
    pub always_run: bool,
    /// TODO
    pub prey_agent: Uuid,
    /// TODO
    pub agent_access: u8,
    /// TODO
    pub agent_textures: Vec<u8>,
    /// TODO
    pub active_group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub group_powers: u64,
    /// TODO
    pub accept_notices: bool,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_AnimationData {
    /// TODO
    pub animation: Uuid,
    /// TODO
    pub object_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_GranterBlock {
    /// TODO
    pub granter_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_NVPairData {
    /// TODO
    pub nv_pairs: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_VisualParam {
    /// TODO
    pub param_value: u8,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_AgentAccess {
    /// TODO
    pub agent_legacy_access: u8,
    /// TODO
    pub agent_max_access: u8,
}

#[derive(Clone, Debug)]
pub struct ChildAgentUpdate_AgentInfo {
    /// TODO
    pub flags: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ChildAgentUpdate {
    pub agent_data: ChildAgentUpdate_AgentData,
    pub group_data: Vec<ChildAgentUpdate_GroupData>,
    pub animation_data: Vec<ChildAgentUpdate_AnimationData>,
    pub granter_block: Vec<ChildAgentUpdate_GranterBlock>,
    pub nv_pair_data: Vec<ChildAgentUpdate_NVPairData>,
    pub visual_param: Vec<ChildAgentUpdate_VisualParam>,
    pub agent_access: Vec<ChildAgentUpdate_AgentAccess>,
    pub agent_info: Vec<ChildAgentUpdate_AgentInfo>,
}


#[derive(Clone, Debug)]
pub struct ClassifiedDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ClassifiedDelete_Data {
    /// TODO
    pub classified_id: Uuid,
}

/// 		TODO:
/// 		/// ClassifiedDelete
/// /// Delete a classified from the database.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ClassifiedDelete {
    pub agent_data: ClassifiedDelete_AgentData,
    pub data: ClassifiedDelete_Data,
}


#[derive(Clone, Debug)]
pub struct ClassifiedGodDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ClassifiedGodDelete_Data {
    /// TODO
    pub classified_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

/// 		TODO:
/// 		/// ClassifiedGodDelete
/// /// Delete a classified from the database.
/// /// QueryID is needed so database can send a repeat list of
/// /// classified.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ClassifiedGodDelete {
    pub agent_data: ClassifiedGodDelete_AgentData,
    pub data: ClassifiedGodDelete_Data,
}


#[derive(Clone, Debug)]
pub struct ClassifiedInfoReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ClassifiedInfoReply_Data {
    /// TODO
    pub classified_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub creation_date: u32,
    /// TODO
    pub expiration_date: u32,
    /// TODO
    pub category: u32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub parent_estate: u32,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub pos_global: Vector3<f64>,
    /// TODO
    pub parcel_name: Vec<u8>,
    /// TODO
    pub classified_flags: u8,
    /// TODO
    pub price_for_listing: i32,
}

/// 		TODO:
/// 		/// ClassifiedInfoReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ClassifiedInfoReply {
    pub agent_data: ClassifiedInfoReply_AgentData,
    pub data: ClassifiedInfoReply_Data,
}


#[derive(Clone, Debug)]
pub struct ClassifiedInfoRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ClassifiedInfoRequest_Data {
    /// TODO
    pub classified_id: Uuid,
}

/// 		TODO:
/// 		/// ClassifiedInfoRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ClassifiedInfoRequest {
    pub agent_data: ClassifiedInfoRequest_AgentData,
    pub data: ClassifiedInfoRequest_Data,
}


#[derive(Clone, Debug)]
pub struct ClassifiedInfoUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ClassifiedInfoUpdate_Data {
    /// TODO
    pub classified_id: Uuid,
    /// TODO
    pub category: u32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub parent_estate: u32,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub pos_global: Vector3<f64>,
    /// TODO
    pub classified_flags: u8,
    /// TODO
    pub price_for_listing: i32,
}

/// 		TODO:
/// 		/// ClassifiedInfoUpdate
/// /// Update a classified.  ParcelID and EstateID are set
/// /// on the simulator as the message passes through.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ClassifiedInfoUpdate {
    pub agent_data: ClassifiedInfoUpdate_AgentData,
    pub data: ClassifiedInfoUpdate_Data,
}


#[derive(Clone, Debug)]
pub struct ClearFollowCamProperties_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// TODO:
/// /// ClearFollowCamProperties
///
#[derive(Clone, Debug)]
pub struct ClearFollowCamProperties {
    pub object_data: ClearFollowCamProperties_ObjectData,
}


/// TODO:
/// /// CloseCircuit - Tells the recipient's messaging system to close the descibed circuit
///
#[derive(Clone, Debug)]
pub struct CloseCircuit {}


#[derive(Clone, Debug)]
pub struct CoarseLocationUpdate_Location {
    /// X coordinate in the region.
    ///
    /// TODO: How is this handled in VarRegion?
    ///
    pub x: u8,
    /// Y coordinate in the region.
    ///
    /// TODO: How is this handled in VarRegion?
    ///
    pub y: u8,
    /// Z coordinate divided by 4. If z>1020m then this is set to 0.
    ///
    pub z: u8,
}

#[derive(Clone, Debug)]
pub struct CoarseLocationUpdate_Index {
    /// The index of the viewer agent in the location list. (0 indexed.)
    ///
    /// If this is not present in the location list, it is set to -1.
    ///
    pub you: i16,
    /// If the viewer is tracking or following somebody, this index value
    /// points to that agent.
    ///
    /// If this is not present in the location list, it is set to -1.
    ///
    pub prey: i16,
}

#[derive(Clone, Debug)]
pub struct CoarseLocationUpdate_AgentData {
    /// The agent id identifies the agent in packets. "client" and "avatar" are
    /// synonymous to agent.
    pub agent_id: Uuid,
}

/// The CoarseLocationUpdate message is sent to notify the viewer of
/// the location of mappable objects in the region. 1 meter resolution is
/// sufficient for this. The index block is used to show where you are,
/// and where someone you are tracking is located. They are -1 if not
/// applicable.
///
/// This is usually used only for the minimap of the region.
/// Its behavior is to always drop all current data and only use the new one
/// for the minimap once such a message arrives.
///
#[derive(Clone, Debug)]
pub struct CoarseLocationUpdate {
    pub location: Vec<CoarseLocationUpdate_Location>,
    pub index: CoarseLocationUpdate_Index,
    pub agent_data: Vec<CoarseLocationUpdate_AgentData>,
}


#[derive(Clone, Debug)]
pub struct CompleteAgentMovement_AgentData {
    /// Agent id of the sender.
    pub agent_id: Uuid,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
    /// The circuit code as provided in the login response. It serves as a
    /// proof of authentication and identfies the client.
    pub circuit_code: u32,
}

/// Move an agent into the simulator.
/// This is the last packet needed to complete the transition into a new simulator.
///
#[derive(Clone, Debug)]
pub struct CompleteAgentMovement {
    pub agent_data: CompleteAgentMovement_AgentData,
}


#[derive(Clone, Debug)]
pub struct CompleteAuction_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
}

/// 		TODO:
/// 		/// sim -> dataserver
/// /// Tell the dataserver that an auction has completed.
///
#[derive(Clone, Debug)]
pub struct CompleteAuction {
    pub parcel_data: Vec<CompleteAuction_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct CompletePingCheck_PingID {
    /// TODO
    pub ping_id: u8,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct CompletePingCheck {
    pub ping_id: CompletePingCheck_PingID,
}


#[derive(Clone, Debug)]
pub struct ConfirmAuctionStart_AuctionData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub auction_id: u32,
}

/// TODO:
/// /// dataserver -> sim
///
#[derive(Clone, Debug)]
pub struct ConfirmAuctionStart {
    pub auction_data: ConfirmAuctionStart_AuctionData,
}


#[derive(Clone, Debug)]
pub struct ConfirmEnableSimulator_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ConfirmEnableSimulator {
    pub agent_data: ConfirmEnableSimulator_AgentData,
}


#[derive(Clone, Debug)]
pub struct ConfirmXferPacket_XferID {
    /// TODO
    pub id: u64,
    /// TODO
    pub packet: u32,
}

/// TODO:
/// /// ConfirmXferPacket
///
#[derive(Clone, Debug)]
pub struct ConfirmXferPacket {
    pub xfer_id: ConfirmXferPacket_XferID,
}


#[derive(Clone, Debug)]
pub struct CopyInventoryFromNotecard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CopyInventoryFromNotecard_NotecardData {
    /// TODO
    pub notecard_item_id: Uuid,
    /// TODO
    pub object_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CopyInventoryFromNotecard_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct CopyInventoryFromNotecard {
    pub agent_data: CopyInventoryFromNotecard_AgentData,
    pub notecard_data: CopyInventoryFromNotecard_NotecardData,
    pub inventory_data: Vec<CopyInventoryFromNotecard_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct CopyInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CopyInventoryItem_InventoryData {
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub old_agent_id: Uuid,
    /// TODO
    pub old_item_id: Uuid,
    /// TODO
    pub new_folder_id: Uuid,
    /// TODO
    pub new_name: Vec<u8>,
}

/// 		TODO:
/// 		/// copy inventory item by item id to specified destination folder,
/// /// send out bulk inventory update when done.
/// ///
/// /// Inventory items are only unique for {agent, inv_id} pairs;
/// /// the OldItemID needs to be paired with the OldAgentID to
/// /// produce a unique inventory item.
///
#[derive(Clone, Debug)]
pub struct CopyInventoryItem {
    pub agent_data: CopyInventoryItem_AgentData,
    pub inventory_data: Vec<CopyInventoryItem_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct CreateGroupReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateGroupReply_ReplyData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub success: bool,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// CreateGroupReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct CreateGroupReply {
    pub agent_data: CreateGroupReply_AgentData,
    pub reply_data: CreateGroupReply_ReplyData,
}


#[derive(Clone, Debug)]
pub struct CreateGroupRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateGroupRequest_GroupData {
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub charter: Vec<u8>,
    /// TODO
    pub show_in_list: bool,
    /// TODO
    pub insignia_id: Uuid,
    /// TODO
    pub membership_fee: i32,
    /// TODO
    pub open_enrollment: bool,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
}

/// 		TODO:
/// 		/// CreateGroupRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct CreateGroupRequest {
    pub agent_data: CreateGroupRequest_AgentData,
    pub group_data: CreateGroupRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct CreateInventoryFolder_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateInventoryFolder_FolderData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct CreateInventoryFolder {
    pub agent_data: CreateInventoryFolder_AgentData,
    pub folder_data: CreateInventoryFolder_FolderData,
}


#[derive(Clone, Debug)]
pub struct CreateInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateInventoryItem_InventoryBlock {
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub wearable_type: u8,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
}

/// TODO:
/// /// Create inventory
///
#[derive(Clone, Debug)]
pub struct CreateInventoryItem {
    pub agent_data: CreateInventoryItem_AgentData,
    pub inventory_block: CreateInventoryItem_InventoryBlock,
}


#[derive(Clone, Debug)]
pub struct CreateLandmarkForEvent_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateLandmarkForEvent_EventData {
    /// TODO
    pub event_id: u32,
}

#[derive(Clone, Debug)]
pub struct CreateLandmarkForEvent_InventoryBlock {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
/// /// give agent a landmark for an event.
///
#[derive(Clone, Debug)]
pub struct CreateLandmarkForEvent {
    pub agent_data: CreateLandmarkForEvent_AgentData,
    pub event_data: CreateLandmarkForEvent_EventData,
    pub inventory_block: CreateLandmarkForEvent_InventoryBlock,
}


#[derive(Clone, Debug)]
pub struct CreateNewOutfitAttachments_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateNewOutfitAttachments_HeaderData {
    /// TODO
    pub new_folder_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CreateNewOutfitAttachments_ObjectData {
    /// TODO
    pub old_item_id: Uuid,
    /// TODO
    pub old_folder_id: Uuid,
}

/// 		TODO:
/// 		/// Viewer -> Sim
/// /// Used in "Make New Outfit"
///
#[derive(Clone, Debug)]
pub struct CreateNewOutfitAttachments {
    pub agent_data: CreateNewOutfitAttachments_AgentData,
    pub header_data: CreateNewOutfitAttachments_HeaderData,
    pub object_data: Vec<CreateNewOutfitAttachments_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct CreateTrustedCircuit_DataBlock {
    /// TODO
    pub end_point_id: Uuid,
    /// TODO
    pub digest: [u8; 32],
}

/// 		TODO:
/// 		/// CreateTrustedCircuit
/// /// Sent to establish a trust relationship between two components.
/// /// Only sent in response to a DenyTrustedCircuit message.
///
#[derive(Clone, Debug)]
pub struct CreateTrustedCircuit {
    pub data_block: CreateTrustedCircuit_DataBlock,
}


#[derive(Clone, Debug)]
pub struct CrossedRegion_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct CrossedRegion_RegionData {
    /// TODO
    pub sim_ip: Ip4Addr,
    /// TODO
    pub sim_port: IpPort,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub seed_capability: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct CrossedRegion_Info {
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// CrossedRegion - new way to tell a viewer it has gone across a region
/// /// boundary
///
#[derive(Clone, Debug)]
pub struct CrossedRegion {
    pub agent_data: CrossedRegion_AgentData,
    pub region_data: CrossedRegion_RegionData,
    pub info: CrossedRegion_Info,
}


#[derive(Clone, Debug)]
pub struct DataHomeLocationReply_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// DataHomeLocationReply data->sim
/// /// response is the location of agent home.
///
#[derive(Clone, Debug)]
pub struct DataHomeLocationReply {
    pub info: DataHomeLocationReply_Info,
}


#[derive(Clone, Debug)]
pub struct DataHomeLocationRequest_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub kicked_from_estate_id: u32,
}

#[derive(Clone, Debug)]
pub struct DataHomeLocationRequest_AgentInfo {
    /// TODO
    pub agent_effective_maturity: u32,
}

/// 		TODO:
/// 		/// DataHomeLocationRequest sim->data
/// /// Request
///
#[derive(Clone, Debug)]
pub struct DataHomeLocationRequest {
    pub info: DataHomeLocationRequest_Info,
    pub agent_info: DataHomeLocationRequest_AgentInfo,
}


#[derive(Clone, Debug)]
pub struct DataServerLogout_UserData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub viewer_ip: Ip4Addr,
    /// TODO
    pub disconnect: bool,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
/// /// userserver -> dataserver
///
#[derive(Clone, Debug)]
pub struct DataServerLogout {
    pub user_data: DataServerLogout_UserData,
}


#[derive(Clone, Debug)]
pub struct DeRezAck_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub success: bool,
}

/// 		TODO:
/// 		/// This message is sent when a derez succeeds, but there's no way to
/// /// know, since no inventory is created on the viewer. For example, when
/// /// saving into task inventory.
///
#[derive(Clone, Debug)]
pub struct DeRezAck {
    pub transaction_data: DeRezAck_TransactionData,
}


#[derive(Clone, Debug)]
pub struct DeRezObject_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DeRezObject_AgentBlock {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub destination: u8,
    /// TODO
    pub destination_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub packet_count: u8,
    /// TODO
    pub packet_number: u8,
}

#[derive(Clone, Debug)]
pub struct DeRezObject_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// These messages are viewer->simulator requests regarding objects
/// /// which are currently being simulated. The viewer will get an
/// /// UpdateInventoryItem response if a DeRez succeeds, and the object
/// /// will appear if a RezObject succeeds.
/// /// The Destination field tells where the derez should wind up, and the
/// /// meaning of DestinationID depends on it. For example, if the
/// /// destination is a category, then the destination is the category id. If
/// /// the destination is a task inventory, then the destination id is the
/// /// task id.
/// /// The transaction id is generated by the viewer on derez, and then
/// /// the packets are counted and numbered. The rest of the information is
/// /// just duplicated (it's not that much, and derezzes that span multiple
/// /// packets will be rare.)
///
#[derive(Clone, Debug)]
pub struct DeRezObject {
    pub agent_data: DeRezObject_AgentData,
    pub agent_block: DeRezObject_AgentBlock,
    pub object_data: Vec<DeRezObject_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct DeactivateGestures_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
}

#[derive(Clone, Debug)]
pub struct DeactivateGestures_Data {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub gesture_flags: u32,
}

/// 		TODO:
/// 		/// Tell the database some gestures are no longer active
/// /// viewer -> sim -> data
///
#[derive(Clone, Debug)]
pub struct DeactivateGestures {
    pub agent_data: DeactivateGestures_AgentData,
    pub data: Vec<DeactivateGestures_Data>,
}


#[derive(Clone, Debug)]
pub struct DeclineCallingCard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DeclineCallingCard_TransactionBlock {
    /// TODO
    pub transaction_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct DeclineCallingCard {
    pub agent_data: DeclineCallingCard_AgentData,
    pub transaction_block: DeclineCallingCard_TransactionBlock,
}


#[derive(Clone, Debug)]
pub struct DeclineFriendship_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DeclineFriendship_TransactionBlock {
    /// TODO
    pub transaction_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct DeclineFriendship {
    pub agent_data: DeclineFriendship_AgentData,
    pub transaction_block: DeclineFriendship_TransactionBlock,
}


#[derive(Clone, Debug)]
pub struct DenyTrustedCircuit_DataBlock {
    /// TODO
    pub end_point_id: Uuid,
}

/// 		TODO:
/// 		/// DenyTrustedCircuit
/// /// Sent :
/// /// - in response to failed CreateTrustedCircuit
/// /// - to force the remote end-point to try to establish a trusted circuit
/// /// - the reception of a trusted message on a non-trusted circuit
/// /// This allows us to re-auth a circuit if it gets closed due to timeouts or network failures.
///
#[derive(Clone, Debug)]
pub struct DenyTrustedCircuit {
    pub data_block: DenyTrustedCircuit_DataBlock,
}


#[derive(Clone, Debug)]
pub struct DerezContainer_Data {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub delete: bool,
}

/// 		TODO:
/// 		/// sim -> viewer
/// /// Used to propperly handle buying asset containers
///
#[derive(Clone, Debug)]
pub struct DerezContainer {
    pub data: DerezContainer_Data,
}


#[derive(Clone, Debug)]
pub struct DetachAttachmentIntoInv_ObjectData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct DetachAttachmentIntoInv {
    pub object_data: DetachAttachmentIntoInv_ObjectData,
}


#[derive(Clone, Debug)]
pub struct DirClassifiedQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirClassifiedQuery_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub category: u32,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirClassifiedQuery viewer->sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirClassifiedQuery {
    pub agent_data: DirClassifiedQuery_AgentData,
    pub query_data: DirClassifiedQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirClassifiedQueryBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirClassifiedQueryBackend_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub category: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirClassifiedQueryBackend sim->dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirClassifiedQueryBackend {
    pub agent_data: DirClassifiedQueryBackend_AgentData,
    pub query_data: DirClassifiedQueryBackend_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirClassifiedReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirClassifiedReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirClassifiedReply_QueryReplies {
    /// TODO
    pub classified_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub classified_flags: u8,
    /// TODO
    pub creation_date: u32,
    /// TODO
    pub expiration_date: u32,
    /// TODO
    pub price_for_listing: i32,
}

#[derive(Clone, Debug)]
pub struct DirClassifiedReply_StatusData {
    /// TODO
    pub status: u32,
}

/// 		TODO:
/// 		/// DirClassifiedReply dataserver->sim->viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirClassifiedReply {
    pub agent_data: DirClassifiedReply_AgentData,
    pub query_data: DirClassifiedReply_QueryData,
    pub query_replies: Vec<DirClassifiedReply_QueryReplies>,
    pub status_data: Vec<DirClassifiedReply_StatusData>,
}


#[derive(Clone, Debug)]
pub struct DirEventsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirEventsReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirEventsReply_QueryReplies {
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub event_id: u32,
    /// TODO
    pub date: Vec<u8>,
    /// TODO
    pub unix_time: u32,
    /// TODO
    pub event_flags: u32,
}

#[derive(Clone, Debug)]
pub struct DirEventsReply_StatusData {
    /// TODO
    pub status: u32,
}

/// TODO:
/// /// DirEventsReply
///
#[derive(Clone, Debug)]
pub struct DirEventsReply {
    pub agent_data: DirEventsReply_AgentData,
    pub query_data: DirEventsReply_QueryData,
    pub query_replies: Vec<DirEventsReply_QueryReplies>,
    pub status_data: Vec<DirEventsReply_StatusData>,
}


#[derive(Clone, Debug)]
pub struct DirFindQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirFindQuery_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirFindQuery viewer->sim
/// /// Message to start asking questions for the directory
///
#[derive(Clone, Debug)]
pub struct DirFindQuery {
    pub agent_data: DirFindQuery_AgentData,
    pub query_data: DirFindQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirFindQueryBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirFindQueryBackend_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub query_start: i32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

/// 		TODO:
/// 		/// DirFindQueryBackend sim->data
/// /// Trusted message generated by receipt of DirFindQuery to sim.
///
#[derive(Clone, Debug)]
pub struct DirFindQueryBackend {
    pub agent_data: DirFindQueryBackend_AgentData,
    pub query_data: DirFindQueryBackend_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirGroupsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirGroupsReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirGroupsReply_QueryReplies {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub group_name: Vec<u8>,
    /// TODO
    pub members: i32,
    /// TODO
    pub search_order: f32,
}

/// 		TODO:
/// 		/// DirGroupsReply
/// /// dataserver -> userserver -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirGroupsReply {
    pub agent_data: DirGroupsReply_AgentData,
    pub query_data: DirGroupsReply_QueryData,
    pub query_replies: Vec<DirGroupsReply_QueryReplies>,
}


#[derive(Clone, Debug)]
pub struct DirLandQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirLandQuery_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub search_type: u32,
    /// TODO
    pub price: i32,
    /// TODO
    pub area: i32,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirLandQuery viewer->sim
/// /// Special query for the land for sale/auction panel.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirLandQuery {
    pub agent_data: DirLandQuery_AgentData,
    pub query_data: DirLandQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirLandQueryBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirLandQueryBackend_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub search_type: u32,
    /// TODO
    pub price: i32,
    /// TODO
    pub area: i32,
    /// TODO
    pub query_start: i32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

/// 		TODO:
/// 		/// DirLandQueryBackend sim->dataserver
/// /// Special query for the land for sale/auction panel.
///
#[derive(Clone, Debug)]
pub struct DirLandQueryBackend {
    pub agent_data: DirLandQueryBackend_AgentData,
    pub query_data: DirLandQueryBackend_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirLandReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirLandReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirLandReply_QueryReplies {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub auction: bool,
    /// TODO
    pub for_sale: bool,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub actual_area: i32,
}

/// 		TODO:
/// 		/// DirLandReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
/// ///{	ProductSKU		Variable 1	}
///
#[derive(Clone, Debug)]
pub struct DirLandReply {
    pub agent_data: DirLandReply_AgentData,
    pub query_data: DirLandReply_QueryData,
    pub query_replies: Vec<DirLandReply_QueryReplies>,
}


#[derive(Clone, Debug)]
pub struct DirPeopleReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPeopleReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPeopleReply_QueryReplies {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub first_name: Vec<u8>,
    /// TODO
    pub last_name: Vec<u8>,
    /// TODO
    pub group: Vec<u8>,
    /// TODO
    pub online: bool,
    /// TODO
    pub reputation: i32,
}

/// TODO:
/// /// DirPeopleReply
///
#[derive(Clone, Debug)]
pub struct DirPeopleReply {
    pub agent_data: DirPeopleReply_AgentData,
    pub query_data: DirPeopleReply_QueryData,
    pub query_replies: Vec<DirPeopleReply_QueryReplies>,
}


#[derive(Clone, Debug)]
pub struct DirPlacesQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPlacesQuery_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub category: i8,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirPlacesQuery viewer->sim
/// /// Used for the Find directory of places
///
#[derive(Clone, Debug)]
pub struct DirPlacesQuery {
    pub agent_data: DirPlacesQuery_AgentData,
    pub query_data: DirPlacesQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirPlacesQueryBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPlacesQueryBackend_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub category: i8,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// DirPlacesQueryBackend sim->dataserver
/// /// Used for the Find directory of places.
///
#[derive(Clone, Debug)]
pub struct DirPlacesQueryBackend {
    pub agent_data: DirPlacesQueryBackend_AgentData,
    pub query_data: DirPlacesQueryBackend_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirPlacesReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPlacesReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPlacesReply_QueryReplies {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub for_sale: bool,
    /// TODO
    pub auction: bool,
    /// TODO
    pub dwell: f32,
}

#[derive(Clone, Debug)]
pub struct DirPlacesReply_StatusData {
    /// TODO
    pub status: u32,
}

/// 		TODO:
/// 		/// DirPlacesReply dataserver->sim->viewer
/// /// If the user has specified a location, use that to compute
/// /// global x,y,z.  Otherwise, use center of the AABB.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirPlacesReply {
    pub agent_data: DirPlacesReply_AgentData,
    pub query_data: Vec<DirPlacesReply_QueryData>,
    pub query_replies: Vec<DirPlacesReply_QueryReplies>,
    pub status_data: Vec<DirPlacesReply_StatusData>,
}


#[derive(Clone, Debug)]
pub struct DirPopularQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPopularQuery_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_flags: u32,
}

/// 		TODO:
/// 		/// DEPRECATED: DirPopularQuery viewer->sim
/// /// Special query for the land for sale/auction panel.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirPopularQuery {
    pub agent_data: DirPopularQuery_AgentData,
    pub query_data: DirPopularQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirPopularQueryBackend_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPopularQueryBackend_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

/// 		TODO:
/// 		/// DEPRECATED: DirPopularQueryBackend sim->dataserver
/// /// Special query for the land for sale/auction panel.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirPopularQueryBackend {
    pub agent_data: DirPopularQueryBackend_AgentData,
    pub query_data: DirPopularQueryBackend_QueryData,
}


#[derive(Clone, Debug)]
pub struct DirPopularReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPopularReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct DirPopularReply_QueryReplies {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub dwell: f32,
}

/// 		TODO:
/// 		/// DEPRECATED: DirPopularReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct DirPopularReply {
    pub agent_data: DirPopularReply_AgentData,
    pub query_data: DirPopularReply_QueryData,
    pub query_replies: Vec<DirPopularReply_QueryReplies>,
}


/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct DisableSimulator {}


#[derive(Clone, Debug)]
pub struct EconomyData_Info {
    /// TODO
    pub object_capacity: i32,
    /// TODO
    pub object_count: i32,
    /// TODO
    pub price_energy_unit: i32,
    /// TODO
    pub price_object_claim: i32,
    /// TODO
    pub price_public_object_decay: i32,
    /// TODO
    pub price_public_object_delete: i32,
    /// TODO
    pub price_parcel_claim: i32,
    /// TODO
    pub price_parcel_claim_factor: f32,
    /// TODO
    pub price_upload: i32,
    /// TODO
    pub price_rent_light: i32,
    /// TODO
    pub teleport_min_price: i32,
    /// TODO
    pub teleport_price_exponent: f32,
    /// TODO
    pub energy_efficiency: f32,
    /// TODO
    pub price_object_rent: f32,
    /// TODO
    pub price_object_scale_factor: f32,
    /// TODO
    pub price_parcel_rent: i32,
    /// TODO
    pub price_group_create: i32,
}

/// TODO:
/// /// dataserver to sim, response w/ econ data
///
#[derive(Clone, Debug)]
pub struct EconomyData {
    pub info: EconomyData_Info,
}


/// TODO:
/// /// once we use local stats, this will include a region handle
///
#[derive(Clone, Debug)]
pub struct EconomyDataRequest {}


#[derive(Clone, Debug)]
pub struct EdgeDataPacket_EdgeData {
    /// TODO
    pub layer_type: u8,
    /// TODO
    pub direction: u8,
    /// TODO
    pub layer_data: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct EdgeDataPacket {
    pub edge_data: EdgeDataPacket_EdgeData,
}


#[derive(Clone, Debug)]
pub struct EjectGroupMemberReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EjectGroupMemberReply_GroupData {
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EjectGroupMemberReply_EjectData {
    /// TODO
    pub success: bool,
}

/// 		TODO:
/// 		/// EjectGroupMemberReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EjectGroupMemberReply {
    pub agent_data: EjectGroupMemberReply_AgentData,
    pub group_data: EjectGroupMemberReply_GroupData,
    pub eject_data: EjectGroupMemberReply_EjectData,
}


#[derive(Clone, Debug)]
pub struct EjectGroupMemberRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EjectGroupMemberRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EjectGroupMemberRequest_EjectData {
    /// TODO
    pub ejectee_id: Uuid,
}

/// 		TODO:
/// 		/// EjectGroupMemberRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EjectGroupMemberRequest {
    pub agent_data: EjectGroupMemberRequest_AgentData,
    pub group_data: EjectGroupMemberRequest_GroupData,
    pub eject_data: Vec<EjectGroupMemberRequest_EjectData>,
}


#[derive(Clone, Debug)]
pub struct EjectUser_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EjectUser_Data {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// EjectUser
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EjectUser {
    pub agent_data: EjectUser_AgentData,
    pub data: EjectUser_Data,
}


#[derive(Clone, Debug)]
pub struct EmailMessageReply_DataBlock {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub more: u32,
    /// TODO
    pub time: u32,
    /// TODO
    pub from_address: Vec<u8>,
    /// TODO
    pub subject: Vec<u8>,
    /// TODO
    pub data: Vec<u8>,
    /// TODO
    pub mail_filter: Vec<u8>,
}

/// 		TODO:
/// 		/// Dataserver gives simulator the oldest email message in the queue, along with
/// /// how many messages are left in the queue.  And passes back the filter used to request emails.
///
#[derive(Clone, Debug)]
pub struct EmailMessageReply {
    pub data_block: EmailMessageReply_DataBlock,
}


#[derive(Clone, Debug)]
pub struct EmailMessageRequest_DataBlock {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub from_address: Vec<u8>,
    /// TODO
    pub subject: Vec<u8>,
}

/// 		TODO:
/// 		/// Script on simulator asks dataserver if there are any email messages
/// /// waiting.
///
#[derive(Clone, Debug)]
pub struct EmailMessageRequest {
    pub data_block: EmailMessageRequest_DataBlock,
}


#[derive(Clone, Debug)]
pub struct EnableSimulator_SimulatorInfo {
    /// TODO
    pub handle: u64,
    /// TODO
    pub ip: Ip4Addr,
    /// TODO
    pub port: IpPort,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct EnableSimulator {
    pub simulator_info: EnableSimulator_SimulatorInfo,
}


#[derive(Clone, Debug)]
pub struct Error_AgentData {
    /// Agent id of the sender.
    ///
    /// TODO: What is the value of this field in the case of sim → agent: is it the
    /// receiver?                      And what is the value in the case of sim → sim?
    ///
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct Error_Data {
    /// Code number of the error.
    ///
    /// TODO: Tabularize at least the most important error codes.
    ///
    pub code: i32,
    /// TODO
    pub token: Vec<u8>,
    /// TODO
    pub id: Uuid,
    /// TODO
    pub system: Vec<u8>,
    /// The full error message.
    pub message: Vec<u8>,
    /// TODO
    pub data: Vec<u8>,
}

/// Any error message to be sent to the UDP recipient.
///
/// Receivers are supposed to at least log the message, or detect a specific error and for example
/// display a relevant UI widget.
///
#[derive(Clone, Debug)]
pub struct Error {
    pub agent_data: Error_AgentData,
    pub data: Error_Data,
}


#[derive(Clone, Debug)]
pub struct EstateCovenantReply_Data {
    /// TODO
    pub covenant_id: Uuid,
    /// TODO
    pub covenant_timestamp: u32,
    /// TODO
    pub estate_name: Vec<u8>,
    /// TODO
    pub estate_owner_id: Uuid,
}

/// 		TODO:
/// 		/// EstateCovenantReply
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EstateCovenantReply {
    pub data: EstateCovenantReply_Data,
}


#[derive(Clone, Debug)]
pub struct EstateCovenantRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// EstateCovenantRequest
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EstateCovenantRequest {
    pub agent_data: EstateCovenantRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct EstateOwnerMessage_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EstateOwnerMessage_MethodData {
    /// TODO
    pub method: Vec<u8>,
    /// TODO
    pub invoice: Uuid,
}

#[derive(Clone, Debug)]
pub struct EstateOwnerMessage_ParamList {
    /// TODO
    pub parameter: Vec<u8>,
}

/// 		TODO:
/// 		/// EstateOwnerMessage
/// /// format must be identical to above
///
#[derive(Clone, Debug)]
pub struct EstateOwnerMessage {
    pub agent_data: EstateOwnerMessage_AgentData,
    pub method_data: EstateOwnerMessage_MethodData,
    pub param_list: Vec<EstateOwnerMessage_ParamList>,
}


#[derive(Clone, Debug)]
pub struct EventGodDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventGodDelete_EventData {
    /// TODO
    pub event_id: u32,
}

#[derive(Clone, Debug)]
pub struct EventGodDelete_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub query_start: i32,
}

/// 		TODO:
/// 		/// EventGodDelete
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// QueryData is used to resend a search result after the deletion
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EventGodDelete {
    pub agent_data: EventGodDelete_AgentData,
    pub event_data: EventGodDelete_EventData,
    pub query_data: EventGodDelete_QueryData,
}


#[derive(Clone, Debug)]
pub struct EventInfoReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventInfoReply_EventData {
    /// TODO
    pub event_id: u32,
    /// TODO
    pub creator: Vec<u8>,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub category: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub date: Vec<u8>,
    /// TODO
    pub date_utc: u32,
    /// TODO
    pub duration: u32,
    /// TODO
    pub cover: u32,
    /// TODO
    pub amount: u32,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub global_pos: Vector3<f64>,
    /// TODO
    pub event_flags: u32,
}

/// 		TODO:
/// 		/// EventInfoReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EventInfoReply {
    pub agent_data: EventInfoReply_AgentData,
    pub event_data: EventInfoReply_EventData,
}


#[derive(Clone, Debug)]
pub struct EventInfoRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventInfoRequest_EventData {
    /// TODO
    pub event_id: u32,
}

/// 		TODO:
/// 		/// EventInfoRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EventInfoRequest {
    pub agent_data: EventInfoRequest_AgentData,
    pub event_data: EventInfoRequest_EventData,
}


#[derive(Clone, Debug)]
pub struct EventLocationReply_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventLocationReply_EventData {
    /// TODO
    pub success: bool,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub region_pos: Vector3<f32>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct EventLocationReply {
    pub query_data: EventLocationReply_QueryData,
    pub event_data: EventLocationReply_EventData,
}


#[derive(Clone, Debug)]
pub struct EventLocationRequest_QueryData {
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventLocationRequest_EventData {
    /// TODO
    pub event_id: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct EventLocationRequest {
    pub query_data: EventLocationRequest_QueryData,
    pub event_data: EventLocationRequest_EventData,
}


#[derive(Clone, Debug)]
pub struct EventNotificationAddRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventNotificationAddRequest_EventData {
    /// TODO
    pub event_id: u32,
}

/// 		TODO:
/// 		/// EventNotificationAddRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EventNotificationAddRequest {
    pub agent_data: EventNotificationAddRequest_AgentData,
    pub event_data: EventNotificationAddRequest_EventData,
}


#[derive(Clone, Debug)]
pub struct EventNotificationRemoveRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct EventNotificationRemoveRequest_EventData {
    /// TODO
    pub event_id: u32,
}

/// 		TODO:
/// 		/// EventNotificationRemoveRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct EventNotificationRemoveRequest {
    pub agent_data: EventNotificationRemoveRequest_AgentData,
    pub event_data: EventNotificationRemoveRequest_EventData,
}


#[derive(Clone, Debug)]
pub struct FeatureDisabled_FailureInfo {
    /// TODO
    pub error_message: Vec<u8>,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

/// TODO:
/// /// Disabled feature response message
///
#[derive(Clone, Debug)]
pub struct FeatureDisabled {
    pub failure_info: FeatureDisabled_FailureInfo,
}


#[derive(Clone, Debug)]
pub struct FetchInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct FetchInventory_InventoryData {
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
/// /// Get inventory item(s) - response comes through FetchInventoryReply
///
#[derive(Clone, Debug)]
pub struct FetchInventory {
    pub agent_data: FetchInventory_AgentData,
    pub inventory_data: Vec<FetchInventory_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct FetchInventoryDescendents_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct FetchInventoryDescendents_InventoryData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub sort_order: i32,
    /// TODO
    pub fetch_folders: bool,
    /// TODO
    pub fetch_items: bool,
}

/// TODO:
/// /// Get inventory segment.
///
#[derive(Clone, Debug)]
pub struct FetchInventoryDescendents {
    pub agent_data: FetchInventoryDescendents_AgentData,
    pub inventory_data: FetchInventoryDescendents_InventoryData,
}


#[derive(Clone, Debug)]
pub struct FetchInventoryReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct FetchInventoryReply_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct FetchInventoryReply {
    pub agent_data: FetchInventoryReply_AgentData,
    pub inventory_data: Vec<FetchInventoryReply_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct FindAgent_AgentBlock {
    /// TODO
    pub hunter: Uuid,
    /// TODO
    pub prey: Uuid,
    /// TODO
    pub space_ip: Ip4Addr,
}

#[derive(Clone, Debug)]
pub struct FindAgent_LocationBlock {
    /// TODO
    pub global_x: f64,
    /// TODO
    pub global_y: f64,
}

/// 		TODO:
/// 		/// FindAgent - used to find an agent's global position. I used a
/// /// variable sized LocationBlock so that the message can be recycled with
/// /// minimum new messages and handlers.
///
#[derive(Clone, Debug)]
pub struct FindAgent {
    pub agent_block: FindAgent_AgentBlock,
    pub location_block: Vec<FindAgent_LocationBlock>,
}


#[derive(Clone, Debug)]
pub struct ForceObjectSelect_Header {
    /// TODO
    pub reset_list: bool,
}

#[derive(Clone, Debug)]
pub struct ForceObjectSelect_Data {
    /// TODO
    pub local_id: u32,
}

/// 		TODO:
/// 		/// ForceObjectSelect
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ForceObjectSelect {
    pub header: ForceObjectSelect_Header,
    pub data: Vec<ForceObjectSelect_Data>,
}


#[derive(Clone, Debug)]
pub struct ForceScriptControlRelease_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// ForceScriptControlRelease
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ForceScriptControlRelease {
    pub agent_data: ForceScriptControlRelease_AgentData,
}


#[derive(Clone, Debug)]
pub struct FormFriendship_AgentBlock {
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct FormFriendship {
    pub agent_block: FormFriendship_AgentBlock,
}


#[derive(Clone, Debug)]
pub struct FreezeUser_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct FreezeUser_Data {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// FreezeUser
/// /// Freeze someone who is on my land.
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct FreezeUser {
    pub agent_data: FreezeUser_AgentData,
    pub data: FreezeUser_Data,
}


#[derive(Clone, Debug)]
pub struct GenericMessage_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GenericMessage_MethodData {
    /// TODO
    pub method: Vec<u8>,
    /// TODO
    pub invoice: Uuid,
}

#[derive(Clone, Debug)]
pub struct GenericMessage_ParamList {
    /// TODO
    pub parameter: Vec<u8>,
}

/// 		TODO:
/// 		/// GenericMessage
/// /// format must be identical to above
/// /// As above, but don't have to be god or estate owner to send.
///
#[derive(Clone, Debug)]
pub struct GenericMessage {
    pub agent_data: GenericMessage_AgentData,
    pub method_data: GenericMessage_MethodData,
    pub param_list: Vec<GenericMessage_ParamList>,
}


#[derive(Clone, Debug)]
pub struct GetScriptRunning_Script {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// GetScriptRunning - asks if a script is running or not. the simulator
/// /// responds with ScriptRunningReply
///
#[derive(Clone, Debug)]
pub struct GetScriptRunning {
    pub script: GetScriptRunning_Script,
}


#[derive(Clone, Debug)]
pub struct GodKickUser_UserInfo {
    /// TODO
    pub god_id: Uuid,
    /// TODO
    pub god_session_id: Uuid,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub kick_flags: u32,
    /// TODO
    pub reason: Vec<u8>,
}

/// 		TODO:
/// 		/// GodKickUser
/// /// When a god wants someone kicked
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GodKickUser {
    pub user_info: GodKickUser_UserInfo,
}


#[derive(Clone, Debug)]
pub struct GodUpdateRegionInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GodUpdateRegionInfo_RegionInfo {
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub parent_estate_id: u32,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub billable_factor: f32,
    /// TODO
    pub price_per_meter: i32,
    /// TODO
    pub redirect_grid_x: i32,
    /// TODO
    pub redirect_grid_y: i32,
}

/// 		TODO:
/// 		/// GodUpdateRegionInfo
/// /// Sent from viewer to sim after a god has changed some
/// /// of the parameters in the god tools floater
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GodUpdateRegionInfo {
    pub agent_data: GodUpdateRegionInfo_AgentData,
    pub region_info: GodUpdateRegionInfo_RegionInfo,
}


#[derive(Clone, Debug)]
pub struct GodlikeMessage_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GodlikeMessage_MethodData {
    /// TODO
    pub method: Vec<u8>,
    /// TODO
    pub invoice: Uuid,
}

#[derive(Clone, Debug)]
pub struct GodlikeMessage_ParamList {
    /// TODO
    pub parameter: Vec<u8>,
}

/// 		TODO:
/// 		/// GodlikeMessage - generalized construct for Gods to send messages
/// /// around the system. Each Request has it's own internal protocol.
///
#[derive(Clone, Debug)]
pub struct GodlikeMessage {
    pub agent_data: GodlikeMessage_AgentData,
    pub method_data: GodlikeMessage_MethodData,
    pub param_list: Vec<GodlikeMessage_ParamList>,
}


#[derive(Clone, Debug)]
pub struct GrantGodlikePowers_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GrantGodlikePowers_GrantData {
    /// TODO
    pub god_level: u8,
    /// TODO
    pub token: Uuid,
}

/// 		TODO:
/// 		/// At the simulator, turn the godlike bit on.
/// /// At the viewer, show the god menu.
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GrantGodlikePowers {
    pub agent_data: GrantGodlikePowers_AgentData,
    pub grant_data: GrantGodlikePowers_GrantData,
}


#[derive(Clone, Debug)]
pub struct GrantUserRights_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GrantUserRights_Rights {
    /// TODO
    pub agent_related: Uuid,
    /// TODO
    pub related_rights: i32,
}

/// 		TODO:
/// 		/// Sent from viewer to simulator to set user rights. This message will be
/// /// relayed up to the dataserver through a PUT. If that
/// /// succeeds, an UpdateUserRights will be relayed to the originating
/// /// viewer, and a presence lookup will be performed to find
/// /// agent-related and the same PUT will be issued to the sim host if
/// /// they are online.
///
#[derive(Clone, Debug)]
pub struct GrantUserRights {
    pub agent_data: GrantUserRights_AgentData,
    pub rights: Vec<GrantUserRights_Rights>,
}


#[derive(Clone, Debug)]
pub struct GroupAccountDetailsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountDetailsReply_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
    /// TODO
    pub start_date: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct GroupAccountDetailsReply_HistoryData {
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub amount: i32,
}

/// TODO:
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountDetailsReply {
    pub agent_data: GroupAccountDetailsReply_AgentData,
    pub money_data: GroupAccountDetailsReply_MoneyData,
    pub history_data: Vec<GroupAccountDetailsReply_HistoryData>,
}


#[derive(Clone, Debug)]
pub struct GroupAccountDetailsRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountDetailsRequest_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
}

/// TODO:
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountDetailsRequest {
    pub agent_data: GroupAccountDetailsRequest_AgentData,
    pub money_data: GroupAccountDetailsRequest_MoneyData,
}


#[derive(Clone, Debug)]
pub struct GroupAccountSummaryReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountSummaryReply_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
    /// TODO
    pub start_date: Vec<u8>,
    /// TODO
    pub balance: i32,
    /// TODO
    pub total_credits: i32,
    /// TODO
    pub total_debits: i32,
    /// TODO
    pub object_tax_current: i32,
    /// TODO
    pub light_tax_current: i32,
    /// TODO
    pub land_tax_current: i32,
    /// TODO
    pub group_tax_current: i32,
    /// TODO
    pub parcel_dir_fee_current: i32,
    /// TODO
    pub object_tax_estimate: i32,
    /// TODO
    pub light_tax_estimate: i32,
    /// TODO
    pub land_tax_estimate: i32,
    /// TODO
    pub group_tax_estimate: i32,
    /// TODO
    pub parcel_dir_fee_estimate: i32,
    /// TODO
    pub non_exempt_members: i32,
    /// TODO
    pub last_tax_date: Vec<u8>,
    /// TODO
    pub tax_date: Vec<u8>,
}

/// 		TODO:
/// 		/// dataserver -> simulator -> viewer
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountSummaryReply {
    pub agent_data: GroupAccountSummaryReply_AgentData,
    pub money_data: GroupAccountSummaryReply_MoneyData,
}


#[derive(Clone, Debug)]
pub struct GroupAccountSummaryRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountSummaryRequest_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
}

/// 		TODO:
/// 		/// CurrentInterval = 0  =>  this period (week, day, etc.)
/// /// CurrentInterval = 1  =>  last period
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountSummaryRequest {
    pub agent_data: GroupAccountSummaryRequest_AgentData,
    pub money_data: GroupAccountSummaryRequest_MoneyData,
}


#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsReply_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
    /// TODO
    pub start_date: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsReply_HistoryData {
    /// TODO
    pub time: Vec<u8>,
    /// TODO
    pub user: Vec<u8>,
    /// TODO
    pub type_: i32,
    /// TODO
    pub item: Vec<u8>,
    /// TODO
    pub amount: i32,
}

/// TODO:
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsReply {
    pub agent_data: GroupAccountTransactionsReply_AgentData,
    pub money_data: GroupAccountTransactionsReply_MoneyData,
    pub history_data: Vec<GroupAccountTransactionsReply_HistoryData>,
}


#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsRequest_MoneyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub interval_days: i32,
    /// TODO
    pub current_interval: i32,
}

/// TODO:
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct GroupAccountTransactionsRequest {
    pub agent_data: GroupAccountTransactionsRequest_AgentData,
    pub money_data: GroupAccountTransactionsRequest_MoneyData,
}


#[derive(Clone, Debug)]
pub struct GroupActiveProposalItemReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupActiveProposalItemReply_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub total_num_items: u32,
}

#[derive(Clone, Debug)]
pub struct GroupActiveProposalItemReply_ProposalData {
    /// TODO
    pub vote_id: Uuid,
    /// TODO
    pub vote_initiator: Uuid,
    /// TODO
    pub terse_date_id: Vec<u8>,
    /// TODO
    pub start_date_time: Vec<u8>,
    /// TODO
    pub end_date_time: Vec<u8>,
    /// TODO
    pub already_voted: bool,
    /// TODO
    pub vote_cast: Vec<u8>,
    /// TODO
    pub majority: f32,
    /// TODO
    pub quorum: i32,
    /// TODO
    pub proposal_text: Vec<u8>,
}

/// 		TODO:
/// 		/// GroupActiveProposalItemReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupActiveProposalItemReply {
    pub agent_data: GroupActiveProposalItemReply_AgentData,
    pub transaction_data: GroupActiveProposalItemReply_TransactionData,
    pub proposal_data: Vec<GroupActiveProposalItemReply_ProposalData>,
}


#[derive(Clone, Debug)]
pub struct GroupActiveProposalsRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupActiveProposalsRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupActiveProposalsRequest_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
}

/// 		TODO:
/// 		/// GroupActiveProposalsRequest
/// /// viewer -> simulator -> dataserver
/// ///reliable
///
#[derive(Clone, Debug)]
pub struct GroupActiveProposalsRequest {
    pub agent_data: GroupActiveProposalsRequest_AgentData,
    pub group_data: GroupActiveProposalsRequest_GroupData,
    pub transaction_data: GroupActiveProposalsRequest_TransactionData,
}


#[derive(Clone, Debug)]
pub struct GroupDataUpdate_AgentGroupData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub agent_powers: u64,
    /// TODO
    pub group_title: Vec<u8>,
}

/// 		TODO:
/// 		/// GroupDataUpdate
/// /// This is a bunch of group data that needs to be appropriatly routed based on presence info.
/// /// dataserver -> simulator
///
#[derive(Clone, Debug)]
pub struct GroupDataUpdate {
    pub agent_group_data: Vec<GroupDataUpdate_AgentGroupData>,
}


#[derive(Clone, Debug)]
pub struct GroupMembersReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupMembersReply_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub member_count: i32,
}

#[derive(Clone, Debug)]
pub struct GroupMembersReply_MemberData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub contribution: i32,
    /// TODO
    pub online_status: Vec<u8>,
    /// TODO
    pub agent_powers: u64,
    /// TODO
    pub title: Vec<u8>,
    /// TODO
    pub is_owner: bool,
}

/// 		TODO:
/// 		/// GroupMembersReply
/// /// list of uuids for the group members
/// /// dataserver -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupMembersReply {
    pub agent_data: GroupMembersReply_AgentData,
    pub group_data: GroupMembersReply_GroupData,
    pub member_data: Vec<GroupMembersReply_MemberData>,
}


#[derive(Clone, Debug)]
pub struct GroupMembersRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupMembersRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
}

/// 		TODO:
/// 		/// GroupMembersRequest
/// /// get the group members
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupMembersRequest {
    pub agent_data: GroupMembersRequest_AgentData,
    pub group_data: GroupMembersRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct GroupNoticeAdd_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupNoticeAdd_MessageBlock {
    /// TODO
    pub to_group_id: Uuid,
    /// TODO
    pub id: Uuid,
    /// TODO
    pub dialog: u8,
    /// TODO
    pub from_agent_name: Vec<u8>,
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub binary_bucket: Vec<u8>,
}

/// 		TODO:
/// 		/// GroupNoticeAdd
/// /// Add a group notice.
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupNoticeAdd {
    pub agent_data: GroupNoticeAdd_AgentData,
    pub message_block: GroupNoticeAdd_MessageBlock,
}


#[derive(Clone, Debug)]
pub struct GroupNoticeRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupNoticeRequest_Data {
    /// TODO
    pub group_notice_id: Uuid,
}

/// 		TODO:
/// 		/// GroupNoticeRequest
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupNoticeRequest {
    pub agent_data: GroupNoticeRequest_AgentData,
    pub data: GroupNoticeRequest_Data,
}


#[derive(Clone, Debug)]
pub struct GroupNoticesListReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupNoticesListReply_Data {
    /// TODO
    pub notice_id: Uuid,
    /// TODO
    pub timestamp: u32,
    /// TODO
    pub from_name: Vec<u8>,
    /// TODO
    pub subject: Vec<u8>,
    /// TODO
    pub has_attachment: bool,
    /// TODO
    pub asset_type: u8,
}

/// 		TODO:
/// 		/// GroupNoticesListReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupNoticesListReply {
    pub agent_data: GroupNoticesListReply_AgentData,
    pub data: Vec<GroupNoticesListReply_Data>,
}


#[derive(Clone, Debug)]
pub struct GroupNoticesListRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupNoticesListRequest_Data {
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// GroupNoticeListRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupNoticesListRequest {
    pub agent_data: GroupNoticesListRequest_AgentData,
    pub data: GroupNoticesListRequest_Data,
}


#[derive(Clone, Debug)]
pub struct GroupProfileReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupProfileReply_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub charter: Vec<u8>,
    /// TODO
    pub show_in_list: bool,
    /// TODO
    pub member_title: Vec<u8>,
    /// TODO
    pub powers_mask: u64,
    /// TODO
    pub insignia_id: Uuid,
    /// TODO
    pub founder_id: Uuid,
    /// TODO
    pub membership_fee: i32,
    /// TODO
    pub open_enrollment: bool,
    /// TODO
    pub money: i32,
    /// TODO
    pub group_membership_count: i32,
    /// TODO
    pub group_roles_count: i32,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
    /// TODO
    pub owner_role: Uuid,
}

/// 		TODO:
/// 		/// GroupProfileReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupProfileReply {
    pub agent_data: GroupProfileReply_AgentData,
    pub group_data: GroupProfileReply_GroupData,
}


#[derive(Clone, Debug)]
pub struct GroupProfileRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupProfileRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// GroupProfileRequest
/// /// viewer-> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupProfileRequest {
    pub agent_data: GroupProfileRequest_AgentData,
    pub group_data: GroupProfileRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct GroupProposalBallot_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupProposalBallot_ProposalData {
    /// TODO
    pub proposal_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub vote_cast: Vec<u8>,
}

/// 		TODO:
/// 		/// GroupProposalBallot
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupProposalBallot {
    pub agent_data: GroupProposalBallot_AgentData,
    pub proposal_data: GroupProposalBallot_ProposalData,
}


#[derive(Clone, Debug)]
pub struct GroupRoleChanges_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupRoleChanges_RoleChange {
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub member_id: Uuid,
    /// TODO
    pub change: u32,
}

/// 		TODO:
/// 		/// GroupRoleChanges
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupRoleChanges {
    pub agent_data: GroupRoleChanges_AgentData,
    pub role_change: Vec<GroupRoleChanges_RoleChange>,
}


#[derive(Clone, Debug)]
pub struct GroupRoleDataReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupRoleDataReply_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub role_count: i32,
}

#[derive(Clone, Debug)]
pub struct GroupRoleDataReply_RoleData {
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub title: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub powers: u64,
    /// TODO
    pub members: u32,
}

/// 		TODO:
/// 		/// GroupRoleDataReply
/// /// All role data for this group
/// /// dataserver -> simulator -> agent
///
#[derive(Clone, Debug)]
pub struct GroupRoleDataReply {
    pub agent_data: GroupRoleDataReply_AgentData,
    pub group_data: GroupRoleDataReply_GroupData,
    pub role_data: Vec<GroupRoleDataReply_RoleData>,
}


#[derive(Clone, Debug)]
pub struct GroupRoleDataRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupRoleDataRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
}

/// 		TODO:
/// 		/// GroupRoleDataRequest
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct GroupRoleDataRequest {
    pub agent_data: GroupRoleDataRequest_AgentData,
    pub group_data: GroupRoleDataRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct GroupRoleMembersReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub total_pairs: u32,
}

#[derive(Clone, Debug)]
pub struct GroupRoleMembersReply_MemberData {
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub member_id: Uuid,
}

/// 		TODO:
/// 		/// GroupRoleMembersReply
/// /// All role::member pairs for this group.
/// /// dataserver -> simulator -> agent
///
#[derive(Clone, Debug)]
pub struct GroupRoleMembersReply {
    pub agent_data: GroupRoleMembersReply_AgentData,
    pub member_data: Vec<GroupRoleMembersReply_MemberData>,
}


#[derive(Clone, Debug)]
pub struct GroupRoleMembersRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupRoleMembersRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
}

/// 		TODO:
/// 		/// GroupRoleMembersRequest
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct GroupRoleMembersRequest {
    pub agent_data: GroupRoleMembersRequest_AgentData,
    pub group_data: GroupRoleMembersRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct GroupRoleUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupRoleUpdate_RoleData {
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub title: Vec<u8>,
    /// TODO
    pub powers: u64,
    /// TODO
    pub update_type: u8,
}

/// 		TODO:
/// 		/// GroupRoleUpdate
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct GroupRoleUpdate {
    pub agent_data: GroupRoleUpdate_AgentData,
    pub role_data: Vec<GroupRoleUpdate_RoleData>,
}


#[derive(Clone, Debug)]
pub struct GroupTitleUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub title_role_id: Uuid,
}

/// 		TODO:
/// 		/// GroupTitleUpdate
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct GroupTitleUpdate {
    pub agent_data: GroupTitleUpdate_AgentData,
}


#[derive(Clone, Debug)]
pub struct GroupTitlesReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupTitlesReply_GroupData {
    /// TODO
    pub title: Vec<u8>,
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub selected: bool,
}

/// 		TODO:
/// 		/// GroupTitlesReply
/// /// dataserver -> simulator -> viewer
///
#[derive(Clone, Debug)]
pub struct GroupTitlesReply {
    pub agent_data: GroupTitlesReply_AgentData,
    pub group_data: Vec<GroupTitlesReply_GroupData>,
}


#[derive(Clone, Debug)]
pub struct GroupTitlesRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub request_id: Uuid,
}

/// 		TODO:
/// 		/// GroupTitlesRequest
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct GroupTitlesRequest {
    pub agent_data: GroupTitlesRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct GroupVoteHistoryItemReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupVoteHistoryItemReply_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub total_num_items: u32,
}

#[derive(Clone, Debug)]
pub struct GroupVoteHistoryItemReply_HistoryItemData {
    /// TODO
    pub vote_id: Uuid,
    /// TODO
    pub terse_date_id: Vec<u8>,
    /// TODO
    pub start_date_time: Vec<u8>,
    /// TODO
    pub end_date_time: Vec<u8>,
    /// TODO
    pub vote_initiator: Uuid,
    /// TODO
    pub vote_type: Vec<u8>,
    /// TODO
    pub vote_result: Vec<u8>,
    /// TODO
    pub majority: f32,
    /// TODO
    pub quorum: i32,
    /// TODO
    pub proposal_text: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct GroupVoteHistoryItemReply_VoteItem {
    /// TODO
    pub candidate_id: Uuid,
    /// TODO
    pub vote_cast: Vec<u8>,
    /// TODO
    pub num_votes: i32,
}

/// 		TODO:
/// 		/// GroupVoteHistoryItemReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct GroupVoteHistoryItemReply {
    pub agent_data: GroupVoteHistoryItemReply_AgentData,
    pub transaction_data: GroupVoteHistoryItemReply_TransactionData,
    pub history_item_data: GroupVoteHistoryItemReply_HistoryItemData,
    pub vote_item: Vec<GroupVoteHistoryItemReply_VoteItem>,
}


#[derive(Clone, Debug)]
pub struct GroupVoteHistoryRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupVoteHistoryRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct GroupVoteHistoryRequest_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
}

/// 		TODO:
/// 		/// GroupVoteHistoryRequest
/// /// viewer -> simulator -> dataserver
/// ///reliable
///
#[derive(Clone, Debug)]
pub struct GroupVoteHistoryRequest {
    pub agent_data: GroupVoteHistoryRequest_AgentData,
    pub group_data: GroupVoteHistoryRequest_GroupData,
    pub transaction_data: GroupVoteHistoryRequest_TransactionData,
}


#[derive(Clone, Debug)]
pub struct HealthMessage_HealthData {
    /// TODO
    pub health: f32,
}

/// 		TODO:
/// 		/// Health Message
/// /// Tells viewer what agent health is
///
#[derive(Clone, Debug)]
pub struct HealthMessage {
    pub health_data: HealthMessage_HealthData,
}


#[derive(Clone, Debug)]
pub struct ImageData_ImageID {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub codec: u8,
    /// TODO
    pub size: u32,
    /// TODO
    pub packets: u16,
}

#[derive(Clone, Debug)]
pub struct ImageData_ImageData {
    /// TODO
    pub data: Vec<u8>,
}

/// TODO:
/// /// ImageData - sent to viewer to transmit information about an image
///
#[derive(Clone, Debug)]
pub struct ImageData {
    pub image_id: ImageData_ImageID,
    pub image_data: ImageData_ImageData,
}


#[derive(Clone, Debug)]
pub struct ImageNotInDatabase_ImageID {
    /// TODO
    pub id: Uuid,
}

/// 		TODO:
/// 		/// ImageNotInDatabase
/// /// Simulator informs viewer that a requsted image definitely does not exist in the asset
/// database
///
#[derive(Clone, Debug)]
pub struct ImageNotInDatabase {
    pub image_id: ImageNotInDatabase_ImageID,
}


#[derive(Clone, Debug)]
pub struct ImagePacket_ImageID {
    /// UUID of the texture.
    pub id: Uuid,
    /// The "packet number" indicates the number of the chunk which was sent.
    ///
    pub packet: u16,
}

#[derive(Clone, Debug)]
pub struct ImagePacket_ImageData {
    /// Binary data of the image.
    pub data: Vec<u8>,
}

/// Response to a RequestImage message having >1 packet of data.
///
#[derive(Clone, Debug)]
pub struct ImagePacket {
    pub image_id: ImagePacket_ImageID,
    pub image_data: ImagePacket_ImageData,
}


#[derive(Clone, Debug)]
pub struct ImprovedInstantMessage_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ImprovedInstantMessage_MessageBlock {
    /// TODO
    pub from_group: bool,
    /// TODO
    pub to_agent_id: Uuid,
    /// TODO
    pub parent_estate_id: u32,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub offline: u8,
    /// TODO
    pub dialog: u8,
    /// TODO
    pub id: Uuid,
    /// TODO
    pub timestamp: u32,
    /// TODO
    pub from_agent_name: Vec<u8>,
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub binary_bucket: Vec<u8>,
}

/// 		TODO:
/// 		/// ImprovedInstantMessage
/// /// This message can potentially route all over the place
/// /// ParentEstateID: parent estate id of the source estate
/// /// RegionID: region id of the source of the IM.
/// /// Position: position of the sender in region local coordinates
/// /// Dialog	see llinstantmessage.h for values
/// /// ID		May be used by dialog. Interpretation depends on context.
/// /// BinaryBucket May be used by some dialog types
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ImprovedInstantMessage {
    pub agent_data: ImprovedInstantMessage_AgentData,
    pub message_block: ImprovedInstantMessage_MessageBlock,
}


#[derive(Clone, Debug)]
pub struct ImprovedTerseObjectUpdate_RegionData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub time_dilation: u16,
}

#[derive(Clone, Debug)]
pub struct ImprovedTerseObjectUpdate_ObjectData {
    /// In sequential fashion the following fields are encoded.
    ///
    /// | bytes | field            | type        | description |
    /// | ----- | ---------------- | ----------- | ----------- |
    /// | 4     | local_id         | u32         | should be the same as client.local_id |
    /// | 1     | state            | u8          | TODO |
    /// | 1     | collision_exists | bool        | If 0 the next field is not specified (zero
    /// bytes), if 1 read as usual. | | 16?   | collision_plane  | Vector4 f32 | |
    /// | 12    | position         | Vector3 f32 | |
    /// | 6     | velocity         | Vector3 u16f [-128;128] | |
    /// | 6     | acceleration     | Vector3 u16f [-64;64] | |
    /// | 8     | rotation (theta) | Quat4 u16f [-1;1] | |
    /// | 6     | angular vel. (omega) | Vector3 u16f [-64;64] | |
    ///
    /// u16f: Means that the data is encoded as u16 (0-255), and is to be mapped
    ///       into the f32 range specified in square brackets afterwards.
    ///       Note that here we have to be careful that we set the value to zero,
    ///       if `abs(fval) < (upper-lower) as f32 / 255`, so exact zeros can
    ///       be decoded.
    ///
    pub data: Vec<u8>,
    /// If this field's value is even shorter than 16 bytes, the OpenMetaverse code
    /// did not fail but report an absence of value, so probably we should do
    /// the same thing. (TODO: Decide on that.)
    ///
    /// A TextureEntry specifies the properties of up to 32 faces.
    /// Each of the properties is encoded for all specified faces as an array,
    /// packed according to the following rules, and the arrays follow directly
    /// after each other.
    ///
    /// These properties are specified (in this order).
    ///
    /// | Property   | Value Type (Bytes) | Description |
    /// | ---------- | ------------------ | ----------- |
    /// | Texture    | UUID (16)          | The texture ID for this face. |
    /// | Color      | Color4 (4)         | RGBA value. |
    /// | RepeatU    | f32 (4)            | TODO |
    /// | RepeatV    | f32 (4)            | TODO |
    /// | OffsetU    | f32 (2) *A         | TODO |
    /// | OffsetV    | f32 (2) *A         | TODO |
    /// | Rotation   | f32 (2) *B         | TODO |
    /// | Material   | u8 (1)             | TODO |
    /// | Media      | u8 (1)             | TODO |
    /// | Glow       | f32 (1) *C         | TODO |
    /// | MaterialID | UUID (16)          | TODO, note this value can also be missing like texture
    /// |
    ///
    /// f32 encoding:
    /// ============
    /// - A: `read_i16::<LE>() / 32767.0f`
    /// - B: `read_u16::<LE>() / 32768.0f * 2π`
    /// - C: `read_u8() / 255.0f`
    ///
    /// Array structure:
    /// ===============
    /// - encode: default value for faces without an explicitly specified value
    /// - repeat
    ///     - encode: faces bit field
    ///         - if bit is 1 set the face property to the following value otherwise ignore
    ///         - if the whole bitset is zero, end of array is reached.
    ///     - encode: value
    ///
    /// Arrays are preceeded with a default value for all unspecified faces,
    /// and then followed by values for a selection of faces.
    ///
    /// Faces bit field:
    ///
    /// ```text
    /// +--------+     +--------+--------+
    /// |1XXXXXXX| ... |1XXXXXXX|0XXXXXXX|
    /// +--------+     +--------+--------+
    /// ```
    /// - The value is obtained by gluing together the X bits in the same order as above,
    ///   (assuming zero padding on the left side) then interpreting this as a little endian
    ///   u32 number.
    /// - Note that there can be even zero bytes with a 1 at the beginning.
    /// - Bits refer right to left to faces 0, 1, 2, etc.
    ///
    pub texture_entry: Vec<u8>,
}

/// A terse object update is sent, when a transformation matrix, velocity or acceleration of an
/// object changes, but the rest does not change.
///
///
#[derive(Clone, Debug)]
pub struct ImprovedTerseObjectUpdate {
    pub region_data: ImprovedTerseObjectUpdate_RegionData,
    pub object_data: Vec<ImprovedTerseObjectUpdate_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct InitiateDownload_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct InitiateDownload_FileData {
    /// TODO
    pub sim_filename: Vec<u8>,
    /// TODO
    pub viewer_filename: Vec<u8>,
}

/// 		TODO:
/// 		/// sim -> viewer
/// /// initiate upload. primarily used for uploading raw files.
///
#[derive(Clone, Debug)]
pub struct InitiateDownload {
    pub agent_data: InitiateDownload_AgentData,
    pub file_data: InitiateDownload_FileData,
}


#[derive(Clone, Debug)]
pub struct InternalScriptMail_DataBlock {
    /// TODO
    pub from: Vec<u8>,
    /// TODO
    pub to: Uuid,
    /// TODO
    pub subject: Vec<u8>,
    /// TODO
    pub body: Vec<u8>,
}

/// TODO:
/// /// Script on simulator sends mail to another script
///
#[derive(Clone, Debug)]
pub struct InternalScriptMail {
    pub data_block: InternalScriptMail_DataBlock,
}


#[derive(Clone, Debug)]
pub struct InventoryAssetResponse_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub is_readable: bool,
}

/// 		TODO:
/// 		/// response to RequestInventoryAsset
/// /// lluuid will be null if agentid in the request above cannot read asset
///
#[derive(Clone, Debug)]
pub struct InventoryAssetResponse {
    pub query_data: InventoryAssetResponse_QueryData,
}


#[derive(Clone, Debug)]
pub struct InventoryDescendents_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub version: i32,
    /// TODO
    pub descendents: i32,
}

#[derive(Clone, Debug)]
pub struct InventoryDescendents_FolderData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub name: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct InventoryDescendents_ItemData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// 		TODO:
/// 		/// return inventory segment.
/// /// *NOTE: This could be compressed more since we already know the
/// /// parent_id for folders and the folder_id for items, but this is
/// /// reasonable until we heve server side inventory.
///
#[derive(Clone, Debug)]
pub struct InventoryDescendents {
    pub agent_data: InventoryDescendents_AgentData,
    pub folder_data: Vec<InventoryDescendents_FolderData>,
    pub item_data: Vec<InventoryDescendents_ItemData>,
}


#[derive(Clone, Debug)]
pub struct InviteGroupRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct InviteGroupRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct InviteGroupRequest_InviteData {
    /// TODO
    pub invitee_id: Uuid,
    /// TODO
    pub role_id: Uuid,
}

/// 		TODO:
/// 		/// InviteGroupRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct InviteGroupRequest {
    pub agent_data: InviteGroupRequest_AgentData,
    pub group_data: InviteGroupRequest_GroupData,
    pub invite_data: Vec<InviteGroupRequest_InviteData>,
}


#[derive(Clone, Debug)]
pub struct InviteGroupResponse_InviteData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub invitee_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub role_id: Uuid,
    /// TODO
    pub membership_fee: i32,
}

/// 		TODO:
/// 		/// InviteGroupResponse
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct InviteGroupResponse {
    pub invite_data: InviteGroupResponse_InviteData,
}


#[derive(Clone, Debug)]
pub struct JoinGroupReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct JoinGroupReply_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub success: bool,
}

/// 		TODO:
/// 		/// JoinGroupReply
/// /// dataserver -> simulator -> viewer
///
#[derive(Clone, Debug)]
pub struct JoinGroupReply {
    pub agent_data: JoinGroupReply_AgentData,
    pub group_data: JoinGroupReply_GroupData,
}


#[derive(Clone, Debug)]
pub struct JoinGroupRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct JoinGroupRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// JoinGroupRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct JoinGroupRequest {
    pub agent_data: JoinGroupRequest_AgentData,
    pub group_data: JoinGroupRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct KickUser_TargetBlock {
    /// TODO
    pub target_ip: Ip4Addr,
    /// TODO
    pub target_port: IpPort,
}

#[derive(Clone, Debug)]
pub struct KickUser_UserInfo {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub reason: Vec<u8>,
}

/// 		TODO:
/// 		/// KickUser
/// /// *FIXME*
/// /// Kick off a logged-in user, such as when two people log in with the
/// /// same account name.
/// /// ROUTED dataserver -> userserver -> spaceserver -> simulator -> viewer
/// /// reliable, but that may not matter if a system component is quitting
///
#[derive(Clone, Debug)]
pub struct KickUser {
    pub target_block: KickUser_TargetBlock,
    pub user_info: KickUser_UserInfo,
}


#[derive(Clone, Debug)]
pub struct KickUserAck_UserInfo {
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// ack sent from the simulator up to the main database so that login
/// /// can continue.
///
#[derive(Clone, Debug)]
pub struct KickUserAck {
    pub user_info: KickUserAck_UserInfo,
}


#[derive(Clone, Debug)]
pub struct KillChildAgents_IDBlock {
    /// TODO
    pub agent_id: Uuid,
}

/// TODO:
/// /// KillChildAgents - A new agent has connected to the simulator . . . make sure that any old
/// child cameras are blitzed
///
#[derive(Clone, Debug)]
pub struct KillChildAgents {
    pub id_block: KillChildAgents_IDBlock,
}


#[derive(Clone, Debug)]
pub struct KillObject_ObjectData {
    /// TODO
    pub id: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct KillObject {
    pub object_data: Vec<KillObject_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct LandStatReply_RequestData {
    /// TODO
    pub report_type: u32,
    /// TODO
    pub request_flags: u32,
    /// TODO
    pub total_object_count: u32,
}

#[derive(Clone, Debug)]
pub struct LandStatReply_ReportData {
    /// TODO
    pub task_local_id: u32,
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub location_x: f32,
    /// TODO
    pub location_y: f32,
    /// TODO
    pub location_z: f32,
    /// TODO
    pub score: f32,
    /// TODO
    pub task_name: Vec<u8>,
    /// TODO
    pub owner_name: Vec<u8>,
}

/// 		TODO:
/// 		/// LandStatReply
/// /// Sent by the simulator in response to LandStatRequest
///
#[derive(Clone, Debug)]
pub struct LandStatReply {
    pub request_data: LandStatReply_RequestData,
    pub report_data: Vec<LandStatReply_ReportData>,
}


#[derive(Clone, Debug)]
pub struct LandStatRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LandStatRequest_RequestData {
    /// TODO
    pub report_type: u32,
    /// TODO
    pub request_flags: u32,
    /// TODO
    pub filter: Vec<u8>,
    /// TODO
    pub parcel_local_id: i32,
}

/// 		TODO:
/// 		/// LandStatRequest
/// /// Sent by the viewer to request collider/script information for a parcel
///
#[derive(Clone, Debug)]
pub struct LandStatRequest {
    pub agent_data: LandStatRequest_AgentData,
    pub request_data: LandStatRequest_RequestData,
}


#[derive(Clone, Debug)]
pub struct LayerData_LayerID {
    /// Describes what kind of layer this is.
    ///
    /// LAND: 'L'
    /// WIND: '7'
    /// CLOUD: '8'
    /// WATER: 'W'
    /// AURORA_LAND: 'M'
    /// AURORA_WATER: 'X'
    /// AURORA_WIND: '9'
    /// AURORA_CLOUD: ':'
    ///
    pub type_: u8,
}

#[derive(Clone, Debug)]
pub struct LayerData_LayerData {
    /// Not all layers seem to be encoded in the same way.
    ///
    /// Land layer:
    /// getLand().decompressDCTPatch
    ///
    /// TODO: Figure out the encoding of this.
    ///
    ///
    pub data: Vec<u8>,
}

/// With this packet the simulator sends information about the region to be rendered.
///
/// TODO:
///
#[derive(Clone, Debug)]
pub struct LayerData {
    pub layer_id: LayerData_LayerID,
    pub layer_data: LayerData_LayerData,
}


#[derive(Clone, Debug)]
pub struct LeaveGroupReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LeaveGroupReply_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub success: bool,
}

/// 		TODO:
/// 		/// LeaveGroupReply
/// /// dataserver -> simulator -> viewer
///
#[derive(Clone, Debug)]
pub struct LeaveGroupReply {
    pub agent_data: LeaveGroupReply_AgentData,
    pub group_data: LeaveGroupReply_GroupData,
}


#[derive(Clone, Debug)]
pub struct LeaveGroupRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LeaveGroupRequest_GroupData {
    /// TODO
    pub group_id: Uuid,
}

/// 		TODO:
/// 		/// LeaveGroupRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct LeaveGroupRequest {
    pub agent_data: LeaveGroupRequest_AgentData,
    pub group_data: LeaveGroupRequest_GroupData,
}


#[derive(Clone, Debug)]
pub struct LinkInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LinkInventoryItem_InventoryBlock {
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub old_item_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct LinkInventoryItem {
    pub agent_data: LinkInventoryItem_AgentData,
    pub inventory_block: LinkInventoryItem_InventoryBlock,
}


#[derive(Clone, Debug)]
pub struct LiveHelpGroupReply_ReplyData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub selection: Vec<u8>,
}

/// 		TODO:
/// 		/// Send down the group
/// /// dataserver -> userserver
///
#[derive(Clone, Debug)]
pub struct LiveHelpGroupReply {
    pub reply_data: LiveHelpGroupReply_ReplyData,
}


#[derive(Clone, Debug)]
pub struct LiveHelpGroupRequest_RequestData {
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub agent_id: Uuid,
}

/// 		TODO:
/// 		/// Request the members of the live help group needed for requesting agent.
/// /// userserver -> dataserver
///
#[derive(Clone, Debug)]
pub struct LiveHelpGroupRequest {
    pub request_data: LiveHelpGroupRequest_RequestData,
}


#[derive(Clone, Debug)]
pub struct LoadURL_Data {
    /// TODO
    pub object_name: Vec<u8>,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub owner_is_group: bool,
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub url: Vec<u8>,
}

/// 		TODO:
/// 		/// LoadURL
/// /// sim -> viewer
/// /// Ask the user if they would like to load a URL
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct LoadURL {
    pub data: LoadURL_Data,
}


#[derive(Clone, Debug)]
pub struct LogDwellTime_DwellInfo {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub duration: f32,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub region_x: u32,
    /// TODO
    pub region_y: u32,
    /// TODO
    pub avg_agents_in_view: u8,
    /// TODO
    pub avg_viewer_fps: u8,
}

/// TODO:
/// /// record dwell time.
///
#[derive(Clone, Debug)]
pub struct LogDwellTime {
    pub dwell_info: LogDwellTime_DwellInfo,
}


#[derive(Clone, Debug)]
pub struct LogFailedMoneyTransaction_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub transaction_time: u32,
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub flags: u8,
    /// TODO
    pub amount: i32,
    /// TODO
    pub simulator_ip: Ip4Addr,
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
    /// TODO
    pub failure_type: u8,
}

/// 		TODO:
/// 		/// record lost money transactions.  This message could be generated
/// /// from either the simulator or the dataserver, depending on how
/// /// the transaction failed.
///
#[derive(Clone, Debug)]
pub struct LogFailedMoneyTransaction {
    pub transaction_data: LogFailedMoneyTransaction_TransactionData,
}


#[derive(Clone, Debug)]
pub struct LogParcelChanges_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LogParcelChanges_RegionData {
    /// TODO
    pub region_handle: u64,
}

#[derive(Clone, Debug)]
pub struct LogParcelChanges_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub is_owner_group: bool,
    /// TODO
    pub actual_area: i32,
    /// TODO
    pub action: i8,
    /// TODO
    pub transaction_id: Uuid,
}

/// TODO:
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct LogParcelChanges {
    pub agent_data: LogParcelChanges_AgentData,
    pub region_data: LogParcelChanges_RegionData,
    pub parcel_data: Vec<LogParcelChanges_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct LogTextMessage_DataBlock {
    /// TODO
    pub from_agent_id: Uuid,
    /// TODO
    pub to_agent_id: Uuid,
    /// TODO
    pub global_x: f64,
    /// TODO
    pub global_y: f64,
    /// TODO
    pub time: u32,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// LogTextMessage
/// /// Asks the dataserver to log the contents of this message in the
/// /// chat and IM log table.
/// /// Sent from userserver (IM logging) and simulator (chat logging).
///
#[derive(Clone, Debug)]
pub struct LogTextMessage {
    pub data_block: Vec<LogTextMessage_DataBlock>,
}


#[derive(Clone, Debug)]
pub struct LogoutReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct LogoutReply_InventoryData {
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// LogoutReply
/// /// it's ok for the viewer to quit.
/// /// sim -> viewer
/// /// reliable
/// /// Includes inventory items to update with new asset ids
///
#[derive(Clone, Debug)]
pub struct LogoutReply {
    pub agent_data: LogoutReply_AgentData,
    pub inventory_data: Vec<LogoutReply_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct LogoutRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// LogoutRequest
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct LogoutRequest {
    pub agent_data: LogoutRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct MapBlockReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub flags: u32,
}

#[derive(Clone, Debug)]
pub struct MapBlockReply_Data {
    /// TODO
    pub x: u16,
    /// TODO
    pub y: u16,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub access: u8,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub water_height: u8,
    /// TODO
    pub agents: u8,
    /// TODO
    pub map_image_id: Uuid,
}

/// TODO:
/// /// sim -> viewer
///
#[derive(Clone, Debug)]
pub struct MapBlockReply {
    pub agent_data: MapBlockReply_AgentData,
    pub data: Vec<MapBlockReply_Data>,
}


#[derive(Clone, Debug)]
pub struct MapBlockRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

#[derive(Clone, Debug)]
pub struct MapBlockRequest_PositionData {
    /// TODO
    pub min_x: u16,
    /// TODO
    pub max_x: u16,
    /// TODO
    pub min_y: u16,
    /// TODO
    pub max_y: u16,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// This message is sent up from the viewer to get a list
/// /// of the sims in a specified region.
/// /// Returns: MapBlockReply
///
#[derive(Clone, Debug)]
pub struct MapBlockRequest {
    pub agent_data: MapBlockRequest_AgentData,
    pub position_data: MapBlockRequest_PositionData,
}


#[derive(Clone, Debug)]
pub struct MapItemReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub flags: u32,
}

#[derive(Clone, Debug)]
pub struct MapItemReply_RequestData {
    /// TODO
    pub item_type: u32,
}

#[derive(Clone, Debug)]
pub struct MapItemReply_Data {
    /// TODO
    pub x: u32,
    /// TODO
    pub y: u32,
    /// TODO
    pub id: Uuid,
    /// TODO
    pub extra: i32,
    /// TODO
    pub extra2: i32,
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
/// /// sim -> viewer
///
#[derive(Clone, Debug)]
pub struct MapItemReply {
    pub agent_data: MapItemReply_AgentData,
    pub request_data: MapItemReply_RequestData,
    pub data: Vec<MapItemReply_Data>,
}


#[derive(Clone, Debug)]
pub struct MapItemRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

#[derive(Clone, Debug)]
pub struct MapItemRequest_RequestData {
    /// TODO
    pub item_type: u32,
    /// TODO
    pub region_handle: u64,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// This message is sent up from the viewer to get a list
/// /// of the items of a particular type on the map.
/// /// Used for Telehubs, Agents, Events, Popular Places, etc.
/// /// Returns: MapBlockReply
///
#[derive(Clone, Debug)]
pub struct MapItemRequest {
    pub agent_data: MapItemRequest_AgentData,
    pub request_data: MapItemRequest_RequestData,
}


#[derive(Clone, Debug)]
pub struct MapLayerReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub flags: u32,
}

#[derive(Clone, Debug)]
pub struct MapLayerReply_LayerData {
    /// TODO
    pub left: u32,
    /// TODO
    pub right: u32,
    /// TODO
    pub top: u32,
    /// TODO
    pub bottom: u32,
    /// TODO
    pub image_id: Uuid,
}

/// TODO:
/// /// sim -> viewer
///
#[derive(Clone, Debug)]
pub struct MapLayerReply {
    pub agent_data: MapLayerReply_AgentData,
    pub layer_data: Vec<MapLayerReply_LayerData>,
}


#[derive(Clone, Debug)]
pub struct MapLayerRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// reliable
/// /// This message is sent up from the viewer to (eventually) get a list
/// /// of all map layers and NULL-layer sims.
/// /// Returns: MapLayerReply and MapBlockReply
///
#[derive(Clone, Debug)]
pub struct MapLayerRequest {
    pub agent_data: MapLayerRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct MapNameRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub flags: u32,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub godlike: bool,
}

#[derive(Clone, Debug)]
pub struct MapNameRequest_NameData {
    /// TODO
    pub name: Vec<u8>,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// This message is sent up from the viewer to get a list
/// /// of the sims with a given name.
/// /// Returns: MapBlockReply
///
#[derive(Clone, Debug)]
pub struct MapNameRequest {
    pub agent_data: MapNameRequest_AgentData,
    pub name_data: MapNameRequest_NameData,
}


#[derive(Clone, Debug)]
pub struct MeanCollisionAlert_MeanCollision {
    /// TODO
    pub victim: Uuid,
    /// TODO
    pub perp: Uuid,
    /// TODO
    pub time: u32,
    /// TODO
    pub mag: f32,
    /// TODO
    pub type_: u8,
}

/// 		TODO:
/// 		/// MeanCollisionAlert
/// /// Specifies the text to be posted in an alert dialog
///
#[derive(Clone, Debug)]
pub struct MeanCollisionAlert {
    pub mean_collision: Vec<MeanCollisionAlert_MeanCollision>,
}


#[derive(Clone, Debug)]
pub struct MergeParcel_MasterParcelData {
    /// TODO
    pub master_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MergeParcel_SlaveParcelData {
    /// TODO
    pub slave_id: Uuid,
}

/// 		TODO:
/// 		/// sim -> dataserver
/// /// Merges some of the database information for parcels (dwell).
///
#[derive(Clone, Debug)]
pub struct MergeParcel {
    pub master_parcel_data: MergeParcel_MasterParcelData,
    pub slave_parcel_data: Vec<MergeParcel_SlaveParcelData>,
}


#[derive(Clone, Debug)]
pub struct ModifyLand_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ModifyLand_ModifyBlock {
    /// TODO
    pub action: u8,
    /// TODO
    pub brush_size: u8,
    /// TODO
    pub seconds: f32,
    /// TODO
    pub height: f32,
}

#[derive(Clone, Debug)]
pub struct ModifyLand_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub west: f32,
    /// TODO
    pub south: f32,
    /// TODO
    pub east: f32,
    /// TODO
    pub north: f32,
}

#[derive(Clone, Debug)]
pub struct ModifyLand_ModifyBlockExtended {
    /// TODO
    pub brush_size: f32,
}

/// 		TODO:
/// 		/// ModifyLand - sent to modify a piece of land on a simulator.
/// /// viewer -> sim
///
#[derive(Clone, Debug)]
pub struct ModifyLand {
    pub agent_data: ModifyLand_AgentData,
    pub modify_block: ModifyLand_ModifyBlock,
    pub parcel_data: Vec<ModifyLand_ParcelData>,
    pub modify_block_extended: Vec<ModifyLand_ModifyBlockExtended>,
}


#[derive(Clone, Debug)]
pub struct MoneyBalanceReply_MoneyData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub transaction_success: bool,
    /// TODO
    pub money_balance: i32,
    /// TODO
    pub square_meters_credit: i32,
    /// TODO
    pub square_meters_committed: i32,
    /// TODO
    pub description: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct MoneyBalanceReply_TransactionInfo {
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub is_source_group: bool,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub is_dest_group: bool,
    /// TODO
    pub amount: i32,
    /// TODO
    pub item_description: Vec<u8>,
}

/// 		TODO:
/// 		/// dataserver -> simulator -> viewer
/// /// For replies that are part of a transaction (buying something) provide
/// /// metadata for localization.  If TransactionType is 0, the message is
/// /// purely a balance update.  Added for server 1.40 and viewer 2.1.  JC
///
#[derive(Clone, Debug)]
pub struct MoneyBalanceReply {
    pub money_data: MoneyBalanceReply_MoneyData,
    pub transaction_info: MoneyBalanceReply_TransactionInfo,
}


#[derive(Clone, Debug)]
pub struct MoneyBalanceRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MoneyBalanceRequest_MoneyData {
    /// TODO
    pub transaction_id: Uuid,
}

/// 		TODO:
/// 		/// viewer -> userserver -> dataserver
/// /// Reliable
///
#[derive(Clone, Debug)]
pub struct MoneyBalanceRequest {
    pub agent_data: MoneyBalanceRequest_AgentData,
    pub money_data: MoneyBalanceRequest_MoneyData,
}


#[derive(Clone, Debug)]
pub struct MoneyTransferBackend_MoneyData {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub transaction_time: u32,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub flags: u8,
    /// TODO
    pub amount: i32,
    /// TODO
    pub aggregate_perm_next_owner: u8,
    /// TODO
    pub aggregate_perm_inventory: u8,
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
    /// TODO
    pub description: Vec<u8>,
}

/// 		TODO:
/// 		/// And, the money transfer
/// /// *NOTE: Unused as of 2010-04-06, because all back-end money transactions
/// /// are done with web services via L$ API.  JC
///
#[derive(Clone, Debug)]
pub struct MoneyTransferBackend {
    pub money_data: MoneyTransferBackend_MoneyData,
}


#[derive(Clone, Debug)]
pub struct MoneyTransferRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MoneyTransferRequest_MoneyData {
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub flags: u8,
    /// TODO
    pub amount: i32,
    /// TODO
    pub aggregate_perm_next_owner: u8,
    /// TODO
    pub aggregate_perm_inventory: u8,
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub description: Vec<u8>,
}

/// 		TODO:
/// 		/// Move money from one agent to another. Validation will happen at the
/// /// simulator, the dataserver will actually do the work. Dataserver
/// /// generates a MoneyBalance message in reply.  The simulator
/// /// will generate a MoneyTransferBackend in response to this.
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct MoneyTransferRequest {
    pub agent_data: MoneyTransferRequest_AgentData,
    pub money_data: MoneyTransferRequest_MoneyData,
}


#[derive(Clone, Debug)]
pub struct MoveInventoryFolder_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub stamp: bool,
}

#[derive(Clone, Debug)]
pub struct MoveInventoryFolder_InventoryData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct MoveInventoryFolder {
    pub agent_data: MoveInventoryFolder_AgentData,
    pub inventory_data: Vec<MoveInventoryFolder_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct MoveInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub stamp: bool,
}

#[derive(Clone, Debug)]
pub struct MoveInventoryItem_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub new_name: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct MoveInventoryItem {
    pub agent_data: MoveInventoryItem_AgentData,
    pub inventory_data: Vec<MoveInventoryItem_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct MoveTaskInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MoveTaskInventory_InventoryData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct MoveTaskInventory {
    pub agent_data: MoveTaskInventory_AgentData,
    pub inventory_data: MoveTaskInventory_InventoryData,
}


#[derive(Clone, Debug)]
pub struct MultipleObjectUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MultipleObjectUpdate_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub type_: u8,
    /// TODO
    pub data: Vec<u8>,
}

/// 		TODO:
/// 		/// MultipleObjectUpdate
/// /// viewer -> simulator
/// /// updates position, rotation and scale in one message
/// /// positions sent as region-local floats
///
#[derive(Clone, Debug)]
pub struct MultipleObjectUpdate {
    pub agent_data: MultipleObjectUpdate_AgentData,
    pub object_data: Vec<MultipleObjectUpdate_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct MuteListRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct MuteListRequest_MuteData {
    /// TODO
    pub mute_crc: u32,
}

/// TODO:
/// /// request for mute list
///
#[derive(Clone, Debug)]
pub struct MuteListRequest {
    pub agent_data: MuteListRequest_AgentData,
    pub mute_data: MuteListRequest_MuteData,
}


#[derive(Clone, Debug)]
pub struct MuteListUpdate_MuteData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub filename: Vec<u8>,
}

/// TODO:
/// /// dataserver-> userserver -> viewer to move around the mute list
///
#[derive(Clone, Debug)]
pub struct MuteListUpdate {
    pub mute_data: MuteListUpdate_MuteData,
}


#[derive(Clone, Debug)]
pub struct NameValuePair_TaskData {
    /// TODO
    pub id: Uuid,
}

#[derive(Clone, Debug)]
pub struct NameValuePair_NameValueData {
    /// TODO
    pub nv_pair: Vec<u8>,
}

/// TODO:
/// /// NameValuePair - if the specific task exists on simulator, add or replace this name value
/// pair
///
#[derive(Clone, Debug)]
pub struct NameValuePair {
    pub task_data: NameValuePair_TaskData,
    pub name_value_data: Vec<NameValuePair_NameValueData>,
}


#[derive(Clone, Debug)]
pub struct NearestLandingRegionReply_LandingRegionData {
    /// TODO
    pub region_handle: u64,
}

/// 		TODO:
/// 		///NearestLandingPointReply
/// ///dataserver->sim
/// ///Sent from the data server to a region in reply
/// ///to the redirectregion request stating which region
/// ///the requesting region should redirect teleports to if necessary
///
#[derive(Clone, Debug)]
pub struct NearestLandingRegionReply {
    pub landing_region_data: NearestLandingRegionReply_LandingRegionData,
}


#[derive(Clone, Debug)]
pub struct NearestLandingRegionRequest_RequestingRegionData {
    /// TODO
    pub region_handle: u64,
}

/// 		TODO:
/// 		///NearestLandingRegionRequest
/// ///sim->dataserver
/// ///Sent from the region to the data server
/// ///to request the most up to date region for the requesting
/// ///region to redirect teleports to
///
#[derive(Clone, Debug)]
pub struct NearestLandingRegionRequest {
    pub requesting_region_data: NearestLandingRegionRequest_RequestingRegionData,
}


#[derive(Clone, Debug)]
pub struct NearestLandingRegionUpdated_RegionData {
    /// TODO
    pub region_handle: u64,
}

/// 		TODO:
/// 		///NearestLandingPointUpdated
/// ///sim->dataserver
/// ///Sent from a region to the data server
/// ///to have the dataserver note/clear in the db
/// ///that the region has updated it's nearest landing point
///
#[derive(Clone, Debug)]
pub struct NearestLandingRegionUpdated {
    pub region_data: NearestLandingRegionUpdated_RegionData,
}


#[derive(Clone, Debug)]
pub struct NeighborList_NeighborBlock {
    /// TODO
    pub ip: Ip4Addr,
    /// TODO
    pub port: IpPort,
    /// TODO
    pub public_ip: Ip4Addr,
    /// TODO
    pub public_port: IpPort,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub sim_access: u8,
}

/// TODO:
/// /// Neighbor List - Passed anytime neighbors change
///
#[derive(Clone, Debug)]
pub struct NeighborList {
    pub neighbor_block: ArrayVec<[NeighborList_NeighborBlock; 4]>,
}


#[derive(Clone, Debug)]
pub struct NetTest_NetBlock {
    /// TODO
    pub port: IpPort,
}

/// 		TODO:
/// 		/// NetTest - This goes back and forth to the space server because of
/// /// problems determining the port
///
#[derive(Clone, Debug)]
pub struct NetTest {
    pub net_block: NetTest_NetBlock,
}


#[derive(Clone, Debug)]
pub struct ObjectAdd_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectAdd_ObjectData {
    /// TODO
    pub p_code: u8,
    /// TODO
    pub material: u8,
    /// TODO
    pub add_flags: u32,
    /// TODO
    pub path_curve: u8,
    /// TODO
    pub profile_curve: u8,
    /// TODO
    pub path_begin: u16,
    /// TODO
    pub path_end: u16,
    /// TODO
    pub path_scale_x: u8,
    /// TODO
    pub path_scale_y: u8,
    /// TODO
    pub path_shear_x: u8,
    /// TODO
    pub path_shear_y: u8,
    /// TODO
    pub path_twist: i8,
    /// TODO
    pub path_twist_begin: i8,
    /// TODO
    pub path_radius_offset: i8,
    /// TODO
    pub path_taper_x: i8,
    /// TODO
    pub path_taper_y: i8,
    /// TODO
    pub path_revolutions: u8,
    /// TODO
    pub path_skew: i8,
    /// TODO
    pub profile_begin: u16,
    /// TODO
    pub profile_end: u16,
    /// TODO
    pub profile_hollow: u16,
    /// TODO
    pub bypass_raycast: u8,
    /// TODO
    pub ray_start: Vector3<f32>,
    /// TODO
    pub ray_end: Vector3<f32>,
    /// TODO
    pub ray_target_id: Uuid,
    /// TODO
    pub ray_end_is_intersection: u8,
    /// TODO
    pub scale: Vector3<f32>,
    /// TODO
    pub rotation: Quaternion<f32>,
    /// TODO
    pub state: u8,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectAdd {
    pub agent_data: ObjectAdd_AgentData,
    pub object_data: ObjectAdd_ObjectData,
}


#[derive(Clone, Debug)]
pub struct ObjectAttach_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub attachment_point: u8,
}

#[derive(Clone, Debug)]
pub struct ObjectAttach_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub rotation: Quaternion<f32>,
}

/// TODO:
/// /// ObjectAttach
///
#[derive(Clone, Debug)]
pub struct ObjectAttach {
    pub agent_data: ObjectAttach_AgentData,
    pub object_data: Vec<ObjectAttach_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectBuy_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub category_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectBuy_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
}

/// TODO:
/// /// Attempt to buy an object. This will only pack root objects.
///
#[derive(Clone, Debug)]
pub struct ObjectBuy {
    pub agent_data: ObjectBuy_AgentData,
    pub object_data: Vec<ObjectBuy_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectCategory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectCategory_ObjectData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub category: u32,
}

/// TODO:
/// /// set object category
///
#[derive(Clone, Debug)]
pub struct ObjectCategory {
    pub agent_data: ObjectCategory_AgentData,
    pub object_data: Vec<ObjectCategory_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectClickAction_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectClickAction_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub click_action: u8,
}

/// 		TODO:
/// 		/// ObjectClickAction
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectClickAction {
    pub agent_data: ObjectClickAction_AgentData,
    pub object_data: Vec<ObjectClickAction_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDeGrab_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDeGrab_ObjectData {
    /// TODO
    pub local_id: u32,
}

#[derive(Clone, Debug)]
pub struct ObjectDeGrab_SurfaceInfo {
    /// TODO
    pub uv_coord: Vector3<f32>,
    /// TODO
    pub st_coord: Vector3<f32>,
    /// TODO
    pub face_index: i32,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub normal: Vector3<f32>,
    /// TODO
    pub binormal: Vector3<f32>,
}

/// TODO:
/// /// ObjectDeGrab
///
#[derive(Clone, Debug)]
pub struct ObjectDeGrab {
    pub agent_data: ObjectDeGrab_AgentData,
    pub object_data: ObjectDeGrab_ObjectData,
    pub surface_info: Vec<ObjectDeGrab_SurfaceInfo>,
}


#[derive(Clone, Debug)]
pub struct ObjectDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub force: bool,
}

#[derive(Clone, Debug)]
pub struct ObjectDelete_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// ObjectDelete
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectDelete {
    pub agent_data: ObjectDelete_AgentData,
    pub object_data: Vec<ObjectDelete_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDelink_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDelink_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
/// /// ObjectDelink
///
#[derive(Clone, Debug)]
pub struct ObjectDelink {
    pub agent_data: ObjectDelink_AgentData,
    pub object_data: Vec<ObjectDelink_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDescription_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDescription_ObjectData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub description: Vec<u8>,
}

/// TODO:
/// /// set object descriptions
///
#[derive(Clone, Debug)]
pub struct ObjectDescription {
    pub agent_data: ObjectDescription_AgentData,
    pub object_data: Vec<ObjectDescription_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDeselect_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDeselect_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectDeselect {
    pub agent_data: ObjectDeselect_AgentData,
    pub object_data: Vec<ObjectDeselect_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDetach_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDetach_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
/// /// ObjectDetach -- derezzes an attachment, marking its item in your inventory as not "(worn)"
///
#[derive(Clone, Debug)]
pub struct ObjectDetach {
    pub agent_data: ObjectDetach_AgentData,
    pub object_data: Vec<ObjectDetach_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDrop_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDrop_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
/// /// ObjectDrop -- drops an attachment from your avatar onto the ground
///
#[derive(Clone, Debug)]
pub struct ObjectDrop {
    pub agent_data: ObjectDrop_AgentData,
    pub object_data: Vec<ObjectDrop_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDuplicate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectDuplicate_SharedData {
    /// TODO
    pub offset: Vector3<f32>,
    /// TODO
    pub duplicate_flags: u32,
}

#[derive(Clone, Debug)]
pub struct ObjectDuplicate_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// ObjectDuplicate
/// /// viewer -> simulator
/// /// Makes a copy of a set of objects, offset by a given amount
///
#[derive(Clone, Debug)]
pub struct ObjectDuplicate {
    pub agent_data: ObjectDuplicate_AgentData,
    pub shared_data: ObjectDuplicate_SharedData,
    pub object_data: Vec<ObjectDuplicate_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectDuplicateOnRay_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub ray_start: Vector3<f32>,
    /// TODO
    pub ray_end: Vector3<f32>,
    /// TODO
    pub bypass_raycast: bool,
    /// TODO
    pub ray_end_is_intersection: bool,
    /// TODO
    pub copy_centers: bool,
    /// TODO
    pub copy_rotates: bool,
    /// TODO
    pub ray_target_id: Uuid,
    /// TODO
    pub duplicate_flags: u32,
}

#[derive(Clone, Debug)]
pub struct ObjectDuplicateOnRay_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// ObjectDuplicateOnRay
/// /// viewer -> simulator
/// /// Makes a copy of an object, using the add object raycast
/// /// code to abut it to other objects.
///
#[derive(Clone, Debug)]
pub struct ObjectDuplicateOnRay {
    pub agent_data: ObjectDuplicateOnRay_AgentData,
    pub object_data: Vec<ObjectDuplicateOnRay_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectExportSelected_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub volume_detail: i16,
}

#[derive(Clone, Debug)]
pub struct ObjectExportSelected_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// 		TODO:
/// 		/// Export selected objects
/// /// viewer->sim
///
#[derive(Clone, Debug)]
pub struct ObjectExportSelected {
    pub agent_data: ObjectExportSelected_AgentData,
    pub object_data: Vec<ObjectExportSelected_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectExtraParams_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectExtraParams_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub param_type: u16,
    /// TODO
    pub param_in_use: bool,
    /// TODO
    pub param_size: u32,
    /// TODO
    pub param_data: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectExtraParams {
    pub agent_data: ObjectExtraParams_AgentData,
    pub object_data: Vec<ObjectExtraParams_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectFlagUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub use_physics: bool,
    /// TODO
    pub is_temporary: bool,
    /// TODO
    pub is_phantom: bool,
    /// TODO
    pub casts_shadows: bool,
}

/// 		TODO:
/// 		/// ObjectFlagUpdate
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectFlagUpdate {
    pub agent_data: ObjectFlagUpdate_AgentData,
}


#[derive(Clone, Debug)]
pub struct ObjectGrab_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectGrab_ObjectData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub grab_offset: Vector3<f32>,
}

#[derive(Clone, Debug)]
pub struct ObjectGrab_SurfaceInfo {
    /// TODO
    pub uv_coord: Vector3<f32>,
    /// TODO
    pub st_coord: Vector3<f32>,
    /// TODO
    pub face_index: i32,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub normal: Vector3<f32>,
    /// TODO
    pub binormal: Vector3<f32>,
}

/// TODO:
/// /// ObjectGrab
///
#[derive(Clone, Debug)]
pub struct ObjectGrab {
    pub agent_data: ObjectGrab_AgentData,
    pub object_data: ObjectGrab_ObjectData,
    pub surface_info: Vec<ObjectGrab_SurfaceInfo>,
}


#[derive(Clone, Debug)]
pub struct ObjectGrabUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectGrabUpdate_ObjectData {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub grab_offset_initial: Vector3<f32>,
    /// TODO
    pub grab_position: Vector3<f32>,
    /// TODO
    pub time_since_last: u32,
}

#[derive(Clone, Debug)]
pub struct ObjectGrabUpdate_SurfaceInfo {
    /// TODO
    pub uv_coord: Vector3<f32>,
    /// TODO
    pub st_coord: Vector3<f32>,
    /// TODO
    pub face_index: i32,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub normal: Vector3<f32>,
    /// TODO
    pub binormal: Vector3<f32>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectGrabUpdate {
    pub agent_data: ObjectGrabUpdate_AgentData,
    pub object_data: ObjectGrabUpdate_ObjectData,
    pub surface_info: Vec<ObjectGrabUpdate_SurfaceInfo>,
}


#[derive(Clone, Debug)]
pub struct ObjectGroup_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectGroup_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// ObjectGroup
/// /// To make the object part of no group, set GroupID = LLUUID::null.
/// /// This call only works if objectid.ownerid == agentid.
///
#[derive(Clone, Debug)]
pub struct ObjectGroup {
    pub agent_data: ObjectGroup_AgentData,
    pub object_data: Vec<ObjectGroup_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectImage_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectImage_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub media_url: Vec<u8>,
    /// TODO
    pub texture_entry: Vec<u8>,
}

/// 		TODO:
/// 		/// ObjectImage
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectImage {
    pub agent_data: ObjectImage_AgentData,
    pub object_data: Vec<ObjectImage_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectIncludeInSearch_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectIncludeInSearch_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub include_in_search: bool,
}

/// 		TODO:
/// 		/// ObjectIncludeInSearch
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectIncludeInSearch {
    pub agent_data: ObjectIncludeInSearch_AgentData,
    pub object_data: Vec<ObjectIncludeInSearch_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectLink_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectLink_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
/// /// ObjectLink
///
#[derive(Clone, Debug)]
pub struct ObjectLink {
    pub agent_data: ObjectLink_AgentData,
    pub object_data: Vec<ObjectLink_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectMaterial_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectMaterial_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub material: u8,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectMaterial {
    pub agent_data: ObjectMaterial_AgentData,
    pub object_data: Vec<ObjectMaterial_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectName_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectName_ObjectData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
/// /// set object names
///
#[derive(Clone, Debug)]
pub struct ObjectName {
    pub agent_data: ObjectName_AgentData,
    pub object_data: Vec<ObjectName_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectOwner_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectOwner_HeaderData {
    /// TODO
    pub override_: bool,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectOwner_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// 		TODO:
/// 		/// ObjectOwner
/// /// To make public, set OwnerID to LLUUID::null.
/// /// TODO: Eliminate god-bit. Maybe not. God-bit is ok, because it's
/// /// known on the server.
///
#[derive(Clone, Debug)]
pub struct ObjectOwner {
    pub agent_data: ObjectOwner_AgentData,
    pub header_data: ObjectOwner_HeaderData,
    pub object_data: Vec<ObjectOwner_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectPermissions_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectPermissions_HeaderData {
    /// TODO
    pub override_: bool,
}

#[derive(Clone, Debug)]
pub struct ObjectPermissions_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub field: u8,
    /// TODO
    pub set: u8,
    /// TODO
    pub mask: u32,
}

/// 		TODO:
/// 		/// ObjectPermissions
/// /// Field - see llpermissionsflags.h
/// /// If Set is true, tries to turn on bits in mask.
/// /// If set is false, tries to turn off bits in mask.
/// /// BUG: This just forces the permissions field.
///
#[derive(Clone, Debug)]
pub struct ObjectPermissions {
    pub agent_data: ObjectPermissions_AgentData,
    pub header_data: ObjectPermissions_HeaderData,
    pub object_data: Vec<ObjectPermissions_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectPosition_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectPosition_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub position: Vector3<f32>,
}

/// 		TODO:
/// 		/// DEPRECATED: ObjectPosition
/// /// == Old Behavior ==
/// /// Set the position on objects
/// ///
/// /// == Reason for deprecation ==
/// /// Unused code path was removed in the move to Havok4
/// /// Object position, scale and rotation messages were already unified
/// /// to MultipleObjectUpdate and this message was unused cruft.
/// ///
/// /// == New Location ==
/// /// MultipleObjectUpdate can be used instead.
///
#[derive(Clone, Debug)]
pub struct ObjectPosition {
    pub agent_data: ObjectPosition_AgentData,
    pub object_data: Vec<ObjectPosition_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectProperties_ObjectData {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub creation_date: u64,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub ownership_cost: i32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub aggregate_perms: u8,
    /// TODO
    pub aggregate_perm_textures: u8,
    /// TODO
    pub aggregate_perm_textures_owner: u8,
    /// TODO
    pub category: u32,
    /// TODO
    pub inventory_serial: i16,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub from_task_id: Uuid,
    /// TODO
    pub last_owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub touch_name: Vec<u8>,
    /// TODO
    pub sit_name: Vec<u8>,
    /// TODO
    pub texture_id: Vec<u8>,
}

/// 		TODO:
/// 		/// ObjectProperties
/// /// Extended information such as creator, permissions, etc.
/// /// Medium because potentially driven by mouse hover events.
/// ///		{	TaxRate			F32	}	// F32
///
#[derive(Clone, Debug)]
pub struct ObjectProperties {
    pub object_data: Vec<ObjectProperties_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectPropertiesFamily_ObjectData {
    /// TODO
    pub request_flags: u32,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub ownership_cost: i32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub category: u32,
    /// TODO
    pub last_owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
}

/// 		TODO:
/// 		/// ObjectPropertiesFamily
/// /// Medium because potentially driven by mouse hover events.
///
#[derive(Clone, Debug)]
pub struct ObjectPropertiesFamily {
    pub object_data: ObjectPropertiesFamily_ObjectData,
}


#[derive(Clone, Debug)]
pub struct ObjectRotation_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectRotation_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub rotation: Quaternion<f32>,
}

/// 		TODO:
/// 		/// ObjectRotation
/// /// viewer -> simulator
///
#[derive(Clone, Debug)]
pub struct ObjectRotation {
    pub agent_data: ObjectRotation_AgentData,
    pub object_data: Vec<ObjectRotation_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectSaleInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectSaleInfo_ObjectData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
}

/// TODO:
/// /// set object sale information
///
#[derive(Clone, Debug)]
pub struct ObjectSaleInfo {
    pub agent_data: ObjectSaleInfo_AgentData,
    pub object_data: Vec<ObjectSaleInfo_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectScale_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectScale_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub scale: Vector3<f32>,
}

/// 		TODO:
/// 		/// DEPRECATED: ObjectScale
/// /// == Old Behavior ==
/// /// Set the scale on objects
/// ///
/// /// == Reason for deprecation ==
/// /// Unused code path was removed in the move to Havok4
/// /// Object position, scale and rotation messages were already unified
/// /// to MultipleObjectUpdate and this message was unused cruft.
/// ///
/// /// == New Location ==
/// /// MultipleObjectUpdate can be used instead.
///
#[derive(Clone, Debug)]
pub struct ObjectScale {
    pub agent_data: ObjectScale_AgentData,
    pub object_data: Vec<ObjectScale_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectSelect_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectSelect_ObjectData {
    /// TODO
    pub object_local_id: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectSelect {
    pub agent_data: ObjectSelect_AgentData,
    pub object_data: Vec<ObjectSelect_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectShape_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectShape_ObjectData {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub path_curve: u8,
    /// TODO
    pub profile_curve: u8,
    /// TODO
    pub path_begin: u16,
    /// TODO
    pub path_end: u16,
    /// TODO
    pub path_scale_x: u8,
    /// TODO
    pub path_scale_y: u8,
    /// TODO
    pub path_shear_x: u8,
    /// TODO
    pub path_shear_y: u8,
    /// TODO
    pub path_twist: i8,
    /// TODO
    pub path_twist_begin: i8,
    /// TODO
    pub path_radius_offset: i8,
    /// TODO
    pub path_taper_x: i8,
    /// TODO
    pub path_taper_y: i8,
    /// TODO
    pub path_revolutions: u8,
    /// TODO
    pub path_skew: i8,
    /// TODO
    pub profile_begin: u16,
    /// TODO
    pub profile_end: u16,
    /// TODO
    pub profile_hollow: u16,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ObjectShape {
    pub agent_data: ObjectShape_AgentData,
    pub object_data: Vec<ObjectShape_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectSpinStart_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectSpinStart_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// TODO:
/// /// ObjectSpinStart
///
#[derive(Clone, Debug)]
pub struct ObjectSpinStart {
    pub agent_data: ObjectSpinStart_AgentData,
    pub object_data: ObjectSpinStart_ObjectData,
}


#[derive(Clone, Debug)]
pub struct ObjectSpinStop_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectSpinStop_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// TODO:
/// /// ObjectSpinStop
///
#[derive(Clone, Debug)]
pub struct ObjectSpinStop {
    pub agent_data: ObjectSpinStop_AgentData,
    pub object_data: ObjectSpinStop_ObjectData,
}


#[derive(Clone, Debug)]
pub struct ObjectSpinUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ObjectSpinUpdate_ObjectData {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub rotation: Quaternion<f32>,
}

/// TODO:
/// /// ObjectSpinUpdate
///
#[derive(Clone, Debug)]
pub struct ObjectSpinUpdate {
    pub agent_data: ObjectSpinUpdate_AgentData,
    pub object_data: ObjectSpinUpdate_ObjectData,
}


#[derive(Clone, Debug)]
pub struct ObjectUpdate_RegionData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub time_dilation: u16,
}

#[derive(Clone, Debug)]
pub struct ObjectUpdate_ObjectData {
    /// TODO: What is the difference between ID and FullID of objects?
    pub id: u32,
    /// TODO
    pub state: u8,
    /// TODO
    pub full_id: Uuid,
    /// TODO
    pub crc: u32,
    /// TODO
    pub p_code: u8,
    /// TODO
    pub material: u8,
    /// TODO
    pub click_action: u8,
    /// TODO
    pub scale: Vector3<f32>,
    /// TODO
    pub object_data: Vec<u8>,
    /// TODO
    pub parent_id: u32,
    /// TODO
    pub update_flags: u32,
    /// TODO
    pub path_curve: u8,
    /// TODO
    pub profile_curve: u8,
    /// TODO
    pub path_begin: u16,
    /// TODO
    pub path_end: u16,
    /// TODO
    pub path_scale_x: u8,
    /// TODO
    pub path_scale_y: u8,
    /// TODO
    pub path_shear_x: u8,
    /// TODO
    pub path_shear_y: u8,
    /// TODO
    pub path_twist: i8,
    /// TODO
    pub path_twist_begin: i8,
    /// TODO
    pub path_radius_offset: i8,
    /// TODO
    pub path_taper_x: i8,
    /// TODO
    pub path_taper_y: i8,
    /// TODO
    pub path_revolutions: u8,
    /// TODO
    pub path_skew: i8,
    /// TODO
    pub profile_begin: u16,
    /// TODO
    pub profile_end: u16,
    /// TODO
    pub profile_hollow: u16,
    /// TODO
    pub texture_entry: Vec<u8>,
    /// TODO
    pub texture_anim: Vec<u8>,
    /// TODO
    pub name_value: Vec<u8>,
    /// TODO
    pub data: Vec<u8>,
    /// TODO
    pub text: Vec<u8>,
    /// TODO
    pub text_color: [u8; 4],
    /// TODO
    pub media_url: Vec<u8>,
    /// TODO
    pub ps_block: Vec<u8>,
    /// TODO
    pub extra_params: Vec<u8>,
    /// TODO
    pub sound: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub gain: f32,
    /// TODO
    pub flags: u8,
    /// TODO
    pub radius: f32,
    /// TODO
    pub joint_type: u8,
    /// TODO
    pub joint_pivot: Vector3<f32>,
    /// TODO
    pub joint_axis_or_anchor: Vector3<f32>,
}

/// TODO:
/// /// joint info -- is sent in the update of each joint-child-root
///
#[derive(Clone, Debug)]
pub struct ObjectUpdate {
    pub region_data: ObjectUpdate_RegionData,
    pub object_data: Vec<ObjectUpdate_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectUpdateCached_RegionData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub time_dilation: u16,
}

#[derive(Clone, Debug)]
pub struct ObjectUpdateCached_ObjectData {
    /// TODO
    pub id: u32,
    /// TODO
    pub crc: u32,
    /// TODO
    pub update_flags: u32,
}

/// 		TODO:
/// 		/// ObjectUpdateCached
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ObjectUpdateCached {
    pub region_data: ObjectUpdateCached_RegionData,
    pub object_data: Vec<ObjectUpdateCached_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct ObjectUpdateCompressed_RegionData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub time_dilation: u16,
}

#[derive(Clone, Debug)]
pub struct ObjectUpdateCompressed_ObjectData {
    /// TODO
    pub update_flags: u32,
    /// TODO
    pub data: Vec<u8>,
}

/// TODO:
/// /// ObjectUpdateCompressed
///
#[derive(Clone, Debug)]
pub struct ObjectUpdateCompressed {
    pub region_data: ObjectUpdateCompressed_RegionData,
    pub object_data: Vec<ObjectUpdateCompressed_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct OfferCallingCard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct OfferCallingCard_AgentBlock {
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

/// TODO:
/// /// used to give someone a calling card.
///
#[derive(Clone, Debug)]
pub struct OfferCallingCard {
    pub agent_data: OfferCallingCard_AgentData,
    pub agent_block: OfferCallingCard_AgentBlock,
}


#[derive(Clone, Debug)]
pub struct OfflineNotification_AgentBlock {
    /// TODO
    pub agent_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct OfflineNotification {
    pub agent_block: Vec<OfflineNotification_AgentBlock>,
}


#[derive(Clone, Debug)]
pub struct OnlineNotification_AgentBlock {
    /// TODO
    pub agent_id: Uuid,
}

/// 		TODO:
/// 		/// notification for login and logout.
/// /// source_sim -> dest_viewer
///
#[derive(Clone, Debug)]
pub struct OnlineNotification {
    pub agent_block: Vec<OnlineNotification_AgentBlock>,
}


#[derive(Clone, Debug)]
pub struct OpenCircuit_CircuitInfo {
    /// TODO
    pub ip: Ip4Addr,
    /// TODO
    pub port: IpPort,
}

/// TODO:
/// /// OpenCircuit - Tells the recipient's messaging system to open the descibed circuit
///
#[derive(Clone, Debug)]
pub struct OpenCircuit {
    pub circuit_info: OpenCircuit_CircuitInfo,
}


#[derive(Clone, Debug)]
pub struct PacketAck_Packets {
    /// Packet id to be acknowledged.
    pub id: u32,
}

/// Informs the receiver that the provided list of packets was successfully received.
///
#[derive(Clone, Debug)]
pub struct PacketAck {
    pub packets: Vec<PacketAck_Packets>,
}


#[derive(Clone, Debug)]
pub struct ParcelAccessListReply_Data {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub flags: u32,
    /// TODO
    pub local_id: i32,
}

#[derive(Clone, Debug)]
pub struct ParcelAccessListReply_List {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub time: i32,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// sim -> viewer
/// /// ParcelAccessListReply
///
#[derive(Clone, Debug)]
pub struct ParcelAccessListReply {
    pub data: ParcelAccessListReply_Data,
    pub list: Vec<ParcelAccessListReply_List>,
}


#[derive(Clone, Debug)]
pub struct ParcelAccessListRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelAccessListRequest_Data {
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub flags: u32,
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// ParcelAccessListRequest
///
#[derive(Clone, Debug)]
pub struct ParcelAccessListRequest {
    pub agent_data: ParcelAccessListRequest_AgentData,
    pub data: ParcelAccessListRequest_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelAccessListUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelAccessListUpdate_Data {
    /// TODO
    pub flags: u32,
    /// TODO
    pub local_id: i32,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub sections: i32,
}

#[derive(Clone, Debug)]
pub struct ParcelAccessListUpdate_List {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub time: i32,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// ParcelAccessListUpdate
///
#[derive(Clone, Debug)]
pub struct ParcelAccessListUpdate {
    pub agent_data: ParcelAccessListUpdate_AgentData,
    pub data: ParcelAccessListUpdate_Data,
    pub list: Vec<ParcelAccessListUpdate_List>,
}


#[derive(Clone, Debug)]
pub struct ParcelAuctions_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub winner_id: Uuid,
}

/// 		TODO:
/// 		/// dataserver -> sim
/// /// tell a particular simulator to finish parcel sale.
///
#[derive(Clone, Debug)]
pub struct ParcelAuctions {
    pub parcel_data: Vec<ParcelAuctions_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct ParcelBuy_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelBuy_Data {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub is_group_owned: bool,
    /// TODO
    pub remove_contribution: bool,
    /// TODO
    pub local_id: i32,
    /// TODO
    pub final_: bool,
}

#[derive(Clone, Debug)]
pub struct ParcelBuy_ParcelData {
    /// TODO
    pub price: i32,
    /// TODO
    pub area: i32,
}

/// 		TODO:
/// 		/// ParcelBuy - change the owner of a patch of land.
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelBuy {
    pub agent_data: ParcelBuy_AgentData,
    pub data: ParcelBuy_Data,
    pub parcel_data: ParcelBuy_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelBuyPass_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelBuyPass_ParcelData {
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// ParcelBuyPass - purchase a temporary access pass
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelBuyPass {
    pub agent_data: ParcelBuyPass_AgentData,
    pub parcel_data: ParcelBuyPass_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelClaim_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelClaim_Data {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub is_group_owned: bool,
    /// TODO
    pub final_: bool,
}

#[derive(Clone, Debug)]
pub struct ParcelClaim_ParcelData {
    /// TODO
    pub west: f32,
    /// TODO
    pub south: f32,
    /// TODO
    pub east: f32,
    /// TODO
    pub north: f32,
}

/// 		TODO:
/// 		/// ParcelClaim - change the owner of a patch of land
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelClaim {
    pub agent_data: ParcelClaim_AgentData,
    pub data: ParcelClaim_Data,
    pub parcel_data: Vec<ParcelClaim_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct ParcelDeedToGroup_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDeedToGroup_Data {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// ParcelDeedToGroup - deed a patch of land to a group
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelDeedToGroup {
    pub agent_data: ParcelDeedToGroup_AgentData,
    pub data: ParcelDeedToGroup_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelDisableObjects_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDisableObjects_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub return_type: u32,
}

#[derive(Clone, Debug)]
pub struct ParcelDisableObjects_TaskIDs {
    /// TODO
    pub task_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDisableObjects_OwnerIDs {
    /// TODO
    pub owner_id: Uuid,
}

/// 		TODO:
/// 		/// Disable makes objects nonphysical and turns off their scripts.
/// /// ParcelDisableObjects
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelDisableObjects {
    pub agent_data: ParcelDisableObjects_AgentData,
    pub parcel_data: ParcelDisableObjects_ParcelData,
    pub task_i_ds: Vec<ParcelDisableObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelDisableObjects_OwnerIDs>,
}


#[derive(Clone, Debug)]
pub struct ParcelDivide_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDivide_ParcelData {
    /// TODO
    pub west: f32,
    /// TODO
    pub south: f32,
    /// TODO
    pub east: f32,
    /// TODO
    pub north: f32,
}

/// 		TODO:
/// 		/// ParcelDivide
/// /// If the selection is a subsection of exactly one parcel,
/// /// chop out that section and make a new parcel of it.
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelDivide {
    pub agent_data: ParcelDivide_AgentData,
    pub parcel_data: ParcelDivide_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelDwellReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDwellReply_Data {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub dwell: f32,
}

/// 		TODO:
/// 		/// dataserver -> sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelDwellReply {
    pub agent_data: ParcelDwellReply_AgentData,
    pub data: ParcelDwellReply_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelDwellRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelDwellRequest_Data {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub parcel_id: Uuid,
}

/// 		TODO:
/// 		/// viewer -> sim -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelDwellRequest {
    pub agent_data: ParcelDwellRequest_AgentData,
    pub data: ParcelDwellRequest_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelGodForceOwner_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelGodForceOwner_Data {
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub local_id: i32,
}

/// TODO:
/// /// ParcelGodForceOwner Unencoded
///
#[derive(Clone, Debug)]
pub struct ParcelGodForceOwner {
    pub agent_data: ParcelGodForceOwner_AgentData,
    pub data: ParcelGodForceOwner_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelGodMarkAsContent_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelGodMarkAsContent_ParcelData {
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// mark parcel and double secret agent content on parcel as owned by
/// /// governor/maint and adjusts permissions approriately. Godlike request.
///
#[derive(Clone, Debug)]
pub struct ParcelGodMarkAsContent {
    pub agent_data: ParcelGodMarkAsContent_AgentData,
    pub parcel_data: ParcelGodMarkAsContent_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelInfoReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelInfoReply_Data {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub actual_area: i32,
    /// TODO
    pub billable_area: i32,
    /// TODO
    pub flags: u8,
    /// TODO
    pub global_x: f32,
    /// TODO
    pub global_y: f32,
    /// TODO
    pub global_z: f32,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub dwell: f32,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub auction_id: i32,
}

/// 		TODO:
/// 		/// ParcelInfoReply
/// /// dataserver -> simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelInfoReply {
    pub agent_data: ParcelInfoReply_AgentData,
    pub data: ParcelInfoReply_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelInfoRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelInfoRequest_Data {
    /// TODO
    pub parcel_id: Uuid,
}

/// 		TODO:
/// 		/// ParcelInfoRequest
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelInfoRequest {
    pub agent_data: ParcelInfoRequest_AgentData,
    pub data: ParcelInfoRequest_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelJoin_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelJoin_ParcelData {
    /// TODO
    pub west: f32,
    /// TODO
    pub south: f32,
    /// TODO
    pub east: f32,
    /// TODO
    pub north: f32,
}

/// 		TODO:
/// 		/// ParcelJoin - Take all parcels which are owned by agent and inside
/// /// rectangle, and make them 1 parcel if they all are leased.
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelJoin {
    pub agent_data: ParcelJoin_AgentData,
    pub parcel_data: ParcelJoin_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelMediaCommandMessage_CommandBlock {
    /// TODO
    pub flags: u32,
    /// TODO
    pub command: u32,
    /// TODO
    pub time: f32,
}

/// 		TODO:
/// 		/// ParcelMediaCommandMessage
/// /// Sends a parcel media command
///
#[derive(Clone, Debug)]
pub struct ParcelMediaCommandMessage {
    pub command_block: ParcelMediaCommandMessage_CommandBlock,
}


#[derive(Clone, Debug)]
pub struct ParcelMediaUpdate_DataBlock {
    /// TODO
    pub media_url: Vec<u8>,
    /// TODO
    pub media_id: Uuid,
    /// TODO
    pub media_auto_scale: u8,
}

#[derive(Clone, Debug)]
pub struct ParcelMediaUpdate_DataBlockExtended {
    /// TODO
    pub media_type: Vec<u8>,
    /// TODO
    pub media_desc: Vec<u8>,
    /// TODO
    pub media_width: i32,
    /// TODO
    pub media_height: i32,
    /// TODO
    pub media_loop: u8,
}

/// 		TODO:
/// 		/// ParcelMediaUpdate
/// /// Sends a parcel media update to a single user
/// /// For global updates use the parcel manager.
///
#[derive(Clone, Debug)]
pub struct ParcelMediaUpdate {
    pub data_block: ParcelMediaUpdate_DataBlock,
    pub data_block_extended: ParcelMediaUpdate_DataBlockExtended,
}


#[derive(Clone, Debug)]
pub struct ParcelObjectOwnersReply_Data {
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub is_group_owned: bool,
    /// TODO
    pub count: i32,
    /// TODO
    pub online_status: bool,
}

/// 		TODO:
/// 		/// ParcelObjectOwnersReply
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelObjectOwnersReply {
    pub data: Vec<ParcelObjectOwnersReply_Data>,
}


#[derive(Clone, Debug)]
pub struct ParcelObjectOwnersRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelObjectOwnersRequest_ParcelData {
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// ParcelObjectOwnersRequest
/// /// viewer -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelObjectOwnersRequest {
    pub agent_data: ParcelObjectOwnersRequest_AgentData,
    pub parcel_data: ParcelObjectOwnersRequest_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelOverlay_ParcelData {
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub data: Vec<u8>,
}

/// 		TODO:
/// 		/// ParcelOverlay
/// /// We send N packets per region to the viewer.
/// /// N = 4, currently.  At 256x256 meter regions, 4x4 meter parcel grid,
/// /// there are 4096 parcel units per region.  At N = 4, that's 1024 units
/// /// per packet, allowing 8 bit bytes.
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelOverlay {
    pub parcel_data: ParcelOverlay_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelProperties_ParcelData {
    /// TODO
    pub request_result: i32,
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub snap_selection: bool,
    /// TODO
    pub self_count: i32,
    /// TODO
    pub other_count: i32,
    /// TODO
    pub public_count: i32,
    /// TODO
    pub local_id: i32,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub is_group_owned: bool,
    /// TODO
    pub auction_id: u32,
    /// TODO
    pub claim_date: i32,
    /// TODO
    pub claim_price: i32,
    /// TODO
    pub rent_price: i32,
    /// TODO
    pub aabb_min: Vector3<f32>,
    /// TODO
    pub aabb_max: Vector3<f32>,
    /// TODO
    pub bitmap: Vec<u8>,
    /// TODO
    pub area: i32,
    /// TODO
    pub status: u8,
    /// TODO
    pub sim_wide_max_prims: i32,
    /// TODO
    pub sim_wide_total_prims: i32,
    /// TODO
    pub max_prims: i32,
    /// TODO
    pub total_prims: i32,
    /// TODO
    pub owner_prims: i32,
    /// TODO
    pub group_prims: i32,
    /// TODO
    pub other_prims: i32,
    /// TODO
    pub selected_prims: i32,
    /// TODO
    pub parcel_prim_bonus: f32,
    /// TODO
    pub other_clean_time: i32,
    /// TODO
    pub parcel_flags: u32,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub music_url: Vec<u8>,
    /// TODO
    pub media_url: Vec<u8>,
    /// TODO
    pub media_id: Uuid,
    /// TODO
    pub media_auto_scale: u8,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub pass_price: i32,
    /// TODO
    pub pass_hours: f32,
    /// TODO
    pub category: u8,
    /// TODO
    pub auth_buyer_id: Uuid,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub user_location: Vector3<f32>,
    /// TODO
    pub user_look_at: Vector3<f32>,
    /// TODO
    pub landing_type: u8,
    /// TODO
    pub region_push_override: bool,
    /// TODO
    pub region_deny_anonymous: bool,
    /// TODO
    pub region_deny_identified: bool,
    /// TODO
    pub region_deny_transacted: bool,
}

#[derive(Clone, Debug)]
pub struct ParcelProperties_AgeVerificationBlock {
    /// TODO
    pub region_deny_age_unverified: bool,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ParcelProperties {
    pub parcel_data: ParcelProperties_ParcelData,
    pub age_verification_block: ParcelProperties_AgeVerificationBlock,
}


#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequest_ParcelData {
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub west: f32,
    /// TODO
    pub south: f32,
    /// TODO
    pub east: f32,
    /// TODO
    pub north: f32,
    /// TODO
    pub snap_selection: bool,
}

/// 		TODO:
/// 		/// ParcelPropertiesRequest
/// /// SequenceID should be -1 or -2, and is echoed back in the
/// /// parcel properties message.
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequest {
    pub agent_data: ParcelPropertiesRequest_AgentData,
    pub parcel_data: ParcelPropertiesRequest_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequestByID_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequestByID_ParcelData {
    /// TODO
    pub sequence_id: i32,
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// ParcelPropertiesRequestByID
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelPropertiesRequestByID {
    pub agent_data: ParcelPropertiesRequestByID_AgentData,
    pub parcel_data: ParcelPropertiesRequestByID_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelPropertiesUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelPropertiesUpdate_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub flags: u32,
    /// TODO
    pub parcel_flags: u32,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub music_url: Vec<u8>,
    /// TODO
    pub media_url: Vec<u8>,
    /// TODO
    pub media_id: Uuid,
    /// TODO
    pub media_auto_scale: u8,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub pass_price: i32,
    /// TODO
    pub pass_hours: f32,
    /// TODO
    pub category: u8,
    /// TODO
    pub auth_buyer_id: Uuid,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub user_location: Vector3<f32>,
    /// TODO
    pub user_look_at: Vector3<f32>,
    /// TODO
    pub landing_type: u8,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ParcelPropertiesUpdate {
    pub agent_data: ParcelPropertiesUpdate_AgentData,
    pub parcel_data: ParcelPropertiesUpdate_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ParcelReclaim_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelReclaim_Data {
    /// TODO
    pub local_id: i32,
}

/// TODO:
/// /// reserved for when island owners force re-claim parcel
///
#[derive(Clone, Debug)]
pub struct ParcelReclaim {
    pub agent_data: ParcelReclaim_AgentData,
    pub data: ParcelReclaim_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelRelease_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelRelease_Data {
    /// TODO
    pub local_id: i32,
}

/// 		TODO:
/// 		/// ParcelRelease
/// /// Release a parcel to public
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelRelease {
    pub agent_data: ParcelRelease_AgentData,
    pub data: ParcelRelease_Data,
}


#[derive(Clone, Debug)]
pub struct ParcelRename_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub new_name: Vec<u8>,
}

/// 		TODO:
/// 		/// spaceserver -> sim
/// /// tell a particular simulator to rename a parcel
///
#[derive(Clone, Debug)]
pub struct ParcelRename {
    pub parcel_data: Vec<ParcelRename_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct ParcelReturnObjects_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelReturnObjects_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub return_type: u32,
}

#[derive(Clone, Debug)]
pub struct ParcelReturnObjects_TaskIDs {
    /// TODO
    pub task_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelReturnObjects_OwnerIDs {
    /// TODO
    pub owner_id: Uuid,
}

/// 		TODO:
/// 		/// ParcelReturnObjects
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelReturnObjects {
    pub agent_data: ParcelReturnObjects_AgentData,
    pub parcel_data: ParcelReturnObjects_ParcelData,
    pub task_i_ds: Vec<ParcelReturnObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelReturnObjects_OwnerIDs>,
}


#[derive(Clone, Debug)]
pub struct ParcelSales_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub buyer_id: Uuid,
}

/// 		TODO:
/// 		/// dataserver -> simulator
/// /// tell a particular simulator to finish parcel sale.
///
#[derive(Clone, Debug)]
pub struct ParcelSales {
    pub parcel_data: Vec<ParcelSales_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct ParcelSelectObjects_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelSelectObjects_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub return_type: u32,
}

#[derive(Clone, Debug)]
pub struct ParcelSelectObjects_ReturnIDs {
    /// TODO
    pub return_id: Uuid,
}

/// 		TODO:
/// 		/// ParcelSelectObjects
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelSelectObjects {
    pub agent_data: ParcelSelectObjects_AgentData,
    pub parcel_data: ParcelSelectObjects_ParcelData,
    pub return_i_ds: Vec<ParcelSelectObjects_ReturnIDs>,
}


#[derive(Clone, Debug)]
pub struct ParcelSetOtherCleanTime_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ParcelSetOtherCleanTime_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub other_clean_time: i32,
}

/// 		TODO:
/// 		/// ParcelSetOtherCleanTime
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ParcelSetOtherCleanTime {
    pub agent_data: ParcelSetOtherCleanTime_AgentData,
    pub parcel_data: ParcelSetOtherCleanTime_ParcelData,
}


#[derive(Clone, Debug)]
pub struct PayPriceReply_ObjectData {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub default_pay_price: i32,
}

#[derive(Clone, Debug)]
pub struct PayPriceReply_ButtonData {
    /// TODO
    pub pay_button: i32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct PayPriceReply {
    pub object_data: PayPriceReply_ObjectData,
    pub button_data: Vec<PayPriceReply_ButtonData>,
}


#[derive(Clone, Debug)]
pub struct PickDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PickDelete_Data {
    /// TODO
    pub pick_id: Uuid,
}

/// 		TODO:
/// 		/// PickDelete
/// /// Delete a non-top pick from the database.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct PickDelete {
    pub agent_data: PickDelete_AgentData,
    pub data: PickDelete_Data,
}


#[derive(Clone, Debug)]
pub struct PickGodDelete_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PickGodDelete_Data {
    /// TODO
    pub pick_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

/// 		TODO:
/// 		/// PickGodDelete
/// /// Delete a pick from the database.
/// /// QueryID is needed so database can send a repeat list of
/// /// picks.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct PickGodDelete {
    pub agent_data: PickGodDelete_AgentData,
    pub data: PickGodDelete_Data,
}


#[derive(Clone, Debug)]
pub struct PickInfoReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PickInfoReply_Data {
    /// TODO
    pub pick_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub top_pick: bool,
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub user: Vec<u8>,
    /// TODO
    pub original_name: Vec<u8>,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub pos_global: Vector3<f64>,
    /// TODO
    pub sort_order: i32,
    /// TODO
    pub enabled: bool,
}

/// 		TODO:
/// 		/// PickInfoReply
/// /// dataserver -> simulator
/// /// simulator -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct PickInfoReply {
    pub agent_data: PickInfoReply_AgentData,
    pub data: PickInfoReply_Data,
}


#[derive(Clone, Debug)]
pub struct PickInfoUpdate_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PickInfoUpdate_Data {
    /// TODO
    pub pick_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub top_pick: bool,
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub pos_global: Vector3<f64>,
    /// TODO
    pub sort_order: i32,
    /// TODO
    pub enabled: bool,
}

/// 		TODO:
/// 		/// PickInfoUpdate
/// /// Update a pick.  ParcelID is set on the simulator as the message
/// /// passes through.
/// /// If TopPick is TRUE, the simulator will only pass on the message
/// /// if the agent_id is a god.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct PickInfoUpdate {
    pub agent_data: PickInfoUpdate_AgentData,
    pub data: PickInfoUpdate_Data,
}


#[derive(Clone, Debug)]
pub struct PlacesQuery_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PlacesQuery_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PlacesQuery_QueryData {
    /// TODO
    pub query_text: Vec<u8>,
    /// TODO
    pub query_flags: u32,
    /// TODO
    pub category: i8,
    /// TODO
    pub sim_name: Vec<u8>,
}

/// 		TODO:
/// 		/// PlacesQuery
/// /// Used for getting a list of places for the group land panel
/// /// and the user land holdings panel.  NOT for the directory.
///
#[derive(Clone, Debug)]
pub struct PlacesQuery {
    pub agent_data: PlacesQuery_AgentData,
    pub transaction_data: PlacesQuery_TransactionData,
    pub query_data: PlacesQuery_QueryData,
}


#[derive(Clone, Debug)]
pub struct PlacesReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub query_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PlacesReply_TransactionData {
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PlacesReply_QueryData {
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub desc: Vec<u8>,
    /// TODO
    pub actual_area: i32,
    /// TODO
    pub billable_area: i32,
    /// TODO
    pub flags: u8,
    /// TODO
    pub global_x: f32,
    /// TODO
    pub global_y: f32,
    /// TODO
    pub global_z: f32,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub dwell: f32,
    /// TODO
    pub price: i32,
}

/// 		TODO:
/// 		/// PlacesReply
/// /// dataserver -> simulator -> viewer
/// /// If the user has specified a location, use that to compute
/// /// global x,y,z.  Otherwise, use center of the AABB.
/// /// reliable
/// ///{	ProductSKU		Variable	1	}
///
#[derive(Clone, Debug)]
pub struct PlacesReply {
    pub agent_data: PlacesReply_AgentData,
    pub transaction_data: PlacesReply_TransactionData,
    pub query_data: Vec<PlacesReply_QueryData>,
}


#[derive(Clone, Debug)]
pub struct PreloadSound_DataBlock {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub sound_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct PreloadSound {
    pub data_block: Vec<PreloadSound_DataBlock>,
}


#[derive(Clone, Debug)]
pub struct PurgeInventoryDescendents_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct PurgeInventoryDescendents_InventoryData {
    /// TODO
    pub folder_id: Uuid,
}

/// 		TODO:
/// 		/// This is how you remove inventory when you're not even sure what it
/// /// is - only it's parenting.
///
#[derive(Clone, Debug)]
pub struct PurgeInventoryDescendents {
    pub agent_data: PurgeInventoryDescendents_AgentData,
    pub inventory_data: PurgeInventoryDescendents_InventoryData,
}


#[derive(Clone, Debug)]
pub struct RebakeAvatarTextures_TextureData {
    /// TODO
    pub texture_id: Uuid,
}

/// 		TODO:
/// 		/// RebakeAvatarTextures
/// /// simulator -> viewer request when a temporary baked avatar texture is not found
///
#[derive(Clone, Debug)]
pub struct RebakeAvatarTextures {
    pub texture_data: RebakeAvatarTextures_TextureData,
}


#[derive(Clone, Debug)]
pub struct Redo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct Redo_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// TODO:
/// /// Redo
///
#[derive(Clone, Debug)]
pub struct Redo {
    pub agent_data: Redo_AgentData,
    pub object_data: Vec<Redo_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct RegionHandleRequest_RequestBlock {
    /// TODO
    pub region_id: Uuid,
}

/// 		TODO:
/// 		/// get information about landmarks. Used by viewers for determining
/// /// the location of a landmark, and by simulators for teleport
///
#[derive(Clone, Debug)]
pub struct RegionHandleRequest {
    pub request_block: RegionHandleRequest_RequestBlock,
}


#[derive(Clone, Debug)]
pub struct RegionHandshake_RegionInfo {
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub sim_owner: Uuid,
    /// TODO
    pub is_estate_manager: bool,
    /// TODO
    pub water_height: f32,
    /// TODO
    pub billable_factor: f32,
    /// TODO
    pub cache_id: Uuid,
    /// TODO
    pub terrain_base0: Uuid,
    /// TODO
    pub terrain_base1: Uuid,
    /// TODO
    pub terrain_base2: Uuid,
    /// TODO
    pub terrain_base3: Uuid,
    /// TODO
    pub terrain_detail0: Uuid,
    /// TODO
    pub terrain_detail1: Uuid,
    /// TODO
    pub terrain_detail2: Uuid,
    /// TODO
    pub terrain_detail3: Uuid,
    /// TODO
    pub terrain_start_height00: f32,
    /// TODO
    pub terrain_start_height01: f32,
    /// TODO
    pub terrain_start_height10: f32,
    /// TODO
    pub terrain_start_height11: f32,
    /// TODO
    pub terrain_height_range00: f32,
    /// TODO
    pub terrain_height_range01: f32,
    /// TODO
    pub terrain_height_range10: f32,
    /// TODO
    pub terrain_height_range11: f32,
}

#[derive(Clone, Debug)]
pub struct RegionHandshake_RegionInfo2 {
    /// TODO
    pub region_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RegionHandshake_RegionInfo3 {
    /// TODO
    pub cpu_class_id: i32,
    /// TODO
    pub cpu_ratio: i32,
    /// TODO
    pub colo_name: Vec<u8>,
    /// TODO
    pub product_sku: Vec<u8>,
    /// TODO
    pub product_name: Vec<u8>,
}

/// 		TODO:
/// 		/// RegionHandshake
/// /// Sent by region to viewer after it has received UseCircuitCode
/// /// from that viewer.
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct RegionHandshake {
    pub region_info: RegionHandshake_RegionInfo,
    pub region_info2: RegionHandshake_RegionInfo2,
    pub region_info3: RegionHandshake_RegionInfo3,
}


#[derive(Clone, Debug)]
pub struct RegionHandshakeReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RegionHandshakeReply_RegionInfo {
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// RegionHandshakeReply
/// /// viewer -> sim
/// /// reliable
/// /// Sent after viewer has initialized the (pre-existing)
/// /// LLViewerRegion with the name, access level, etc. and
/// /// has loaded the cache for the region.
/// /// After the simulator receives this, it will start sending
/// /// data about objects.
///
#[derive(Clone, Debug)]
pub struct RegionHandshakeReply {
    pub agent_data: RegionHandshakeReply_AgentData,
    pub region_info: RegionHandshakeReply_RegionInfo,
}


#[derive(Clone, Debug)]
pub struct RegionIDAndHandleReply_ReplyBlock {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub region_handle: u64,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RegionIDAndHandleReply {
    pub reply_block: RegionIDAndHandleReply_ReplyBlock,
}


#[derive(Clone, Debug)]
pub struct RegionInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RegionInfo_RegionInfo {
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub parent_estate_id: u32,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub max_agents: u8,
    /// TODO
    pub billable_factor: f32,
    /// TODO
    pub object_bonus_factor: f32,
    /// TODO
    pub water_height: f32,
    /// TODO
    pub terrain_raise_limit: f32,
    /// TODO
    pub terrain_lower_limit: f32,
    /// TODO
    pub price_per_meter: i32,
    /// TODO
    pub redirect_grid_x: i32,
    /// TODO
    pub redirect_grid_y: i32,
    /// TODO
    pub use_estate_sun: bool,
    /// TODO
    pub sun_hour: f32,
}

#[derive(Clone, Debug)]
pub struct RegionInfo_RegionInfo2 {
    /// TODO
    pub product_sku: Vec<u8>,
    /// TODO
    pub product_name: Vec<u8>,
    /// TODO
    pub max_agents32: u32,
    /// TODO
    pub hard_max_agents: u32,
    /// TODO
    pub hard_max_objects: u32,
}

/// 		TODO:
/// 		/// RegionInfo
/// /// Used to populate UI for both region/estate floater
/// /// and god tools floater
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct RegionInfo {
    pub agent_data: RegionInfo_AgentData,
    pub region_info: RegionInfo_RegionInfo,
    pub region_info2: RegionInfo_RegionInfo2,
}


#[derive(Clone, Debug)]
pub struct RegionPresenceRequestByHandle_RegionData {
    /// TODO
    pub region_handle: u64,
}

/// TODO:
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct RegionPresenceRequestByHandle {
    pub region_data: Vec<RegionPresenceRequestByHandle_RegionData>,
}


#[derive(Clone, Debug)]
pub struct RegionPresenceRequestByRegionID_RegionData {
    /// TODO
    pub region_id: Uuid,
}

/// TODO:
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct RegionPresenceRequestByRegionID {
    pub region_data: Vec<RegionPresenceRequestByRegionID_RegionData>,
}


#[derive(Clone, Debug)]
pub struct RegionPresenceResponse_RegionData {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub internal_region_ip: Ip4Addr,
    /// TODO
    pub external_region_ip: Ip4Addr,
    /// TODO
    pub region_port: IpPort,
    /// TODO
    pub valid_until: f64,
    /// TODO
    pub message: Vec<u8>,
}

/// TODO:
/// /// dataserver -> sim
///
#[derive(Clone, Debug)]
pub struct RegionPresenceResponse {
    pub region_data: Vec<RegionPresenceResponse_RegionData>,
}


#[derive(Clone, Debug)]
pub struct RemoveAttachment_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveAttachment_AttachmentBlock {
    /// TODO
    pub attachment_point: u8,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
/// /// Simulator informs Dataserver that attachment has been taken off
///
#[derive(Clone, Debug)]
pub struct RemoveAttachment {
    pub agent_data: RemoveAttachment_AgentData,
    pub attachment_block: RemoveAttachment_AttachmentBlock,
}


#[derive(Clone, Debug)]
pub struct RemoveInventoryFolder_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveInventoryFolder_FolderData {
    /// TODO
    pub folder_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RemoveInventoryFolder {
    pub agent_data: RemoveInventoryFolder_AgentData,
    pub folder_data: Vec<RemoveInventoryFolder_FolderData>,
}


#[derive(Clone, Debug)]
pub struct RemoveInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveInventoryItem_InventoryData {
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RemoveInventoryItem {
    pub agent_data: RemoveInventoryItem_AgentData,
    pub inventory_data: Vec<RemoveInventoryItem_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct RemoveInventoryObjects_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveInventoryObjects_FolderData {
    /// TODO
    pub folder_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveInventoryObjects_ItemData {
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// This is the new improved way to remove inventory items.  It is
/// /// currently only supported in viewer->userserver->dataserver
/// /// messages typically initiated by an empty trash method.
///
#[derive(Clone, Debug)]
pub struct RemoveInventoryObjects {
    pub agent_data: RemoveInventoryObjects_AgentData,
    pub folder_data: Vec<RemoveInventoryObjects_FolderData>,
    pub item_data: Vec<RemoveInventoryObjects_ItemData>,
}


#[derive(Clone, Debug)]
pub struct RemoveMuteListEntry_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveMuteListEntry_MuteData {
    /// TODO
    pub mute_id: Uuid,
    /// TODO
    pub mute_name: Vec<u8>,
}

/// TODO:
/// /// Remove a mute list entry.
///
#[derive(Clone, Debug)]
pub struct RemoveMuteListEntry {
    pub agent_data: RemoveMuteListEntry_AgentData,
    pub mute_data: RemoveMuteListEntry_MuteData,
}


#[derive(Clone, Debug)]
pub struct RemoveNameValuePair_TaskData {
    /// TODO
    pub id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveNameValuePair_NameValueData {
    /// TODO
    pub nv_pair: Vec<u8>,
}

/// TODO:
/// /// NameValuePair - if the specific task exists on simulator or dataserver, remove the name
/// value pair (value is ignored)
///
#[derive(Clone, Debug)]
pub struct RemoveNameValuePair {
    pub task_data: RemoveNameValuePair_TaskData,
    pub name_value_data: Vec<RemoveNameValuePair_NameValueData>,
}


#[derive(Clone, Debug)]
pub struct RemoveParcel_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
}

/// 		TODO:
/// 		/// sim -> dataserver or space ->sim
/// /// This message is used to tell the dataserver that a parcel has been
/// /// removed.
///
#[derive(Clone, Debug)]
pub struct RemoveParcel {
    pub parcel_data: Vec<RemoveParcel_ParcelData>,
}


#[derive(Clone, Debug)]
pub struct RemoveTaskInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RemoveTaskInventory_InventoryData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RemoveTaskInventory {
    pub agent_data: RemoveTaskInventory_AgentData,
    pub inventory_data: RemoveTaskInventory_InventoryData,
}


#[derive(Clone, Debug)]
pub struct ReplyTaskInventory_InventoryData {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub serial: i16,
    /// TODO
    pub filename: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ReplyTaskInventory {
    pub inventory_data: ReplyTaskInventory_InventoryData,
}


#[derive(Clone, Debug)]
pub struct ReportAutosaveCrash_AutosaveData {
    /// TODO
    pub pid: i32,
    /// TODO
    pub status: i32,
}

/// 		TODO:
/// 		/// ReportAutosaveCrash
/// /// sim->launcher
///
#[derive(Clone, Debug)]
pub struct ReportAutosaveCrash {
    pub autosave_data: ReportAutosaveCrash_AutosaveData,
}


#[derive(Clone, Debug)]
pub struct RequestGodlikePowers_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RequestGodlikePowers_RequestBlock {
    /// TODO
    pub godlike: bool,
    /// TODO
    pub token: Uuid,
}

/// 		TODO:
/// 		/// Set godlike to 1 if you want to become godlike.
/// /// Set godlike to 0 if you want to relinquish god powers.
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct RequestGodlikePowers {
    pub agent_data: RequestGodlikePowers_AgentData,
    pub request_block: RequestGodlikePowers_RequestBlock,
}


#[derive(Clone, Debug)]
pub struct RequestImage_AgentData {
    /// Agent id of the sender.
    pub agent_id: Uuid,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RequestImage_RequestImage {
    /// UUID of the texture to be downloaded.
    pub image: Uuid,
    /// Specifies how much detail the texture should have.
    ///
    /// 0 = Original version with all detail preserved.
    /// 1 = Second highest detail, half the size in each dimension.
    ///
    /// TODO: According to a screenshot values > 1 are possible, however it's unclear what kind of
    /// detail they correspond to.
    ///
    pub discard_level: i8,
    /// Priority of this download compared to other requests.
    /// A higher value indicates a higher priority.
    ///
    pub download_priority: f32,
    /// Specifies which part of the file should be transmitted.
    ///
    /// It's not possible to transmit large images in one single message, hence they are split into
    /// multiple packets by the server and the client can specify a value ≥ 0 to select a specific
    /// chunk of data.
    ///
    /// In the code we find the following definition:
    /// last_packet = (mFileSize - FIRST_PACKET_SIZE + MAX_IMG_PACKET_SIZE-1) /
    /// MAX_IMG_PACKET_SIZE + 1; where everything in caps is hard coded, with the following
    /// values:
    ///
    /// FIRST_PACKET_SIZE: 600
    /// MAX_IMG_PACKET_SIZE: 1000
    ///
    /// TODO: But I'm still not convinced, is only the first packet 600 bytes long, and every
    /// other packet size is 1000 until for the last one? Or is there some other mechanism to
    /// communicate the packet sizes. (Also they misleadingly call this packet sizes, but it's
    /// more like a chunk size since it seems to only indicate the size of the image payload.)
    ///
    pub packet: u32,
    /// 0 = NORMAL
    /// 1 = AVATAR_BAKE
    ///
    pub type_: u8,
}

/// Used to request textures over UDP from a simulator.
///
/// It's also possible to cancel a texture transmission using this message, by specifying certain
/// values. TODO: which ones (lines 3381-3386)
///
#[derive(Clone, Debug)]
pub struct RequestImage {
    pub agent_data: RequestImage_AgentData,
    pub request_image: Vec<RequestImage_RequestImage>,
}


#[derive(Clone, Debug)]
pub struct RequestInventoryAsset_QueryData {
    /// TODO
    pub query_id: Uuid,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// request permissions for agent id to get the asset for owner_id's
/// /// item_id.
///
#[derive(Clone, Debug)]
pub struct RequestInventoryAsset {
    pub query_data: RequestInventoryAsset_QueryData,
}


#[derive(Clone, Debug)]
pub struct RequestMultipleObjects_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RequestMultipleObjects_ObjectData {
    /// TODO
    pub cache_miss_type: u8,
    /// TODO
    pub id: u32,
}

/// 		TODO:
/// 		/// RequestMultipleObjects
/// /// viewer -> simulator
/// /// reliable
/// ///
/// /// When the viewer gets a local_id/crc for an object that
/// /// it either doesn't have, or doesn't have the current version
/// /// of, it sends this upstream get get an update.
/// ///
/// /// CacheMissType 0 => full object (viewer doesn't have it)
/// /// CacheMissType 1 => CRC mismatch only
///
#[derive(Clone, Debug)]
pub struct RequestMultipleObjects {
    pub agent_data: RequestMultipleObjects_AgentData,
    pub object_data: Vec<RequestMultipleObjects_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct RequestObjectPropertiesFamily_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RequestObjectPropertiesFamily_ObjectData {
    /// TODO
    pub request_flags: u32,
    /// TODO
    pub object_id: Uuid,
}

/// 		TODO:
/// 		/// RequestObjectPropertiesFamily
/// /// Ask for extended information, such as creator, permissions, resources, etc.
/// /// Medium frequency because it is driven by mouse hovering over objects, which
/// /// occurs at high rates.
///
#[derive(Clone, Debug)]
pub struct RequestObjectPropertiesFamily {
    pub agent_data: RequestObjectPropertiesFamily_AgentData,
    pub object_data: RequestObjectPropertiesFamily_ObjectData,
}


#[derive(Clone, Debug)]
pub struct RequestParcelTransfer_Data {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub transaction_time: u32,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub flags: u8,
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub amount: i32,
    /// TODO
    pub billable_area: i32,
    /// TODO
    pub actual_area: i32,
    /// TODO
    pub final_: bool,
}

#[derive(Clone, Debug)]
pub struct RequestParcelTransfer_RegionData {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
}

/// 		TODO:
/// 		/// sim -> dataserver
/// /// This message is used to check if a user can buy a parcel. If
/// /// successful, the transaction is approved through a money balance reply
/// /// with the same transaction id.
///
#[derive(Clone, Debug)]
pub struct RequestParcelTransfer {
    pub data: RequestParcelTransfer_Data,
    pub region_data: RequestParcelTransfer_RegionData,
}


#[derive(Clone, Debug)]
pub struct RequestPayPrice_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// 		TODO:
/// 		/// RequestPayPrice
/// /// viewer -> sim
///
#[derive(Clone, Debug)]
pub struct RequestPayPrice {
    pub object_data: RequestPayPrice_ObjectData,
}


#[derive(Clone, Debug)]
pub struct RequestRegionInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct RequestRegionInfo {
    pub agent_data: RequestRegionInfo_AgentData,
}


#[derive(Clone, Debug)]
pub struct RequestTaskInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RequestTaskInventory_InventoryData {
    /// TODO
    pub local_id: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RequestTaskInventory {
    pub agent_data: RequestTaskInventory_AgentData,
    pub inventory_data: RequestTaskInventory_InventoryData,
}


/// 		TODO:
/// 		/// RequestTrustedCircuit
/// /// If the destination does not trust the sender, a Deny is sent back.
///
#[derive(Clone, Debug)]
pub struct RequestTrustedCircuit {}


#[derive(Clone, Debug)]
pub struct RequestXfer_XferID {
    /// TODO
    pub id: u64,
    /// Filename of the requested asset.
    pub filename: Vec<u8>,
    /// TODO
    pub file_path: u8,
    /// If this is true this will delete the asset from the server after
    /// retrieving it.
    pub delete_on_completion: bool,
    /// Whether to use big transfer packets. (TODO: What does this mean, how is
    /// this implemented in the llUDP stack?)
    pub use_big_packets: bool,
    /// If the filename is empty, this should specify the UUID of the requested
    /// file.
    pub v_file_id: Uuid,
    /// If the filename is empty this should be the asset type.
    pub v_file_type: i16,
}

/// This message can be sent from the viewer to the sim to request initiating a Xfer.
///
/// A file can be either requested by specifying its filename or its UUID.
/// In the later case the `VFileType` has to be specified, otherwise the filetype is
/// determined according to its extension.
///
/// | Asset type  | Code | Ext | Description |
/// | ----------  | ---- | --- | ----------- |
/// | Unknown     | -1   | | Unknown asset type |
/// | Texture     | 0    | Texture asset, stored in JPEG2000 J2C stream format |
/// | Sound       | 1    | | Sound asset |
/// | CallingCard | 2    | | Calling card for another avatar |
/// | Landmark    | 3    | | Link to a location in world |
/// | [obsolete]  | 4    | | |
/// | Clothing    | 5    | | Collection of textures and parameters that can be  worn by an avatar |
/// | Object      | 6    | | Primitive that can contain textures, sounds, scripts and more |
/// | Notecard    | 7    | | Notecard asset |
/// | Folder      | 8    | | Holds a collection of inventory items |
/// | RootFolder  | 9    | | Root inventory folder |
/// | LSLText     | 10   | | Linden scripting language script |
/// | LSLBytecode | 11   | | LSO bytecode for a script |
/// | TextureTGA  | 12   | | Uncompressed TGA texture |
/// | Bodypart    | 13   | | Collection of textures and shape parameters that can be worn |
/// | TrashFolder | 14   | | Trash folder |
/// | SnapshotFolder | 15 | | Snapshot folder |
/// | LostAndFoundFolder | 16 | | Lost and found folder |
/// | SoundWAV | 17 | | Uncompressed sound |
/// | ImageTGA | 18 | | Uncompressed TGA non-square image, not to be used as a texture |
/// | ImageJPEG | 19 | | Compressed JPEG non-square image, not to be used as a texture |
/// | Animation | 20 | | Animation |
/// | Gesture | 21 | | Sequence of animations, sounds, chat, and pauses |
/// | Simstate | 22 | | Simstate file |
/// | FavoriteFolder | 23 | | Contains landmarks for favorites |
/// | Link | 24 | | Asset is a link to another inventory item |
/// | LinkFolder | 25 | | Asset is a link to another inventory folder |
/// | EnsembleStart | 26 | | Beginning of the range reserved for ensembles |
/// | EnsembleEnd | 45 | | End of the range reserved for ensembles |
/// | CurrentOutfitFolder | 46 | | Folder containing inventory links to wearables and attachments
/// that are part of the current outfit | | OutfitFolder | 47 | | Folder containing inventory items
/// or links to inventory items of wearables and attachments together make a full outfit |
/// | MyOutfitsFolder | 48 | | Root folder for the folders of type OutfitFolder |
/// | Mesh | 49 | | Linden mesh format |
/// | Inbox | 50 | | Marketplace direct delivery inbox ("Received Items") |
/// | Outbox | 51 | | Marketplace direct delivery outbox |
/// | BasicRoot | 51 | | |
///
#[derive(Clone, Debug)]
pub struct RequestXfer {
    pub xfer_id: RequestXfer_XferID,
}


#[derive(Clone, Debug)]
pub struct RetrieveInstantMessages_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// RetrieveInstantMessages - used to get instant messages that
/// /// were persisted out to the database while the user was offline
///
#[derive(Clone, Debug)]
pub struct RetrieveInstantMessages {
    pub agent_data: RetrieveInstantMessages_AgentData,
}


#[derive(Clone, Debug)]
pub struct RevokePermissions_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RevokePermissions_Data {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub object_permissions: u32,
}

/// 		TODO:
/// 		/// RevokePermissions
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct RevokePermissions {
    pub agent_data: RevokePermissions_AgentData,
    pub data: RevokePermissions_Data,
}


#[derive(Clone, Debug)]
pub struct RezMultipleAttachmentsFromInv_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezMultipleAttachmentsFromInv_HeaderData {
    /// TODO
    pub compound_msg_id: Uuid,
    /// TODO
    pub total_objects: u8,
    /// TODO
    pub first_detach_all: bool,
}

#[derive(Clone, Debug)]
pub struct RezMultipleAttachmentsFromInv_ObjectData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub attachment_pt: u8,
    /// TODO
    pub item_flags: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RezMultipleAttachmentsFromInv {
    pub agent_data: RezMultipleAttachmentsFromInv_AgentData,
    pub header_data: RezMultipleAttachmentsFromInv_HeaderData,
    pub object_data: Vec<RezMultipleAttachmentsFromInv_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct RezObject_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezObject_RezData {
    /// TODO
    pub from_task_id: Uuid,
    /// TODO
    pub bypass_raycast: u8,
    /// TODO
    pub ray_start: Vector3<f32>,
    /// TODO
    pub ray_end: Vector3<f32>,
    /// TODO
    pub ray_target_id: Uuid,
    /// TODO
    pub ray_end_is_intersection: bool,
    /// TODO
    pub rez_selected: bool,
    /// TODO
    pub remove_item: bool,
    /// TODO
    pub item_flags: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
}

#[derive(Clone, Debug)]
pub struct RezObject_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// 		TODO:
/// 		/// This message is sent from viewer -> simulator when the viewer wants
/// /// to rez an object out of inventory.
///
#[derive(Clone, Debug)]
pub struct RezObject {
    pub agent_data: RezObject_AgentData,
    pub rez_data: RezObject_RezData,
    pub inventory_data: RezObject_InventoryData,
}


#[derive(Clone, Debug)]
pub struct RezObjectFromNotecard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezObjectFromNotecard_RezData {
    /// TODO
    pub from_task_id: Uuid,
    /// TODO
    pub bypass_raycast: u8,
    /// TODO
    pub ray_start: Vector3<f32>,
    /// TODO
    pub ray_end: Vector3<f32>,
    /// TODO
    pub ray_target_id: Uuid,
    /// TODO
    pub ray_end_is_intersection: bool,
    /// TODO
    pub rez_selected: bool,
    /// TODO
    pub remove_item: bool,
    /// TODO
    pub item_flags: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
}

#[derive(Clone, Debug)]
pub struct RezObjectFromNotecard_NotecardData {
    /// TODO
    pub notecard_item_id: Uuid,
    /// TODO
    pub object_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezObjectFromNotecard_InventoryData {
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// This message is sent from viewer -> simulator when the viewer wants
/// /// to rez an object from a notecard.
///
#[derive(Clone, Debug)]
pub struct RezObjectFromNotecard {
    pub agent_data: RezObjectFromNotecard_AgentData,
    pub rez_data: RezObjectFromNotecard_RezData,
    pub notecard_data: RezObjectFromNotecard_NotecardData,
    pub inventory_data: Vec<RezObjectFromNotecard_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct RezRestoreToWorld_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezRestoreToWorld_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// 		TODO:
/// 		/// This message is sent from viewer -> simulator when the viewer wants
/// /// to rez an object out of inventory back to its position before it
/// /// last moved into the inventory
///
#[derive(Clone, Debug)]
pub struct RezRestoreToWorld {
    pub agent_data: RezRestoreToWorld_AgentData,
    pub inventory_data: RezRestoreToWorld_InventoryData,
}


#[derive(Clone, Debug)]
pub struct RezScript_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezScript_UpdateBlock {
    /// TODO
    pub object_local_id: u32,
    /// TODO
    pub enabled: bool,
}

#[derive(Clone, Debug)]
pub struct RezScript_InventoryBlock {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// TODO:
/// /// Rez a script onto an object
///
#[derive(Clone, Debug)]
pub struct RezScript {
    pub agent_data: RezScript_AgentData,
    pub update_block: RezScript_UpdateBlock,
    pub inventory_block: RezScript_InventoryBlock,
}


#[derive(Clone, Debug)]
pub struct RezSingleAttachmentFromInv_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct RezSingleAttachmentFromInv_ObjectData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub attachment_pt: u8,
    /// TODO
    pub item_flags: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct RezSingleAttachmentFromInv {
    pub agent_data: RezSingleAttachmentFromInv_AgentData,
    pub object_data: RezSingleAttachmentFromInv_ObjectData,
}


#[derive(Clone, Debug)]
pub struct RoutedMoneyBalanceReply_TargetBlock {
    /// TODO
    pub target_ip: Ip4Addr,
    /// TODO
    pub target_port: IpPort,
}

#[derive(Clone, Debug)]
pub struct RoutedMoneyBalanceReply_MoneyData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub transaction_success: bool,
    /// TODO
    pub money_balance: i32,
    /// TODO
    pub square_meters_credit: i32,
    /// TODO
    pub square_meters_committed: i32,
    /// TODO
    pub description: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct RoutedMoneyBalanceReply_TransactionInfo {
    /// TODO
    pub transaction_type: i32,
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub is_source_group: bool,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub is_dest_group: bool,
    /// TODO
    pub amount: i32,
    /// TODO
    pub item_description: Vec<u8>,
}

/// 		TODO:
/// 		/// RoutedMoneyBalanceReply
/// /// This message is used when a dataserver needs to send updated
/// /// money balance information to a simulator other than the one it
/// /// is connected to.  It uses the standard TransferBlock format.
/// /// dataserver -> simulator -> spaceserver -> simulator -> viewer
/// /// reliable
/// /// See MoneyBalanceReply above.
///
#[derive(Clone, Debug)]
pub struct RoutedMoneyBalanceReply {
    pub target_block: RoutedMoneyBalanceReply_TargetBlock,
    pub money_data: RoutedMoneyBalanceReply_MoneyData,
    pub transaction_info: RoutedMoneyBalanceReply_TransactionInfo,
}


#[derive(Clone, Debug)]
pub struct RpcChannelReply_DataBlock {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub channel_id: Uuid,
}

/// 		TODO:
/// 		/// RpcServer allocated a session for the script
/// /// ChannelID will be the NULL UUID if unable to register
/// /// dataserver -> simulator
///
#[derive(Clone, Debug)]
pub struct RpcChannelReply {
    pub data_block: RpcChannelReply_DataBlock,
}


#[derive(Clone, Debug)]
pub struct RpcChannelRequest_DataBlock {
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// 		TODO:
/// 		/// RPC messages
/// /// Script on simulator requests rpc channel from rpcserver
/// /// simulator -> dataserver -> MySQL
///
#[derive(Clone, Debug)]
pub struct RpcChannelRequest {
    pub data_block: RpcChannelRequest_DataBlock,
}


#[derive(Clone, Debug)]
pub struct RpcScriptReplyInbound_DataBlock {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub channel_id: Uuid,
    /// TODO
    pub int_value: u32,
    /// TODO
    pub string_value: Vec<u8>,
}

/// 		TODO:
/// 		/// simulator -> rpcserver
/// /// Not trusted because trust establishment doesn't work here.
///
#[derive(Clone, Debug)]
pub struct RpcScriptReplyInbound {
    pub data_block: RpcScriptReplyInbound_DataBlock,
}


#[derive(Clone, Debug)]
pub struct RpcScriptRequestInbound_TargetBlock {
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
}

#[derive(Clone, Debug)]
pub struct RpcScriptRequestInbound_DataBlock {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub channel_id: Uuid,
    /// TODO
    pub int_value: u32,
    /// TODO
    pub string_value: Vec<u8>,
}

/// 		TODO:
/// 		/// Inbound RPC requests follow this path:
/// /// RpcScriptRequestInbound: rpcserver -> spaceserver
/// /// RpcScriptRequestInboundForward: spaceserver -> simulator
/// /// reply: simulator -> rpcserver
///
#[derive(Clone, Debug)]
pub struct RpcScriptRequestInbound {
    pub target_block: RpcScriptRequestInbound_TargetBlock,
    pub data_block: RpcScriptRequestInbound_DataBlock,
}


#[derive(Clone, Debug)]
pub struct RpcScriptRequestInboundForward_DataBlock {
    /// TODO
    pub rpc_server_ip: Ip4Addr,
    /// TODO
    pub rpc_server_port: IpPort,
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub channel_id: Uuid,
    /// TODO
    pub int_value: u32,
    /// TODO
    pub string_value: Vec<u8>,
}

/// TODO:
/// /// spaceserver -> simulator
///
#[derive(Clone, Debug)]
pub struct RpcScriptRequestInboundForward {
    pub data_block: RpcScriptRequestInboundForward_DataBlock,
}


#[derive(Clone, Debug)]
pub struct SaveAssetIntoInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SaveAssetIntoInventory_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub new_asset_id: Uuid,
}

/// 		TODO:
/// 		///
/// /// Sim outgoing only (to dataserver, to viewer)
/// /// NOT viewer to sim, sim should not have handler, ever
/// /// This message is currently only uses objects, so the viewer ignores
/// /// the asset id.
///
#[derive(Clone, Debug)]
pub struct SaveAssetIntoInventory {
    pub agent_data: SaveAssetIntoInventory_AgentData,
    pub inventory_data: SaveAssetIntoInventory_InventoryData,
}


#[derive(Clone, Debug)]
pub struct ScriptAnswerYes_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ScriptAnswerYes_Data {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub questions: i32,
}

/// 		TODO:
/// 		/// ScriptAnswerYes
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptAnswerYes {
    pub agent_data: ScriptAnswerYes_AgentData,
    pub data: ScriptAnswerYes_Data,
}


#[derive(Clone, Debug)]
pub struct ScriptControlChange_Data {
    /// TODO
    pub take_controls: bool,
    /// TODO
    pub controls: u32,
    /// TODO
    pub pass_to_agent: bool,
}

/// 		TODO:
/// 		/// ScriptControlChange
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptControlChange {
    pub data: Vec<ScriptControlChange_Data>,
}


#[derive(Clone, Debug)]
pub struct ScriptDataReply_DataBlock {
    /// TODO
    pub hash: u64,
    /// TODO
    pub reply: Vec<u8>,
}

/// TODO:
/// /// Data server responds with data
///
#[derive(Clone, Debug)]
pub struct ScriptDataReply {
    pub data_block: Vec<ScriptDataReply_DataBlock>,
}


#[derive(Clone, Debug)]
pub struct ScriptDataRequest_DataBlock {
    /// TODO
    pub hash: u64,
    /// TODO
    pub request_type: i8,
    /// TODO
    pub request: Vec<u8>,
}

/// TODO:
/// /// Script on simulator asks dataserver for information
///
#[derive(Clone, Debug)]
pub struct ScriptDataRequest {
    pub data_block: Vec<ScriptDataRequest_DataBlock>,
}


#[derive(Clone, Debug)]
pub struct ScriptDialog_Data {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub first_name: Vec<u8>,
    /// TODO
    pub last_name: Vec<u8>,
    /// TODO
    pub object_name: Vec<u8>,
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub chat_channel: i32,
    /// TODO
    pub image_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ScriptDialog_Buttons {
    /// TODO
    pub button_label: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct ScriptDialog_OwnerData {
    /// TODO
    pub owner_id: Uuid,
}

/// 		TODO:
/// 		/// ScriptDialog
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptDialog {
    pub data: ScriptDialog_Data,
    pub buttons: Vec<ScriptDialog_Buttons>,
    pub owner_data: Vec<ScriptDialog_OwnerData>,
}


#[derive(Clone, Debug)]
pub struct ScriptDialogReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ScriptDialogReply_Data {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub chat_channel: i32,
    /// TODO
    pub button_index: i32,
    /// TODO
    pub button_label: Vec<u8>,
}

/// 		TODO:
/// 		/// ScriptDialogReply
/// /// viewer -> sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptDialogReply {
    pub agent_data: ScriptDialogReply_AgentData,
    pub data: ScriptDialogReply_Data,
}


#[derive(Clone, Debug)]
pub struct ScriptMailRegistration_DataBlock {
    /// TODO
    pub target_ip: Vec<u8>,
    /// TODO
    pub target_port: IpPort,
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// ScriptMailRegistration
/// /// Simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct ScriptMailRegistration {
    pub data_block: ScriptMailRegistration_DataBlock,
}


#[derive(Clone, Debug)]
pub struct ScriptQuestion_Data {
    /// TODO
    pub task_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub object_name: Vec<u8>,
    /// TODO
    pub object_owner: Vec<u8>,
    /// TODO
    pub questions: i32,
}

/// 		TODO:
/// 		/// ScriptQuestion
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptQuestion {
    pub data: ScriptQuestion_Data,
}


#[derive(Clone, Debug)]
pub struct ScriptReset_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ScriptReset_Script {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub item_id: Uuid,
}

/// TODO:
/// /// ScriptReset - causes a script to reset
///
#[derive(Clone, Debug)]
pub struct ScriptReset {
    pub agent_data: ScriptReset_AgentData,
    pub script: ScriptReset_Script,
}


#[derive(Clone, Debug)]
pub struct ScriptRunningReply_Script {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub running: bool,
}

/// 		TODO:
/// 		/// ScriptRunningReply - response from simulator to message above
/// ///		{	Mono			BOOL	} Added to LLSD message
///
#[derive(Clone, Debug)]
pub struct ScriptRunningReply {
    pub script: ScriptRunningReply_Script,
}


#[derive(Clone, Debug)]
pub struct ScriptSensorReply_Requester {
    /// TODO
    pub source_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ScriptSensorReply_SensedData {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub velocity: Vector3<f32>,
    /// TODO
    pub rotation: Quaternion<f32>,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub type_: i32,
    /// TODO
    pub range: f32,
}

/// TODO:
/// /// ScriptSensorReply - returns the request script search information back to the requester
///
#[derive(Clone, Debug)]
pub struct ScriptSensorReply {
    pub requester: ScriptSensorReply_Requester,
    pub sensed_data: Vec<ScriptSensorReply_SensedData>,
}


#[derive(Clone, Debug)]
pub struct ScriptSensorRequest_Requester {
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub request_id: Uuid,
    /// TODO
    pub search_id: Uuid,
    /// TODO
    pub search_pos: Vector3<f32>,
    /// TODO
    pub search_dir: Quaternion<f32>,
    /// TODO
    pub search_name: Vec<u8>,
    /// TODO
    pub type_: i32,
    /// TODO
    pub range: f32,
    /// TODO
    pub arc: f32,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub search_regions: u8,
}

/// TODO:
/// /// ScriptSensorRequest - causes the receiving sim to run a script sensor and return the results
///
#[derive(Clone, Debug)]
pub struct ScriptSensorRequest {
    pub requester: ScriptSensorRequest_Requester,
}


#[derive(Clone, Debug)]
pub struct ScriptTeleportRequest_Data {
    /// TODO
    pub object_name: Vec<u8>,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub sim_position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// ScriptTeleportRequest
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct ScriptTeleportRequest {
    pub data: ScriptTeleportRequest_Data,
}


#[derive(Clone, Debug)]
pub struct SendPostcard_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub pos_global: Vector3<f64>,
    /// TODO
    pub to: Vec<u8>,
    /// TODO
    pub from: Vec<u8>,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub subject: Vec<u8>,
    /// TODO
    pub msg: Vec<u8>,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
}

/// 		TODO:
/// 		///-----------------------------------------------------------------------------
/// /// Postcard messages
/// ///-----------------------------------------------------------------------------
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct SendPostcard {
    pub agent_data: SendPostcard_AgentData,
}


#[derive(Clone, Debug)]
pub struct SendXferPacket_XferID {
    /// TODO
    pub id: u64,
    /// TODO: Probably the sequence number of the data?
    ///
    pub packet: u32,
}

#[derive(Clone, Debug)]
pub struct SendXferPacket_DataPacket {
    /// Payload data.
    pub data: Vec<u8>,
}

/// A chunk of Xfer data sent from the sim to the viewer.
///
#[derive(Clone, Debug)]
pub struct SendXferPacket {
    pub xfer_id: SendXferPacket_XferID,
    pub data_packet: SendXferPacket_DataPacket,
}


#[derive(Clone, Debug)]
pub struct SetAlwaysRun_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub always_run: bool,
}

/// 		TODO:
/// 		/// SetAlwaysRun
/// /// Lets the viewer choose between running and walking
///
#[derive(Clone, Debug)]
pub struct SetAlwaysRun {
    pub agent_data: SetAlwaysRun_AgentData,
}


#[derive(Clone, Debug)]
pub struct SetCPURatio_Data {
    /// TODO
    pub ratio: u8,
}

/// 		TODO:
/// 		/// SetChildCount - Sent to launcher to adjust nominal child count
/// /// Simulator sends this increase the sim/cpu ratio on startup
///
#[derive(Clone, Debug)]
pub struct SetCPURatio {
    pub data: SetCPURatio_Data,
}


#[derive(Clone, Debug)]
pub struct SetFollowCamProperties_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SetFollowCamProperties_CameraProperty {
    /// TODO
    pub type_: i32,
    /// TODO
    pub value: f32,
}

/// TODO:
/// /// SetFollowCamProperties
///
#[derive(Clone, Debug)]
pub struct SetFollowCamProperties {
    pub object_data: SetFollowCamProperties_ObjectData,
    pub camera_property: Vec<SetFollowCamProperties_CameraProperty>,
}


#[derive(Clone, Debug)]
pub struct SetGroupAcceptNotices_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SetGroupAcceptNotices_Data {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub accept_notices: bool,
}

#[derive(Clone, Debug)]
pub struct SetGroupAcceptNotices_NewData {
    /// TODO
    pub list_in_profile: bool,
}

/// TODO:
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct SetGroupAcceptNotices {
    pub agent_data: SetGroupAcceptNotices_AgentData,
    pub data: SetGroupAcceptNotices_Data,
    pub new_data: SetGroupAcceptNotices_NewData,
}


#[derive(Clone, Debug)]
pub struct SetGroupContribution_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SetGroupContribution_Data {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub contribution: i32,
}

/// TODO:
/// /// viewer -> simulator -> dataserver
///
#[derive(Clone, Debug)]
pub struct SetGroupContribution {
    pub agent_data: SetGroupContribution_AgentData,
    pub data: SetGroupContribution_Data,
}


#[derive(Clone, Debug)]
pub struct SetScriptRunning_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SetScriptRunning_Script {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub running: bool,
}

/// 		TODO:
/// 		/// SetScriptRunning - makes a script active or inactive (Enable may be
/// /// true or false)
///
#[derive(Clone, Debug)]
pub struct SetScriptRunning {
    pub agent_data: SetScriptRunning_AgentData,
    pub script: SetScriptRunning_Script,
}


#[derive(Clone, Debug)]
pub struct SetSimPresenceInDatabase_SimData {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub host_name: Vec<u8>,
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
    /// TODO
    pub pid: i32,
    /// TODO
    pub agent_count: i32,
    /// TODO
    pub time_to_live: i32,
    /// TODO
    pub status: Vec<u8>,
}

/// 		TODO:
/// 		/// SetSimPresenceInDatabase
/// /// updates the "presence" table in the database to ensure
/// /// that a given simulator is present and valid for a set amount of
/// /// time
///
#[derive(Clone, Debug)]
pub struct SetSimPresenceInDatabase {
    pub sim_data: SetSimPresenceInDatabase_SimData,
}


#[derive(Clone, Debug)]
pub struct SetSimStatusInDatabase_Data {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub host_name: Vec<u8>,
    /// TODO
    pub x: i32,
    /// TODO
    pub y: i32,
    /// TODO
    pub pid: i32,
    /// TODO
    pub agent_count: i32,
    /// TODO
    pub time_to_live: i32,
    /// TODO
    pub status: Vec<u8>,
}

/// 		TODO:
/// 		/// SetSimStatusInDatabase
/// /// alters the "simulator" table in the database
/// /// sim -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct SetSimStatusInDatabase {
    pub data: SetSimStatusInDatabase_Data,
}


#[derive(Clone, Debug)]
pub struct SetStartLocation_StartLocationData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub location_id: u32,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub location_pos: Vector3<f32>,
    /// TODO
    pub location_look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// SetStartLocation
/// /// sim -> dataserver
///
#[derive(Clone, Debug)]
pub struct SetStartLocation {
    pub start_location_data: SetStartLocation_StartLocationData,
}


#[derive(Clone, Debug)]
pub struct SetStartLocationRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SetStartLocationRequest_StartLocationData {
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub location_id: u32,
    /// TODO
    pub location_pos: Vector3<f32>,
    /// TODO
    pub location_look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// SetStartLocationRequest
/// /// viewer -> sim
/// /// failure checked at sim and triggers ImprovedInstantMessage
/// /// success triggers SetStartLocation
///
#[derive(Clone, Debug)]
pub struct SetStartLocationRequest {
    pub agent_data: SetStartLocationRequest_AgentData,
    pub start_location_data: SetStartLocationRequest_StartLocationData,
}


#[derive(Clone, Debug)]
pub struct SimCrashed_Data {
    /// TODO
    pub region_x: u32,
    /// TODO
    pub region_y: u32,
}

#[derive(Clone, Debug)]
pub struct SimCrashed_Users {
    /// TODO
    pub agent_id: Uuid,
}

/// 		TODO:
/// 		/// SimCrashed - Sent to dataserver when the sim goes down.
/// /// Maybe we should notify the spaceserver as well?
///
#[derive(Clone, Debug)]
pub struct SimCrashed {
    pub data: SimCrashed_Data,
    pub users: Vec<SimCrashed_Users>,
}


#[derive(Clone, Debug)]
pub struct SimStats_Region {
    /// TODO
    pub region_x: u32,
    /// TODO
    pub region_y: u32,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub object_capacity: u32,
}

#[derive(Clone, Debug)]
pub struct SimStats_Stat {
    /// TODO
    pub stat_id: u32,
    /// TODO
    pub stat_value: f32,
}

#[derive(Clone, Debug)]
pub struct SimStats_PidStat {
    /// TODO
    pub pid: i32,
}

/// TODO:
/// /// Simulator statistics packet (goes out to viewer and dataserver/spaceserver)
///
#[derive(Clone, Debug)]
pub struct SimStats {
    pub region: SimStats_Region,
    pub stat: Vec<SimStats_Stat>,
    pub pid_stat: SimStats_PidStat,
}


#[derive(Clone, Debug)]
pub struct SimStatus_SimStatus {
    /// TODO
    pub can_accept_agents: bool,
    /// TODO
    pub can_accept_tasks: bool,
}

/// 		TODO:
/// 		/// Sim status, condition of this sim
/// /// sent reliably, when dirty
///
#[derive(Clone, Debug)]
pub struct SimStatus {
    pub sim_status: SimStatus_SimStatus,
}


#[derive(Clone, Debug)]
pub struct SimWideDeletes_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct SimWideDeletes_DataBlock {
    /// TODO
    pub target_id: Uuid,
    /// TODO
    pub flags: u32,
}

/// TODO:
/// /// SimWideDeletes
///
#[derive(Clone, Debug)]
pub struct SimWideDeletes {
    pub agent_data: SimWideDeletes_AgentData,
    pub data_block: SimWideDeletes_DataBlock,
}


#[derive(Clone, Debug)]
pub struct SimulatorLoad_SimulatorLoad {
    /// TODO
    pub time_dilation: f32,
    /// TODO
    pub agent_count: i32,
    /// TODO
    pub can_accept_agents: bool,
}

#[derive(Clone, Debug)]
pub struct SimulatorLoad_AgentList {
    /// TODO
    pub circuit_code: u32,
    /// TODO
    pub x: u8,
    /// TODO
    pub y: u8,
}

/// 		TODO:
/// 		/// SimulatorLoad
/// /// simulator -> spaceserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct SimulatorLoad {
    pub simulator_load: SimulatorLoad_SimulatorLoad,
    pub agent_list: Vec<SimulatorLoad_AgentList>,
}


#[derive(Clone, Debug)]
pub struct SimulatorMapUpdate_MapData {
    /// TODO
    pub flags: u32,
}

/// 		TODO:
/// 		/// SimulatorMapUpdate
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct SimulatorMapUpdate {
    pub map_data: SimulatorMapUpdate_MapData,
}


#[derive(Clone, Debug)]
pub struct SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    /// TODO
    pub port: IpPort,
    /// TODO
    pub simulator_ip: Ip4Addr,
    /// TODO
    pub grid_x: u32,
    /// TODO
    pub grid_y: u32,
}

#[derive(Clone, Debug)]
pub struct SimulatorPresentAtLocation_NeighborBlock {
    /// TODO
    pub ip: Ip4Addr,
    /// TODO
    pub port: IpPort,
}

#[derive(Clone, Debug)]
pub struct SimulatorPresentAtLocation_SimulatorBlock {
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub parent_estate_id: u32,
}

#[derive(Clone, Debug)]
pub struct SimulatorPresentAtLocation_TelehubBlock {
    /// TODO
    pub has_telehub: bool,
    /// TODO
    pub telehub_pos: Vector3<f32>,
}

/// 		TODO:
/// 		/// SimulatorPresentAtLocation - indicates that the sim is present at a grid
/// /// location and passes what it believes its neighbors are
///
#[derive(Clone, Debug)]
pub struct SimulatorPresentAtLocation {
    pub simulator_public_host_block: SimulatorPresentAtLocation_SimulatorPublicHostBlock,
    pub neighbor_block: ArrayVec<[SimulatorPresentAtLocation_NeighborBlock; 4]>,
    pub simulator_block: SimulatorPresentAtLocation_SimulatorBlock,
    pub telehub_block: Vec<SimulatorPresentAtLocation_TelehubBlock>,
}


#[derive(Clone, Debug)]
pub struct SimulatorReady_SimulatorBlock {
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub region_flags: u32,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub parent_estate_id: u32,
}

#[derive(Clone, Debug)]
pub struct SimulatorReady_TelehubBlock {
    /// TODO
    pub has_telehub: bool,
    /// TODO
    pub telehub_pos: Vector3<f32>,
}

/// 		TODO:
/// 		/// SimulatorReady - indicates the sim has finished loading its state
/// /// and is ready to receive updates from others
///
#[derive(Clone, Debug)]
pub struct SimulatorReady {
    pub simulator_block: SimulatorReady_SimulatorBlock,
    pub telehub_block: SimulatorReady_TelehubBlock,
}


#[derive(Clone, Debug)]
pub struct SimulatorSetMap_MapData {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub type_: i32,
    /// TODO
    pub map_image: Uuid,
}

/// 		TODO:
/// 		/// SimulatorSetMap
/// /// simulator -> dataserver
/// /// reliable
/// /// Used to upload a map image into the database (currently used only for Land For Sale)
///
#[derive(Clone, Debug)]
pub struct SimulatorSetMap {
    pub map_data: SimulatorSetMap_MapData,
}


/// TODO:
/// /// Simulator Shutdown Request - Tells spaceserver that a simulator is trying to shutdown
///
#[derive(Clone, Debug)]
pub struct SimulatorShutdownRequest {}


#[derive(Clone, Debug)]
pub struct SimulatorViewerTimeMessage_TimeInfo {
    /// TODO
    pub usec_since_start: u64,
    /// TODO
    pub sec_per_day: u32,
    /// TODO
    pub sec_per_year: u32,
    /// TODO
    pub sun_direction: Vector3<f32>,
    /// TODO
    pub sun_phase: f32,
    /// TODO
    pub sun_ang_velocity: Vector3<f32>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct SimulatorViewerTimeMessage {
    pub time_info: SimulatorViewerTimeMessage_TimeInfo,
}


#[derive(Clone, Debug)]
pub struct SoundTrigger_SoundData {
    /// TODO
    pub sound_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
    /// TODO
    pub handle: u64,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub gain: f32,
}

/// TODO:
/// /// SoundTrigger - Sent by simulator to viewer to trigger sound outside current region
///
#[derive(Clone, Debug)]
pub struct SoundTrigger {
    pub sound_data: SoundTrigger_SoundData,
}


#[derive(Clone, Debug)]
pub struct StartAuction_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct StartAuction_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub name: Vec<u8>,
}

/// 		TODO:
/// 		/// sim -> dataserver
/// /// Once all of the data has been gathered,
///
#[derive(Clone, Debug)]
pub struct StartAuction {
    pub agent_data: StartAuction_AgentData,
    pub parcel_data: StartAuction_ParcelData,
}


#[derive(Clone, Debug)]
pub struct StartGroupProposal_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct StartGroupProposal_ProposalData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub quorum: i32,
    /// TODO
    pub majority: f32,
    /// TODO
    pub duration: i32,
    /// TODO
    pub proposal_text: Vec<u8>,
}

/// 		TODO:
/// 		/// StartGroupProposal
/// /// viewer -> simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct StartGroupProposal {
    pub agent_data: StartGroupProposal_AgentData,
    pub proposal_data: StartGroupProposal_ProposalData,
}


#[derive(Clone, Debug)]
pub struct StartLure_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct StartLure_Info {
    /// TODO
    pub lure_type: u8,
    /// TODO
    pub message: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct StartLure_TargetData {
    /// TODO
    pub target_id: Uuid,
}

/// 		TODO:
/// 		/// StartLure viewer->sim
/// /// Sent from viewer to the local simulator to lure target id to near
/// /// agent id. This will generate an instant message that will be routed
/// /// through the space server and out to the userserver. When that IM
/// /// goes through the userserver and the TargetID is online, the
/// /// userserver will send an InitializeLure to the spaceserver. When that
/// /// packet is acked, the original instant message is finally forwarded to
/// /// TargetID.
///
#[derive(Clone, Debug)]
pub struct StartLure {
    pub agent_data: StartLure_AgentData,
    pub info: StartLure_Info,
    pub target_data: Vec<StartLure_TargetData>,
}


#[derive(Clone, Debug)]
pub struct StartPingCheck_PingID {
    /// TODO
    pub ping_id: u8,
    /// TODO
    pub oldest_unacked: u32,
}

/// 		TODO:
/// 		/// StartPingCheck - used to measure circuit ping times
/// /// PingID is used to determine how backlogged the ping was that was
/// /// returned (or how hosed the other side is)
///
#[derive(Clone, Debug)]
pub struct StartPingCheck {
    pub ping_id: StartPingCheck_PingID,
}


#[derive(Clone, Debug)]
pub struct StateSave_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct StateSave_DataBlock {
    /// TODO
    pub filename: Vec<u8>,
}

/// 		TODO:
/// 		/// Save State
/// /// viewer->sim
/// /// requires administrative access
///
#[derive(Clone, Debug)]
pub struct StateSave {
    pub agent_data: StateSave_AgentData,
    pub data_block: StateSave_DataBlock,
}


/// 		TODO:
/// 		/// SubscribeLoad
/// /// spaceserver -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct SubscribeLoad {}


#[derive(Clone, Debug)]
pub struct SystemKickUser_AgentInfo {
    /// TODO
    pub agent_id: Uuid,
}

/// 		TODO:
/// 		/// SystemKickUser
/// /// user->space, reliable
///
#[derive(Clone, Debug)]
pub struct SystemKickUser {
    pub agent_info: Vec<SystemKickUser_AgentInfo>,
}


#[derive(Clone, Debug)]
pub struct SystemMessage_MethodData {
    /// TODO
    pub method: Vec<u8>,
    /// TODO
    pub invoice: Uuid,
    /// TODO
    pub digest: [u8; 32],
}

#[derive(Clone, Debug)]
pub struct SystemMessage_ParamList {
    /// TODO
    pub parameter: Vec<u8>,
}

/// 		TODO:
/// 		/// Generalized system message. Each Requst has its own protocol for
/// /// the StringData block format and contents.
///
#[derive(Clone, Debug)]
pub struct SystemMessage {
    pub method_data: SystemMessage_MethodData,
    pub param_list: Vec<SystemMessage_ParamList>,
}


/// 		TODO:
/// 		/// TallyVotes userserver -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct TallyVotes {}


#[derive(Clone, Debug)]
pub struct TelehubInfo_TelehubBlock {
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub object_name: Vec<u8>,
    /// TODO
    pub telehub_pos: Vector3<f32>,
    /// TODO
    pub telehub_rot: Quaternion<f32>,
}

#[derive(Clone, Debug)]
pub struct TelehubInfo_SpawnPointBlock {
    /// TODO
    pub spawn_point_pos: Vector3<f32>,
}

/// 		TODO:
/// 		/// TelehubInfo - fill in the UI for telehub creation floater.
/// /// sim -> viewer
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct TelehubInfo {
    pub telehub_block: TelehubInfo_TelehubBlock,
    pub spawn_point_block: Vec<TelehubInfo_SpawnPointBlock>,
}


#[derive(Clone, Debug)]
pub struct TeleportCancel_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// TeleportCancel viewer->sim
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct TeleportCancel {
    pub info: TeleportCancel_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportFailed_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub reason: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct TeleportFailed_AlertInfo {
    /// TODO
    pub message: Vec<u8>,
    /// TODO
    pub extra_params: Vec<u8>,
}

/// 		TODO:
/// 		/// TeleportFailed somewhere->sim->viewer
/// /// announce failure of teleport request
///
#[derive(Clone, Debug)]
pub struct TeleportFailed {
    pub info: TeleportFailed_Info,
    pub alert_info: Vec<TeleportFailed_AlertInfo>,
}


#[derive(Clone, Debug)]
pub struct TeleportFinish_Info {
    /// Agent id of the client.
    pub agent_id: Uuid,
    /// TODO
    pub location_id: u32,
    /// TODO
    pub sim_ip: Ip4Addr,
    /// TODO
    pub sim_port: IpPort,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub seed_capability: Vec<u8>,
    /// TODO
    pub sim_access: u8,
    /// TODO
    pub teleport_flags: u32,
    /// TODO
    pub region_size_x: u32,
    /// TODO
    pub region_size_y: u32,
}

///         TODO:
///         /// TeleportFinish sim->viewer
/// /// called when all of the information has been collected and readied for
/// /// the agent.
///
#[derive(Clone, Debug)]
pub struct TeleportFinish {
    pub info: TeleportFinish_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportLandingStatusChanged_RegionData {
    /// TODO
    pub region_handle: u64,
}

/// 		TODO:
/// 		///TeleportLandingStatusChanged
/// ///sim->dataserver
/// ///Sent from the region to the data server
/// ///to note that the region's teleportation landing status has changed
///
#[derive(Clone, Debug)]
pub struct TeleportLandingStatusChanged {
    pub region_data: TeleportLandingStatusChanged_RegionData,
}


#[derive(Clone, Debug)]
pub struct TeleportLandmarkRequest_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub landmark_id: Uuid,
}

/// 		TODO:
/// 		/// TeleportLandmarkRequest viewer->sim
/// /// teleport to landmark asset ID destination. use LLUUD::null for home.
///
#[derive(Clone, Debug)]
pub struct TeleportLandmarkRequest {
    pub info: TeleportLandmarkRequest_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportLocal_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub location_id: u32,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
    /// TODO
    pub teleport_flags: u32,
}

/// 		TODO:
/// 		/// TeleportLocal
/// /// sim -> viewer reply telling the viewer that we've successfully TP'd
/// /// to somewhere else within the sim
///
#[derive(Clone, Debug)]
pub struct TeleportLocal {
    pub info: TeleportLocal_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportLocationRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TeleportLocationRequest_Info {
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// TeleportLocationRequest
/// /// viewer -> sim specifying exact teleport destination
///
#[derive(Clone, Debug)]
pub struct TeleportLocationRequest {
    pub agent_data: TeleportLocationRequest_AgentData,
    pub info: TeleportLocationRequest_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportLureRequest_Info {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub lure_id: Uuid,
    /// TODO
    pub teleport_flags: u32,
}

/// 		TODO:
/// 		/// TeleportLureRequest viewer->sim
/// /// Message from target of lure to begin the teleport process on the
/// /// local simulator.
///
#[derive(Clone, Debug)]
pub struct TeleportLureRequest {
    pub info: TeleportLureRequest_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportProgress_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TeleportProgress_Info {
    /// TODO
    pub teleport_flags: u32,
    /// TODO
    pub message: Vec<u8>,
}

/// 		TODO:
/// 		/// TeleportProgress sim->viewer
/// /// Tell the agent how the teleport is going.
///
#[derive(Clone, Debug)]
pub struct TeleportProgress {
    pub agent_data: TeleportProgress_AgentData,
    pub info: TeleportProgress_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TeleportRequest_Info {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub look_at: Vector3<f32>,
}

/// 		TODO:
/// 		/// TeleportRequest
/// /// viewer -> sim specifying exact teleport destination
///
#[derive(Clone, Debug)]
pub struct TeleportRequest {
    pub agent_data: TeleportRequest_AgentData,
    pub info: TeleportRequest_Info,
}


#[derive(Clone, Debug)]
pub struct TeleportStart_Info {
    /// TODO
    pub teleport_flags: u32,
}

/// 		TODO:
/// 		/// TeleportStart sim->viewer
/// /// announce a successful teleport request to the viewer.
///
#[derive(Clone, Debug)]
pub struct TeleportStart {
    pub info: TeleportStart_Info,
}


#[derive(Clone, Debug)]
pub struct TerminateFriendship_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TerminateFriendship_ExBlock {
    /// TODO
    pub other_id: Uuid,
}

/// 		TODO:
/// 		/// Cancels user relationship
/// /// Updates inventory for both users.
/// /// Stops agent tracking in userserver.
/// /// viewer -> userserver -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct TerminateFriendship {
    pub agent_data: TerminateFriendship_AgentData,
    pub ex_block: TerminateFriendship_ExBlock,
}


#[derive(Clone, Debug)]
pub struct TestMessage_TestBlock1 {
    /// TODO
    pub test1: u32,
}

#[derive(Clone, Debug)]
pub struct TestMessage_NeighborBlock {
    /// TODO
    pub test0: u32,
    /// TODO
    pub test1: u32,
    /// TODO
    pub test2: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct TestMessage {
    pub test_block1: TestMessage_TestBlock1,
    pub neighbor_block: ArrayVec<[TestMessage_NeighborBlock; 4]>,
}


#[derive(Clone, Debug)]
pub struct TrackAgent_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TrackAgent_TargetData {
    /// TODO
    pub prey_id: Uuid,
}

/// 		TODO:
/// 		/// Track agent - this information is used when sending out the
/// /// coarse location update so that we know who you are tracking.
/// /// To stop tracking - send a null uuid as the prey.
///
#[derive(Clone, Debug)]
pub struct TrackAgent {
    pub agent_data: TrackAgent_AgentData,
    pub target_data: TrackAgent_TargetData,
}


#[derive(Clone, Debug)]
pub struct TransferAbort_TransferInfo {
    /// TODO
    pub transfer_id: Uuid,
    /// TODO
    pub channel_type: i32,
}

/// TODO:
/// /// Abort a transfer in progress (either from target->source or source->target)
///
#[derive(Clone, Debug)]
pub struct TransferAbort {
    pub transfer_info: TransferAbort_TransferInfo,
}


#[derive(Clone, Debug)]
pub struct TransferInfo_TransferInfo {
    /// TODO
    pub transfer_id: Uuid,
    /// TODO
    pub channel_type: i32,
    /// TODO
    pub target_type: i32,
    /// TODO
    pub status: i32,
    /// TODO
    pub size: i32,
    /// TODO
    pub params: Vec<u8>,
}

/// 		TODO:
/// 		/// Return info about a transfer/initiate transfer (source->target)
/// /// Possibly should have a Params field like above
///
#[derive(Clone, Debug)]
pub struct TransferInfo {
    pub transfer_info: TransferInfo_TransferInfo,
}


#[derive(Clone, Debug)]
pub struct TransferInventory_InfoBlock {
    /// TODO
    pub source_id: Uuid,
    /// TODO
    pub dest_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct TransferInventory_InventoryBlock {
    /// TODO
    pub inventory_id: Uuid,
    /// TODO
    pub type_: i8,
}

/// 		TODO:
/// 		/// sim -> dataserver
/// /// sent during agent to agent inventory transfers
///
#[derive(Clone, Debug)]
pub struct TransferInventory {
    pub info_block: TransferInventory_InfoBlock,
    pub inventory_block: Vec<TransferInventory_InventoryBlock>,
}


#[derive(Clone, Debug)]
pub struct TransferInventoryAck_InfoBlock {
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub inventory_id: Uuid,
}

/// 		TODO:
/// 		/// dataserver -> sim
/// /// InventoryID is the id of the inventory object that the end user
/// /// should discard if they deny the transfer.
///
#[derive(Clone, Debug)]
pub struct TransferInventoryAck {
    pub info_block: TransferInventoryAck_InfoBlock,
}


#[derive(Clone, Debug)]
pub struct TransferPacket_TransferData {
    /// TODO
    pub transfer_id: Uuid,
    /// TODO
    pub channel_type: i32,
    /// TODO
    pub packet: i32,
    /// TODO
    pub status: i32,
    /// TODO
    pub data: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct TransferPacket {
    pub transfer_data: TransferPacket_TransferData,
}


#[derive(Clone, Debug)]
pub struct TransferRequest_TransferInfo {
    /// TODO
    pub transfer_id: Uuid,
    /// TODO
    pub channel_type: i32,
    /// TODO
    pub source_type: i32,
    /// TODO
    pub priority: f32,
    /// TODO
    pub params: Vec<u8>,
}

/// TODO:
/// /// Request a new transfer (target->source)
///
#[derive(Clone, Debug)]
pub struct TransferRequest {
    pub transfer_info: TransferRequest_TransferInfo,
}


#[derive(Clone, Debug)]
pub struct UUIDGroupNameReply_UUIDNameBlock {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub group_name: Vec<u8>,
}

/// 		TODO:
/// 		/// UUIDGroupNameReply
/// /// Translate a UUID into a group name
///
#[derive(Clone, Debug)]
pub struct UUIDGroupNameReply {
    pub uuid_name_block: Vec<UUIDGroupNameReply_UUIDNameBlock>,
}


#[derive(Clone, Debug)]
pub struct UUIDGroupNameRequest_UUIDNameBlock {
    /// TODO
    pub id: Uuid,
}

/// 		TODO:
/// 		/// UUIDGroupNameRequest
/// /// Translate a UUID into a group name
///
#[derive(Clone, Debug)]
pub struct UUIDGroupNameRequest {
    pub uuid_name_block: Vec<UUIDGroupNameRequest_UUIDNameBlock>,
}


#[derive(Clone, Debug)]
pub struct UUIDNameReply_UUIDNameBlock {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub first_name: Vec<u8>,
    /// TODO
    pub last_name: Vec<u8>,
}

/// 		TODO:
/// 		/// UUIDNameReply
/// /// Translate a UUID into first and last names
///
#[derive(Clone, Debug)]
pub struct UUIDNameReply {
    pub uuid_name_block: Vec<UUIDNameReply_UUIDNameBlock>,
}


#[derive(Clone, Debug)]
pub struct UUIDNameRequest_UUIDNameBlock {
    /// TODO
    pub id: Uuid,
}

/// 		TODO:
/// 		/// UUIDNameRequest
/// /// Translate a UUID into first and last names
///
#[derive(Clone, Debug)]
pub struct UUIDNameRequest {
    pub uuid_name_block: Vec<UUIDNameRequest_UUIDNameBlock>,
}


#[derive(Clone, Debug)]
pub struct Undo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub group_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct Undo_ObjectData {
    /// TODO
    pub object_id: Uuid,
}

/// TODO:
/// /// Undo
///
#[derive(Clone, Debug)]
pub struct Undo {
    pub agent_data: Undo_AgentData,
    pub object_data: Vec<Undo_ObjectData>,
}


#[derive(Clone, Debug)]
pub struct UndoLand_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
/// /// UndoLand
///
#[derive(Clone, Debug)]
pub struct UndoLand {
    pub agent_data: UndoLand_AgentData,
}


/// 		TODO:
/// 		/// UnsubscribeLoad
/// /// spaceserver -> simulator
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct UnsubscribeLoad {}


#[derive(Clone, Debug)]
pub struct UpdateAttachment_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateAttachment_AttachmentBlock {
    /// TODO
    pub attachment_point: u8,
}

#[derive(Clone, Debug)]
pub struct UpdateAttachment_OperationData {
    /// TODO
    pub add_item: bool,
    /// TODO
    pub use_existing_asset: bool,
}

#[derive(Clone, Debug)]
pub struct UpdateAttachment_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UpdateAttachment {
    pub agent_data: UpdateAttachment_AgentData,
    pub attachment_block: UpdateAttachment_AttachmentBlock,
    pub operation_data: UpdateAttachment_OperationData,
    pub inventory_data: UpdateAttachment_InventoryData,
}


#[derive(Clone, Debug)]
pub struct UpdateCreateInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub sim_approved: bool,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateCreateInventoryItem_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub asset_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UpdateCreateInventoryItem {
    pub agent_data: UpdateCreateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateCreateInventoryItem_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct UpdateGroupInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateGroupInfo_GroupData {
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub charter: Vec<u8>,
    /// TODO
    pub show_in_list: bool,
    /// TODO
    pub insignia_id: Uuid,
    /// TODO
    pub membership_fee: i32,
    /// TODO
    pub open_enrollment: bool,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
}

/// 		TODO:
/// 		/// UpdateGroupInfo
/// /// viewer -> simulator
/// /// simulator -> dataserver
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct UpdateGroupInfo {
    pub agent_data: UpdateGroupInfo_AgentData,
    pub group_data: UpdateGroupInfo_GroupData,
}


#[derive(Clone, Debug)]
pub struct UpdateInventoryFolder_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateInventoryFolder_FolderData {
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub parent_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub name: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UpdateInventoryFolder {
    pub agent_data: UpdateInventoryFolder_AgentData,
    pub folder_data: Vec<UpdateInventoryFolder_FolderData>,
}


#[derive(Clone, Debug)]
pub struct UpdateInventoryItem_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub transaction_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateInventoryItem_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub callback_id: u32,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UpdateInventoryItem {
    pub agent_data: UpdateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateInventoryItem_InventoryData>,
}


#[derive(Clone, Debug)]
pub struct UpdateMuteListEntry_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateMuteListEntry_MuteData {
    /// TODO
    pub mute_id: Uuid,
    /// TODO
    pub mute_name: Vec<u8>,
    /// TODO
    pub mute_type: i32,
    /// TODO
    pub mute_flags: u32,
}

/// TODO:
/// /// update/add someone in the mute list
///
#[derive(Clone, Debug)]
pub struct UpdateMuteListEntry {
    pub agent_data: UpdateMuteListEntry_AgentData,
    pub mute_data: UpdateMuteListEntry_MuteData,
}


#[derive(Clone, Debug)]
pub struct UpdateParcel_ParcelData {
    /// TODO
    pub parcel_id: Uuid,
    /// TODO
    pub region_handle: u64,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub status: u8,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub music_url: Vec<u8>,
    /// TODO
    pub region_x: f32,
    /// TODO
    pub region_y: f32,
    /// TODO
    pub actual_area: i32,
    /// TODO
    pub billable_area: i32,
    /// TODO
    pub show_dir: bool,
    /// TODO
    pub is_for_sale: bool,
    /// TODO
    pub category: u8,
    /// TODO
    pub snapshot_id: Uuid,
    /// TODO
    pub user_location: Vector3<f32>,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub authorized_buyer_id: Uuid,
    /// TODO
    pub allow_publish: bool,
    /// TODO
    pub mature_publish: bool,
}

/// 		TODO:
/// 		/// sim ->dataserver
/// /// This message is used to send up complete parcel properties for
/// /// persistance in the database.
/// /// If you add something here, you should probably also change the
/// /// simulator's database update query on startup.
///
#[derive(Clone, Debug)]
pub struct UpdateParcel {
    pub parcel_data: UpdateParcel_ParcelData,
}


#[derive(Clone, Debug)]
pub struct UpdateSimulator_SimulatorInfo {
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub sim_name: Vec<u8>,
    /// TODO
    pub estate_id: u32,
    /// TODO
    pub sim_access: u8,
}

/// TODO:
/// /// Updates SimName, EstateID and SimAccess using RegionID as a key
///
#[derive(Clone, Debug)]
pub struct UpdateSimulator {
    pub simulator_info: UpdateSimulator_SimulatorInfo,
}


#[derive(Clone, Debug)]
pub struct UpdateTaskInventory_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateTaskInventory_UpdateData {
    /// TODO
    pub local_id: u32,
    /// TODO
    pub key: u8,
}

#[derive(Clone, Debug)]
pub struct UpdateTaskInventory_InventoryData {
    /// TODO
    pub item_id: Uuid,
    /// TODO
    pub folder_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub group_id: Uuid,
    /// TODO
    pub base_mask: u32,
    /// TODO
    pub owner_mask: u32,
    /// TODO
    pub group_mask: u32,
    /// TODO
    pub everyone_mask: u32,
    /// TODO
    pub next_owner_mask: u32,
    /// TODO
    pub group_owned: bool,
    /// TODO
    pub transaction_id: Uuid,
    /// TODO
    pub type_: i8,
    /// TODO
    pub inv_type: i8,
    /// TODO
    pub flags: u32,
    /// TODO
    pub sale_type: u8,
    /// TODO
    pub sale_price: i32,
    /// TODO
    pub name: Vec<u8>,
    /// TODO
    pub description: Vec<u8>,
    /// TODO
    pub creation_date: i32,
    /// TODO
    pub crc: u32,
}

/// 		TODO:
/// 		/// These messages are viewer->simulator requests to update a task's
/// /// inventory.
/// /// if Key == 0, itemid is the key. if Key == 1, assetid is the key.
///
#[derive(Clone, Debug)]
pub struct UpdateTaskInventory {
    pub agent_data: UpdateTaskInventory_AgentData,
    pub update_data: UpdateTaskInventory_UpdateData,
    pub inventory_data: UpdateTaskInventory_InventoryData,
}


#[derive(Clone, Debug)]
pub struct UpdateUserInfo_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UpdateUserInfo_UserData {
    /// TODO
    pub im_via_e_mail: bool,
    /// TODO
    pub directory_visibility: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UpdateUserInfo {
    pub agent_data: UpdateUserInfo_AgentData,
    pub user_data: UpdateUserInfo_UserData,
}


#[derive(Clone, Debug)]
pub struct UseCachedMuteList_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

/// TODO:
/// /// tell viewer to use the local mute cache
///
#[derive(Clone, Debug)]
pub struct UseCachedMuteList {
    pub agent_data: UseCachedMuteList_AgentData,
}


#[derive(Clone, Debug)]
pub struct UseCircuitCode_CircuitCode {
    /// The circuit code as provided in the login response. It serves as a
    /// proof of authentication and identfies the client.
    pub code: u32,
    /// Temporary id assigned to this session by the simulator on login, used
    /// to verify our identity in packets.
    pub session_id: Uuid,
    /// Agent id of the sender.
    pub id: Uuid,
}

/// Provide the recipent with IP address and port information of the sender.
///
#[derive(Clone, Debug)]
pub struct UseCircuitCode {
    pub circuit_code: UseCircuitCode_CircuitCode,
}


#[derive(Clone, Debug)]
pub struct UserInfoReply_AgentData {
    /// TODO
    pub agent_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UserInfoReply_UserData {
    /// TODO
    pub im_via_e_mail: bool,
    /// TODO
    pub directory_visibility: Vec<u8>,
    /// TODO
    pub e_mail: Vec<u8>,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UserInfoReply {
    pub agent_data: UserInfoReply_AgentData,
    pub user_data: UserInfoReply_UserData,
}


#[derive(Clone, Debug)]
pub struct UserInfoRequest_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct UserInfoRequest {
    pub agent_data: UserInfoRequest_AgentData,
}


#[derive(Clone, Debug)]
pub struct UserReport_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct UserReport_ReportData {
    /// TODO
    pub report_type: u8,
    /// TODO
    pub category: u8,
    /// TODO
    pub position: Vector3<f32>,
    /// TODO
    pub check_flags: u8,
    /// TODO
    pub screenshot_id: Uuid,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub abuser_id: Uuid,
    /// TODO
    pub abuse_region_name: Vec<u8>,
    /// TODO
    pub abuse_region_id: Uuid,
    /// TODO
    pub summary: Vec<u8>,
    /// TODO
    pub details: Vec<u8>,
    /// TODO
    pub version_string: Vec<u8>,
}

/// 		TODO:
/// 		/// complaint/bug-report
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct UserReport {
    pub agent_data: UserReport_AgentData,
    pub report_data: UserReport_ReportData,
}


#[derive(Clone, Debug)]
pub struct UserReportInternal_ReportData {
    /// TODO
    pub report_type: u8,
    /// TODO
    pub category: u8,
    /// TODO
    pub reporter_id: Uuid,
    /// TODO
    pub viewer_position: Vector3<f32>,
    /// TODO
    pub agent_position: Vector3<f32>,
    /// TODO
    pub screenshot_id: Uuid,
    /// TODO
    pub object_id: Uuid,
    /// TODO
    pub owner_id: Uuid,
    /// TODO
    pub last_owner_id: Uuid,
    /// TODO
    pub creator_id: Uuid,
    /// TODO
    pub region_id: Uuid,
    /// TODO
    pub abuser_id: Uuid,
    /// TODO
    pub abuse_region_name: Vec<u8>,
    /// TODO
    pub abuse_region_id: Uuid,
    /// TODO
    pub summary: Vec<u8>,
    /// TODO
    pub details: Vec<u8>,
    /// TODO
    pub version_string: Vec<u8>,
}

/// 		TODO:
/// 		/// complaint/bug-report - sim -> dataserver. see UserReport for details.
/// /// reliable
///
#[derive(Clone, Debug)]
pub struct UserReportInternal {
    pub report_data: UserReportInternal_ReportData,
}


#[derive(Clone, Debug)]
pub struct VelocityInterpolateOff_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// VelocityInterpolateOff
/// /// viewer->sim
/// /// requires administrative access
///
#[derive(Clone, Debug)]
pub struct VelocityInterpolateOff {
    pub agent_data: VelocityInterpolateOff_AgentData,
}


#[derive(Clone, Debug)]
pub struct VelocityInterpolateOn_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

/// 		TODO:
/// 		/// VelocityInterpolateOn
/// /// viewer->sim
/// /// requires administrative access
///
#[derive(Clone, Debug)]
pub struct VelocityInterpolateOn {
    pub agent_data: VelocityInterpolateOn_AgentData,
}


#[derive(Clone, Debug)]
pub struct ViewerEffect_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ViewerEffect_Effect {
    /// TODO
    pub id: Uuid,
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub type_: u8,
    /// TODO
    pub duration: f32,
    /// TODO
    pub color: [u8; 4],
    /// TODO
    pub type_data: Vec<u8>,
}

/// 		TODO:
/// 		/// ViewerEffect
/// /// Viewer side effect that's sent from one viewer, and broadcast to other agents nearby
/// /// viewer-->sim (single effect created by viewer)
/// /// sim-->viewer (multiple effects that can be seen by viewer)
/// /// the AgentData block used for authentication for viewer-->sim messages
///
#[derive(Clone, Debug)]
pub struct ViewerEffect {
    pub agent_data: ViewerEffect_AgentData,
    pub effect: Vec<ViewerEffect_Effect>,
}


#[derive(Clone, Debug)]
pub struct ViewerFrozenMessage_FrozenData {
    /// TODO
    pub data: bool,
}

/// 		TODO:
/// 		/// ViewerFrozenMessage
/// /// Specifies the text to be posted in an alert dialog
///
#[derive(Clone, Debug)]
pub struct ViewerFrozenMessage {
    pub frozen_data: ViewerFrozenMessage_FrozenData,
}


#[derive(Clone, Debug)]
pub struct ViewerStartAuction_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
}

#[derive(Clone, Debug)]
pub struct ViewerStartAuction_ParcelData {
    /// TODO
    pub local_id: i32,
    /// TODO
    pub snapshot_id: Uuid,
}

/// 		TODO:
/// 		/// viewer -> sim
/// /// start an auction. viewer fills in the appropriate date, simulator
/// /// validates and fills in the rest of the information to start an auction
/// /// on a parcel. Processing currently requires that AgentID is a god.
///
#[derive(Clone, Debug)]
pub struct ViewerStartAuction {
    pub agent_data: ViewerStartAuction_AgentData,
    pub parcel_data: ViewerStartAuction_ParcelData,
}


#[derive(Clone, Debug)]
pub struct ViewerStats_AgentData {
    /// TODO
    pub agent_id: Uuid,
    /// TODO
    pub session_id: Uuid,
    /// TODO
    pub ip: Ip4Addr,
    /// TODO
    pub start_time: u32,
    /// TODO
    pub run_time: f32,
    /// TODO
    pub sim_fps: f32,
    /// TODO
    pub fps: f32,
    /// TODO
    pub agents_in_view: u8,
    /// TODO
    pub ping: f32,
    /// TODO
    pub meters_traveled: f64,
    /// TODO
    pub regions_visited: i32,
    /// TODO
    pub sys_ram: u32,
    /// TODO
    pub sys_os: Vec<u8>,
    /// TODO
    pub sys_cpu: Vec<u8>,
    /// TODO
    pub sys_gpu: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct ViewerStats_DownloadTotals {
    /// TODO
    pub world: u32,
    /// TODO
    pub objects: u32,
    /// TODO
    pub textures: u32,
}

#[derive(Clone, Debug)]
pub struct ViewerStats_NetStats {
    /// TODO
    pub bytes: u32,
    /// TODO
    pub packets: u32,
    /// TODO
    pub compressed: u32,
    /// TODO
    pub savings: u32,
}

#[derive(Clone, Debug)]
pub struct ViewerStats_FailStats {
    /// TODO
    pub send_packet: u32,
    /// TODO
    pub dropped: u32,
    /// TODO
    pub resent: u32,
    /// TODO
    pub failed_resends: u32,
    /// TODO
    pub off_circuit: u32,
    /// TODO
    pub invalid: u32,
}

#[derive(Clone, Debug)]
pub struct ViewerStats_MiscStats {
    /// TODO
    pub type_: u32,
    /// TODO
    pub value: f64,
}

/// TODO:
///
///
#[derive(Clone, Debug)]
pub struct ViewerStats {
    pub agent_data: ViewerStats_AgentData,
    pub download_totals: ViewerStats_DownloadTotals,
    pub net_stats: ArrayVec<[ViewerStats_NetStats; 2]>,
    pub fail_stats: ViewerStats_FailStats,
    pub misc_stats: Vec<ViewerStats_MiscStats>,
}


#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum MessageType {
    AbortXfer,
    AcceptCallingCard,
    AcceptFriendship,
    ActivateGestures,
    ActivateGroup,
    AddCircuitCode,
    AgentAlertMessage,
    AgentAnimation,
    AgentCachedTexture,
    AgentCachedTextureResponse,
    AgentDataUpdate,
    AgentDataUpdateRequest,
    AgentDropGroup,
    AgentFOV,
    AgentGroupDataUpdate,
    AgentHeightWidth,
    AgentIsNowWearing,
    AgentMovementComplete,
    AgentPause,
    AgentQuitCopy,
    AgentRequestSit,
    AgentResume,
    AgentSetAppearance,
    AgentSit,
    AgentThrottle,
    AgentUpdate,
    AgentWearablesRequest,
    AgentWearablesUpdate,
    AlertMessage,
    AssetUploadComplete,
    AssetUploadRequest,
    AtomicPassObject,
    AttachedSound,
    AttachedSoundGainChange,
    AvatarAnimation,
    AvatarAppearance,
    AvatarClassifiedReply,
    AvatarGroupsReply,
    AvatarInterestsReply,
    AvatarInterestsUpdate,
    AvatarNotesReply,
    AvatarNotesUpdate,
    AvatarPickerReply,
    AvatarPickerRequest,
    AvatarPickerRequestBackend,
    AvatarPicksReply,
    AvatarPropertiesReply,
    AvatarPropertiesRequest,
    AvatarPropertiesRequestBackend,
    AvatarPropertiesUpdate,
    AvatarSitResponse,
    AvatarTextureUpdate,
    BulkUpdateInventory,
    BuyObjectInventory,
    CameraConstraint,
    CancelAuction,
    ChangeInventoryItemFlags,
    ChangeUserRights,
    ChatFromSimulator,
    ChatFromViewer,
    ChatPass,
    CheckParcelAuctions,
    CheckParcelSales,
    ChildAgentAlive,
    ChildAgentDying,
    ChildAgentPositionUpdate,
    ChildAgentUnknown,
    ChildAgentUpdate,
    ClassifiedDelete,
    ClassifiedGodDelete,
    ClassifiedInfoReply,
    ClassifiedInfoRequest,
    ClassifiedInfoUpdate,
    ClearFollowCamProperties,
    CloseCircuit,
    CoarseLocationUpdate,
    CompleteAgentMovement,
    CompleteAuction,
    CompletePingCheck,
    ConfirmAuctionStart,
    ConfirmEnableSimulator,
    ConfirmXferPacket,
    CopyInventoryFromNotecard,
    CopyInventoryItem,
    CreateGroupReply,
    CreateGroupRequest,
    CreateInventoryFolder,
    CreateInventoryItem,
    CreateLandmarkForEvent,
    CreateNewOutfitAttachments,
    CreateTrustedCircuit,
    CrossedRegion,
    DataHomeLocationReply,
    DataHomeLocationRequest,
    DataServerLogout,
    DeRezAck,
    DeRezObject,
    DeactivateGestures,
    DeclineCallingCard,
    DeclineFriendship,
    DenyTrustedCircuit,
    DerezContainer,
    DetachAttachmentIntoInv,
    DirClassifiedQuery,
    DirClassifiedQueryBackend,
    DirClassifiedReply,
    DirEventsReply,
    DirFindQuery,
    DirFindQueryBackend,
    DirGroupsReply,
    DirLandQuery,
    DirLandQueryBackend,
    DirLandReply,
    DirPeopleReply,
    DirPlacesQuery,
    DirPlacesQueryBackend,
    DirPlacesReply,
    DirPopularQuery,
    DirPopularQueryBackend,
    DirPopularReply,
    DisableSimulator,
    EconomyData,
    EconomyDataRequest,
    EdgeDataPacket,
    EjectGroupMemberReply,
    EjectGroupMemberRequest,
    EjectUser,
    EmailMessageReply,
    EmailMessageRequest,
    EnableSimulator,
    Error,
    EstateCovenantReply,
    EstateCovenantRequest,
    EstateOwnerMessage,
    EventGodDelete,
    EventInfoReply,
    EventInfoRequest,
    EventLocationReply,
    EventLocationRequest,
    EventNotificationAddRequest,
    EventNotificationRemoveRequest,
    FeatureDisabled,
    FetchInventory,
    FetchInventoryDescendents,
    FetchInventoryReply,
    FindAgent,
    ForceObjectSelect,
    ForceScriptControlRelease,
    FormFriendship,
    FreezeUser,
    GenericMessage,
    GetScriptRunning,
    GodKickUser,
    GodUpdateRegionInfo,
    GodlikeMessage,
    GrantGodlikePowers,
    GrantUserRights,
    GroupAccountDetailsReply,
    GroupAccountDetailsRequest,
    GroupAccountSummaryReply,
    GroupAccountSummaryRequest,
    GroupAccountTransactionsReply,
    GroupAccountTransactionsRequest,
    GroupActiveProposalItemReply,
    GroupActiveProposalsRequest,
    GroupDataUpdate,
    GroupMembersReply,
    GroupMembersRequest,
    GroupNoticeAdd,
    GroupNoticeRequest,
    GroupNoticesListReply,
    GroupNoticesListRequest,
    GroupProfileReply,
    GroupProfileRequest,
    GroupProposalBallot,
    GroupRoleChanges,
    GroupRoleDataReply,
    GroupRoleDataRequest,
    GroupRoleMembersReply,
    GroupRoleMembersRequest,
    GroupRoleUpdate,
    GroupTitleUpdate,
    GroupTitlesReply,
    GroupTitlesRequest,
    GroupVoteHistoryItemReply,
    GroupVoteHistoryRequest,
    HealthMessage,
    ImageData,
    ImageNotInDatabase,
    ImagePacket,
    ImprovedInstantMessage,
    ImprovedTerseObjectUpdate,
    InitiateDownload,
    InternalScriptMail,
    InventoryAssetResponse,
    InventoryDescendents,
    InviteGroupRequest,
    InviteGroupResponse,
    JoinGroupReply,
    JoinGroupRequest,
    KickUser,
    KickUserAck,
    KillChildAgents,
    KillObject,
    LandStatReply,
    LandStatRequest,
    LayerData,
    LeaveGroupReply,
    LeaveGroupRequest,
    LinkInventoryItem,
    LiveHelpGroupReply,
    LiveHelpGroupRequest,
    LoadURL,
    LogDwellTime,
    LogFailedMoneyTransaction,
    LogParcelChanges,
    LogTextMessage,
    LogoutReply,
    LogoutRequest,
    MapBlockReply,
    MapBlockRequest,
    MapItemReply,
    MapItemRequest,
    MapLayerReply,
    MapLayerRequest,
    MapNameRequest,
    MeanCollisionAlert,
    MergeParcel,
    ModifyLand,
    MoneyBalanceReply,
    MoneyBalanceRequest,
    MoneyTransferBackend,
    MoneyTransferRequest,
    MoveInventoryFolder,
    MoveInventoryItem,
    MoveTaskInventory,
    MultipleObjectUpdate,
    MuteListRequest,
    MuteListUpdate,
    NameValuePair,
    NearestLandingRegionReply,
    NearestLandingRegionRequest,
    NearestLandingRegionUpdated,
    NeighborList,
    NetTest,
    ObjectAdd,
    ObjectAttach,
    ObjectBuy,
    ObjectCategory,
    ObjectClickAction,
    ObjectDeGrab,
    ObjectDelete,
    ObjectDelink,
    ObjectDescription,
    ObjectDeselect,
    ObjectDetach,
    ObjectDrop,
    ObjectDuplicate,
    ObjectDuplicateOnRay,
    ObjectExportSelected,
    ObjectExtraParams,
    ObjectFlagUpdate,
    ObjectGrab,
    ObjectGrabUpdate,
    ObjectGroup,
    ObjectImage,
    ObjectIncludeInSearch,
    ObjectLink,
    ObjectMaterial,
    ObjectName,
    ObjectOwner,
    ObjectPermissions,
    ObjectPosition,
    ObjectProperties,
    ObjectPropertiesFamily,
    ObjectRotation,
    ObjectSaleInfo,
    ObjectScale,
    ObjectSelect,
    ObjectShape,
    ObjectSpinStart,
    ObjectSpinStop,
    ObjectSpinUpdate,
    ObjectUpdate,
    ObjectUpdateCached,
    ObjectUpdateCompressed,
    OfferCallingCard,
    OfflineNotification,
    OnlineNotification,
    OpenCircuit,
    PacketAck,
    ParcelAccessListReply,
    ParcelAccessListRequest,
    ParcelAccessListUpdate,
    ParcelAuctions,
    ParcelBuy,
    ParcelBuyPass,
    ParcelClaim,
    ParcelDeedToGroup,
    ParcelDisableObjects,
    ParcelDivide,
    ParcelDwellReply,
    ParcelDwellRequest,
    ParcelGodForceOwner,
    ParcelGodMarkAsContent,
    ParcelInfoReply,
    ParcelInfoRequest,
    ParcelJoin,
    ParcelMediaCommandMessage,
    ParcelMediaUpdate,
    ParcelObjectOwnersReply,
    ParcelObjectOwnersRequest,
    ParcelOverlay,
    ParcelProperties,
    ParcelPropertiesRequest,
    ParcelPropertiesRequestByID,
    ParcelPropertiesUpdate,
    ParcelReclaim,
    ParcelRelease,
    ParcelRename,
    ParcelReturnObjects,
    ParcelSales,
    ParcelSelectObjects,
    ParcelSetOtherCleanTime,
    PayPriceReply,
    PickDelete,
    PickGodDelete,
    PickInfoReply,
    PickInfoUpdate,
    PlacesQuery,
    PlacesReply,
    PreloadSound,
    PurgeInventoryDescendents,
    RebakeAvatarTextures,
    Redo,
    RegionHandleRequest,
    RegionHandshake,
    RegionHandshakeReply,
    RegionIDAndHandleReply,
    RegionInfo,
    RegionPresenceRequestByHandle,
    RegionPresenceRequestByRegionID,
    RegionPresenceResponse,
    RemoveAttachment,
    RemoveInventoryFolder,
    RemoveInventoryItem,
    RemoveInventoryObjects,
    RemoveMuteListEntry,
    RemoveNameValuePair,
    RemoveParcel,
    RemoveTaskInventory,
    ReplyTaskInventory,
    ReportAutosaveCrash,
    RequestGodlikePowers,
    RequestImage,
    RequestInventoryAsset,
    RequestMultipleObjects,
    RequestObjectPropertiesFamily,
    RequestParcelTransfer,
    RequestPayPrice,
    RequestRegionInfo,
    RequestTaskInventory,
    RequestTrustedCircuit,
    RequestXfer,
    RetrieveInstantMessages,
    RevokePermissions,
    RezMultipleAttachmentsFromInv,
    RezObject,
    RezObjectFromNotecard,
    RezRestoreToWorld,
    RezScript,
    RezSingleAttachmentFromInv,
    RoutedMoneyBalanceReply,
    RpcChannelReply,
    RpcChannelRequest,
    RpcScriptReplyInbound,
    RpcScriptRequestInbound,
    RpcScriptRequestInboundForward,
    SaveAssetIntoInventory,
    ScriptAnswerYes,
    ScriptControlChange,
    ScriptDataReply,
    ScriptDataRequest,
    ScriptDialog,
    ScriptDialogReply,
    ScriptMailRegistration,
    ScriptQuestion,
    ScriptReset,
    ScriptRunningReply,
    ScriptSensorReply,
    ScriptSensorRequest,
    ScriptTeleportRequest,
    SendPostcard,
    SendXferPacket,
    SetAlwaysRun,
    SetCPURatio,
    SetFollowCamProperties,
    SetGroupAcceptNotices,
    SetGroupContribution,
    SetScriptRunning,
    SetSimPresenceInDatabase,
    SetSimStatusInDatabase,
    SetStartLocation,
    SetStartLocationRequest,
    SimCrashed,
    SimStats,
    SimStatus,
    SimWideDeletes,
    SimulatorLoad,
    SimulatorMapUpdate,
    SimulatorPresentAtLocation,
    SimulatorReady,
    SimulatorSetMap,
    SimulatorShutdownRequest,
    SimulatorViewerTimeMessage,
    SoundTrigger,
    StartAuction,
    StartGroupProposal,
    StartLure,
    StartPingCheck,
    StateSave,
    SubscribeLoad,
    SystemKickUser,
    SystemMessage,
    TallyVotes,
    TelehubInfo,
    TeleportCancel,
    TeleportFailed,
    TeleportFinish,
    TeleportLandingStatusChanged,
    TeleportLandmarkRequest,
    TeleportLocal,
    TeleportLocationRequest,
    TeleportLureRequest,
    TeleportProgress,
    TeleportRequest,
    TeleportStart,
    TerminateFriendship,
    TestMessage,
    TrackAgent,
    TransferAbort,
    TransferInfo,
    TransferInventory,
    TransferInventoryAck,
    TransferPacket,
    TransferRequest,
    UUIDGroupNameReply,
    UUIDGroupNameRequest,
    UUIDNameReply,
    UUIDNameRequest,
    Undo,
    UndoLand,
    UnsubscribeLoad,
    UpdateAttachment,
    UpdateCreateInventoryItem,
    UpdateGroupInfo,
    UpdateInventoryFolder,
    UpdateInventoryItem,
    UpdateMuteListEntry,
    UpdateParcel,
    UpdateSimulator,
    UpdateTaskInventory,
    UpdateUserInfo,
    UseCachedMuteList,
    UseCircuitCode,
    UserInfoReply,
    UserInfoRequest,
    UserReport,
    UserReportInternal,
    VelocityInterpolateOff,
    VelocityInterpolateOn,
    ViewerEffect,
    ViewerFrozenMessage,
    ViewerStartAuction,
    ViewerStats,
}

#[derive(Clone, Debug)]
pub enum MessageInstance {
    AbortXfer(AbortXfer),
    AcceptCallingCard(AcceptCallingCard),
    AcceptFriendship(AcceptFriendship),
    ActivateGestures(ActivateGestures),
    ActivateGroup(ActivateGroup),
    AddCircuitCode(AddCircuitCode),
    AgentAlertMessage(AgentAlertMessage),
    AgentAnimation(AgentAnimation),
    AgentCachedTexture(AgentCachedTexture),
    AgentCachedTextureResponse(AgentCachedTextureResponse),
    AgentDataUpdate(AgentDataUpdate),
    AgentDataUpdateRequest(AgentDataUpdateRequest),
    AgentDropGroup(AgentDropGroup),
    AgentFOV(AgentFOV),
    AgentGroupDataUpdate(AgentGroupDataUpdate),
    AgentHeightWidth(AgentHeightWidth),
    AgentIsNowWearing(AgentIsNowWearing),
    AgentMovementComplete(AgentMovementComplete),
    AgentPause(AgentPause),
    AgentQuitCopy(AgentQuitCopy),
    AgentRequestSit(AgentRequestSit),
    AgentResume(AgentResume),
    AgentSetAppearance(AgentSetAppearance),
    AgentSit(AgentSit),
    AgentThrottle(AgentThrottle),
    AgentUpdate(AgentUpdate),
    AgentWearablesRequest(AgentWearablesRequest),
    AgentWearablesUpdate(AgentWearablesUpdate),
    AlertMessage(AlertMessage),
    AssetUploadComplete(AssetUploadComplete),
    AssetUploadRequest(AssetUploadRequest),
    AtomicPassObject(AtomicPassObject),
    AttachedSound(AttachedSound),
    AttachedSoundGainChange(AttachedSoundGainChange),
    AvatarAnimation(AvatarAnimation),
    AvatarAppearance(AvatarAppearance),
    AvatarClassifiedReply(AvatarClassifiedReply),
    AvatarGroupsReply(AvatarGroupsReply),
    AvatarInterestsReply(AvatarInterestsReply),
    AvatarInterestsUpdate(AvatarInterestsUpdate),
    AvatarNotesReply(AvatarNotesReply),
    AvatarNotesUpdate(AvatarNotesUpdate),
    AvatarPickerReply(AvatarPickerReply),
    AvatarPickerRequest(AvatarPickerRequest),
    AvatarPickerRequestBackend(AvatarPickerRequestBackend),
    AvatarPicksReply(AvatarPicksReply),
    AvatarPropertiesReply(AvatarPropertiesReply),
    AvatarPropertiesRequest(AvatarPropertiesRequest),
    AvatarPropertiesRequestBackend(AvatarPropertiesRequestBackend),
    AvatarPropertiesUpdate(AvatarPropertiesUpdate),
    AvatarSitResponse(AvatarSitResponse),
    AvatarTextureUpdate(AvatarTextureUpdate),
    BulkUpdateInventory(BulkUpdateInventory),
    BuyObjectInventory(BuyObjectInventory),
    CameraConstraint(CameraConstraint),
    CancelAuction(CancelAuction),
    ChangeInventoryItemFlags(ChangeInventoryItemFlags),
    ChangeUserRights(ChangeUserRights),
    ChatFromSimulator(ChatFromSimulator),
    ChatFromViewer(ChatFromViewer),
    ChatPass(ChatPass),
    CheckParcelAuctions(CheckParcelAuctions),
    CheckParcelSales(CheckParcelSales),
    ChildAgentAlive(ChildAgentAlive),
    ChildAgentDying(ChildAgentDying),
    ChildAgentPositionUpdate(ChildAgentPositionUpdate),
    ChildAgentUnknown(ChildAgentUnknown),
    ChildAgentUpdate(ChildAgentUpdate),
    ClassifiedDelete(ClassifiedDelete),
    ClassifiedGodDelete(ClassifiedGodDelete),
    ClassifiedInfoReply(ClassifiedInfoReply),
    ClassifiedInfoRequest(ClassifiedInfoRequest),
    ClassifiedInfoUpdate(ClassifiedInfoUpdate),
    ClearFollowCamProperties(ClearFollowCamProperties),
    CloseCircuit(CloseCircuit),
    CoarseLocationUpdate(CoarseLocationUpdate),
    CompleteAgentMovement(CompleteAgentMovement),
    CompleteAuction(CompleteAuction),
    CompletePingCheck(CompletePingCheck),
    ConfirmAuctionStart(ConfirmAuctionStart),
    ConfirmEnableSimulator(ConfirmEnableSimulator),
    ConfirmXferPacket(ConfirmXferPacket),
    CopyInventoryFromNotecard(CopyInventoryFromNotecard),
    CopyInventoryItem(CopyInventoryItem),
    CreateGroupReply(CreateGroupReply),
    CreateGroupRequest(CreateGroupRequest),
    CreateInventoryFolder(CreateInventoryFolder),
    CreateInventoryItem(CreateInventoryItem),
    CreateLandmarkForEvent(CreateLandmarkForEvent),
    CreateNewOutfitAttachments(CreateNewOutfitAttachments),
    CreateTrustedCircuit(CreateTrustedCircuit),
    CrossedRegion(CrossedRegion),
    DataHomeLocationReply(DataHomeLocationReply),
    DataHomeLocationRequest(DataHomeLocationRequest),
    DataServerLogout(DataServerLogout),
    DeRezAck(DeRezAck),
    DeRezObject(DeRezObject),
    DeactivateGestures(DeactivateGestures),
    DeclineCallingCard(DeclineCallingCard),
    DeclineFriendship(DeclineFriendship),
    DenyTrustedCircuit(DenyTrustedCircuit),
    DerezContainer(DerezContainer),
    DetachAttachmentIntoInv(DetachAttachmentIntoInv),
    DirClassifiedQuery(DirClassifiedQuery),
    DirClassifiedQueryBackend(DirClassifiedQueryBackend),
    DirClassifiedReply(DirClassifiedReply),
    DirEventsReply(DirEventsReply),
    DirFindQuery(DirFindQuery),
    DirFindQueryBackend(DirFindQueryBackend),
    DirGroupsReply(DirGroupsReply),
    DirLandQuery(DirLandQuery),
    DirLandQueryBackend(DirLandQueryBackend),
    DirLandReply(DirLandReply),
    DirPeopleReply(DirPeopleReply),
    DirPlacesQuery(DirPlacesQuery),
    DirPlacesQueryBackend(DirPlacesQueryBackend),
    DirPlacesReply(DirPlacesReply),
    DirPopularQuery(DirPopularQuery),
    DirPopularQueryBackend(DirPopularQueryBackend),
    DirPopularReply(DirPopularReply),
    DisableSimulator(DisableSimulator),
    EconomyData(EconomyData),
    EconomyDataRequest(EconomyDataRequest),
    EdgeDataPacket(EdgeDataPacket),
    EjectGroupMemberReply(EjectGroupMemberReply),
    EjectGroupMemberRequest(EjectGroupMemberRequest),
    EjectUser(EjectUser),
    EmailMessageReply(EmailMessageReply),
    EmailMessageRequest(EmailMessageRequest),
    EnableSimulator(EnableSimulator),
    Error(Error),
    EstateCovenantReply(EstateCovenantReply),
    EstateCovenantRequest(EstateCovenantRequest),
    EstateOwnerMessage(EstateOwnerMessage),
    EventGodDelete(EventGodDelete),
    EventInfoReply(EventInfoReply),
    EventInfoRequest(EventInfoRequest),
    EventLocationReply(EventLocationReply),
    EventLocationRequest(EventLocationRequest),
    EventNotificationAddRequest(EventNotificationAddRequest),
    EventNotificationRemoveRequest(EventNotificationRemoveRequest),
    FeatureDisabled(FeatureDisabled),
    FetchInventory(FetchInventory),
    FetchInventoryDescendents(FetchInventoryDescendents),
    FetchInventoryReply(FetchInventoryReply),
    FindAgent(FindAgent),
    ForceObjectSelect(ForceObjectSelect),
    ForceScriptControlRelease(ForceScriptControlRelease),
    FormFriendship(FormFriendship),
    FreezeUser(FreezeUser),
    GenericMessage(GenericMessage),
    GetScriptRunning(GetScriptRunning),
    GodKickUser(GodKickUser),
    GodUpdateRegionInfo(GodUpdateRegionInfo),
    GodlikeMessage(GodlikeMessage),
    GrantGodlikePowers(GrantGodlikePowers),
    GrantUserRights(GrantUserRights),
    GroupAccountDetailsReply(GroupAccountDetailsReply),
    GroupAccountDetailsRequest(GroupAccountDetailsRequest),
    GroupAccountSummaryReply(GroupAccountSummaryReply),
    GroupAccountSummaryRequest(GroupAccountSummaryRequest),
    GroupAccountTransactionsReply(GroupAccountTransactionsReply),
    GroupAccountTransactionsRequest(GroupAccountTransactionsRequest),
    GroupActiveProposalItemReply(GroupActiveProposalItemReply),
    GroupActiveProposalsRequest(GroupActiveProposalsRequest),
    GroupDataUpdate(GroupDataUpdate),
    GroupMembersReply(GroupMembersReply),
    GroupMembersRequest(GroupMembersRequest),
    GroupNoticeAdd(GroupNoticeAdd),
    GroupNoticeRequest(GroupNoticeRequest),
    GroupNoticesListReply(GroupNoticesListReply),
    GroupNoticesListRequest(GroupNoticesListRequest),
    GroupProfileReply(GroupProfileReply),
    GroupProfileRequest(GroupProfileRequest),
    GroupProposalBallot(GroupProposalBallot),
    GroupRoleChanges(GroupRoleChanges),
    GroupRoleDataReply(GroupRoleDataReply),
    GroupRoleDataRequest(GroupRoleDataRequest),
    GroupRoleMembersReply(GroupRoleMembersReply),
    GroupRoleMembersRequest(GroupRoleMembersRequest),
    GroupRoleUpdate(GroupRoleUpdate),
    GroupTitleUpdate(GroupTitleUpdate),
    GroupTitlesReply(GroupTitlesReply),
    GroupTitlesRequest(GroupTitlesRequest),
    GroupVoteHistoryItemReply(GroupVoteHistoryItemReply),
    GroupVoteHistoryRequest(GroupVoteHistoryRequest),
    HealthMessage(HealthMessage),
    ImageData(ImageData),
    ImageNotInDatabase(ImageNotInDatabase),
    ImagePacket(ImagePacket),
    ImprovedInstantMessage(ImprovedInstantMessage),
    ImprovedTerseObjectUpdate(ImprovedTerseObjectUpdate),
    InitiateDownload(InitiateDownload),
    InternalScriptMail(InternalScriptMail),
    InventoryAssetResponse(InventoryAssetResponse),
    InventoryDescendents(InventoryDescendents),
    InviteGroupRequest(InviteGroupRequest),
    InviteGroupResponse(InviteGroupResponse),
    JoinGroupReply(JoinGroupReply),
    JoinGroupRequest(JoinGroupRequest),
    KickUser(KickUser),
    KickUserAck(KickUserAck),
    KillChildAgents(KillChildAgents),
    KillObject(KillObject),
    LandStatReply(LandStatReply),
    LandStatRequest(LandStatRequest),
    LayerData(LayerData),
    LeaveGroupReply(LeaveGroupReply),
    LeaveGroupRequest(LeaveGroupRequest),
    LinkInventoryItem(LinkInventoryItem),
    LiveHelpGroupReply(LiveHelpGroupReply),
    LiveHelpGroupRequest(LiveHelpGroupRequest),
    LoadURL(LoadURL),
    LogDwellTime(LogDwellTime),
    LogFailedMoneyTransaction(LogFailedMoneyTransaction),
    LogParcelChanges(LogParcelChanges),
    LogTextMessage(LogTextMessage),
    LogoutReply(LogoutReply),
    LogoutRequest(LogoutRequest),
    MapBlockReply(MapBlockReply),
    MapBlockRequest(MapBlockRequest),
    MapItemReply(MapItemReply),
    MapItemRequest(MapItemRequest),
    MapLayerReply(MapLayerReply),
    MapLayerRequest(MapLayerRequest),
    MapNameRequest(MapNameRequest),
    MeanCollisionAlert(MeanCollisionAlert),
    MergeParcel(MergeParcel),
    ModifyLand(ModifyLand),
    MoneyBalanceReply(MoneyBalanceReply),
    MoneyBalanceRequest(MoneyBalanceRequest),
    MoneyTransferBackend(MoneyTransferBackend),
    MoneyTransferRequest(MoneyTransferRequest),
    MoveInventoryFolder(MoveInventoryFolder),
    MoveInventoryItem(MoveInventoryItem),
    MoveTaskInventory(MoveTaskInventory),
    MultipleObjectUpdate(MultipleObjectUpdate),
    MuteListRequest(MuteListRequest),
    MuteListUpdate(MuteListUpdate),
    NameValuePair(NameValuePair),
    NearestLandingRegionReply(NearestLandingRegionReply),
    NearestLandingRegionRequest(NearestLandingRegionRequest),
    NearestLandingRegionUpdated(NearestLandingRegionUpdated),
    NeighborList(NeighborList),
    NetTest(NetTest),
    ObjectAdd(ObjectAdd),
    ObjectAttach(ObjectAttach),
    ObjectBuy(ObjectBuy),
    ObjectCategory(ObjectCategory),
    ObjectClickAction(ObjectClickAction),
    ObjectDeGrab(ObjectDeGrab),
    ObjectDelete(ObjectDelete),
    ObjectDelink(ObjectDelink),
    ObjectDescription(ObjectDescription),
    ObjectDeselect(ObjectDeselect),
    ObjectDetach(ObjectDetach),
    ObjectDrop(ObjectDrop),
    ObjectDuplicate(ObjectDuplicate),
    ObjectDuplicateOnRay(ObjectDuplicateOnRay),
    ObjectExportSelected(ObjectExportSelected),
    ObjectExtraParams(ObjectExtraParams),
    ObjectFlagUpdate(ObjectFlagUpdate),
    ObjectGrab(ObjectGrab),
    ObjectGrabUpdate(ObjectGrabUpdate),
    ObjectGroup(ObjectGroup),
    ObjectImage(ObjectImage),
    ObjectIncludeInSearch(ObjectIncludeInSearch),
    ObjectLink(ObjectLink),
    ObjectMaterial(ObjectMaterial),
    ObjectName(ObjectName),
    ObjectOwner(ObjectOwner),
    ObjectPermissions(ObjectPermissions),
    ObjectPosition(ObjectPosition),
    ObjectProperties(ObjectProperties),
    ObjectPropertiesFamily(ObjectPropertiesFamily),
    ObjectRotation(ObjectRotation),
    ObjectSaleInfo(ObjectSaleInfo),
    ObjectScale(ObjectScale),
    ObjectSelect(ObjectSelect),
    ObjectShape(ObjectShape),
    ObjectSpinStart(ObjectSpinStart),
    ObjectSpinStop(ObjectSpinStop),
    ObjectSpinUpdate(ObjectSpinUpdate),
    ObjectUpdate(ObjectUpdate),
    ObjectUpdateCached(ObjectUpdateCached),
    ObjectUpdateCompressed(ObjectUpdateCompressed),
    OfferCallingCard(OfferCallingCard),
    OfflineNotification(OfflineNotification),
    OnlineNotification(OnlineNotification),
    OpenCircuit(OpenCircuit),
    PacketAck(PacketAck),
    ParcelAccessListReply(ParcelAccessListReply),
    ParcelAccessListRequest(ParcelAccessListRequest),
    ParcelAccessListUpdate(ParcelAccessListUpdate),
    ParcelAuctions(ParcelAuctions),
    ParcelBuy(ParcelBuy),
    ParcelBuyPass(ParcelBuyPass),
    ParcelClaim(ParcelClaim),
    ParcelDeedToGroup(ParcelDeedToGroup),
    ParcelDisableObjects(ParcelDisableObjects),
    ParcelDivide(ParcelDivide),
    ParcelDwellReply(ParcelDwellReply),
    ParcelDwellRequest(ParcelDwellRequest),
    ParcelGodForceOwner(ParcelGodForceOwner),
    ParcelGodMarkAsContent(ParcelGodMarkAsContent),
    ParcelInfoReply(ParcelInfoReply),
    ParcelInfoRequest(ParcelInfoRequest),
    ParcelJoin(ParcelJoin),
    ParcelMediaCommandMessage(ParcelMediaCommandMessage),
    ParcelMediaUpdate(ParcelMediaUpdate),
    ParcelObjectOwnersReply(ParcelObjectOwnersReply),
    ParcelObjectOwnersRequest(ParcelObjectOwnersRequest),
    ParcelOverlay(ParcelOverlay),
    ParcelProperties(ParcelProperties),
    ParcelPropertiesRequest(ParcelPropertiesRequest),
    ParcelPropertiesRequestByID(ParcelPropertiesRequestByID),
    ParcelPropertiesUpdate(ParcelPropertiesUpdate),
    ParcelReclaim(ParcelReclaim),
    ParcelRelease(ParcelRelease),
    ParcelRename(ParcelRename),
    ParcelReturnObjects(ParcelReturnObjects),
    ParcelSales(ParcelSales),
    ParcelSelectObjects(ParcelSelectObjects),
    ParcelSetOtherCleanTime(ParcelSetOtherCleanTime),
    PayPriceReply(PayPriceReply),
    PickDelete(PickDelete),
    PickGodDelete(PickGodDelete),
    PickInfoReply(PickInfoReply),
    PickInfoUpdate(PickInfoUpdate),
    PlacesQuery(PlacesQuery),
    PlacesReply(PlacesReply),
    PreloadSound(PreloadSound),
    PurgeInventoryDescendents(PurgeInventoryDescendents),
    RebakeAvatarTextures(RebakeAvatarTextures),
    Redo(Redo),
    RegionHandleRequest(RegionHandleRequest),
    RegionHandshake(RegionHandshake),
    RegionHandshakeReply(RegionHandshakeReply),
    RegionIDAndHandleReply(RegionIDAndHandleReply),
    RegionInfo(RegionInfo),
    RegionPresenceRequestByHandle(RegionPresenceRequestByHandle),
    RegionPresenceRequestByRegionID(RegionPresenceRequestByRegionID),
    RegionPresenceResponse(RegionPresenceResponse),
    RemoveAttachment(RemoveAttachment),
    RemoveInventoryFolder(RemoveInventoryFolder),
    RemoveInventoryItem(RemoveInventoryItem),
    RemoveInventoryObjects(RemoveInventoryObjects),
    RemoveMuteListEntry(RemoveMuteListEntry),
    RemoveNameValuePair(RemoveNameValuePair),
    RemoveParcel(RemoveParcel),
    RemoveTaskInventory(RemoveTaskInventory),
    ReplyTaskInventory(ReplyTaskInventory),
    ReportAutosaveCrash(ReportAutosaveCrash),
    RequestGodlikePowers(RequestGodlikePowers),
    RequestImage(RequestImage),
    RequestInventoryAsset(RequestInventoryAsset),
    RequestMultipleObjects(RequestMultipleObjects),
    RequestObjectPropertiesFamily(RequestObjectPropertiesFamily),
    RequestParcelTransfer(RequestParcelTransfer),
    RequestPayPrice(RequestPayPrice),
    RequestRegionInfo(RequestRegionInfo),
    RequestTaskInventory(RequestTaskInventory),
    RequestTrustedCircuit(RequestTrustedCircuit),
    RequestXfer(RequestXfer),
    RetrieveInstantMessages(RetrieveInstantMessages),
    RevokePermissions(RevokePermissions),
    RezMultipleAttachmentsFromInv(RezMultipleAttachmentsFromInv),
    RezObject(RezObject),
    RezObjectFromNotecard(RezObjectFromNotecard),
    RezRestoreToWorld(RezRestoreToWorld),
    RezScript(RezScript),
    RezSingleAttachmentFromInv(RezSingleAttachmentFromInv),
    RoutedMoneyBalanceReply(RoutedMoneyBalanceReply),
    RpcChannelReply(RpcChannelReply),
    RpcChannelRequest(RpcChannelRequest),
    RpcScriptReplyInbound(RpcScriptReplyInbound),
    RpcScriptRequestInbound(RpcScriptRequestInbound),
    RpcScriptRequestInboundForward(RpcScriptRequestInboundForward),
    SaveAssetIntoInventory(SaveAssetIntoInventory),
    ScriptAnswerYes(ScriptAnswerYes),
    ScriptControlChange(ScriptControlChange),
    ScriptDataReply(ScriptDataReply),
    ScriptDataRequest(ScriptDataRequest),
    ScriptDialog(ScriptDialog),
    ScriptDialogReply(ScriptDialogReply),
    ScriptMailRegistration(ScriptMailRegistration),
    ScriptQuestion(ScriptQuestion),
    ScriptReset(ScriptReset),
    ScriptRunningReply(ScriptRunningReply),
    ScriptSensorReply(ScriptSensorReply),
    ScriptSensorRequest(ScriptSensorRequest),
    ScriptTeleportRequest(ScriptTeleportRequest),
    SendPostcard(SendPostcard),
    SendXferPacket(SendXferPacket),
    SetAlwaysRun(SetAlwaysRun),
    SetCPURatio(SetCPURatio),
    SetFollowCamProperties(SetFollowCamProperties),
    SetGroupAcceptNotices(SetGroupAcceptNotices),
    SetGroupContribution(SetGroupContribution),
    SetScriptRunning(SetScriptRunning),
    SetSimPresenceInDatabase(SetSimPresenceInDatabase),
    SetSimStatusInDatabase(SetSimStatusInDatabase),
    SetStartLocation(SetStartLocation),
    SetStartLocationRequest(SetStartLocationRequest),
    SimCrashed(SimCrashed),
    SimStats(SimStats),
    SimStatus(SimStatus),
    SimWideDeletes(SimWideDeletes),
    SimulatorLoad(SimulatorLoad),
    SimulatorMapUpdate(SimulatorMapUpdate),
    SimulatorPresentAtLocation(SimulatorPresentAtLocation),
    SimulatorReady(SimulatorReady),
    SimulatorSetMap(SimulatorSetMap),
    SimulatorShutdownRequest(SimulatorShutdownRequest),
    SimulatorViewerTimeMessage(SimulatorViewerTimeMessage),
    SoundTrigger(SoundTrigger),
    StartAuction(StartAuction),
    StartGroupProposal(StartGroupProposal),
    StartLure(StartLure),
    StartPingCheck(StartPingCheck),
    StateSave(StateSave),
    SubscribeLoad(SubscribeLoad),
    SystemKickUser(SystemKickUser),
    SystemMessage(SystemMessage),
    TallyVotes(TallyVotes),
    TelehubInfo(TelehubInfo),
    TeleportCancel(TeleportCancel),
    TeleportFailed(TeleportFailed),
    TeleportFinish(TeleportFinish),
    TeleportLandingStatusChanged(TeleportLandingStatusChanged),
    TeleportLandmarkRequest(TeleportLandmarkRequest),
    TeleportLocal(TeleportLocal),
    TeleportLocationRequest(TeleportLocationRequest),
    TeleportLureRequest(TeleportLureRequest),
    TeleportProgress(TeleportProgress),
    TeleportRequest(TeleportRequest),
    TeleportStart(TeleportStart),
    TerminateFriendship(TerminateFriendship),
    TestMessage(TestMessage),
    TrackAgent(TrackAgent),
    TransferAbort(TransferAbort),
    TransferInfo(TransferInfo),
    TransferInventory(TransferInventory),
    TransferInventoryAck(TransferInventoryAck),
    TransferPacket(TransferPacket),
    TransferRequest(TransferRequest),
    UUIDGroupNameReply(UUIDGroupNameReply),
    UUIDGroupNameRequest(UUIDGroupNameRequest),
    UUIDNameReply(UUIDNameReply),
    UUIDNameRequest(UUIDNameRequest),
    Undo(Undo),
    UndoLand(UndoLand),
    UnsubscribeLoad(UnsubscribeLoad),
    UpdateAttachment(UpdateAttachment),
    UpdateCreateInventoryItem(UpdateCreateInventoryItem),
    UpdateGroupInfo(UpdateGroupInfo),
    UpdateInventoryFolder(UpdateInventoryFolder),
    UpdateInventoryItem(UpdateInventoryItem),
    UpdateMuteListEntry(UpdateMuteListEntry),
    UpdateParcel(UpdateParcel),
    UpdateSimulator(UpdateSimulator),
    UpdateTaskInventory(UpdateTaskInventory),
    UpdateUserInfo(UpdateUserInfo),
    UseCachedMuteList(UseCachedMuteList),
    UseCircuitCode(UseCircuitCode),
    UserInfoReply(UserInfoReply),
    UserInfoRequest(UserInfoRequest),
    UserReport(UserReport),
    UserReportInternal(UserReportInternal),
    VelocityInterpolateOff(VelocityInterpolateOff),
    VelocityInterpolateOn(VelocityInterpolateOn),
    ViewerEffect(ViewerEffect),
    ViewerFrozenMessage(ViewerFrozenMessage),
    ViewerStartAuction(ViewerStartAuction),
    ViewerStats(ViewerStats),
}

impl MessageInstance {
    pub fn message_type(&self) -> MessageType {
        match *self {
            MessageInstance::AbortXfer(_) => MessageType::AbortXfer,
            MessageInstance::AcceptCallingCard(_) => MessageType::AcceptCallingCard,
            MessageInstance::AcceptFriendship(_) => MessageType::AcceptFriendship,
            MessageInstance::ActivateGestures(_) => MessageType::ActivateGestures,
            MessageInstance::ActivateGroup(_) => MessageType::ActivateGroup,
            MessageInstance::AddCircuitCode(_) => MessageType::AddCircuitCode,
            MessageInstance::AgentAlertMessage(_) => MessageType::AgentAlertMessage,
            MessageInstance::AgentAnimation(_) => MessageType::AgentAnimation,
            MessageInstance::AgentCachedTexture(_) => MessageType::AgentCachedTexture,
            MessageInstance::AgentCachedTextureResponse(_) => {
                MessageType::AgentCachedTextureResponse
            }
            MessageInstance::AgentDataUpdate(_) => MessageType::AgentDataUpdate,
            MessageInstance::AgentDataUpdateRequest(_) => MessageType::AgentDataUpdateRequest,
            MessageInstance::AgentDropGroup(_) => MessageType::AgentDropGroup,
            MessageInstance::AgentFOV(_) => MessageType::AgentFOV,
            MessageInstance::AgentGroupDataUpdate(_) => MessageType::AgentGroupDataUpdate,
            MessageInstance::AgentHeightWidth(_) => MessageType::AgentHeightWidth,
            MessageInstance::AgentIsNowWearing(_) => MessageType::AgentIsNowWearing,
            MessageInstance::AgentMovementComplete(_) => MessageType::AgentMovementComplete,
            MessageInstance::AgentPause(_) => MessageType::AgentPause,
            MessageInstance::AgentQuitCopy(_) => MessageType::AgentQuitCopy,
            MessageInstance::AgentRequestSit(_) => MessageType::AgentRequestSit,
            MessageInstance::AgentResume(_) => MessageType::AgentResume,
            MessageInstance::AgentSetAppearance(_) => MessageType::AgentSetAppearance,
            MessageInstance::AgentSit(_) => MessageType::AgentSit,
            MessageInstance::AgentThrottle(_) => MessageType::AgentThrottle,
            MessageInstance::AgentUpdate(_) => MessageType::AgentUpdate,
            MessageInstance::AgentWearablesRequest(_) => MessageType::AgentWearablesRequest,
            MessageInstance::AgentWearablesUpdate(_) => MessageType::AgentWearablesUpdate,
            MessageInstance::AlertMessage(_) => MessageType::AlertMessage,
            MessageInstance::AssetUploadComplete(_) => MessageType::AssetUploadComplete,
            MessageInstance::AssetUploadRequest(_) => MessageType::AssetUploadRequest,
            MessageInstance::AtomicPassObject(_) => MessageType::AtomicPassObject,
            MessageInstance::AttachedSound(_) => MessageType::AttachedSound,
            MessageInstance::AttachedSoundGainChange(_) => MessageType::AttachedSoundGainChange,
            MessageInstance::AvatarAnimation(_) => MessageType::AvatarAnimation,
            MessageInstance::AvatarAppearance(_) => MessageType::AvatarAppearance,
            MessageInstance::AvatarClassifiedReply(_) => MessageType::AvatarClassifiedReply,
            MessageInstance::AvatarGroupsReply(_) => MessageType::AvatarGroupsReply,
            MessageInstance::AvatarInterestsReply(_) => MessageType::AvatarInterestsReply,
            MessageInstance::AvatarInterestsUpdate(_) => MessageType::AvatarInterestsUpdate,
            MessageInstance::AvatarNotesReply(_) => MessageType::AvatarNotesReply,
            MessageInstance::AvatarNotesUpdate(_) => MessageType::AvatarNotesUpdate,
            MessageInstance::AvatarPickerReply(_) => MessageType::AvatarPickerReply,
            MessageInstance::AvatarPickerRequest(_) => MessageType::AvatarPickerRequest,
            MessageInstance::AvatarPickerRequestBackend(_) => {
                MessageType::AvatarPickerRequestBackend
            }
            MessageInstance::AvatarPicksReply(_) => MessageType::AvatarPicksReply,
            MessageInstance::AvatarPropertiesReply(_) => MessageType::AvatarPropertiesReply,
            MessageInstance::AvatarPropertiesRequest(_) => MessageType::AvatarPropertiesRequest,
            MessageInstance::AvatarPropertiesRequestBackend(_) => {
                MessageType::AvatarPropertiesRequestBackend
            }
            MessageInstance::AvatarPropertiesUpdate(_) => MessageType::AvatarPropertiesUpdate,
            MessageInstance::AvatarSitResponse(_) => MessageType::AvatarSitResponse,
            MessageInstance::AvatarTextureUpdate(_) => MessageType::AvatarTextureUpdate,
            MessageInstance::BulkUpdateInventory(_) => MessageType::BulkUpdateInventory,
            MessageInstance::BuyObjectInventory(_) => MessageType::BuyObjectInventory,
            MessageInstance::CameraConstraint(_) => MessageType::CameraConstraint,
            MessageInstance::CancelAuction(_) => MessageType::CancelAuction,
            MessageInstance::ChangeInventoryItemFlags(_) => MessageType::ChangeInventoryItemFlags,
            MessageInstance::ChangeUserRights(_) => MessageType::ChangeUserRights,
            MessageInstance::ChatFromSimulator(_) => MessageType::ChatFromSimulator,
            MessageInstance::ChatFromViewer(_) => MessageType::ChatFromViewer,
            MessageInstance::ChatPass(_) => MessageType::ChatPass,
            MessageInstance::CheckParcelAuctions(_) => MessageType::CheckParcelAuctions,
            MessageInstance::CheckParcelSales(_) => MessageType::CheckParcelSales,
            MessageInstance::ChildAgentAlive(_) => MessageType::ChildAgentAlive,
            MessageInstance::ChildAgentDying(_) => MessageType::ChildAgentDying,
            MessageInstance::ChildAgentPositionUpdate(_) => MessageType::ChildAgentPositionUpdate,
            MessageInstance::ChildAgentUnknown(_) => MessageType::ChildAgentUnknown,
            MessageInstance::ChildAgentUpdate(_) => MessageType::ChildAgentUpdate,
            MessageInstance::ClassifiedDelete(_) => MessageType::ClassifiedDelete,
            MessageInstance::ClassifiedGodDelete(_) => MessageType::ClassifiedGodDelete,
            MessageInstance::ClassifiedInfoReply(_) => MessageType::ClassifiedInfoReply,
            MessageInstance::ClassifiedInfoRequest(_) => MessageType::ClassifiedInfoRequest,
            MessageInstance::ClassifiedInfoUpdate(_) => MessageType::ClassifiedInfoUpdate,
            MessageInstance::ClearFollowCamProperties(_) => MessageType::ClearFollowCamProperties,
            MessageInstance::CloseCircuit(_) => MessageType::CloseCircuit,
            MessageInstance::CoarseLocationUpdate(_) => MessageType::CoarseLocationUpdate,
            MessageInstance::CompleteAgentMovement(_) => MessageType::CompleteAgentMovement,
            MessageInstance::CompleteAuction(_) => MessageType::CompleteAuction,
            MessageInstance::CompletePingCheck(_) => MessageType::CompletePingCheck,
            MessageInstance::ConfirmAuctionStart(_) => MessageType::ConfirmAuctionStart,
            MessageInstance::ConfirmEnableSimulator(_) => MessageType::ConfirmEnableSimulator,
            MessageInstance::ConfirmXferPacket(_) => MessageType::ConfirmXferPacket,
            MessageInstance::CopyInventoryFromNotecard(_) => MessageType::CopyInventoryFromNotecard,
            MessageInstance::CopyInventoryItem(_) => MessageType::CopyInventoryItem,
            MessageInstance::CreateGroupReply(_) => MessageType::CreateGroupReply,
            MessageInstance::CreateGroupRequest(_) => MessageType::CreateGroupRequest,
            MessageInstance::CreateInventoryFolder(_) => MessageType::CreateInventoryFolder,
            MessageInstance::CreateInventoryItem(_) => MessageType::CreateInventoryItem,
            MessageInstance::CreateLandmarkForEvent(_) => MessageType::CreateLandmarkForEvent,
            MessageInstance::CreateNewOutfitAttachments(_) => {
                MessageType::CreateNewOutfitAttachments
            }
            MessageInstance::CreateTrustedCircuit(_) => MessageType::CreateTrustedCircuit,
            MessageInstance::CrossedRegion(_) => MessageType::CrossedRegion,
            MessageInstance::DataHomeLocationReply(_) => MessageType::DataHomeLocationReply,
            MessageInstance::DataHomeLocationRequest(_) => MessageType::DataHomeLocationRequest,
            MessageInstance::DataServerLogout(_) => MessageType::DataServerLogout,
            MessageInstance::DeRezAck(_) => MessageType::DeRezAck,
            MessageInstance::DeRezObject(_) => MessageType::DeRezObject,
            MessageInstance::DeactivateGestures(_) => MessageType::DeactivateGestures,
            MessageInstance::DeclineCallingCard(_) => MessageType::DeclineCallingCard,
            MessageInstance::DeclineFriendship(_) => MessageType::DeclineFriendship,
            MessageInstance::DenyTrustedCircuit(_) => MessageType::DenyTrustedCircuit,
            MessageInstance::DerezContainer(_) => MessageType::DerezContainer,
            MessageInstance::DetachAttachmentIntoInv(_) => MessageType::DetachAttachmentIntoInv,
            MessageInstance::DirClassifiedQuery(_) => MessageType::DirClassifiedQuery,
            MessageInstance::DirClassifiedQueryBackend(_) => MessageType::DirClassifiedQueryBackend,
            MessageInstance::DirClassifiedReply(_) => MessageType::DirClassifiedReply,
            MessageInstance::DirEventsReply(_) => MessageType::DirEventsReply,
            MessageInstance::DirFindQuery(_) => MessageType::DirFindQuery,
            MessageInstance::DirFindQueryBackend(_) => MessageType::DirFindQueryBackend,
            MessageInstance::DirGroupsReply(_) => MessageType::DirGroupsReply,
            MessageInstance::DirLandQuery(_) => MessageType::DirLandQuery,
            MessageInstance::DirLandQueryBackend(_) => MessageType::DirLandQueryBackend,
            MessageInstance::DirLandReply(_) => MessageType::DirLandReply,
            MessageInstance::DirPeopleReply(_) => MessageType::DirPeopleReply,
            MessageInstance::DirPlacesQuery(_) => MessageType::DirPlacesQuery,
            MessageInstance::DirPlacesQueryBackend(_) => MessageType::DirPlacesQueryBackend,
            MessageInstance::DirPlacesReply(_) => MessageType::DirPlacesReply,
            MessageInstance::DirPopularQuery(_) => MessageType::DirPopularQuery,
            MessageInstance::DirPopularQueryBackend(_) => MessageType::DirPopularQueryBackend,
            MessageInstance::DirPopularReply(_) => MessageType::DirPopularReply,
            MessageInstance::DisableSimulator(_) => MessageType::DisableSimulator,
            MessageInstance::EconomyData(_) => MessageType::EconomyData,
            MessageInstance::EconomyDataRequest(_) => MessageType::EconomyDataRequest,
            MessageInstance::EdgeDataPacket(_) => MessageType::EdgeDataPacket,
            MessageInstance::EjectGroupMemberReply(_) => MessageType::EjectGroupMemberReply,
            MessageInstance::EjectGroupMemberRequest(_) => MessageType::EjectGroupMemberRequest,
            MessageInstance::EjectUser(_) => MessageType::EjectUser,
            MessageInstance::EmailMessageReply(_) => MessageType::EmailMessageReply,
            MessageInstance::EmailMessageRequest(_) => MessageType::EmailMessageRequest,
            MessageInstance::EnableSimulator(_) => MessageType::EnableSimulator,
            MessageInstance::Error(_) => MessageType::Error,
            MessageInstance::EstateCovenantReply(_) => MessageType::EstateCovenantReply,
            MessageInstance::EstateCovenantRequest(_) => MessageType::EstateCovenantRequest,
            MessageInstance::EstateOwnerMessage(_) => MessageType::EstateOwnerMessage,
            MessageInstance::EventGodDelete(_) => MessageType::EventGodDelete,
            MessageInstance::EventInfoReply(_) => MessageType::EventInfoReply,
            MessageInstance::EventInfoRequest(_) => MessageType::EventInfoRequest,
            MessageInstance::EventLocationReply(_) => MessageType::EventLocationReply,
            MessageInstance::EventLocationRequest(_) => MessageType::EventLocationRequest,
            MessageInstance::EventNotificationAddRequest(_) => {
                MessageType::EventNotificationAddRequest
            }
            MessageInstance::EventNotificationRemoveRequest(_) => {
                MessageType::EventNotificationRemoveRequest
            }
            MessageInstance::FeatureDisabled(_) => MessageType::FeatureDisabled,
            MessageInstance::FetchInventory(_) => MessageType::FetchInventory,
            MessageInstance::FetchInventoryDescendents(_) => MessageType::FetchInventoryDescendents,
            MessageInstance::FetchInventoryReply(_) => MessageType::FetchInventoryReply,
            MessageInstance::FindAgent(_) => MessageType::FindAgent,
            MessageInstance::ForceObjectSelect(_) => MessageType::ForceObjectSelect,
            MessageInstance::ForceScriptControlRelease(_) => MessageType::ForceScriptControlRelease,
            MessageInstance::FormFriendship(_) => MessageType::FormFriendship,
            MessageInstance::FreezeUser(_) => MessageType::FreezeUser,
            MessageInstance::GenericMessage(_) => MessageType::GenericMessage,
            MessageInstance::GetScriptRunning(_) => MessageType::GetScriptRunning,
            MessageInstance::GodKickUser(_) => MessageType::GodKickUser,
            MessageInstance::GodUpdateRegionInfo(_) => MessageType::GodUpdateRegionInfo,
            MessageInstance::GodlikeMessage(_) => MessageType::GodlikeMessage,
            MessageInstance::GrantGodlikePowers(_) => MessageType::GrantGodlikePowers,
            MessageInstance::GrantUserRights(_) => MessageType::GrantUserRights,
            MessageInstance::GroupAccountDetailsReply(_) => MessageType::GroupAccountDetailsReply,
            MessageInstance::GroupAccountDetailsRequest(_) => {
                MessageType::GroupAccountDetailsRequest
            }
            MessageInstance::GroupAccountSummaryReply(_) => MessageType::GroupAccountSummaryReply,
            MessageInstance::GroupAccountSummaryRequest(_) => {
                MessageType::GroupAccountSummaryRequest
            }
            MessageInstance::GroupAccountTransactionsReply(_) => {
                MessageType::GroupAccountTransactionsReply
            }
            MessageInstance::GroupAccountTransactionsRequest(_) => {
                MessageType::GroupAccountTransactionsRequest
            }
            MessageInstance::GroupActiveProposalItemReply(_) => {
                MessageType::GroupActiveProposalItemReply
            }
            MessageInstance::GroupActiveProposalsRequest(_) => {
                MessageType::GroupActiveProposalsRequest
            }
            MessageInstance::GroupDataUpdate(_) => MessageType::GroupDataUpdate,
            MessageInstance::GroupMembersReply(_) => MessageType::GroupMembersReply,
            MessageInstance::GroupMembersRequest(_) => MessageType::GroupMembersRequest,
            MessageInstance::GroupNoticeAdd(_) => MessageType::GroupNoticeAdd,
            MessageInstance::GroupNoticeRequest(_) => MessageType::GroupNoticeRequest,
            MessageInstance::GroupNoticesListReply(_) => MessageType::GroupNoticesListReply,
            MessageInstance::GroupNoticesListRequest(_) => MessageType::GroupNoticesListRequest,
            MessageInstance::GroupProfileReply(_) => MessageType::GroupProfileReply,
            MessageInstance::GroupProfileRequest(_) => MessageType::GroupProfileRequest,
            MessageInstance::GroupProposalBallot(_) => MessageType::GroupProposalBallot,
            MessageInstance::GroupRoleChanges(_) => MessageType::GroupRoleChanges,
            MessageInstance::GroupRoleDataReply(_) => MessageType::GroupRoleDataReply,
            MessageInstance::GroupRoleDataRequest(_) => MessageType::GroupRoleDataRequest,
            MessageInstance::GroupRoleMembersReply(_) => MessageType::GroupRoleMembersReply,
            MessageInstance::GroupRoleMembersRequest(_) => MessageType::GroupRoleMembersRequest,
            MessageInstance::GroupRoleUpdate(_) => MessageType::GroupRoleUpdate,
            MessageInstance::GroupTitleUpdate(_) => MessageType::GroupTitleUpdate,
            MessageInstance::GroupTitlesReply(_) => MessageType::GroupTitlesReply,
            MessageInstance::GroupTitlesRequest(_) => MessageType::GroupTitlesRequest,
            MessageInstance::GroupVoteHistoryItemReply(_) => MessageType::GroupVoteHistoryItemReply,
            MessageInstance::GroupVoteHistoryRequest(_) => MessageType::GroupVoteHistoryRequest,
            MessageInstance::HealthMessage(_) => MessageType::HealthMessage,
            MessageInstance::ImageData(_) => MessageType::ImageData,
            MessageInstance::ImageNotInDatabase(_) => MessageType::ImageNotInDatabase,
            MessageInstance::ImagePacket(_) => MessageType::ImagePacket,
            MessageInstance::ImprovedInstantMessage(_) => MessageType::ImprovedInstantMessage,
            MessageInstance::ImprovedTerseObjectUpdate(_) => MessageType::ImprovedTerseObjectUpdate,
            MessageInstance::InitiateDownload(_) => MessageType::InitiateDownload,
            MessageInstance::InternalScriptMail(_) => MessageType::InternalScriptMail,
            MessageInstance::InventoryAssetResponse(_) => MessageType::InventoryAssetResponse,
            MessageInstance::InventoryDescendents(_) => MessageType::InventoryDescendents,
            MessageInstance::InviteGroupRequest(_) => MessageType::InviteGroupRequest,
            MessageInstance::InviteGroupResponse(_) => MessageType::InviteGroupResponse,
            MessageInstance::JoinGroupReply(_) => MessageType::JoinGroupReply,
            MessageInstance::JoinGroupRequest(_) => MessageType::JoinGroupRequest,
            MessageInstance::KickUser(_) => MessageType::KickUser,
            MessageInstance::KickUserAck(_) => MessageType::KickUserAck,
            MessageInstance::KillChildAgents(_) => MessageType::KillChildAgents,
            MessageInstance::KillObject(_) => MessageType::KillObject,
            MessageInstance::LandStatReply(_) => MessageType::LandStatReply,
            MessageInstance::LandStatRequest(_) => MessageType::LandStatRequest,
            MessageInstance::LayerData(_) => MessageType::LayerData,
            MessageInstance::LeaveGroupReply(_) => MessageType::LeaveGroupReply,
            MessageInstance::LeaveGroupRequest(_) => MessageType::LeaveGroupRequest,
            MessageInstance::LinkInventoryItem(_) => MessageType::LinkInventoryItem,
            MessageInstance::LiveHelpGroupReply(_) => MessageType::LiveHelpGroupReply,
            MessageInstance::LiveHelpGroupRequest(_) => MessageType::LiveHelpGroupRequest,
            MessageInstance::LoadURL(_) => MessageType::LoadURL,
            MessageInstance::LogDwellTime(_) => MessageType::LogDwellTime,
            MessageInstance::LogFailedMoneyTransaction(_) => MessageType::LogFailedMoneyTransaction,
            MessageInstance::LogParcelChanges(_) => MessageType::LogParcelChanges,
            MessageInstance::LogTextMessage(_) => MessageType::LogTextMessage,
            MessageInstance::LogoutReply(_) => MessageType::LogoutReply,
            MessageInstance::LogoutRequest(_) => MessageType::LogoutRequest,
            MessageInstance::MapBlockReply(_) => MessageType::MapBlockReply,
            MessageInstance::MapBlockRequest(_) => MessageType::MapBlockRequest,
            MessageInstance::MapItemReply(_) => MessageType::MapItemReply,
            MessageInstance::MapItemRequest(_) => MessageType::MapItemRequest,
            MessageInstance::MapLayerReply(_) => MessageType::MapLayerReply,
            MessageInstance::MapLayerRequest(_) => MessageType::MapLayerRequest,
            MessageInstance::MapNameRequest(_) => MessageType::MapNameRequest,
            MessageInstance::MeanCollisionAlert(_) => MessageType::MeanCollisionAlert,
            MessageInstance::MergeParcel(_) => MessageType::MergeParcel,
            MessageInstance::ModifyLand(_) => MessageType::ModifyLand,
            MessageInstance::MoneyBalanceReply(_) => MessageType::MoneyBalanceReply,
            MessageInstance::MoneyBalanceRequest(_) => MessageType::MoneyBalanceRequest,
            MessageInstance::MoneyTransferBackend(_) => MessageType::MoneyTransferBackend,
            MessageInstance::MoneyTransferRequest(_) => MessageType::MoneyTransferRequest,
            MessageInstance::MoveInventoryFolder(_) => MessageType::MoveInventoryFolder,
            MessageInstance::MoveInventoryItem(_) => MessageType::MoveInventoryItem,
            MessageInstance::MoveTaskInventory(_) => MessageType::MoveTaskInventory,
            MessageInstance::MultipleObjectUpdate(_) => MessageType::MultipleObjectUpdate,
            MessageInstance::MuteListRequest(_) => MessageType::MuteListRequest,
            MessageInstance::MuteListUpdate(_) => MessageType::MuteListUpdate,
            MessageInstance::NameValuePair(_) => MessageType::NameValuePair,
            MessageInstance::NearestLandingRegionReply(_) => MessageType::NearestLandingRegionReply,
            MessageInstance::NearestLandingRegionRequest(_) => {
                MessageType::NearestLandingRegionRequest
            }
            MessageInstance::NearestLandingRegionUpdated(_) => {
                MessageType::NearestLandingRegionUpdated
            }
            MessageInstance::NeighborList(_) => MessageType::NeighborList,
            MessageInstance::NetTest(_) => MessageType::NetTest,
            MessageInstance::ObjectAdd(_) => MessageType::ObjectAdd,
            MessageInstance::ObjectAttach(_) => MessageType::ObjectAttach,
            MessageInstance::ObjectBuy(_) => MessageType::ObjectBuy,
            MessageInstance::ObjectCategory(_) => MessageType::ObjectCategory,
            MessageInstance::ObjectClickAction(_) => MessageType::ObjectClickAction,
            MessageInstance::ObjectDeGrab(_) => MessageType::ObjectDeGrab,
            MessageInstance::ObjectDelete(_) => MessageType::ObjectDelete,
            MessageInstance::ObjectDelink(_) => MessageType::ObjectDelink,
            MessageInstance::ObjectDescription(_) => MessageType::ObjectDescription,
            MessageInstance::ObjectDeselect(_) => MessageType::ObjectDeselect,
            MessageInstance::ObjectDetach(_) => MessageType::ObjectDetach,
            MessageInstance::ObjectDrop(_) => MessageType::ObjectDrop,
            MessageInstance::ObjectDuplicate(_) => MessageType::ObjectDuplicate,
            MessageInstance::ObjectDuplicateOnRay(_) => MessageType::ObjectDuplicateOnRay,
            MessageInstance::ObjectExportSelected(_) => MessageType::ObjectExportSelected,
            MessageInstance::ObjectExtraParams(_) => MessageType::ObjectExtraParams,
            MessageInstance::ObjectFlagUpdate(_) => MessageType::ObjectFlagUpdate,
            MessageInstance::ObjectGrab(_) => MessageType::ObjectGrab,
            MessageInstance::ObjectGrabUpdate(_) => MessageType::ObjectGrabUpdate,
            MessageInstance::ObjectGroup(_) => MessageType::ObjectGroup,
            MessageInstance::ObjectImage(_) => MessageType::ObjectImage,
            MessageInstance::ObjectIncludeInSearch(_) => MessageType::ObjectIncludeInSearch,
            MessageInstance::ObjectLink(_) => MessageType::ObjectLink,
            MessageInstance::ObjectMaterial(_) => MessageType::ObjectMaterial,
            MessageInstance::ObjectName(_) => MessageType::ObjectName,
            MessageInstance::ObjectOwner(_) => MessageType::ObjectOwner,
            MessageInstance::ObjectPermissions(_) => MessageType::ObjectPermissions,
            MessageInstance::ObjectPosition(_) => MessageType::ObjectPosition,
            MessageInstance::ObjectProperties(_) => MessageType::ObjectProperties,
            MessageInstance::ObjectPropertiesFamily(_) => MessageType::ObjectPropertiesFamily,
            MessageInstance::ObjectRotation(_) => MessageType::ObjectRotation,
            MessageInstance::ObjectSaleInfo(_) => MessageType::ObjectSaleInfo,
            MessageInstance::ObjectScale(_) => MessageType::ObjectScale,
            MessageInstance::ObjectSelect(_) => MessageType::ObjectSelect,
            MessageInstance::ObjectShape(_) => MessageType::ObjectShape,
            MessageInstance::ObjectSpinStart(_) => MessageType::ObjectSpinStart,
            MessageInstance::ObjectSpinStop(_) => MessageType::ObjectSpinStop,
            MessageInstance::ObjectSpinUpdate(_) => MessageType::ObjectSpinUpdate,
            MessageInstance::ObjectUpdate(_) => MessageType::ObjectUpdate,
            MessageInstance::ObjectUpdateCached(_) => MessageType::ObjectUpdateCached,
            MessageInstance::ObjectUpdateCompressed(_) => MessageType::ObjectUpdateCompressed,
            MessageInstance::OfferCallingCard(_) => MessageType::OfferCallingCard,
            MessageInstance::OfflineNotification(_) => MessageType::OfflineNotification,
            MessageInstance::OnlineNotification(_) => MessageType::OnlineNotification,
            MessageInstance::OpenCircuit(_) => MessageType::OpenCircuit,
            MessageInstance::PacketAck(_) => MessageType::PacketAck,
            MessageInstance::ParcelAccessListReply(_) => MessageType::ParcelAccessListReply,
            MessageInstance::ParcelAccessListRequest(_) => MessageType::ParcelAccessListRequest,
            MessageInstance::ParcelAccessListUpdate(_) => MessageType::ParcelAccessListUpdate,
            MessageInstance::ParcelAuctions(_) => MessageType::ParcelAuctions,
            MessageInstance::ParcelBuy(_) => MessageType::ParcelBuy,
            MessageInstance::ParcelBuyPass(_) => MessageType::ParcelBuyPass,
            MessageInstance::ParcelClaim(_) => MessageType::ParcelClaim,
            MessageInstance::ParcelDeedToGroup(_) => MessageType::ParcelDeedToGroup,
            MessageInstance::ParcelDisableObjects(_) => MessageType::ParcelDisableObjects,
            MessageInstance::ParcelDivide(_) => MessageType::ParcelDivide,
            MessageInstance::ParcelDwellReply(_) => MessageType::ParcelDwellReply,
            MessageInstance::ParcelDwellRequest(_) => MessageType::ParcelDwellRequest,
            MessageInstance::ParcelGodForceOwner(_) => MessageType::ParcelGodForceOwner,
            MessageInstance::ParcelGodMarkAsContent(_) => MessageType::ParcelGodMarkAsContent,
            MessageInstance::ParcelInfoReply(_) => MessageType::ParcelInfoReply,
            MessageInstance::ParcelInfoRequest(_) => MessageType::ParcelInfoRequest,
            MessageInstance::ParcelJoin(_) => MessageType::ParcelJoin,
            MessageInstance::ParcelMediaCommandMessage(_) => MessageType::ParcelMediaCommandMessage,
            MessageInstance::ParcelMediaUpdate(_) => MessageType::ParcelMediaUpdate,
            MessageInstance::ParcelObjectOwnersReply(_) => MessageType::ParcelObjectOwnersReply,
            MessageInstance::ParcelObjectOwnersRequest(_) => MessageType::ParcelObjectOwnersRequest,
            MessageInstance::ParcelOverlay(_) => MessageType::ParcelOverlay,
            MessageInstance::ParcelProperties(_) => MessageType::ParcelProperties,
            MessageInstance::ParcelPropertiesRequest(_) => MessageType::ParcelPropertiesRequest,
            MessageInstance::ParcelPropertiesRequestByID(_) => {
                MessageType::ParcelPropertiesRequestByID
            }
            MessageInstance::ParcelPropertiesUpdate(_) => MessageType::ParcelPropertiesUpdate,
            MessageInstance::ParcelReclaim(_) => MessageType::ParcelReclaim,
            MessageInstance::ParcelRelease(_) => MessageType::ParcelRelease,
            MessageInstance::ParcelRename(_) => MessageType::ParcelRename,
            MessageInstance::ParcelReturnObjects(_) => MessageType::ParcelReturnObjects,
            MessageInstance::ParcelSales(_) => MessageType::ParcelSales,
            MessageInstance::ParcelSelectObjects(_) => MessageType::ParcelSelectObjects,
            MessageInstance::ParcelSetOtherCleanTime(_) => MessageType::ParcelSetOtherCleanTime,
            MessageInstance::PayPriceReply(_) => MessageType::PayPriceReply,
            MessageInstance::PickDelete(_) => MessageType::PickDelete,
            MessageInstance::PickGodDelete(_) => MessageType::PickGodDelete,
            MessageInstance::PickInfoReply(_) => MessageType::PickInfoReply,
            MessageInstance::PickInfoUpdate(_) => MessageType::PickInfoUpdate,
            MessageInstance::PlacesQuery(_) => MessageType::PlacesQuery,
            MessageInstance::PlacesReply(_) => MessageType::PlacesReply,
            MessageInstance::PreloadSound(_) => MessageType::PreloadSound,
            MessageInstance::PurgeInventoryDescendents(_) => MessageType::PurgeInventoryDescendents,
            MessageInstance::RebakeAvatarTextures(_) => MessageType::RebakeAvatarTextures,
            MessageInstance::Redo(_) => MessageType::Redo,
            MessageInstance::RegionHandleRequest(_) => MessageType::RegionHandleRequest,
            MessageInstance::RegionHandshake(_) => MessageType::RegionHandshake,
            MessageInstance::RegionHandshakeReply(_) => MessageType::RegionHandshakeReply,
            MessageInstance::RegionIDAndHandleReply(_) => MessageType::RegionIDAndHandleReply,
            MessageInstance::RegionInfo(_) => MessageType::RegionInfo,
            MessageInstance::RegionPresenceRequestByHandle(_) => {
                MessageType::RegionPresenceRequestByHandle
            }
            MessageInstance::RegionPresenceRequestByRegionID(_) => {
                MessageType::RegionPresenceRequestByRegionID
            }
            MessageInstance::RegionPresenceResponse(_) => MessageType::RegionPresenceResponse,
            MessageInstance::RemoveAttachment(_) => MessageType::RemoveAttachment,
            MessageInstance::RemoveInventoryFolder(_) => MessageType::RemoveInventoryFolder,
            MessageInstance::RemoveInventoryItem(_) => MessageType::RemoveInventoryItem,
            MessageInstance::RemoveInventoryObjects(_) => MessageType::RemoveInventoryObjects,
            MessageInstance::RemoveMuteListEntry(_) => MessageType::RemoveMuteListEntry,
            MessageInstance::RemoveNameValuePair(_) => MessageType::RemoveNameValuePair,
            MessageInstance::RemoveParcel(_) => MessageType::RemoveParcel,
            MessageInstance::RemoveTaskInventory(_) => MessageType::RemoveTaskInventory,
            MessageInstance::ReplyTaskInventory(_) => MessageType::ReplyTaskInventory,
            MessageInstance::ReportAutosaveCrash(_) => MessageType::ReportAutosaveCrash,
            MessageInstance::RequestGodlikePowers(_) => MessageType::RequestGodlikePowers,
            MessageInstance::RequestImage(_) => MessageType::RequestImage,
            MessageInstance::RequestInventoryAsset(_) => MessageType::RequestInventoryAsset,
            MessageInstance::RequestMultipleObjects(_) => MessageType::RequestMultipleObjects,
            MessageInstance::RequestObjectPropertiesFamily(_) => {
                MessageType::RequestObjectPropertiesFamily
            }
            MessageInstance::RequestParcelTransfer(_) => MessageType::RequestParcelTransfer,
            MessageInstance::RequestPayPrice(_) => MessageType::RequestPayPrice,
            MessageInstance::RequestRegionInfo(_) => MessageType::RequestRegionInfo,
            MessageInstance::RequestTaskInventory(_) => MessageType::RequestTaskInventory,
            MessageInstance::RequestTrustedCircuit(_) => MessageType::RequestTrustedCircuit,
            MessageInstance::RequestXfer(_) => MessageType::RequestXfer,
            MessageInstance::RetrieveInstantMessages(_) => MessageType::RetrieveInstantMessages,
            MessageInstance::RevokePermissions(_) => MessageType::RevokePermissions,
            MessageInstance::RezMultipleAttachmentsFromInv(_) => {
                MessageType::RezMultipleAttachmentsFromInv
            }
            MessageInstance::RezObject(_) => MessageType::RezObject,
            MessageInstance::RezObjectFromNotecard(_) => MessageType::RezObjectFromNotecard,
            MessageInstance::RezRestoreToWorld(_) => MessageType::RezRestoreToWorld,
            MessageInstance::RezScript(_) => MessageType::RezScript,
            MessageInstance::RezSingleAttachmentFromInv(_) => {
                MessageType::RezSingleAttachmentFromInv
            }
            MessageInstance::RoutedMoneyBalanceReply(_) => MessageType::RoutedMoneyBalanceReply,
            MessageInstance::RpcChannelReply(_) => MessageType::RpcChannelReply,
            MessageInstance::RpcChannelRequest(_) => MessageType::RpcChannelRequest,
            MessageInstance::RpcScriptReplyInbound(_) => MessageType::RpcScriptReplyInbound,
            MessageInstance::RpcScriptRequestInbound(_) => MessageType::RpcScriptRequestInbound,
            MessageInstance::RpcScriptRequestInboundForward(_) => {
                MessageType::RpcScriptRequestInboundForward
            }
            MessageInstance::SaveAssetIntoInventory(_) => MessageType::SaveAssetIntoInventory,
            MessageInstance::ScriptAnswerYes(_) => MessageType::ScriptAnswerYes,
            MessageInstance::ScriptControlChange(_) => MessageType::ScriptControlChange,
            MessageInstance::ScriptDataReply(_) => MessageType::ScriptDataReply,
            MessageInstance::ScriptDataRequest(_) => MessageType::ScriptDataRequest,
            MessageInstance::ScriptDialog(_) => MessageType::ScriptDialog,
            MessageInstance::ScriptDialogReply(_) => MessageType::ScriptDialogReply,
            MessageInstance::ScriptMailRegistration(_) => MessageType::ScriptMailRegistration,
            MessageInstance::ScriptQuestion(_) => MessageType::ScriptQuestion,
            MessageInstance::ScriptReset(_) => MessageType::ScriptReset,
            MessageInstance::ScriptRunningReply(_) => MessageType::ScriptRunningReply,
            MessageInstance::ScriptSensorReply(_) => MessageType::ScriptSensorReply,
            MessageInstance::ScriptSensorRequest(_) => MessageType::ScriptSensorRequest,
            MessageInstance::ScriptTeleportRequest(_) => MessageType::ScriptTeleportRequest,
            MessageInstance::SendPostcard(_) => MessageType::SendPostcard,
            MessageInstance::SendXferPacket(_) => MessageType::SendXferPacket,
            MessageInstance::SetAlwaysRun(_) => MessageType::SetAlwaysRun,
            MessageInstance::SetCPURatio(_) => MessageType::SetCPURatio,
            MessageInstance::SetFollowCamProperties(_) => MessageType::SetFollowCamProperties,
            MessageInstance::SetGroupAcceptNotices(_) => MessageType::SetGroupAcceptNotices,
            MessageInstance::SetGroupContribution(_) => MessageType::SetGroupContribution,
            MessageInstance::SetScriptRunning(_) => MessageType::SetScriptRunning,
            MessageInstance::SetSimPresenceInDatabase(_) => MessageType::SetSimPresenceInDatabase,
            MessageInstance::SetSimStatusInDatabase(_) => MessageType::SetSimStatusInDatabase,
            MessageInstance::SetStartLocation(_) => MessageType::SetStartLocation,
            MessageInstance::SetStartLocationRequest(_) => MessageType::SetStartLocationRequest,
            MessageInstance::SimCrashed(_) => MessageType::SimCrashed,
            MessageInstance::SimStats(_) => MessageType::SimStats,
            MessageInstance::SimStatus(_) => MessageType::SimStatus,
            MessageInstance::SimWideDeletes(_) => MessageType::SimWideDeletes,
            MessageInstance::SimulatorLoad(_) => MessageType::SimulatorLoad,
            MessageInstance::SimulatorMapUpdate(_) => MessageType::SimulatorMapUpdate,
            MessageInstance::SimulatorPresentAtLocation(_) => {
                MessageType::SimulatorPresentAtLocation
            }
            MessageInstance::SimulatorReady(_) => MessageType::SimulatorReady,
            MessageInstance::SimulatorSetMap(_) => MessageType::SimulatorSetMap,
            MessageInstance::SimulatorShutdownRequest(_) => MessageType::SimulatorShutdownRequest,
            MessageInstance::SimulatorViewerTimeMessage(_) => {
                MessageType::SimulatorViewerTimeMessage
            }
            MessageInstance::SoundTrigger(_) => MessageType::SoundTrigger,
            MessageInstance::StartAuction(_) => MessageType::StartAuction,
            MessageInstance::StartGroupProposal(_) => MessageType::StartGroupProposal,
            MessageInstance::StartLure(_) => MessageType::StartLure,
            MessageInstance::StartPingCheck(_) => MessageType::StartPingCheck,
            MessageInstance::StateSave(_) => MessageType::StateSave,
            MessageInstance::SubscribeLoad(_) => MessageType::SubscribeLoad,
            MessageInstance::SystemKickUser(_) => MessageType::SystemKickUser,
            MessageInstance::SystemMessage(_) => MessageType::SystemMessage,
            MessageInstance::TallyVotes(_) => MessageType::TallyVotes,
            MessageInstance::TelehubInfo(_) => MessageType::TelehubInfo,
            MessageInstance::TeleportCancel(_) => MessageType::TeleportCancel,
            MessageInstance::TeleportFailed(_) => MessageType::TeleportFailed,
            MessageInstance::TeleportFinish(_) => MessageType::TeleportFinish,
            MessageInstance::TeleportLandingStatusChanged(_) => {
                MessageType::TeleportLandingStatusChanged
            }
            MessageInstance::TeleportLandmarkRequest(_) => MessageType::TeleportLandmarkRequest,
            MessageInstance::TeleportLocal(_) => MessageType::TeleportLocal,
            MessageInstance::TeleportLocationRequest(_) => MessageType::TeleportLocationRequest,
            MessageInstance::TeleportLureRequest(_) => MessageType::TeleportLureRequest,
            MessageInstance::TeleportProgress(_) => MessageType::TeleportProgress,
            MessageInstance::TeleportRequest(_) => MessageType::TeleportRequest,
            MessageInstance::TeleportStart(_) => MessageType::TeleportStart,
            MessageInstance::TerminateFriendship(_) => MessageType::TerminateFriendship,
            MessageInstance::TestMessage(_) => MessageType::TestMessage,
            MessageInstance::TrackAgent(_) => MessageType::TrackAgent,
            MessageInstance::TransferAbort(_) => MessageType::TransferAbort,
            MessageInstance::TransferInfo(_) => MessageType::TransferInfo,
            MessageInstance::TransferInventory(_) => MessageType::TransferInventory,
            MessageInstance::TransferInventoryAck(_) => MessageType::TransferInventoryAck,
            MessageInstance::TransferPacket(_) => MessageType::TransferPacket,
            MessageInstance::TransferRequest(_) => MessageType::TransferRequest,
            MessageInstance::UUIDGroupNameReply(_) => MessageType::UUIDGroupNameReply,
            MessageInstance::UUIDGroupNameRequest(_) => MessageType::UUIDGroupNameRequest,
            MessageInstance::UUIDNameReply(_) => MessageType::UUIDNameReply,
            MessageInstance::UUIDNameRequest(_) => MessageType::UUIDNameRequest,
            MessageInstance::Undo(_) => MessageType::Undo,
            MessageInstance::UndoLand(_) => MessageType::UndoLand,
            MessageInstance::UnsubscribeLoad(_) => MessageType::UnsubscribeLoad,
            MessageInstance::UpdateAttachment(_) => MessageType::UpdateAttachment,
            MessageInstance::UpdateCreateInventoryItem(_) => MessageType::UpdateCreateInventoryItem,
            MessageInstance::UpdateGroupInfo(_) => MessageType::UpdateGroupInfo,
            MessageInstance::UpdateInventoryFolder(_) => MessageType::UpdateInventoryFolder,
            MessageInstance::UpdateInventoryItem(_) => MessageType::UpdateInventoryItem,
            MessageInstance::UpdateMuteListEntry(_) => MessageType::UpdateMuteListEntry,
            MessageInstance::UpdateParcel(_) => MessageType::UpdateParcel,
            MessageInstance::UpdateSimulator(_) => MessageType::UpdateSimulator,
            MessageInstance::UpdateTaskInventory(_) => MessageType::UpdateTaskInventory,
            MessageInstance::UpdateUserInfo(_) => MessageType::UpdateUserInfo,
            MessageInstance::UseCachedMuteList(_) => MessageType::UseCachedMuteList,
            MessageInstance::UseCircuitCode(_) => MessageType::UseCircuitCode,
            MessageInstance::UserInfoReply(_) => MessageType::UserInfoReply,
            MessageInstance::UserInfoRequest(_) => MessageType::UserInfoRequest,
            MessageInstance::UserReport(_) => MessageType::UserReport,
            MessageInstance::UserReportInternal(_) => MessageType::UserReportInternal,
            MessageInstance::VelocityInterpolateOff(_) => MessageType::VelocityInterpolateOff,
            MessageInstance::VelocityInterpolateOn(_) => MessageType::VelocityInterpolateOn,
            MessageInstance::ViewerEffect(_) => MessageType::ViewerEffect,
            MessageInstance::ViewerFrozenMessage(_) => MessageType::ViewerFrozenMessage,
            MessageInstance::ViewerStartAuction(_) => MessageType::ViewerStartAuction,
            MessageInstance::ViewerStats(_) => MessageType::ViewerStats,
        }
    }

    pub fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        match *self {
            MessageInstance::AbortXfer(ref msg) => msg.write_to(buffer),
            MessageInstance::AcceptCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::AcceptFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::ActivateGestures(ref msg) => msg.write_to(buffer),
            MessageInstance::ActivateGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::AddCircuitCode(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentAlertMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentAnimation(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentCachedTexture(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentCachedTextureResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDataUpdateRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDropGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentFOV(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentGroupDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentHeightWidth(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentIsNowWearing(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentMovementComplete(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentPause(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentQuitCopy(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentRequestSit(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentResume(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentSetAppearance(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentSit(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentThrottle(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentWearablesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentWearablesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AlertMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::AssetUploadComplete(ref msg) => msg.write_to(buffer),
            MessageInstance::AssetUploadRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AtomicPassObject(ref msg) => msg.write_to(buffer),
            MessageInstance::AttachedSound(ref msg) => msg.write_to(buffer),
            MessageInstance::AttachedSoundGainChange(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarAnimation(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarAppearance(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarClassifiedReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarGroupsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarInterestsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarInterestsUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarNotesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarNotesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerRequestBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPicksReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesRequestBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarSitResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarTextureUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::BulkUpdateInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::BuyObjectInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::CameraConstraint(ref msg) => msg.write_to(buffer),
            MessageInstance::CancelAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::ChangeInventoryItemFlags(ref msg) => msg.write_to(buffer),
            MessageInstance::ChangeUserRights(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatFromSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatFromViewer(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatPass(ref msg) => msg.write_to(buffer),
            MessageInstance::CheckParcelAuctions(ref msg) => msg.write_to(buffer),
            MessageInstance::CheckParcelSales(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentAlive(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentDying(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentPositionUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentUnknown(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ClearFollowCamProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::CloseCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::CoarseLocationUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::CompleteAgentMovement(ref msg) => msg.write_to(buffer),
            MessageInstance::CompleteAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::CompletePingCheck(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmAuctionStart(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmEnableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmXferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::CopyInventoryFromNotecard(ref msg) => msg.write_to(buffer),
            MessageInstance::CopyInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateLandmarkForEvent(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateNewOutfitAttachments(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::CrossedRegion(ref msg) => msg.write_to(buffer),
            MessageInstance::DataHomeLocationReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DataHomeLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::DataServerLogout(ref msg) => msg.write_to(buffer),
            MessageInstance::DeRezAck(ref msg) => msg.write_to(buffer),
            MessageInstance::DeRezObject(ref msg) => msg.write_to(buffer),
            MessageInstance::DeactivateGestures(ref msg) => msg.write_to(buffer),
            MessageInstance::DeclineCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::DeclineFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::DenyTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::DerezContainer(ref msg) => msg.write_to(buffer),
            MessageInstance::DetachAttachmentIntoInv(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirEventsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirFindQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirFindQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirGroupsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPeopleReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DisableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::EconomyData(ref msg) => msg.write_to(buffer),
            MessageInstance::EconomyDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EdgeDataPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectGroupMemberReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectGroupMemberRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectUser(ref msg) => msg.write_to(buffer),
            MessageInstance::EmailMessageReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EmailMessageRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EnableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::Error(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateCovenantReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateCovenantRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateOwnerMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::EventGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::EventInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EventInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventLocationReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EventLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventNotificationAddRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventNotificationRemoveRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::FeatureDisabled(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventoryReply(ref msg) => msg.write_to(buffer),
            MessageInstance::FindAgent(ref msg) => msg.write_to(buffer),
            MessageInstance::ForceObjectSelect(ref msg) => msg.write_to(buffer),
            MessageInstance::ForceScriptControlRelease(ref msg) => msg.write_to(buffer),
            MessageInstance::FormFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::FreezeUser(ref msg) => msg.write_to(buffer),
            MessageInstance::GenericMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::GetScriptRunning(ref msg) => msg.write_to(buffer),
            MessageInstance::GodKickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::GodUpdateRegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::GodlikeMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::GrantGodlikePowers(ref msg) => msg.write_to(buffer),
            MessageInstance::GrantUserRights(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountDetailsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountDetailsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountSummaryReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountSummaryRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountTransactionsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountTransactionsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupActiveProposalItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupActiveProposalsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupMembersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupMembersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticeAdd(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticeRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticesListReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticesListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProfileReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProfileRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProposalBallot(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleChanges(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleDataReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleMembersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleMembersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitleUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitlesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitlesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupVoteHistoryItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupVoteHistoryRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::HealthMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ImageData(ref msg) => msg.write_to(buffer),
            MessageInstance::ImageNotInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::ImagePacket(ref msg) => msg.write_to(buffer),
            MessageInstance::ImprovedInstantMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ImprovedTerseObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::InitiateDownload(ref msg) => msg.write_to(buffer),
            MessageInstance::InternalScriptMail(ref msg) => msg.write_to(buffer),
            MessageInstance::InventoryAssetResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::InventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::InviteGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::InviteGroupResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::JoinGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::JoinGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::KickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::KickUserAck(ref msg) => msg.write_to(buffer),
            MessageInstance::KillChildAgents(ref msg) => msg.write_to(buffer),
            MessageInstance::KillObject(ref msg) => msg.write_to(buffer),
            MessageInstance::LandStatReply(ref msg) => msg.write_to(buffer),
            MessageInstance::LandStatRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LayerData(ref msg) => msg.write_to(buffer),
            MessageInstance::LeaveGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::LeaveGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LinkInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::LiveHelpGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::LiveHelpGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LoadURL(ref msg) => msg.write_to(buffer),
            MessageInstance::LogDwellTime(ref msg) => msg.write_to(buffer),
            MessageInstance::LogFailedMoneyTransaction(ref msg) => msg.write_to(buffer),
            MessageInstance::LogParcelChanges(ref msg) => msg.write_to(buffer),
            MessageInstance::LogTextMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::LogoutReply(ref msg) => msg.write_to(buffer),
            MessageInstance::LogoutRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapBlockReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MapBlockRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MapItemRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapLayerReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MapLayerRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MeanCollisionAlert(ref msg) => msg.write_to(buffer),
            MessageInstance::MergeParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::ModifyLand(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyBalanceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyBalanceRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyTransferBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyTransferRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::MultipleObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::MuteListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MuteListUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::NameValuePair(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionReply(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionUpdated(ref msg) => msg.write_to(buffer),
            MessageInstance::NeighborList(ref msg) => msg.write_to(buffer),
            MessageInstance::NetTest(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectAdd(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectAttach(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectBuy(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectCategory(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectClickAction(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDeGrab(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDelink(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDescription(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDeselect(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDetach(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDrop(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDuplicate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDuplicateOnRay(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectExportSelected(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectExtraParams(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectFlagUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGrab(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGrabUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectImage(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectIncludeInSearch(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectLink(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectMaterial(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectName(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectOwner(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPermissions(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPosition(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPropertiesFamily(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectRotation(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSaleInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectScale(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSelect(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectShape(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinStart(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinStop(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdateCached(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdateCompressed(ref msg) => msg.write_to(buffer),
            MessageInstance::OfferCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::OfflineNotification(ref msg) => msg.write_to(buffer),
            MessageInstance::OnlineNotification(ref msg) => msg.write_to(buffer),
            MessageInstance::OpenCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::PacketAck(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAuctions(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelBuy(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelBuyPass(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelClaim(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDeedToGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDisableObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDivide(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDwellReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDwellRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelGodForceOwner(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelGodMarkAsContent(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelJoin(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelMediaCommandMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelMediaUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelObjectOwnersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelObjectOwnersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelOverlay(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesRequestByID(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelReclaim(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelRelease(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelRename(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelReturnObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSales(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSelectObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSetOtherCleanTime(ref msg) => msg.write_to(buffer),
            MessageInstance::PayPriceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::PickDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::PickGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::PickInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::PickInfoUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::PlacesQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::PlacesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::PreloadSound(ref msg) => msg.write_to(buffer),
            MessageInstance::PurgeInventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::RebakeAvatarTextures(ref msg) => msg.write_to(buffer),
            MessageInstance::Redo(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandleRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandshake(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandshakeReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionIDAndHandleReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceRequestByHandle(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceRequestByRegionID(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveAttachment(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveMuteListEntry(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveNameValuePair(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::ReplyTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::ReportAutosaveCrash(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestGodlikePowers(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestImage(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestInventoryAsset(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestMultipleObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestObjectPropertiesFamily(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestParcelTransfer(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestPayPrice(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestRegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestXfer(ref msg) => msg.write_to(buffer),
            MessageInstance::RetrieveInstantMessages(ref msg) => msg.write_to(buffer),
            MessageInstance::RevokePermissions(ref msg) => msg.write_to(buffer),
            MessageInstance::RezMultipleAttachmentsFromInv(ref msg) => msg.write_to(buffer),
            MessageInstance::RezObject(ref msg) => msg.write_to(buffer),
            MessageInstance::RezObjectFromNotecard(ref msg) => msg.write_to(buffer),
            MessageInstance::RezRestoreToWorld(ref msg) => msg.write_to(buffer),
            MessageInstance::RezScript(ref msg) => msg.write_to(buffer),
            MessageInstance::RezSingleAttachmentFromInv(ref msg) => msg.write_to(buffer),
            MessageInstance::RoutedMoneyBalanceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcChannelReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcChannelRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptReplyInbound(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptRequestInbound(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptRequestInboundForward(ref msg) => msg.write_to(buffer),
            MessageInstance::SaveAssetIntoInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptAnswerYes(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptControlChange(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDataReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDialog(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDialogReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptMailRegistration(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptQuestion(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptReset(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptRunningReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptSensorReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptSensorRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptTeleportRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::SendPostcard(ref msg) => msg.write_to(buffer),
            MessageInstance::SendXferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::SetAlwaysRun(ref msg) => msg.write_to(buffer),
            MessageInstance::SetCPURatio(ref msg) => msg.write_to(buffer),
            MessageInstance::SetFollowCamProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::SetGroupAcceptNotices(ref msg) => msg.write_to(buffer),
            MessageInstance::SetGroupContribution(ref msg) => msg.write_to(buffer),
            MessageInstance::SetScriptRunning(ref msg) => msg.write_to(buffer),
            MessageInstance::SetSimPresenceInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::SetSimStatusInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::SetStartLocation(ref msg) => msg.write_to(buffer),
            MessageInstance::SetStartLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::SimCrashed(ref msg) => msg.write_to(buffer),
            MessageInstance::SimStats(ref msg) => msg.write_to(buffer),
            MessageInstance::SimStatus(ref msg) => msg.write_to(buffer),
            MessageInstance::SimWideDeletes(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorMapUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorPresentAtLocation(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorReady(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorSetMap(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorShutdownRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorViewerTimeMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::SoundTrigger(ref msg) => msg.write_to(buffer),
            MessageInstance::StartAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::StartGroupProposal(ref msg) => msg.write_to(buffer),
            MessageInstance::StartLure(ref msg) => msg.write_to(buffer),
            MessageInstance::StartPingCheck(ref msg) => msg.write_to(buffer),
            MessageInstance::StateSave(ref msg) => msg.write_to(buffer),
            MessageInstance::SubscribeLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::SystemKickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::SystemMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::TallyVotes(ref msg) => msg.write_to(buffer),
            MessageInstance::TelehubInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportCancel(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportFailed(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportFinish(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLandingStatusChanged(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLandmarkRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLocal(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLureRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportProgress(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportStart(ref msg) => msg.write_to(buffer),
            MessageInstance::TerminateFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::TestMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::TrackAgent(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferAbort(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInventoryAck(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDGroupNameReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDGroupNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDNameReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::Undo(ref msg) => msg.write_to(buffer),
            MessageInstance::UndoLand(ref msg) => msg.write_to(buffer),
            MessageInstance::UnsubscribeLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateAttachment(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateCreateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateGroupInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateMuteListEntry(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateUserInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::UseCachedMuteList(ref msg) => msg.write_to(buffer),
            MessageInstance::UseCircuitCode(ref msg) => msg.write_to(buffer),
            MessageInstance::UserInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UserInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UserReport(ref msg) => msg.write_to(buffer),
            MessageInstance::UserReportInternal(ref msg) => msg.write_to(buffer),
            MessageInstance::VelocityInterpolateOff(ref msg) => msg.write_to(buffer),
            MessageInstance::VelocityInterpolateOn(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerEffect(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerFrozenMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerStartAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerStats(ref msg) => msg.write_to(buffer),
        }
    }
    pub fn read_message<R: ?Sized>(
        buffer: &mut R,
        message_num: u32,
    ) -> Result<MessageInstance, ReadError>
    where
        R: Read, {
        match message_num {
            0x9d00ffff => AbortXfer::read_from(buffer),
            0x2e01ffff => AcceptCallingCard::read_from(buffer),
            0x2901ffff => AcceptFriendship::read_from(buffer),
            0x3c01ffff => ActivateGestures::read_from(buffer),
            0x7001ffff => ActivateGroup::read_from(buffer),
            0x0200ffff => AddCircuitCode::read_from(buffer),
            0x8700ffff => AgentAlertMessage::read_from(buffer),
            0x00000005 => AgentAnimation::read_from(buffer),
            0x8001ffff => AgentCachedTexture::read_from(buffer),
            0x8101ffff => AgentCachedTextureResponse::read_from(buffer),
            0x8301ffff => AgentDataUpdate::read_from(buffer),
            0x8201ffff => AgentDataUpdateRequest::read_from(buffer),
            0x8601ffff => AgentDropGroup::read_from(buffer),
            0x5200ffff => AgentFOV::read_from(buffer),
            0x8501ffff => AgentGroupDataUpdate::read_from(buffer),
            0x5300ffff => AgentHeightWidth::read_from(buffer),
            0x7f01ffff => AgentIsNowWearing::read_from(buffer),
            0xfa00ffff => AgentMovementComplete::read_from(buffer),
            0x4e00ffff => AgentPause::read_from(buffer),
            0x5500ffff => AgentQuitCopy::read_from(buffer),
            0x00000006 => AgentRequestSit::read_from(buffer),
            0x4f00ffff => AgentResume::read_from(buffer),
            0x5400ffff => AgentSetAppearance::read_from(buffer),
            0x00000007 => AgentSit::read_from(buffer),
            0x5100ffff => AgentThrottle::read_from(buffer),
            0x00000004 => AgentUpdate::read_from(buffer),
            0x7d01ffff => AgentWearablesRequest::read_from(buffer),
            0x7e01ffff => AgentWearablesUpdate::read_from(buffer),
            0x8600ffff => AlertMessage::read_from(buffer),
            0x4e01ffff => AssetUploadComplete::read_from(buffer),
            0x4d01ffff => AssetUploadRequest::read_from(buffer),
            0x0000001c => AtomicPassObject::read_from(buffer),
            0x00000dff => AttachedSound::read_from(buffer),
            0x00000eff => AttachedSoundGainChange::read_from(buffer),
            0x00000014 => AvatarAnimation::read_from(buffer),
            0x9e00ffff => AvatarAppearance::read_from(buffer),
            0x2a00ffff => AvatarClassifiedReply::read_from(buffer),
            0xad00ffff => AvatarGroupsReply::read_from(buffer),
            0xac00ffff => AvatarInterestsReply::read_from(buffer),
            0xaf00ffff => AvatarInterestsUpdate::read_from(buffer),
            0xb000ffff => AvatarNotesReply::read_from(buffer),
            0xb100ffff => AvatarNotesUpdate::read_from(buffer),
            0x1c00ffff => AvatarPickerReply::read_from(buffer),
            0x1a00ffff => AvatarPickerRequest::read_from(buffer),
            0x1b00ffff => AvatarPickerRequestBackend::read_from(buffer),
            0xb200ffff => AvatarPicksReply::read_from(buffer),
            0xab00ffff => AvatarPropertiesReply::read_from(buffer),
            0xa900ffff => AvatarPropertiesRequest::read_from(buffer),
            0xaa00ffff => AvatarPropertiesRequestBackend::read_from(buffer),
            0xae00ffff => AvatarPropertiesUpdate::read_from(buffer),
            0x00000015 => AvatarSitResponse::read_from(buffer),
            0x0400ffff => AvatarTextureUpdate::read_from(buffer),
            0x1901ffff => BulkUpdateInventory::read_from(buffer),
            0x6700ffff => BuyObjectInventory::read_from(buffer),
            0x00000016 => CameraConstraint::read_from(buffer),
            0xe800ffff => CancelAuction::read_from(buffer),
            0x0f01ffff => ChangeInventoryItemFlags::read_from(buffer),
            0x4101ffff => ChangeUserRights::read_from(buffer),
            0x8b00ffff => ChatFromSimulator::read_from(buffer),
            0x5000ffff => ChatFromViewer::read_from(buffer),
            0xef00ffff => ChatPass::read_from(buffer),
            0xe900ffff => CheckParcelAuctions::read_from(buffer),
            0xe100ffff => CheckParcelSales::read_from(buffer),
            0x0000001a => ChildAgentAlive::read_from(buffer),
            0xf000ffff => ChildAgentDying::read_from(buffer),
            0x0000001b => ChildAgentPositionUpdate::read_from(buffer),
            0xf100ffff => ChildAgentUnknown::read_from(buffer),
            0x00000019 => ChildAgentUpdate::read_from(buffer),
            0x2e00ffff => ClassifiedDelete::read_from(buffer),
            0x2f00ffff => ClassifiedGodDelete::read_from(buffer),
            0x2c00ffff => ClassifiedInfoReply::read_from(buffer),
            0x2b00ffff => ClassifiedInfoRequest::read_from(buffer),
            0x2d00ffff => ClassifiedInfoUpdate::read_from(buffer),
            0xa000ffff => ClearFollowCamProperties::read_from(buffer),
            0xFDffffff => CloseCircuit::read_from(buffer),
            0x000006ff => CoarseLocationUpdate::read_from(buffer),
            0xf900ffff => CompleteAgentMovement::read_from(buffer),
            0xe700ffff => CompleteAuction::read_from(buffer),
            0x00000002 => CompletePingCheck::read_from(buffer),
            0xe600ffff => ConfirmAuctionStart::read_from(buffer),
            0x000008ff => ConfirmEnableSimulator::read_from(buffer),
            0x00000013 => ConfirmXferPacket::read_from(buffer),
            0x0901ffff => CopyInventoryFromNotecard::read_from(buffer),
            0x0d01ffff => CopyInventoryItem::read_from(buffer),
            0x5401ffff => CreateGroupReply::read_from(buffer),
            0x5301ffff => CreateGroupRequest::read_from(buffer),
            0x1101ffff => CreateInventoryFolder::read_from(buffer),
            0x3101ffff => CreateInventoryItem::read_from(buffer),
            0x3201ffff => CreateLandmarkForEvent::read_from(buffer),
            0x8e01ffff => CreateNewOutfitAttachments::read_from(buffer),
            0x8801ffff => CreateTrustedCircuit::read_from(buffer),
            0x000007ff => CrossedRegion::read_from(buffer),
            0x4400ffff => DataHomeLocationReply::read_from(buffer),
            0x4300ffff => DataHomeLocationRequest::read_from(buffer),
            0xfb00ffff => DataServerLogout::read_from(buffer),
            0x2401ffff => DeRezAck::read_from(buffer),
            0x2301ffff => DeRezObject::read_from(buffer),
            0x3d01ffff => DeactivateGestures::read_from(buffer),
            0x2f01ffff => DeclineCallingCard::read_from(buffer),
            0x2a01ffff => DeclineFriendship::read_from(buffer),
            0x8901ffff => DenyTrustedCircuit::read_from(buffer),
            0x6800ffff => DerezContainer::read_from(buffer),
            0x8d01ffff => DetachAttachmentIntoInv::read_from(buffer),
            0x2700ffff => DirClassifiedQuery::read_from(buffer),
            0x2800ffff => DirClassifiedQueryBackend::read_from(buffer),
            0x2900ffff => DirClassifiedReply::read_from(buffer),
            0x2500ffff => DirEventsReply::read_from(buffer),
            0x1f00ffff => DirFindQuery::read_from(buffer),
            0x2000ffff => DirFindQueryBackend::read_from(buffer),
            0x2600ffff => DirGroupsReply::read_from(buffer),
            0x3000ffff => DirLandQuery::read_from(buffer),
            0x3100ffff => DirLandQueryBackend::read_from(buffer),
            0x3200ffff => DirLandReply::read_from(buffer),
            0x2400ffff => DirPeopleReply::read_from(buffer),
            0x2100ffff => DirPlacesQuery::read_from(buffer),
            0x2200ffff => DirPlacesQueryBackend::read_from(buffer),
            0x2300ffff => DirPlacesReply::read_from(buffer),
            0x3300ffff => DirPopularQuery::read_from(buffer),
            0x3400ffff => DirPopularQueryBackend::read_from(buffer),
            0x3500ffff => DirPopularReply::read_from(buffer),
            0x9800ffff => DisableSimulator::read_from(buffer),
            0x1900ffff => EconomyData::read_from(buffer),
            0x1800ffff => EconomyDataRequest::read_from(buffer),
            0x00000018 => EdgeDataPacket::read_from(buffer),
            0x5a01ffff => EjectGroupMemberReply::read_from(buffer),
            0x5901ffff => EjectGroupMemberRequest::read_from(buffer),
            0xa700ffff => EjectUser::read_from(buffer),
            0x5001ffff => EmailMessageReply::read_from(buffer),
            0x4f01ffff => EmailMessageRequest::read_from(buffer),
            0x9700ffff => EnableSimulator::read_from(buffer),
            0xa701ffff => Error::read_from(buffer),
            0xcc00ffff => EstateCovenantReply::read_from(buffer),
            0xcb00ffff => EstateCovenantRequest::read_from(buffer),
            0x0401ffff => EstateOwnerMessage::read_from(buffer),
            0xb700ffff => EventGodDelete::read_from(buffer),
            0xb400ffff => EventInfoReply::read_from(buffer),
            0xb300ffff => EventInfoRequest::read_from(buffer),
            0x3401ffff => EventLocationReply::read_from(buffer),
            0x3301ffff => EventLocationRequest::read_from(buffer),
            0xb500ffff => EventNotificationAddRequest::read_from(buffer),
            0xb600ffff => EventNotificationRemoveRequest::read_from(buffer),
            0x1300ffff => FeatureDisabled::read_from(buffer),
            0x1701ffff => FetchInventory::read_from(buffer),
            0x1501ffff => FetchInventoryDescendents::read_from(buffer),
            0x1801ffff => FetchInventoryReply::read_from(buffer),
            0x0001ffff => FindAgent::read_from(buffer),
            0xcd00ffff => ForceObjectSelect::read_from(buffer),
            0xc000ffff => ForceScriptControlRelease::read_from(buffer),
            0x2b01ffff => FormFriendship::read_from(buffer),
            0xa800ffff => FreezeUser::read_from(buffer),
            0x0501ffff => GenericMessage::read_from(buffer),
            0xf300ffff => GetScriptRunning::read_from(buffer),
            0xa500ffff => GodKickUser::read_from(buffer),
            0x8f00ffff => GodUpdateRegionInfo::read_from(buffer),
            0x0301ffff => GodlikeMessage::read_from(buffer),
            0x0201ffff => GrantGodlikePowers::read_from(buffer),
            0x4001ffff => GrantUserRights::read_from(buffer),
            0x6401ffff => GroupAccountDetailsReply::read_from(buffer),
            0x6301ffff => GroupAccountDetailsRequest::read_from(buffer),
            0x6201ffff => GroupAccountSummaryReply::read_from(buffer),
            0x6101ffff => GroupAccountSummaryRequest::read_from(buffer),
            0x6601ffff => GroupAccountTransactionsReply::read_from(buffer),
            0x6501ffff => GroupAccountTransactionsRequest::read_from(buffer),
            0x6801ffff => GroupActiveProposalItemReply::read_from(buffer),
            0x6701ffff => GroupActiveProposalsRequest::read_from(buffer),
            0x8401ffff => GroupDataUpdate::read_from(buffer),
            0x6f01ffff => GroupMembersReply::read_from(buffer),
            0x6e01ffff => GroupMembersRequest::read_from(buffer),
            0x3d00ffff => GroupNoticeAdd::read_from(buffer),
            0x3c00ffff => GroupNoticeRequest::read_from(buffer),
            0x3b00ffff => GroupNoticesListReply::read_from(buffer),
            0x3a00ffff => GroupNoticesListRequest::read_from(buffer),
            0x6001ffff => GroupProfileReply::read_from(buffer),
            0x5f01ffff => GroupProfileRequest::read_from(buffer),
            0x6c01ffff => GroupProposalBallot::read_from(buffer),
            0x5601ffff => GroupRoleChanges::read_from(buffer),
            0x7401ffff => GroupRoleDataReply::read_from(buffer),
            0x7301ffff => GroupRoleDataRequest::read_from(buffer),
            0x7601ffff => GroupRoleMembersReply::read_from(buffer),
            0x7501ffff => GroupRoleMembersRequest::read_from(buffer),
            0x7a01ffff => GroupRoleUpdate::read_from(buffer),
            0x7901ffff => GroupTitleUpdate::read_from(buffer),
            0x7801ffff => GroupTitlesReply::read_from(buffer),
            0x7701ffff => GroupTitlesRequest::read_from(buffer),
            0x6a01ffff => GroupVoteHistoryItemReply::read_from(buffer),
            0x6901ffff => GroupVoteHistoryRequest::read_from(buffer),
            0x8a00ffff => HealthMessage::read_from(buffer),
            0x00000009 => ImageData::read_from(buffer),
            0x5600ffff => ImageNotInDatabase::read_from(buffer),
            0x0000000a => ImagePacket::read_from(buffer),
            0xfe00ffff => ImprovedInstantMessage::read_from(buffer),
            0x0000000f => ImprovedTerseObjectUpdate::read_from(buffer),
            0x9301ffff => InitiateDownload::read_from(buffer),
            0x000010ff => InternalScriptMail::read_from(buffer),
            0x1b01ffff => InventoryAssetResponse::read_from(buffer),
            0x1601ffff => InventoryDescendents::read_from(buffer),
            0x5d01ffff => InviteGroupRequest::read_from(buffer),
            0x5e01ffff => InviteGroupResponse::read_from(buffer),
            0x5801ffff => JoinGroupReply::read_from(buffer),
            0x5701ffff => JoinGroupRequest::read_from(buffer),
            0xa300ffff => KickUser::read_from(buffer),
            0xa400ffff => KickUserAck::read_from(buffer),
            0xf200ffff => KillChildAgents::read_from(buffer),
            0x00000010 => KillObject::read_from(buffer),
            0xa601ffff => LandStatReply::read_from(buffer),
            0xa501ffff => LandStatRequest::read_from(buffer),
            0x0000000b => LayerData::read_from(buffer),
            0x5c01ffff => LeaveGroupReply::read_from(buffer),
            0x5b01ffff => LeaveGroupRequest::read_from(buffer),
            0xaa01ffff => LinkInventoryItem::read_from(buffer),
            0x7c01ffff => LiveHelpGroupReply::read_from(buffer),
            0x7b01ffff => LiveHelpGroupRequest::read_from(buffer),
            0xc200ffff => LoadURL::read_from(buffer),
            0x1200ffff => LogDwellTime::read_from(buffer),
            0x1400ffff => LogFailedMoneyTransaction::read_from(buffer),
            0xe000ffff => LogParcelChanges::read_from(buffer),
            0x8701ffff => LogTextMessage::read_from(buffer),
            0xfd00ffff => LogoutReply::read_from(buffer),
            0xfc00ffff => LogoutRequest::read_from(buffer),
            0x9901ffff => MapBlockReply::read_from(buffer),
            0x9701ffff => MapBlockRequest::read_from(buffer),
            0x9b01ffff => MapItemReply::read_from(buffer),
            0x9a01ffff => MapItemRequest::read_from(buffer),
            0x9601ffff => MapLayerReply::read_from(buffer),
            0x9501ffff => MapLayerRequest::read_from(buffer),
            0x9801ffff => MapNameRequest::read_from(buffer),
            0x8800ffff => MeanCollisionAlert::read_from(buffer),
            0xdf00ffff => MergeParcel::read_from(buffer),
            0x7c00ffff => ModifyLand::read_from(buffer),
            0x3a01ffff => MoneyBalanceReply::read_from(buffer),
            0x3901ffff => MoneyBalanceRequest::read_from(buffer),
            0x3801ffff => MoneyTransferBackend::read_from(buffer),
            0x3701ffff => MoneyTransferRequest::read_from(buffer),
            0x1301ffff => MoveInventoryFolder::read_from(buffer),
            0x0c01ffff => MoveInventoryItem::read_from(buffer),
            0x2001ffff => MoveTaskInventory::read_from(buffer),
            0x000002ff => MultipleObjectUpdate::read_from(buffer),
            0x0601ffff => MuteListRequest::read_from(buffer),
            0x3e01ffff => MuteListUpdate::read_from(buffer),
            0x4901ffff => NameValuePair::read_from(buffer),
            0x9100ffff => NearestLandingRegionReply::read_from(buffer),
            0x9000ffff => NearestLandingRegionRequest::read_from(buffer),
            0x9200ffff => NearestLandingRegionUpdated::read_from(buffer),
            0x00000003 => NeighborList::read_from(buffer),
            0x4601ffff => NetTest::read_from(buffer),
            0x000001ff => ObjectAdd::read_from(buffer),
            0x7000ffff => ObjectAttach::read_from(buffer),
            0x6600ffff => ObjectBuy::read_from(buffer),
            0x6d00ffff => ObjectCategory::read_from(buffer),
            0x5f00ffff => ObjectClickAction::read_from(buffer),
            0x7700ffff => ObjectDeGrab::read_from(buffer),
            0x5900ffff => ObjectDelete::read_from(buffer),
            0x7400ffff => ObjectDelink::read_from(buffer),
            0x6c00ffff => ObjectDescription::read_from(buffer),
            0x6f00ffff => ObjectDeselect::read_from(buffer),
            0x7100ffff => ObjectDetach::read_from(buffer),
            0x7200ffff => ObjectDrop::read_from(buffer),
            0x5a00ffff => ObjectDuplicate::read_from(buffer),
            0x5b00ffff => ObjectDuplicateOnRay::read_from(buffer),
            0x7b00ffff => ObjectExportSelected::read_from(buffer),
            0x6300ffff => ObjectExtraParams::read_from(buffer),
            0x5e00ffff => ObjectFlagUpdate::read_from(buffer),
            0x7500ffff => ObjectGrab::read_from(buffer),
            0x7600ffff => ObjectGrabUpdate::read_from(buffer),
            0x6500ffff => ObjectGroup::read_from(buffer),
            0x6000ffff => ObjectImage::read_from(buffer),
            0xa801ffff => ObjectIncludeInSearch::read_from(buffer),
            0x7300ffff => ObjectLink::read_from(buffer),
            0x6100ffff => ObjectMaterial::read_from(buffer),
            0x6b00ffff => ObjectName::read_from(buffer),
            0x6400ffff => ObjectOwner::read_from(buffer),
            0x6900ffff => ObjectPermissions::read_from(buffer),
            0x000004ff => ObjectPosition::read_from(buffer),
            0x000009ff => ObjectProperties::read_from(buffer),
            0x00000aff => ObjectPropertiesFamily::read_from(buffer),
            0x5d00ffff => ObjectRotation::read_from(buffer),
            0x6a00ffff => ObjectSaleInfo::read_from(buffer),
            0x5c00ffff => ObjectScale::read_from(buffer),
            0x6e00ffff => ObjectSelect::read_from(buffer),
            0x6200ffff => ObjectShape::read_from(buffer),
            0x7800ffff => ObjectSpinStart::read_from(buffer),
            0x7a00ffff => ObjectSpinStop::read_from(buffer),
            0x7900ffff => ObjectSpinUpdate::read_from(buffer),
            0x0000000c => ObjectUpdate::read_from(buffer),
            0x0000000e => ObjectUpdateCached::read_from(buffer),
            0x0000000d => ObjectUpdateCompressed::read_from(buffer),
            0x2d01ffff => OfferCallingCard::read_from(buffer),
            0x4301ffff => OfflineNotification::read_from(buffer),
            0x4201ffff => OnlineNotification::read_from(buffer),
            0xFCffffff => OpenCircuit::read_from(buffer),
            0xFBffffff => PacketAck::read_from(buffer),
            0xd800ffff => ParcelAccessListReply::read_from(buffer),
            0xd700ffff => ParcelAccessListRequest::read_from(buffer),
            0xd900ffff => ParcelAccessListUpdate::read_from(buffer),
            0xea00ffff => ParcelAuctions::read_from(buffer),
            0xd500ffff => ParcelBuy::read_from(buffer),
            0xce00ffff => ParcelBuyPass::read_from(buffer),
            0xd100ffff => ParcelClaim::read_from(buffer),
            0xcf00ffff => ParcelDeedToGroup::read_from(buffer),
            0xc900ffff => ParcelDisableObjects::read_from(buffer),
            0xd300ffff => ParcelDivide::read_from(buffer),
            0xdb00ffff => ParcelDwellReply::read_from(buffer),
            0xda00ffff => ParcelDwellRequest::read_from(buffer),
            0xd600ffff => ParcelGodForceOwner::read_from(buffer),
            0xe300ffff => ParcelGodMarkAsContent::read_from(buffer),
            0x3700ffff => ParcelInfoReply::read_from(buffer),
            0x3600ffff => ParcelInfoRequest::read_from(buffer),
            0xd200ffff => ParcelJoin::read_from(buffer),
            0xa301ffff => ParcelMediaCommandMessage::read_from(buffer),
            0xa401ffff => ParcelMediaUpdate::read_from(buffer),
            0x3900ffff => ParcelObjectOwnersReply::read_from(buffer),
            0x3800ffff => ParcelObjectOwnersRequest::read_from(buffer),
            0xc400ffff => ParcelOverlay::read_from(buffer),
            0x00000017 => ParcelProperties::read_from(buffer),
            0x00000bff => ParcelPropertiesRequest::read_from(buffer),
            0xc500ffff => ParcelPropertiesRequestByID::read_from(buffer),
            0xc600ffff => ParcelPropertiesUpdate::read_from(buffer),
            0xd000ffff => ParcelReclaim::read_from(buffer),
            0xd400ffff => ParcelRelease::read_from(buffer),
            0x9201ffff => ParcelRename::read_from(buffer),
            0xc700ffff => ParcelReturnObjects::read_from(buffer),
            0xe200ffff => ParcelSales::read_from(buffer),
            0xca00ffff => ParcelSelectObjects::read_from(buffer),
            0xc800ffff => ParcelSetOtherCleanTime::read_from(buffer),
            0xa200ffff => PayPriceReply::read_from(buffer),
            0xba00ffff => PickDelete::read_from(buffer),
            0xbb00ffff => PickGodDelete::read_from(buffer),
            0xb800ffff => PickInfoReply::read_from(buffer),
            0xb900ffff => PickInfoUpdate::read_from(buffer),
            0x1d00ffff => PlacesQuery::read_from(buffer),
            0x1e00ffff => PlacesReply::read_from(buffer),
            0x00000fff => PreloadSound::read_from(buffer),
            0x1d01ffff => PurgeInventoryDescendents::read_from(buffer),
            0x5700ffff => RebakeAvatarTextures::read_from(buffer),
            0x4c00ffff => Redo::read_from(buffer),
            0x3501ffff => RegionHandleRequest::read_from(buffer),
            0x9400ffff => RegionHandshake::read_from(buffer),
            0x9500ffff => RegionHandshakeReply::read_from(buffer),
            0x3601ffff => RegionIDAndHandleReply::read_from(buffer),
            0x8e00ffff => RegionInfo::read_from(buffer),
            0x0f00ffff => RegionPresenceRequestByHandle::read_from(buffer),
            0x0e00ffff => RegionPresenceRequestByRegionID::read_from(buffer),
            0x1000ffff => RegionPresenceResponse::read_from(buffer),
            0x4c01ffff => RemoveAttachment::read_from(buffer),
            0x1401ffff => RemoveInventoryFolder::read_from(buffer),
            0x0e01ffff => RemoveInventoryItem::read_from(buffer),
            0x1c01ffff => RemoveInventoryObjects::read_from(buffer),
            0x0801ffff => RemoveMuteListEntry::read_from(buffer),
            0x4a01ffff => RemoveNameValuePair::read_from(buffer),
            0xde00ffff => RemoveParcel::read_from(buffer),
            0x1f01ffff => RemoveTaskInventory::read_from(buffer),
            0x2201ffff => ReplyTaskInventory::read_from(buffer),
            0x8000ffff => ReportAutosaveCrash::read_from(buffer),
            0x0101ffff => RequestGodlikePowers::read_from(buffer),
            0x00000008 => RequestImage::read_from(buffer),
            0x1a01ffff => RequestInventoryAsset::read_from(buffer),
            0x000003ff => RequestMultipleObjects::read_from(buffer),
            0x000005ff => RequestObjectPropertiesFamily::read_from(buffer),
            0xdc00ffff => RequestParcelTransfer::read_from(buffer),
            0xa100ffff => RequestPayPrice::read_from(buffer),
            0x8d00ffff => RequestRegionInfo::read_from(buffer),
            0x2101ffff => RequestTaskInventory::read_from(buffer),
            0x8a01ffff => RequestTrustedCircuit::read_from(buffer),
            0x9c00ffff => RequestXfer::read_from(buffer),
            0xff00ffff => RetrieveInstantMessages::read_from(buffer),
            0xc100ffff => RevokePermissions::read_from(buffer),
            0x8c01ffff => RezMultipleAttachmentsFromInv::read_from(buffer),
            0x2501ffff => RezObject::read_from(buffer),
            0x2601ffff => RezObjectFromNotecard::read_from(buffer),
            0xa901ffff => RezRestoreToWorld::read_from(buffer),
            0x3001ffff => RezScript::read_from(buffer),
            0x8b01ffff => RezSingleAttachmentFromInv::read_from(buffer),
            0x3b01ffff => RoutedMoneyBalanceReply::read_from(buffer),
            0x9e01ffff => RpcChannelReply::read_from(buffer),
            0x9d01ffff => RpcChannelRequest::read_from(buffer),
            0xa101ffff => RpcScriptReplyInbound::read_from(buffer),
            0x9f01ffff => RpcScriptRequestInbound::read_from(buffer),
            0xa001ffff => RpcScriptRequestInboundForward::read_from(buffer),
            0x1001ffff => SaveAssetIntoInventory::read_from(buffer),
            0x8400ffff => ScriptAnswerYes::read_from(buffer),
            0xbd00ffff => ScriptControlChange::read_from(buffer),
            0x5201ffff => ScriptDataReply::read_from(buffer),
            0x5101ffff => ScriptDataRequest::read_from(buffer),
            0xbe00ffff => ScriptDialog::read_from(buffer),
            0xbf00ffff => ScriptDialogReply::read_from(buffer),
            0xa201ffff => ScriptMailRegistration::read_from(buffer),
            0xbc00ffff => ScriptQuestion::read_from(buffer),
            0xf600ffff => ScriptReset::read_from(buffer),
            0xf400ffff => ScriptRunningReply::read_from(buffer),
            0xf800ffff => ScriptSensorReply::read_from(buffer),
            0xf700ffff => ScriptSensorRequest::read_from(buffer),
            0xc300ffff => ScriptTeleportRequest::read_from(buffer),
            0x9c01ffff => SendPostcard::read_from(buffer),
            0x00000012 => SendXferPacket::read_from(buffer),
            0x5800ffff => SetAlwaysRun::read_from(buffer),
            0x4701ffff => SetCPURatio::read_from(buffer),
            0x9f00ffff => SetFollowCamProperties::read_from(buffer),
            0x7201ffff => SetGroupAcceptNotices::read_from(buffer),
            0x7101ffff => SetGroupContribution::read_from(buffer),
            0xf500ffff => SetScriptRunning::read_from(buffer),
            0x1700ffff => SetSimPresenceInDatabase::read_from(buffer),
            0x1600ffff => SetSimStatusInDatabase::read_from(buffer),
            0x4501ffff => SetStartLocation::read_from(buffer),
            0x4401ffff => SetStartLocationRequest::read_from(buffer),
            0x4801ffff => SimCrashed::read_from(buffer),
            0x8c00ffff => SimStats::read_from(buffer),
            0x00000cff => SimStatus::read_from(buffer),
            0x8100ffff => SimWideDeletes::read_from(buffer),
            0x0c00ffff => SimulatorLoad::read_from(buffer),
            0x0500ffff => SimulatorMapUpdate::read_from(buffer),
            0x0b00ffff => SimulatorPresentAtLocation::read_from(buffer),
            0x0900ffff => SimulatorReady::read_from(buffer),
            0x0600ffff => SimulatorSetMap::read_from(buffer),
            0x0d00ffff => SimulatorShutdownRequest::read_from(buffer),
            0x9600ffff => SimulatorViewerTimeMessage::read_from(buffer),
            0x0000001d => SoundTrigger::read_from(buffer),
            0xe500ffff => StartAuction::read_from(buffer),
            0x6b01ffff => StartGroupProposal::read_from(buffer),
            0x4600ffff => StartLure::read_from(buffer),
            0x00000001 => StartPingCheck::read_from(buffer),
            0x7f00ffff => StateSave::read_from(buffer),
            0x0700ffff => SubscribeLoad::read_from(buffer),
            0xa600ffff => SystemKickUser::read_from(buffer),
            0x9401ffff => SystemMessage::read_from(buffer),
            0x6d01ffff => TallyVotes::read_from(buffer),
            0x0a00ffff => TelehubInfo::read_from(buffer),
            0x4800ffff => TeleportCancel::read_from(buffer),
            0x4a00ffff => TeleportFailed::read_from(buffer),
            0x4500ffff => TeleportFinish::read_from(buffer),
            0x9300ffff => TeleportLandingStatusChanged::read_from(buffer),
            0x4100ffff => TeleportLandmarkRequest::read_from(buffer),
            0x4000ffff => TeleportLocal::read_from(buffer),
            0x3f00ffff => TeleportLocationRequest::read_from(buffer),
            0x4700ffff => TeleportLureRequest::read_from(buffer),
            0x4200ffff => TeleportProgress::read_from(buffer),
            0x3e00ffff => TeleportRequest::read_from(buffer),
            0x4900ffff => TeleportStart::read_from(buffer),
            0x2c01ffff => TerminateFriendship::read_from(buffer),
            0x0100ffff => TestMessage::read_from(buffer),
            0x8200ffff => TrackAgent::read_from(buffer),
            0x9b00ffff => TransferAbort::read_from(buffer),
            0x9a00ffff => TransferInfo::read_from(buffer),
            0x2701ffff => TransferInventory::read_from(buffer),
            0x2801ffff => TransferInventoryAck::read_from(buffer),
            0x00000011 => TransferPacket::read_from(buffer),
            0x9900ffff => TransferRequest::read_from(buffer),
            0xee00ffff => UUIDGroupNameReply::read_from(buffer),
            0xed00ffff => UUIDGroupNameRequest::read_from(buffer),
            0xec00ffff => UUIDNameReply::read_from(buffer),
            0xeb00ffff => UUIDNameRequest::read_from(buffer),
            0x4b00ffff => Undo::read_from(buffer),
            0x4d00ffff => UndoLand::read_from(buffer),
            0x0800ffff => UnsubscribeLoad::read_from(buffer),
            0x4b01ffff => UpdateAttachment::read_from(buffer),
            0x0b01ffff => UpdateCreateInventoryItem::read_from(buffer),
            0x5501ffff => UpdateGroupInfo::read_from(buffer),
            0x1201ffff => UpdateInventoryFolder::read_from(buffer),
            0x0a01ffff => UpdateInventoryItem::read_from(buffer),
            0x0701ffff => UpdateMuteListEntry::read_from(buffer),
            0xdd00ffff => UpdateParcel::read_from(buffer),
            0x1100ffff => UpdateSimulator::read_from(buffer),
            0x1e01ffff => UpdateTaskInventory::read_from(buffer),
            0x9101ffff => UpdateUserInfo::read_from(buffer),
            0x3f01ffff => UseCachedMuteList::read_from(buffer),
            0x0300ffff => UseCircuitCode::read_from(buffer),
            0x9001ffff => UserInfoReply::read_from(buffer),
            0x8f01ffff => UserInfoRequest::read_from(buffer),
            0x8500ffff => UserReport::read_from(buffer),
            0x1500ffff => UserReportInternal::read_from(buffer),
            0x7e00ffff => VelocityInterpolateOff::read_from(buffer),
            0x7d00ffff => VelocityInterpolateOn::read_from(buffer),
            0x000011ff => ViewerEffect::read_from(buffer),
            0x8900ffff => ViewerFrozenMessage::read_from(buffer),
            0xe400ffff => ViewerStartAuction::read_from(buffer),
            0x8300ffff => ViewerStats::read_from(buffer),
            _ => Err(ReadErrorKind::UnknownMessageNumber(message_num).into()),
        }
    }
}

impl From<AbortXfer> for MessageInstance {
    fn from(msg: AbortXfer) -> Self {
        MessageInstance::AbortXfer(msg)
    }
}

impl From<AcceptCallingCard> for MessageInstance {
    fn from(msg: AcceptCallingCard) -> Self {
        MessageInstance::AcceptCallingCard(msg)
    }
}

impl From<AcceptFriendship> for MessageInstance {
    fn from(msg: AcceptFriendship) -> Self {
        MessageInstance::AcceptFriendship(msg)
    }
}

impl From<ActivateGestures> for MessageInstance {
    fn from(msg: ActivateGestures) -> Self {
        MessageInstance::ActivateGestures(msg)
    }
}

impl From<ActivateGroup> for MessageInstance {
    fn from(msg: ActivateGroup) -> Self {
        MessageInstance::ActivateGroup(msg)
    }
}

impl From<AddCircuitCode> for MessageInstance {
    fn from(msg: AddCircuitCode) -> Self {
        MessageInstance::AddCircuitCode(msg)
    }
}

impl From<AgentAlertMessage> for MessageInstance {
    fn from(msg: AgentAlertMessage) -> Self {
        MessageInstance::AgentAlertMessage(msg)
    }
}

impl From<AgentAnimation> for MessageInstance {
    fn from(msg: AgentAnimation) -> Self {
        MessageInstance::AgentAnimation(msg)
    }
}

impl From<AgentCachedTexture> for MessageInstance {
    fn from(msg: AgentCachedTexture) -> Self {
        MessageInstance::AgentCachedTexture(msg)
    }
}

impl From<AgentCachedTextureResponse> for MessageInstance {
    fn from(msg: AgentCachedTextureResponse) -> Self {
        MessageInstance::AgentCachedTextureResponse(msg)
    }
}

impl From<AgentDataUpdate> for MessageInstance {
    fn from(msg: AgentDataUpdate) -> Self {
        MessageInstance::AgentDataUpdate(msg)
    }
}

impl From<AgentDataUpdateRequest> for MessageInstance {
    fn from(msg: AgentDataUpdateRequest) -> Self {
        MessageInstance::AgentDataUpdateRequest(msg)
    }
}

impl From<AgentDropGroup> for MessageInstance {
    fn from(msg: AgentDropGroup) -> Self {
        MessageInstance::AgentDropGroup(msg)
    }
}

impl From<AgentFOV> for MessageInstance {
    fn from(msg: AgentFOV) -> Self {
        MessageInstance::AgentFOV(msg)
    }
}

impl From<AgentGroupDataUpdate> for MessageInstance {
    fn from(msg: AgentGroupDataUpdate) -> Self {
        MessageInstance::AgentGroupDataUpdate(msg)
    }
}

impl From<AgentHeightWidth> for MessageInstance {
    fn from(msg: AgentHeightWidth) -> Self {
        MessageInstance::AgentHeightWidth(msg)
    }
}

impl From<AgentIsNowWearing> for MessageInstance {
    fn from(msg: AgentIsNowWearing) -> Self {
        MessageInstance::AgentIsNowWearing(msg)
    }
}

impl From<AgentMovementComplete> for MessageInstance {
    fn from(msg: AgentMovementComplete) -> Self {
        MessageInstance::AgentMovementComplete(msg)
    }
}

impl From<AgentPause> for MessageInstance {
    fn from(msg: AgentPause) -> Self {
        MessageInstance::AgentPause(msg)
    }
}

impl From<AgentQuitCopy> for MessageInstance {
    fn from(msg: AgentQuitCopy) -> Self {
        MessageInstance::AgentQuitCopy(msg)
    }
}

impl From<AgentRequestSit> for MessageInstance {
    fn from(msg: AgentRequestSit) -> Self {
        MessageInstance::AgentRequestSit(msg)
    }
}

impl From<AgentResume> for MessageInstance {
    fn from(msg: AgentResume) -> Self {
        MessageInstance::AgentResume(msg)
    }
}

impl From<AgentSetAppearance> for MessageInstance {
    fn from(msg: AgentSetAppearance) -> Self {
        MessageInstance::AgentSetAppearance(msg)
    }
}

impl From<AgentSit> for MessageInstance {
    fn from(msg: AgentSit) -> Self {
        MessageInstance::AgentSit(msg)
    }
}

impl From<AgentThrottle> for MessageInstance {
    fn from(msg: AgentThrottle) -> Self {
        MessageInstance::AgentThrottle(msg)
    }
}

impl From<AgentUpdate> for MessageInstance {
    fn from(msg: AgentUpdate) -> Self {
        MessageInstance::AgentUpdate(msg)
    }
}

impl From<AgentWearablesRequest> for MessageInstance {
    fn from(msg: AgentWearablesRequest) -> Self {
        MessageInstance::AgentWearablesRequest(msg)
    }
}

impl From<AgentWearablesUpdate> for MessageInstance {
    fn from(msg: AgentWearablesUpdate) -> Self {
        MessageInstance::AgentWearablesUpdate(msg)
    }
}

impl From<AlertMessage> for MessageInstance {
    fn from(msg: AlertMessage) -> Self {
        MessageInstance::AlertMessage(msg)
    }
}

impl From<AssetUploadComplete> for MessageInstance {
    fn from(msg: AssetUploadComplete) -> Self {
        MessageInstance::AssetUploadComplete(msg)
    }
}

impl From<AssetUploadRequest> for MessageInstance {
    fn from(msg: AssetUploadRequest) -> Self {
        MessageInstance::AssetUploadRequest(msg)
    }
}

impl From<AtomicPassObject> for MessageInstance {
    fn from(msg: AtomicPassObject) -> Self {
        MessageInstance::AtomicPassObject(msg)
    }
}

impl From<AttachedSound> for MessageInstance {
    fn from(msg: AttachedSound) -> Self {
        MessageInstance::AttachedSound(msg)
    }
}

impl From<AttachedSoundGainChange> for MessageInstance {
    fn from(msg: AttachedSoundGainChange) -> Self {
        MessageInstance::AttachedSoundGainChange(msg)
    }
}

impl From<AvatarAnimation> for MessageInstance {
    fn from(msg: AvatarAnimation) -> Self {
        MessageInstance::AvatarAnimation(msg)
    }
}

impl From<AvatarAppearance> for MessageInstance {
    fn from(msg: AvatarAppearance) -> Self {
        MessageInstance::AvatarAppearance(msg)
    }
}

impl From<AvatarClassifiedReply> for MessageInstance {
    fn from(msg: AvatarClassifiedReply) -> Self {
        MessageInstance::AvatarClassifiedReply(msg)
    }
}

impl From<AvatarGroupsReply> for MessageInstance {
    fn from(msg: AvatarGroupsReply) -> Self {
        MessageInstance::AvatarGroupsReply(msg)
    }
}

impl From<AvatarInterestsReply> for MessageInstance {
    fn from(msg: AvatarInterestsReply) -> Self {
        MessageInstance::AvatarInterestsReply(msg)
    }
}

impl From<AvatarInterestsUpdate> for MessageInstance {
    fn from(msg: AvatarInterestsUpdate) -> Self {
        MessageInstance::AvatarInterestsUpdate(msg)
    }
}

impl From<AvatarNotesReply> for MessageInstance {
    fn from(msg: AvatarNotesReply) -> Self {
        MessageInstance::AvatarNotesReply(msg)
    }
}

impl From<AvatarNotesUpdate> for MessageInstance {
    fn from(msg: AvatarNotesUpdate) -> Self {
        MessageInstance::AvatarNotesUpdate(msg)
    }
}

impl From<AvatarPickerReply> for MessageInstance {
    fn from(msg: AvatarPickerReply) -> Self {
        MessageInstance::AvatarPickerReply(msg)
    }
}

impl From<AvatarPickerRequest> for MessageInstance {
    fn from(msg: AvatarPickerRequest) -> Self {
        MessageInstance::AvatarPickerRequest(msg)
    }
}

impl From<AvatarPickerRequestBackend> for MessageInstance {
    fn from(msg: AvatarPickerRequestBackend) -> Self {
        MessageInstance::AvatarPickerRequestBackend(msg)
    }
}

impl From<AvatarPicksReply> for MessageInstance {
    fn from(msg: AvatarPicksReply) -> Self {
        MessageInstance::AvatarPicksReply(msg)
    }
}

impl From<AvatarPropertiesReply> for MessageInstance {
    fn from(msg: AvatarPropertiesReply) -> Self {
        MessageInstance::AvatarPropertiesReply(msg)
    }
}

impl From<AvatarPropertiesRequest> for MessageInstance {
    fn from(msg: AvatarPropertiesRequest) -> Self {
        MessageInstance::AvatarPropertiesRequest(msg)
    }
}

impl From<AvatarPropertiesRequestBackend> for MessageInstance {
    fn from(msg: AvatarPropertiesRequestBackend) -> Self {
        MessageInstance::AvatarPropertiesRequestBackend(msg)
    }
}

impl From<AvatarPropertiesUpdate> for MessageInstance {
    fn from(msg: AvatarPropertiesUpdate) -> Self {
        MessageInstance::AvatarPropertiesUpdate(msg)
    }
}

impl From<AvatarSitResponse> for MessageInstance {
    fn from(msg: AvatarSitResponse) -> Self {
        MessageInstance::AvatarSitResponse(msg)
    }
}

impl From<AvatarTextureUpdate> for MessageInstance {
    fn from(msg: AvatarTextureUpdate) -> Self {
        MessageInstance::AvatarTextureUpdate(msg)
    }
}

impl From<BulkUpdateInventory> for MessageInstance {
    fn from(msg: BulkUpdateInventory) -> Self {
        MessageInstance::BulkUpdateInventory(msg)
    }
}

impl From<BuyObjectInventory> for MessageInstance {
    fn from(msg: BuyObjectInventory) -> Self {
        MessageInstance::BuyObjectInventory(msg)
    }
}

impl From<CameraConstraint> for MessageInstance {
    fn from(msg: CameraConstraint) -> Self {
        MessageInstance::CameraConstraint(msg)
    }
}

impl From<CancelAuction> for MessageInstance {
    fn from(msg: CancelAuction) -> Self {
        MessageInstance::CancelAuction(msg)
    }
}

impl From<ChangeInventoryItemFlags> for MessageInstance {
    fn from(msg: ChangeInventoryItemFlags) -> Self {
        MessageInstance::ChangeInventoryItemFlags(msg)
    }
}

impl From<ChangeUserRights> for MessageInstance {
    fn from(msg: ChangeUserRights) -> Self {
        MessageInstance::ChangeUserRights(msg)
    }
}

impl From<ChatFromSimulator> for MessageInstance {
    fn from(msg: ChatFromSimulator) -> Self {
        MessageInstance::ChatFromSimulator(msg)
    }
}

impl From<ChatFromViewer> for MessageInstance {
    fn from(msg: ChatFromViewer) -> Self {
        MessageInstance::ChatFromViewer(msg)
    }
}

impl From<ChatPass> for MessageInstance {
    fn from(msg: ChatPass) -> Self {
        MessageInstance::ChatPass(msg)
    }
}

impl From<CheckParcelAuctions> for MessageInstance {
    fn from(msg: CheckParcelAuctions) -> Self {
        MessageInstance::CheckParcelAuctions(msg)
    }
}

impl From<CheckParcelSales> for MessageInstance {
    fn from(msg: CheckParcelSales) -> Self {
        MessageInstance::CheckParcelSales(msg)
    }
}

impl From<ChildAgentAlive> for MessageInstance {
    fn from(msg: ChildAgentAlive) -> Self {
        MessageInstance::ChildAgentAlive(msg)
    }
}

impl From<ChildAgentDying> for MessageInstance {
    fn from(msg: ChildAgentDying) -> Self {
        MessageInstance::ChildAgentDying(msg)
    }
}

impl From<ChildAgentPositionUpdate> for MessageInstance {
    fn from(msg: ChildAgentPositionUpdate) -> Self {
        MessageInstance::ChildAgentPositionUpdate(msg)
    }
}

impl From<ChildAgentUnknown> for MessageInstance {
    fn from(msg: ChildAgentUnknown) -> Self {
        MessageInstance::ChildAgentUnknown(msg)
    }
}

impl From<ChildAgentUpdate> for MessageInstance {
    fn from(msg: ChildAgentUpdate) -> Self {
        MessageInstance::ChildAgentUpdate(msg)
    }
}

impl From<ClassifiedDelete> for MessageInstance {
    fn from(msg: ClassifiedDelete) -> Self {
        MessageInstance::ClassifiedDelete(msg)
    }
}

impl From<ClassifiedGodDelete> for MessageInstance {
    fn from(msg: ClassifiedGodDelete) -> Self {
        MessageInstance::ClassifiedGodDelete(msg)
    }
}

impl From<ClassifiedInfoReply> for MessageInstance {
    fn from(msg: ClassifiedInfoReply) -> Self {
        MessageInstance::ClassifiedInfoReply(msg)
    }
}

impl From<ClassifiedInfoRequest> for MessageInstance {
    fn from(msg: ClassifiedInfoRequest) -> Self {
        MessageInstance::ClassifiedInfoRequest(msg)
    }
}

impl From<ClassifiedInfoUpdate> for MessageInstance {
    fn from(msg: ClassifiedInfoUpdate) -> Self {
        MessageInstance::ClassifiedInfoUpdate(msg)
    }
}

impl From<ClearFollowCamProperties> for MessageInstance {
    fn from(msg: ClearFollowCamProperties) -> Self {
        MessageInstance::ClearFollowCamProperties(msg)
    }
}

impl From<CloseCircuit> for MessageInstance {
    fn from(msg: CloseCircuit) -> Self {
        MessageInstance::CloseCircuit(msg)
    }
}

impl From<CoarseLocationUpdate> for MessageInstance {
    fn from(msg: CoarseLocationUpdate) -> Self {
        MessageInstance::CoarseLocationUpdate(msg)
    }
}

impl From<CompleteAgentMovement> for MessageInstance {
    fn from(msg: CompleteAgentMovement) -> Self {
        MessageInstance::CompleteAgentMovement(msg)
    }
}

impl From<CompleteAuction> for MessageInstance {
    fn from(msg: CompleteAuction) -> Self {
        MessageInstance::CompleteAuction(msg)
    }
}

impl From<CompletePingCheck> for MessageInstance {
    fn from(msg: CompletePingCheck) -> Self {
        MessageInstance::CompletePingCheck(msg)
    }
}

impl From<ConfirmAuctionStart> for MessageInstance {
    fn from(msg: ConfirmAuctionStart) -> Self {
        MessageInstance::ConfirmAuctionStart(msg)
    }
}

impl From<ConfirmEnableSimulator> for MessageInstance {
    fn from(msg: ConfirmEnableSimulator) -> Self {
        MessageInstance::ConfirmEnableSimulator(msg)
    }
}

impl From<ConfirmXferPacket> for MessageInstance {
    fn from(msg: ConfirmXferPacket) -> Self {
        MessageInstance::ConfirmXferPacket(msg)
    }
}

impl From<CopyInventoryFromNotecard> for MessageInstance {
    fn from(msg: CopyInventoryFromNotecard) -> Self {
        MessageInstance::CopyInventoryFromNotecard(msg)
    }
}

impl From<CopyInventoryItem> for MessageInstance {
    fn from(msg: CopyInventoryItem) -> Self {
        MessageInstance::CopyInventoryItem(msg)
    }
}

impl From<CreateGroupReply> for MessageInstance {
    fn from(msg: CreateGroupReply) -> Self {
        MessageInstance::CreateGroupReply(msg)
    }
}

impl From<CreateGroupRequest> for MessageInstance {
    fn from(msg: CreateGroupRequest) -> Self {
        MessageInstance::CreateGroupRequest(msg)
    }
}

impl From<CreateInventoryFolder> for MessageInstance {
    fn from(msg: CreateInventoryFolder) -> Self {
        MessageInstance::CreateInventoryFolder(msg)
    }
}

impl From<CreateInventoryItem> for MessageInstance {
    fn from(msg: CreateInventoryItem) -> Self {
        MessageInstance::CreateInventoryItem(msg)
    }
}

impl From<CreateLandmarkForEvent> for MessageInstance {
    fn from(msg: CreateLandmarkForEvent) -> Self {
        MessageInstance::CreateLandmarkForEvent(msg)
    }
}

impl From<CreateNewOutfitAttachments> for MessageInstance {
    fn from(msg: CreateNewOutfitAttachments) -> Self {
        MessageInstance::CreateNewOutfitAttachments(msg)
    }
}

impl From<CreateTrustedCircuit> for MessageInstance {
    fn from(msg: CreateTrustedCircuit) -> Self {
        MessageInstance::CreateTrustedCircuit(msg)
    }
}

impl From<CrossedRegion> for MessageInstance {
    fn from(msg: CrossedRegion) -> Self {
        MessageInstance::CrossedRegion(msg)
    }
}

impl From<DataHomeLocationReply> for MessageInstance {
    fn from(msg: DataHomeLocationReply) -> Self {
        MessageInstance::DataHomeLocationReply(msg)
    }
}

impl From<DataHomeLocationRequest> for MessageInstance {
    fn from(msg: DataHomeLocationRequest) -> Self {
        MessageInstance::DataHomeLocationRequest(msg)
    }
}

impl From<DataServerLogout> for MessageInstance {
    fn from(msg: DataServerLogout) -> Self {
        MessageInstance::DataServerLogout(msg)
    }
}

impl From<DeRezAck> for MessageInstance {
    fn from(msg: DeRezAck) -> Self {
        MessageInstance::DeRezAck(msg)
    }
}

impl From<DeRezObject> for MessageInstance {
    fn from(msg: DeRezObject) -> Self {
        MessageInstance::DeRezObject(msg)
    }
}

impl From<DeactivateGestures> for MessageInstance {
    fn from(msg: DeactivateGestures) -> Self {
        MessageInstance::DeactivateGestures(msg)
    }
}

impl From<DeclineCallingCard> for MessageInstance {
    fn from(msg: DeclineCallingCard) -> Self {
        MessageInstance::DeclineCallingCard(msg)
    }
}

impl From<DeclineFriendship> for MessageInstance {
    fn from(msg: DeclineFriendship) -> Self {
        MessageInstance::DeclineFriendship(msg)
    }
}

impl From<DenyTrustedCircuit> for MessageInstance {
    fn from(msg: DenyTrustedCircuit) -> Self {
        MessageInstance::DenyTrustedCircuit(msg)
    }
}

impl From<DerezContainer> for MessageInstance {
    fn from(msg: DerezContainer) -> Self {
        MessageInstance::DerezContainer(msg)
    }
}

impl From<DetachAttachmentIntoInv> for MessageInstance {
    fn from(msg: DetachAttachmentIntoInv) -> Self {
        MessageInstance::DetachAttachmentIntoInv(msg)
    }
}

impl From<DirClassifiedQuery> for MessageInstance {
    fn from(msg: DirClassifiedQuery) -> Self {
        MessageInstance::DirClassifiedQuery(msg)
    }
}

impl From<DirClassifiedQueryBackend> for MessageInstance {
    fn from(msg: DirClassifiedQueryBackend) -> Self {
        MessageInstance::DirClassifiedQueryBackend(msg)
    }
}

impl From<DirClassifiedReply> for MessageInstance {
    fn from(msg: DirClassifiedReply) -> Self {
        MessageInstance::DirClassifiedReply(msg)
    }
}

impl From<DirEventsReply> for MessageInstance {
    fn from(msg: DirEventsReply) -> Self {
        MessageInstance::DirEventsReply(msg)
    }
}

impl From<DirFindQuery> for MessageInstance {
    fn from(msg: DirFindQuery) -> Self {
        MessageInstance::DirFindQuery(msg)
    }
}

impl From<DirFindQueryBackend> for MessageInstance {
    fn from(msg: DirFindQueryBackend) -> Self {
        MessageInstance::DirFindQueryBackend(msg)
    }
}

impl From<DirGroupsReply> for MessageInstance {
    fn from(msg: DirGroupsReply) -> Self {
        MessageInstance::DirGroupsReply(msg)
    }
}

impl From<DirLandQuery> for MessageInstance {
    fn from(msg: DirLandQuery) -> Self {
        MessageInstance::DirLandQuery(msg)
    }
}

impl From<DirLandQueryBackend> for MessageInstance {
    fn from(msg: DirLandQueryBackend) -> Self {
        MessageInstance::DirLandQueryBackend(msg)
    }
}

impl From<DirLandReply> for MessageInstance {
    fn from(msg: DirLandReply) -> Self {
        MessageInstance::DirLandReply(msg)
    }
}

impl From<DirPeopleReply> for MessageInstance {
    fn from(msg: DirPeopleReply) -> Self {
        MessageInstance::DirPeopleReply(msg)
    }
}

impl From<DirPlacesQuery> for MessageInstance {
    fn from(msg: DirPlacesQuery) -> Self {
        MessageInstance::DirPlacesQuery(msg)
    }
}

impl From<DirPlacesQueryBackend> for MessageInstance {
    fn from(msg: DirPlacesQueryBackend) -> Self {
        MessageInstance::DirPlacesQueryBackend(msg)
    }
}

impl From<DirPlacesReply> for MessageInstance {
    fn from(msg: DirPlacesReply) -> Self {
        MessageInstance::DirPlacesReply(msg)
    }
}

impl From<DirPopularQuery> for MessageInstance {
    fn from(msg: DirPopularQuery) -> Self {
        MessageInstance::DirPopularQuery(msg)
    }
}

impl From<DirPopularQueryBackend> for MessageInstance {
    fn from(msg: DirPopularQueryBackend) -> Self {
        MessageInstance::DirPopularQueryBackend(msg)
    }
}

impl From<DirPopularReply> for MessageInstance {
    fn from(msg: DirPopularReply) -> Self {
        MessageInstance::DirPopularReply(msg)
    }
}

impl From<DisableSimulator> for MessageInstance {
    fn from(msg: DisableSimulator) -> Self {
        MessageInstance::DisableSimulator(msg)
    }
}

impl From<EconomyData> for MessageInstance {
    fn from(msg: EconomyData) -> Self {
        MessageInstance::EconomyData(msg)
    }
}

impl From<EconomyDataRequest> for MessageInstance {
    fn from(msg: EconomyDataRequest) -> Self {
        MessageInstance::EconomyDataRequest(msg)
    }
}

impl From<EdgeDataPacket> for MessageInstance {
    fn from(msg: EdgeDataPacket) -> Self {
        MessageInstance::EdgeDataPacket(msg)
    }
}

impl From<EjectGroupMemberReply> for MessageInstance {
    fn from(msg: EjectGroupMemberReply) -> Self {
        MessageInstance::EjectGroupMemberReply(msg)
    }
}

impl From<EjectGroupMemberRequest> for MessageInstance {
    fn from(msg: EjectGroupMemberRequest) -> Self {
        MessageInstance::EjectGroupMemberRequest(msg)
    }
}

impl From<EjectUser> for MessageInstance {
    fn from(msg: EjectUser) -> Self {
        MessageInstance::EjectUser(msg)
    }
}

impl From<EmailMessageReply> for MessageInstance {
    fn from(msg: EmailMessageReply) -> Self {
        MessageInstance::EmailMessageReply(msg)
    }
}

impl From<EmailMessageRequest> for MessageInstance {
    fn from(msg: EmailMessageRequest) -> Self {
        MessageInstance::EmailMessageRequest(msg)
    }
}

impl From<EnableSimulator> for MessageInstance {
    fn from(msg: EnableSimulator) -> Self {
        MessageInstance::EnableSimulator(msg)
    }
}

impl From<Error> for MessageInstance {
    fn from(msg: Error) -> Self {
        MessageInstance::Error(msg)
    }
}

impl From<EstateCovenantReply> for MessageInstance {
    fn from(msg: EstateCovenantReply) -> Self {
        MessageInstance::EstateCovenantReply(msg)
    }
}

impl From<EstateCovenantRequest> for MessageInstance {
    fn from(msg: EstateCovenantRequest) -> Self {
        MessageInstance::EstateCovenantRequest(msg)
    }
}

impl From<EstateOwnerMessage> for MessageInstance {
    fn from(msg: EstateOwnerMessage) -> Self {
        MessageInstance::EstateOwnerMessage(msg)
    }
}

impl From<EventGodDelete> for MessageInstance {
    fn from(msg: EventGodDelete) -> Self {
        MessageInstance::EventGodDelete(msg)
    }
}

impl From<EventInfoReply> for MessageInstance {
    fn from(msg: EventInfoReply) -> Self {
        MessageInstance::EventInfoReply(msg)
    }
}

impl From<EventInfoRequest> for MessageInstance {
    fn from(msg: EventInfoRequest) -> Self {
        MessageInstance::EventInfoRequest(msg)
    }
}

impl From<EventLocationReply> for MessageInstance {
    fn from(msg: EventLocationReply) -> Self {
        MessageInstance::EventLocationReply(msg)
    }
}

impl From<EventLocationRequest> for MessageInstance {
    fn from(msg: EventLocationRequest) -> Self {
        MessageInstance::EventLocationRequest(msg)
    }
}

impl From<EventNotificationAddRequest> for MessageInstance {
    fn from(msg: EventNotificationAddRequest) -> Self {
        MessageInstance::EventNotificationAddRequest(msg)
    }
}

impl From<EventNotificationRemoveRequest> for MessageInstance {
    fn from(msg: EventNotificationRemoveRequest) -> Self {
        MessageInstance::EventNotificationRemoveRequest(msg)
    }
}

impl From<FeatureDisabled> for MessageInstance {
    fn from(msg: FeatureDisabled) -> Self {
        MessageInstance::FeatureDisabled(msg)
    }
}

impl From<FetchInventory> for MessageInstance {
    fn from(msg: FetchInventory) -> Self {
        MessageInstance::FetchInventory(msg)
    }
}

impl From<FetchInventoryDescendents> for MessageInstance {
    fn from(msg: FetchInventoryDescendents) -> Self {
        MessageInstance::FetchInventoryDescendents(msg)
    }
}

impl From<FetchInventoryReply> for MessageInstance {
    fn from(msg: FetchInventoryReply) -> Self {
        MessageInstance::FetchInventoryReply(msg)
    }
}

impl From<FindAgent> for MessageInstance {
    fn from(msg: FindAgent) -> Self {
        MessageInstance::FindAgent(msg)
    }
}

impl From<ForceObjectSelect> for MessageInstance {
    fn from(msg: ForceObjectSelect) -> Self {
        MessageInstance::ForceObjectSelect(msg)
    }
}

impl From<ForceScriptControlRelease> for MessageInstance {
    fn from(msg: ForceScriptControlRelease) -> Self {
        MessageInstance::ForceScriptControlRelease(msg)
    }
}

impl From<FormFriendship> for MessageInstance {
    fn from(msg: FormFriendship) -> Self {
        MessageInstance::FormFriendship(msg)
    }
}

impl From<FreezeUser> for MessageInstance {
    fn from(msg: FreezeUser) -> Self {
        MessageInstance::FreezeUser(msg)
    }
}

impl From<GenericMessage> for MessageInstance {
    fn from(msg: GenericMessage) -> Self {
        MessageInstance::GenericMessage(msg)
    }
}

impl From<GetScriptRunning> for MessageInstance {
    fn from(msg: GetScriptRunning) -> Self {
        MessageInstance::GetScriptRunning(msg)
    }
}

impl From<GodKickUser> for MessageInstance {
    fn from(msg: GodKickUser) -> Self {
        MessageInstance::GodKickUser(msg)
    }
}

impl From<GodUpdateRegionInfo> for MessageInstance {
    fn from(msg: GodUpdateRegionInfo) -> Self {
        MessageInstance::GodUpdateRegionInfo(msg)
    }
}

impl From<GodlikeMessage> for MessageInstance {
    fn from(msg: GodlikeMessage) -> Self {
        MessageInstance::GodlikeMessage(msg)
    }
}

impl From<GrantGodlikePowers> for MessageInstance {
    fn from(msg: GrantGodlikePowers) -> Self {
        MessageInstance::GrantGodlikePowers(msg)
    }
}

impl From<GrantUserRights> for MessageInstance {
    fn from(msg: GrantUserRights) -> Self {
        MessageInstance::GrantUserRights(msg)
    }
}

impl From<GroupAccountDetailsReply> for MessageInstance {
    fn from(msg: GroupAccountDetailsReply) -> Self {
        MessageInstance::GroupAccountDetailsReply(msg)
    }
}

impl From<GroupAccountDetailsRequest> for MessageInstance {
    fn from(msg: GroupAccountDetailsRequest) -> Self {
        MessageInstance::GroupAccountDetailsRequest(msg)
    }
}

impl From<GroupAccountSummaryReply> for MessageInstance {
    fn from(msg: GroupAccountSummaryReply) -> Self {
        MessageInstance::GroupAccountSummaryReply(msg)
    }
}

impl From<GroupAccountSummaryRequest> for MessageInstance {
    fn from(msg: GroupAccountSummaryRequest) -> Self {
        MessageInstance::GroupAccountSummaryRequest(msg)
    }
}

impl From<GroupAccountTransactionsReply> for MessageInstance {
    fn from(msg: GroupAccountTransactionsReply) -> Self {
        MessageInstance::GroupAccountTransactionsReply(msg)
    }
}

impl From<GroupAccountTransactionsRequest> for MessageInstance {
    fn from(msg: GroupAccountTransactionsRequest) -> Self {
        MessageInstance::GroupAccountTransactionsRequest(msg)
    }
}

impl From<GroupActiveProposalItemReply> for MessageInstance {
    fn from(msg: GroupActiveProposalItemReply) -> Self {
        MessageInstance::GroupActiveProposalItemReply(msg)
    }
}

impl From<GroupActiveProposalsRequest> for MessageInstance {
    fn from(msg: GroupActiveProposalsRequest) -> Self {
        MessageInstance::GroupActiveProposalsRequest(msg)
    }
}

impl From<GroupDataUpdate> for MessageInstance {
    fn from(msg: GroupDataUpdate) -> Self {
        MessageInstance::GroupDataUpdate(msg)
    }
}

impl From<GroupMembersReply> for MessageInstance {
    fn from(msg: GroupMembersReply) -> Self {
        MessageInstance::GroupMembersReply(msg)
    }
}

impl From<GroupMembersRequest> for MessageInstance {
    fn from(msg: GroupMembersRequest) -> Self {
        MessageInstance::GroupMembersRequest(msg)
    }
}

impl From<GroupNoticeAdd> for MessageInstance {
    fn from(msg: GroupNoticeAdd) -> Self {
        MessageInstance::GroupNoticeAdd(msg)
    }
}

impl From<GroupNoticeRequest> for MessageInstance {
    fn from(msg: GroupNoticeRequest) -> Self {
        MessageInstance::GroupNoticeRequest(msg)
    }
}

impl From<GroupNoticesListReply> for MessageInstance {
    fn from(msg: GroupNoticesListReply) -> Self {
        MessageInstance::GroupNoticesListReply(msg)
    }
}

impl From<GroupNoticesListRequest> for MessageInstance {
    fn from(msg: GroupNoticesListRequest) -> Self {
        MessageInstance::GroupNoticesListRequest(msg)
    }
}

impl From<GroupProfileReply> for MessageInstance {
    fn from(msg: GroupProfileReply) -> Self {
        MessageInstance::GroupProfileReply(msg)
    }
}

impl From<GroupProfileRequest> for MessageInstance {
    fn from(msg: GroupProfileRequest) -> Self {
        MessageInstance::GroupProfileRequest(msg)
    }
}

impl From<GroupProposalBallot> for MessageInstance {
    fn from(msg: GroupProposalBallot) -> Self {
        MessageInstance::GroupProposalBallot(msg)
    }
}

impl From<GroupRoleChanges> for MessageInstance {
    fn from(msg: GroupRoleChanges) -> Self {
        MessageInstance::GroupRoleChanges(msg)
    }
}

impl From<GroupRoleDataReply> for MessageInstance {
    fn from(msg: GroupRoleDataReply) -> Self {
        MessageInstance::GroupRoleDataReply(msg)
    }
}

impl From<GroupRoleDataRequest> for MessageInstance {
    fn from(msg: GroupRoleDataRequest) -> Self {
        MessageInstance::GroupRoleDataRequest(msg)
    }
}

impl From<GroupRoleMembersReply> for MessageInstance {
    fn from(msg: GroupRoleMembersReply) -> Self {
        MessageInstance::GroupRoleMembersReply(msg)
    }
}

impl From<GroupRoleMembersRequest> for MessageInstance {
    fn from(msg: GroupRoleMembersRequest) -> Self {
        MessageInstance::GroupRoleMembersRequest(msg)
    }
}

impl From<GroupRoleUpdate> for MessageInstance {
    fn from(msg: GroupRoleUpdate) -> Self {
        MessageInstance::GroupRoleUpdate(msg)
    }
}

impl From<GroupTitleUpdate> for MessageInstance {
    fn from(msg: GroupTitleUpdate) -> Self {
        MessageInstance::GroupTitleUpdate(msg)
    }
}

impl From<GroupTitlesReply> for MessageInstance {
    fn from(msg: GroupTitlesReply) -> Self {
        MessageInstance::GroupTitlesReply(msg)
    }
}

impl From<GroupTitlesRequest> for MessageInstance {
    fn from(msg: GroupTitlesRequest) -> Self {
        MessageInstance::GroupTitlesRequest(msg)
    }
}

impl From<GroupVoteHistoryItemReply> for MessageInstance {
    fn from(msg: GroupVoteHistoryItemReply) -> Self {
        MessageInstance::GroupVoteHistoryItemReply(msg)
    }
}

impl From<GroupVoteHistoryRequest> for MessageInstance {
    fn from(msg: GroupVoteHistoryRequest) -> Self {
        MessageInstance::GroupVoteHistoryRequest(msg)
    }
}

impl From<HealthMessage> for MessageInstance {
    fn from(msg: HealthMessage) -> Self {
        MessageInstance::HealthMessage(msg)
    }
}

impl From<ImageData> for MessageInstance {
    fn from(msg: ImageData) -> Self {
        MessageInstance::ImageData(msg)
    }
}

impl From<ImageNotInDatabase> for MessageInstance {
    fn from(msg: ImageNotInDatabase) -> Self {
        MessageInstance::ImageNotInDatabase(msg)
    }
}

impl From<ImagePacket> for MessageInstance {
    fn from(msg: ImagePacket) -> Self {
        MessageInstance::ImagePacket(msg)
    }
}

impl From<ImprovedInstantMessage> for MessageInstance {
    fn from(msg: ImprovedInstantMessage) -> Self {
        MessageInstance::ImprovedInstantMessage(msg)
    }
}

impl From<ImprovedTerseObjectUpdate> for MessageInstance {
    fn from(msg: ImprovedTerseObjectUpdate) -> Self {
        MessageInstance::ImprovedTerseObjectUpdate(msg)
    }
}

impl From<InitiateDownload> for MessageInstance {
    fn from(msg: InitiateDownload) -> Self {
        MessageInstance::InitiateDownload(msg)
    }
}

impl From<InternalScriptMail> for MessageInstance {
    fn from(msg: InternalScriptMail) -> Self {
        MessageInstance::InternalScriptMail(msg)
    }
}

impl From<InventoryAssetResponse> for MessageInstance {
    fn from(msg: InventoryAssetResponse) -> Self {
        MessageInstance::InventoryAssetResponse(msg)
    }
}

impl From<InventoryDescendents> for MessageInstance {
    fn from(msg: InventoryDescendents) -> Self {
        MessageInstance::InventoryDescendents(msg)
    }
}

impl From<InviteGroupRequest> for MessageInstance {
    fn from(msg: InviteGroupRequest) -> Self {
        MessageInstance::InviteGroupRequest(msg)
    }
}

impl From<InviteGroupResponse> for MessageInstance {
    fn from(msg: InviteGroupResponse) -> Self {
        MessageInstance::InviteGroupResponse(msg)
    }
}

impl From<JoinGroupReply> for MessageInstance {
    fn from(msg: JoinGroupReply) -> Self {
        MessageInstance::JoinGroupReply(msg)
    }
}

impl From<JoinGroupRequest> for MessageInstance {
    fn from(msg: JoinGroupRequest) -> Self {
        MessageInstance::JoinGroupRequest(msg)
    }
}

impl From<KickUser> for MessageInstance {
    fn from(msg: KickUser) -> Self {
        MessageInstance::KickUser(msg)
    }
}

impl From<KickUserAck> for MessageInstance {
    fn from(msg: KickUserAck) -> Self {
        MessageInstance::KickUserAck(msg)
    }
}

impl From<KillChildAgents> for MessageInstance {
    fn from(msg: KillChildAgents) -> Self {
        MessageInstance::KillChildAgents(msg)
    }
}

impl From<KillObject> for MessageInstance {
    fn from(msg: KillObject) -> Self {
        MessageInstance::KillObject(msg)
    }
}

impl From<LandStatReply> for MessageInstance {
    fn from(msg: LandStatReply) -> Self {
        MessageInstance::LandStatReply(msg)
    }
}

impl From<LandStatRequest> for MessageInstance {
    fn from(msg: LandStatRequest) -> Self {
        MessageInstance::LandStatRequest(msg)
    }
}

impl From<LayerData> for MessageInstance {
    fn from(msg: LayerData) -> Self {
        MessageInstance::LayerData(msg)
    }
}

impl From<LeaveGroupReply> for MessageInstance {
    fn from(msg: LeaveGroupReply) -> Self {
        MessageInstance::LeaveGroupReply(msg)
    }
}

impl From<LeaveGroupRequest> for MessageInstance {
    fn from(msg: LeaveGroupRequest) -> Self {
        MessageInstance::LeaveGroupRequest(msg)
    }
}

impl From<LinkInventoryItem> for MessageInstance {
    fn from(msg: LinkInventoryItem) -> Self {
        MessageInstance::LinkInventoryItem(msg)
    }
}

impl From<LiveHelpGroupReply> for MessageInstance {
    fn from(msg: LiveHelpGroupReply) -> Self {
        MessageInstance::LiveHelpGroupReply(msg)
    }
}

impl From<LiveHelpGroupRequest> for MessageInstance {
    fn from(msg: LiveHelpGroupRequest) -> Self {
        MessageInstance::LiveHelpGroupRequest(msg)
    }
}

impl From<LoadURL> for MessageInstance {
    fn from(msg: LoadURL) -> Self {
        MessageInstance::LoadURL(msg)
    }
}

impl From<LogDwellTime> for MessageInstance {
    fn from(msg: LogDwellTime) -> Self {
        MessageInstance::LogDwellTime(msg)
    }
}

impl From<LogFailedMoneyTransaction> for MessageInstance {
    fn from(msg: LogFailedMoneyTransaction) -> Self {
        MessageInstance::LogFailedMoneyTransaction(msg)
    }
}

impl From<LogParcelChanges> for MessageInstance {
    fn from(msg: LogParcelChanges) -> Self {
        MessageInstance::LogParcelChanges(msg)
    }
}

impl From<LogTextMessage> for MessageInstance {
    fn from(msg: LogTextMessage) -> Self {
        MessageInstance::LogTextMessage(msg)
    }
}

impl From<LogoutReply> for MessageInstance {
    fn from(msg: LogoutReply) -> Self {
        MessageInstance::LogoutReply(msg)
    }
}

impl From<LogoutRequest> for MessageInstance {
    fn from(msg: LogoutRequest) -> Self {
        MessageInstance::LogoutRequest(msg)
    }
}

impl From<MapBlockReply> for MessageInstance {
    fn from(msg: MapBlockReply) -> Self {
        MessageInstance::MapBlockReply(msg)
    }
}

impl From<MapBlockRequest> for MessageInstance {
    fn from(msg: MapBlockRequest) -> Self {
        MessageInstance::MapBlockRequest(msg)
    }
}

impl From<MapItemReply> for MessageInstance {
    fn from(msg: MapItemReply) -> Self {
        MessageInstance::MapItemReply(msg)
    }
}

impl From<MapItemRequest> for MessageInstance {
    fn from(msg: MapItemRequest) -> Self {
        MessageInstance::MapItemRequest(msg)
    }
}

impl From<MapLayerReply> for MessageInstance {
    fn from(msg: MapLayerReply) -> Self {
        MessageInstance::MapLayerReply(msg)
    }
}

impl From<MapLayerRequest> for MessageInstance {
    fn from(msg: MapLayerRequest) -> Self {
        MessageInstance::MapLayerRequest(msg)
    }
}

impl From<MapNameRequest> for MessageInstance {
    fn from(msg: MapNameRequest) -> Self {
        MessageInstance::MapNameRequest(msg)
    }
}

impl From<MeanCollisionAlert> for MessageInstance {
    fn from(msg: MeanCollisionAlert) -> Self {
        MessageInstance::MeanCollisionAlert(msg)
    }
}

impl From<MergeParcel> for MessageInstance {
    fn from(msg: MergeParcel) -> Self {
        MessageInstance::MergeParcel(msg)
    }
}

impl From<ModifyLand> for MessageInstance {
    fn from(msg: ModifyLand) -> Self {
        MessageInstance::ModifyLand(msg)
    }
}

impl From<MoneyBalanceReply> for MessageInstance {
    fn from(msg: MoneyBalanceReply) -> Self {
        MessageInstance::MoneyBalanceReply(msg)
    }
}

impl From<MoneyBalanceRequest> for MessageInstance {
    fn from(msg: MoneyBalanceRequest) -> Self {
        MessageInstance::MoneyBalanceRequest(msg)
    }
}

impl From<MoneyTransferBackend> for MessageInstance {
    fn from(msg: MoneyTransferBackend) -> Self {
        MessageInstance::MoneyTransferBackend(msg)
    }
}

impl From<MoneyTransferRequest> for MessageInstance {
    fn from(msg: MoneyTransferRequest) -> Self {
        MessageInstance::MoneyTransferRequest(msg)
    }
}

impl From<MoveInventoryFolder> for MessageInstance {
    fn from(msg: MoveInventoryFolder) -> Self {
        MessageInstance::MoveInventoryFolder(msg)
    }
}

impl From<MoveInventoryItem> for MessageInstance {
    fn from(msg: MoveInventoryItem) -> Self {
        MessageInstance::MoveInventoryItem(msg)
    }
}

impl From<MoveTaskInventory> for MessageInstance {
    fn from(msg: MoveTaskInventory) -> Self {
        MessageInstance::MoveTaskInventory(msg)
    }
}

impl From<MultipleObjectUpdate> for MessageInstance {
    fn from(msg: MultipleObjectUpdate) -> Self {
        MessageInstance::MultipleObjectUpdate(msg)
    }
}

impl From<MuteListRequest> for MessageInstance {
    fn from(msg: MuteListRequest) -> Self {
        MessageInstance::MuteListRequest(msg)
    }
}

impl From<MuteListUpdate> for MessageInstance {
    fn from(msg: MuteListUpdate) -> Self {
        MessageInstance::MuteListUpdate(msg)
    }
}

impl From<NameValuePair> for MessageInstance {
    fn from(msg: NameValuePair) -> Self {
        MessageInstance::NameValuePair(msg)
    }
}

impl From<NearestLandingRegionReply> for MessageInstance {
    fn from(msg: NearestLandingRegionReply) -> Self {
        MessageInstance::NearestLandingRegionReply(msg)
    }
}

impl From<NearestLandingRegionRequest> for MessageInstance {
    fn from(msg: NearestLandingRegionRequest) -> Self {
        MessageInstance::NearestLandingRegionRequest(msg)
    }
}

impl From<NearestLandingRegionUpdated> for MessageInstance {
    fn from(msg: NearestLandingRegionUpdated) -> Self {
        MessageInstance::NearestLandingRegionUpdated(msg)
    }
}

impl From<NeighborList> for MessageInstance {
    fn from(msg: NeighborList) -> Self {
        MessageInstance::NeighborList(msg)
    }
}

impl From<NetTest> for MessageInstance {
    fn from(msg: NetTest) -> Self {
        MessageInstance::NetTest(msg)
    }
}

impl From<ObjectAdd> for MessageInstance {
    fn from(msg: ObjectAdd) -> Self {
        MessageInstance::ObjectAdd(msg)
    }
}

impl From<ObjectAttach> for MessageInstance {
    fn from(msg: ObjectAttach) -> Self {
        MessageInstance::ObjectAttach(msg)
    }
}

impl From<ObjectBuy> for MessageInstance {
    fn from(msg: ObjectBuy) -> Self {
        MessageInstance::ObjectBuy(msg)
    }
}

impl From<ObjectCategory> for MessageInstance {
    fn from(msg: ObjectCategory) -> Self {
        MessageInstance::ObjectCategory(msg)
    }
}

impl From<ObjectClickAction> for MessageInstance {
    fn from(msg: ObjectClickAction) -> Self {
        MessageInstance::ObjectClickAction(msg)
    }
}

impl From<ObjectDeGrab> for MessageInstance {
    fn from(msg: ObjectDeGrab) -> Self {
        MessageInstance::ObjectDeGrab(msg)
    }
}

impl From<ObjectDelete> for MessageInstance {
    fn from(msg: ObjectDelete) -> Self {
        MessageInstance::ObjectDelete(msg)
    }
}

impl From<ObjectDelink> for MessageInstance {
    fn from(msg: ObjectDelink) -> Self {
        MessageInstance::ObjectDelink(msg)
    }
}

impl From<ObjectDescription> for MessageInstance {
    fn from(msg: ObjectDescription) -> Self {
        MessageInstance::ObjectDescription(msg)
    }
}

impl From<ObjectDeselect> for MessageInstance {
    fn from(msg: ObjectDeselect) -> Self {
        MessageInstance::ObjectDeselect(msg)
    }
}

impl From<ObjectDetach> for MessageInstance {
    fn from(msg: ObjectDetach) -> Self {
        MessageInstance::ObjectDetach(msg)
    }
}

impl From<ObjectDrop> for MessageInstance {
    fn from(msg: ObjectDrop) -> Self {
        MessageInstance::ObjectDrop(msg)
    }
}

impl From<ObjectDuplicate> for MessageInstance {
    fn from(msg: ObjectDuplicate) -> Self {
        MessageInstance::ObjectDuplicate(msg)
    }
}

impl From<ObjectDuplicateOnRay> for MessageInstance {
    fn from(msg: ObjectDuplicateOnRay) -> Self {
        MessageInstance::ObjectDuplicateOnRay(msg)
    }
}

impl From<ObjectExportSelected> for MessageInstance {
    fn from(msg: ObjectExportSelected) -> Self {
        MessageInstance::ObjectExportSelected(msg)
    }
}

impl From<ObjectExtraParams> for MessageInstance {
    fn from(msg: ObjectExtraParams) -> Self {
        MessageInstance::ObjectExtraParams(msg)
    }
}

impl From<ObjectFlagUpdate> for MessageInstance {
    fn from(msg: ObjectFlagUpdate) -> Self {
        MessageInstance::ObjectFlagUpdate(msg)
    }
}

impl From<ObjectGrab> for MessageInstance {
    fn from(msg: ObjectGrab) -> Self {
        MessageInstance::ObjectGrab(msg)
    }
}

impl From<ObjectGrabUpdate> for MessageInstance {
    fn from(msg: ObjectGrabUpdate) -> Self {
        MessageInstance::ObjectGrabUpdate(msg)
    }
}

impl From<ObjectGroup> for MessageInstance {
    fn from(msg: ObjectGroup) -> Self {
        MessageInstance::ObjectGroup(msg)
    }
}

impl From<ObjectImage> for MessageInstance {
    fn from(msg: ObjectImage) -> Self {
        MessageInstance::ObjectImage(msg)
    }
}

impl From<ObjectIncludeInSearch> for MessageInstance {
    fn from(msg: ObjectIncludeInSearch) -> Self {
        MessageInstance::ObjectIncludeInSearch(msg)
    }
}

impl From<ObjectLink> for MessageInstance {
    fn from(msg: ObjectLink) -> Self {
        MessageInstance::ObjectLink(msg)
    }
}

impl From<ObjectMaterial> for MessageInstance {
    fn from(msg: ObjectMaterial) -> Self {
        MessageInstance::ObjectMaterial(msg)
    }
}

impl From<ObjectName> for MessageInstance {
    fn from(msg: ObjectName) -> Self {
        MessageInstance::ObjectName(msg)
    }
}

impl From<ObjectOwner> for MessageInstance {
    fn from(msg: ObjectOwner) -> Self {
        MessageInstance::ObjectOwner(msg)
    }
}

impl From<ObjectPermissions> for MessageInstance {
    fn from(msg: ObjectPermissions) -> Self {
        MessageInstance::ObjectPermissions(msg)
    }
}

impl From<ObjectPosition> for MessageInstance {
    fn from(msg: ObjectPosition) -> Self {
        MessageInstance::ObjectPosition(msg)
    }
}

impl From<ObjectProperties> for MessageInstance {
    fn from(msg: ObjectProperties) -> Self {
        MessageInstance::ObjectProperties(msg)
    }
}

impl From<ObjectPropertiesFamily> for MessageInstance {
    fn from(msg: ObjectPropertiesFamily) -> Self {
        MessageInstance::ObjectPropertiesFamily(msg)
    }
}

impl From<ObjectRotation> for MessageInstance {
    fn from(msg: ObjectRotation) -> Self {
        MessageInstance::ObjectRotation(msg)
    }
}

impl From<ObjectSaleInfo> for MessageInstance {
    fn from(msg: ObjectSaleInfo) -> Self {
        MessageInstance::ObjectSaleInfo(msg)
    }
}

impl From<ObjectScale> for MessageInstance {
    fn from(msg: ObjectScale) -> Self {
        MessageInstance::ObjectScale(msg)
    }
}

impl From<ObjectSelect> for MessageInstance {
    fn from(msg: ObjectSelect) -> Self {
        MessageInstance::ObjectSelect(msg)
    }
}

impl From<ObjectShape> for MessageInstance {
    fn from(msg: ObjectShape) -> Self {
        MessageInstance::ObjectShape(msg)
    }
}

impl From<ObjectSpinStart> for MessageInstance {
    fn from(msg: ObjectSpinStart) -> Self {
        MessageInstance::ObjectSpinStart(msg)
    }
}

impl From<ObjectSpinStop> for MessageInstance {
    fn from(msg: ObjectSpinStop) -> Self {
        MessageInstance::ObjectSpinStop(msg)
    }
}

impl From<ObjectSpinUpdate> for MessageInstance {
    fn from(msg: ObjectSpinUpdate) -> Self {
        MessageInstance::ObjectSpinUpdate(msg)
    }
}

impl From<ObjectUpdate> for MessageInstance {
    fn from(msg: ObjectUpdate) -> Self {
        MessageInstance::ObjectUpdate(msg)
    }
}

impl From<ObjectUpdateCached> for MessageInstance {
    fn from(msg: ObjectUpdateCached) -> Self {
        MessageInstance::ObjectUpdateCached(msg)
    }
}

impl From<ObjectUpdateCompressed> for MessageInstance {
    fn from(msg: ObjectUpdateCompressed) -> Self {
        MessageInstance::ObjectUpdateCompressed(msg)
    }
}

impl From<OfferCallingCard> for MessageInstance {
    fn from(msg: OfferCallingCard) -> Self {
        MessageInstance::OfferCallingCard(msg)
    }
}

impl From<OfflineNotification> for MessageInstance {
    fn from(msg: OfflineNotification) -> Self {
        MessageInstance::OfflineNotification(msg)
    }
}

impl From<OnlineNotification> for MessageInstance {
    fn from(msg: OnlineNotification) -> Self {
        MessageInstance::OnlineNotification(msg)
    }
}

impl From<OpenCircuit> for MessageInstance {
    fn from(msg: OpenCircuit) -> Self {
        MessageInstance::OpenCircuit(msg)
    }
}

impl From<PacketAck> for MessageInstance {
    fn from(msg: PacketAck) -> Self {
        MessageInstance::PacketAck(msg)
    }
}

impl From<ParcelAccessListReply> for MessageInstance {
    fn from(msg: ParcelAccessListReply) -> Self {
        MessageInstance::ParcelAccessListReply(msg)
    }
}

impl From<ParcelAccessListRequest> for MessageInstance {
    fn from(msg: ParcelAccessListRequest) -> Self {
        MessageInstance::ParcelAccessListRequest(msg)
    }
}

impl From<ParcelAccessListUpdate> for MessageInstance {
    fn from(msg: ParcelAccessListUpdate) -> Self {
        MessageInstance::ParcelAccessListUpdate(msg)
    }
}

impl From<ParcelAuctions> for MessageInstance {
    fn from(msg: ParcelAuctions) -> Self {
        MessageInstance::ParcelAuctions(msg)
    }
}

impl From<ParcelBuy> for MessageInstance {
    fn from(msg: ParcelBuy) -> Self {
        MessageInstance::ParcelBuy(msg)
    }
}

impl From<ParcelBuyPass> for MessageInstance {
    fn from(msg: ParcelBuyPass) -> Self {
        MessageInstance::ParcelBuyPass(msg)
    }
}

impl From<ParcelClaim> for MessageInstance {
    fn from(msg: ParcelClaim) -> Self {
        MessageInstance::ParcelClaim(msg)
    }
}

impl From<ParcelDeedToGroup> for MessageInstance {
    fn from(msg: ParcelDeedToGroup) -> Self {
        MessageInstance::ParcelDeedToGroup(msg)
    }
}

impl From<ParcelDisableObjects> for MessageInstance {
    fn from(msg: ParcelDisableObjects) -> Self {
        MessageInstance::ParcelDisableObjects(msg)
    }
}

impl From<ParcelDivide> for MessageInstance {
    fn from(msg: ParcelDivide) -> Self {
        MessageInstance::ParcelDivide(msg)
    }
}

impl From<ParcelDwellReply> for MessageInstance {
    fn from(msg: ParcelDwellReply) -> Self {
        MessageInstance::ParcelDwellReply(msg)
    }
}

impl From<ParcelDwellRequest> for MessageInstance {
    fn from(msg: ParcelDwellRequest) -> Self {
        MessageInstance::ParcelDwellRequest(msg)
    }
}

impl From<ParcelGodForceOwner> for MessageInstance {
    fn from(msg: ParcelGodForceOwner) -> Self {
        MessageInstance::ParcelGodForceOwner(msg)
    }
}

impl From<ParcelGodMarkAsContent> for MessageInstance {
    fn from(msg: ParcelGodMarkAsContent) -> Self {
        MessageInstance::ParcelGodMarkAsContent(msg)
    }
}

impl From<ParcelInfoReply> for MessageInstance {
    fn from(msg: ParcelInfoReply) -> Self {
        MessageInstance::ParcelInfoReply(msg)
    }
}

impl From<ParcelInfoRequest> for MessageInstance {
    fn from(msg: ParcelInfoRequest) -> Self {
        MessageInstance::ParcelInfoRequest(msg)
    }
}

impl From<ParcelJoin> for MessageInstance {
    fn from(msg: ParcelJoin) -> Self {
        MessageInstance::ParcelJoin(msg)
    }
}

impl From<ParcelMediaCommandMessage> for MessageInstance {
    fn from(msg: ParcelMediaCommandMessage) -> Self {
        MessageInstance::ParcelMediaCommandMessage(msg)
    }
}

impl From<ParcelMediaUpdate> for MessageInstance {
    fn from(msg: ParcelMediaUpdate) -> Self {
        MessageInstance::ParcelMediaUpdate(msg)
    }
}

impl From<ParcelObjectOwnersReply> for MessageInstance {
    fn from(msg: ParcelObjectOwnersReply) -> Self {
        MessageInstance::ParcelObjectOwnersReply(msg)
    }
}

impl From<ParcelObjectOwnersRequest> for MessageInstance {
    fn from(msg: ParcelObjectOwnersRequest) -> Self {
        MessageInstance::ParcelObjectOwnersRequest(msg)
    }
}

impl From<ParcelOverlay> for MessageInstance {
    fn from(msg: ParcelOverlay) -> Self {
        MessageInstance::ParcelOverlay(msg)
    }
}

impl From<ParcelProperties> for MessageInstance {
    fn from(msg: ParcelProperties) -> Self {
        MessageInstance::ParcelProperties(msg)
    }
}

impl From<ParcelPropertiesRequest> for MessageInstance {
    fn from(msg: ParcelPropertiesRequest) -> Self {
        MessageInstance::ParcelPropertiesRequest(msg)
    }
}

impl From<ParcelPropertiesRequestByID> for MessageInstance {
    fn from(msg: ParcelPropertiesRequestByID) -> Self {
        MessageInstance::ParcelPropertiesRequestByID(msg)
    }
}

impl From<ParcelPropertiesUpdate> for MessageInstance {
    fn from(msg: ParcelPropertiesUpdate) -> Self {
        MessageInstance::ParcelPropertiesUpdate(msg)
    }
}

impl From<ParcelReclaim> for MessageInstance {
    fn from(msg: ParcelReclaim) -> Self {
        MessageInstance::ParcelReclaim(msg)
    }
}

impl From<ParcelRelease> for MessageInstance {
    fn from(msg: ParcelRelease) -> Self {
        MessageInstance::ParcelRelease(msg)
    }
}

impl From<ParcelRename> for MessageInstance {
    fn from(msg: ParcelRename) -> Self {
        MessageInstance::ParcelRename(msg)
    }
}

impl From<ParcelReturnObjects> for MessageInstance {
    fn from(msg: ParcelReturnObjects) -> Self {
        MessageInstance::ParcelReturnObjects(msg)
    }
}

impl From<ParcelSales> for MessageInstance {
    fn from(msg: ParcelSales) -> Self {
        MessageInstance::ParcelSales(msg)
    }
}

impl From<ParcelSelectObjects> for MessageInstance {
    fn from(msg: ParcelSelectObjects) -> Self {
        MessageInstance::ParcelSelectObjects(msg)
    }
}

impl From<ParcelSetOtherCleanTime> for MessageInstance {
    fn from(msg: ParcelSetOtherCleanTime) -> Self {
        MessageInstance::ParcelSetOtherCleanTime(msg)
    }
}

impl From<PayPriceReply> for MessageInstance {
    fn from(msg: PayPriceReply) -> Self {
        MessageInstance::PayPriceReply(msg)
    }
}

impl From<PickDelete> for MessageInstance {
    fn from(msg: PickDelete) -> Self {
        MessageInstance::PickDelete(msg)
    }
}

impl From<PickGodDelete> for MessageInstance {
    fn from(msg: PickGodDelete) -> Self {
        MessageInstance::PickGodDelete(msg)
    }
}

impl From<PickInfoReply> for MessageInstance {
    fn from(msg: PickInfoReply) -> Self {
        MessageInstance::PickInfoReply(msg)
    }
}

impl From<PickInfoUpdate> for MessageInstance {
    fn from(msg: PickInfoUpdate) -> Self {
        MessageInstance::PickInfoUpdate(msg)
    }
}

impl From<PlacesQuery> for MessageInstance {
    fn from(msg: PlacesQuery) -> Self {
        MessageInstance::PlacesQuery(msg)
    }
}

impl From<PlacesReply> for MessageInstance {
    fn from(msg: PlacesReply) -> Self {
        MessageInstance::PlacesReply(msg)
    }
}

impl From<PreloadSound> for MessageInstance {
    fn from(msg: PreloadSound) -> Self {
        MessageInstance::PreloadSound(msg)
    }
}

impl From<PurgeInventoryDescendents> for MessageInstance {
    fn from(msg: PurgeInventoryDescendents) -> Self {
        MessageInstance::PurgeInventoryDescendents(msg)
    }
}

impl From<RebakeAvatarTextures> for MessageInstance {
    fn from(msg: RebakeAvatarTextures) -> Self {
        MessageInstance::RebakeAvatarTextures(msg)
    }
}

impl From<Redo> for MessageInstance {
    fn from(msg: Redo) -> Self {
        MessageInstance::Redo(msg)
    }
}

impl From<RegionHandleRequest> for MessageInstance {
    fn from(msg: RegionHandleRequest) -> Self {
        MessageInstance::RegionHandleRequest(msg)
    }
}

impl From<RegionHandshake> for MessageInstance {
    fn from(msg: RegionHandshake) -> Self {
        MessageInstance::RegionHandshake(msg)
    }
}

impl From<RegionHandshakeReply> for MessageInstance {
    fn from(msg: RegionHandshakeReply) -> Self {
        MessageInstance::RegionHandshakeReply(msg)
    }
}

impl From<RegionIDAndHandleReply> for MessageInstance {
    fn from(msg: RegionIDAndHandleReply) -> Self {
        MessageInstance::RegionIDAndHandleReply(msg)
    }
}

impl From<RegionInfo> for MessageInstance {
    fn from(msg: RegionInfo) -> Self {
        MessageInstance::RegionInfo(msg)
    }
}

impl From<RegionPresenceRequestByHandle> for MessageInstance {
    fn from(msg: RegionPresenceRequestByHandle) -> Self {
        MessageInstance::RegionPresenceRequestByHandle(msg)
    }
}

impl From<RegionPresenceRequestByRegionID> for MessageInstance {
    fn from(msg: RegionPresenceRequestByRegionID) -> Self {
        MessageInstance::RegionPresenceRequestByRegionID(msg)
    }
}

impl From<RegionPresenceResponse> for MessageInstance {
    fn from(msg: RegionPresenceResponse) -> Self {
        MessageInstance::RegionPresenceResponse(msg)
    }
}

impl From<RemoveAttachment> for MessageInstance {
    fn from(msg: RemoveAttachment) -> Self {
        MessageInstance::RemoveAttachment(msg)
    }
}

impl From<RemoveInventoryFolder> for MessageInstance {
    fn from(msg: RemoveInventoryFolder) -> Self {
        MessageInstance::RemoveInventoryFolder(msg)
    }
}

impl From<RemoveInventoryItem> for MessageInstance {
    fn from(msg: RemoveInventoryItem) -> Self {
        MessageInstance::RemoveInventoryItem(msg)
    }
}

impl From<RemoveInventoryObjects> for MessageInstance {
    fn from(msg: RemoveInventoryObjects) -> Self {
        MessageInstance::RemoveInventoryObjects(msg)
    }
}

impl From<RemoveMuteListEntry> for MessageInstance {
    fn from(msg: RemoveMuteListEntry) -> Self {
        MessageInstance::RemoveMuteListEntry(msg)
    }
}

impl From<RemoveNameValuePair> for MessageInstance {
    fn from(msg: RemoveNameValuePair) -> Self {
        MessageInstance::RemoveNameValuePair(msg)
    }
}

impl From<RemoveParcel> for MessageInstance {
    fn from(msg: RemoveParcel) -> Self {
        MessageInstance::RemoveParcel(msg)
    }
}

impl From<RemoveTaskInventory> for MessageInstance {
    fn from(msg: RemoveTaskInventory) -> Self {
        MessageInstance::RemoveTaskInventory(msg)
    }
}

impl From<ReplyTaskInventory> for MessageInstance {
    fn from(msg: ReplyTaskInventory) -> Self {
        MessageInstance::ReplyTaskInventory(msg)
    }
}

impl From<ReportAutosaveCrash> for MessageInstance {
    fn from(msg: ReportAutosaveCrash) -> Self {
        MessageInstance::ReportAutosaveCrash(msg)
    }
}

impl From<RequestGodlikePowers> for MessageInstance {
    fn from(msg: RequestGodlikePowers) -> Self {
        MessageInstance::RequestGodlikePowers(msg)
    }
}

impl From<RequestImage> for MessageInstance {
    fn from(msg: RequestImage) -> Self {
        MessageInstance::RequestImage(msg)
    }
}

impl From<RequestInventoryAsset> for MessageInstance {
    fn from(msg: RequestInventoryAsset) -> Self {
        MessageInstance::RequestInventoryAsset(msg)
    }
}

impl From<RequestMultipleObjects> for MessageInstance {
    fn from(msg: RequestMultipleObjects) -> Self {
        MessageInstance::RequestMultipleObjects(msg)
    }
}

impl From<RequestObjectPropertiesFamily> for MessageInstance {
    fn from(msg: RequestObjectPropertiesFamily) -> Self {
        MessageInstance::RequestObjectPropertiesFamily(msg)
    }
}

impl From<RequestParcelTransfer> for MessageInstance {
    fn from(msg: RequestParcelTransfer) -> Self {
        MessageInstance::RequestParcelTransfer(msg)
    }
}

impl From<RequestPayPrice> for MessageInstance {
    fn from(msg: RequestPayPrice) -> Self {
        MessageInstance::RequestPayPrice(msg)
    }
}

impl From<RequestRegionInfo> for MessageInstance {
    fn from(msg: RequestRegionInfo) -> Self {
        MessageInstance::RequestRegionInfo(msg)
    }
}

impl From<RequestTaskInventory> for MessageInstance {
    fn from(msg: RequestTaskInventory) -> Self {
        MessageInstance::RequestTaskInventory(msg)
    }
}

impl From<RequestTrustedCircuit> for MessageInstance {
    fn from(msg: RequestTrustedCircuit) -> Self {
        MessageInstance::RequestTrustedCircuit(msg)
    }
}

impl From<RequestXfer> for MessageInstance {
    fn from(msg: RequestXfer) -> Self {
        MessageInstance::RequestXfer(msg)
    }
}

impl From<RetrieveInstantMessages> for MessageInstance {
    fn from(msg: RetrieveInstantMessages) -> Self {
        MessageInstance::RetrieveInstantMessages(msg)
    }
}

impl From<RevokePermissions> for MessageInstance {
    fn from(msg: RevokePermissions) -> Self {
        MessageInstance::RevokePermissions(msg)
    }
}

impl From<RezMultipleAttachmentsFromInv> for MessageInstance {
    fn from(msg: RezMultipleAttachmentsFromInv) -> Self {
        MessageInstance::RezMultipleAttachmentsFromInv(msg)
    }
}

impl From<RezObject> for MessageInstance {
    fn from(msg: RezObject) -> Self {
        MessageInstance::RezObject(msg)
    }
}

impl From<RezObjectFromNotecard> for MessageInstance {
    fn from(msg: RezObjectFromNotecard) -> Self {
        MessageInstance::RezObjectFromNotecard(msg)
    }
}

impl From<RezRestoreToWorld> for MessageInstance {
    fn from(msg: RezRestoreToWorld) -> Self {
        MessageInstance::RezRestoreToWorld(msg)
    }
}

impl From<RezScript> for MessageInstance {
    fn from(msg: RezScript) -> Self {
        MessageInstance::RezScript(msg)
    }
}

impl From<RezSingleAttachmentFromInv> for MessageInstance {
    fn from(msg: RezSingleAttachmentFromInv) -> Self {
        MessageInstance::RezSingleAttachmentFromInv(msg)
    }
}

impl From<RoutedMoneyBalanceReply> for MessageInstance {
    fn from(msg: RoutedMoneyBalanceReply) -> Self {
        MessageInstance::RoutedMoneyBalanceReply(msg)
    }
}

impl From<RpcChannelReply> for MessageInstance {
    fn from(msg: RpcChannelReply) -> Self {
        MessageInstance::RpcChannelReply(msg)
    }
}

impl From<RpcChannelRequest> for MessageInstance {
    fn from(msg: RpcChannelRequest) -> Self {
        MessageInstance::RpcChannelRequest(msg)
    }
}

impl From<RpcScriptReplyInbound> for MessageInstance {
    fn from(msg: RpcScriptReplyInbound) -> Self {
        MessageInstance::RpcScriptReplyInbound(msg)
    }
}

impl From<RpcScriptRequestInbound> for MessageInstance {
    fn from(msg: RpcScriptRequestInbound) -> Self {
        MessageInstance::RpcScriptRequestInbound(msg)
    }
}

impl From<RpcScriptRequestInboundForward> for MessageInstance {
    fn from(msg: RpcScriptRequestInboundForward) -> Self {
        MessageInstance::RpcScriptRequestInboundForward(msg)
    }
}

impl From<SaveAssetIntoInventory> for MessageInstance {
    fn from(msg: SaveAssetIntoInventory) -> Self {
        MessageInstance::SaveAssetIntoInventory(msg)
    }
}

impl From<ScriptAnswerYes> for MessageInstance {
    fn from(msg: ScriptAnswerYes) -> Self {
        MessageInstance::ScriptAnswerYes(msg)
    }
}

impl From<ScriptControlChange> for MessageInstance {
    fn from(msg: ScriptControlChange) -> Self {
        MessageInstance::ScriptControlChange(msg)
    }
}

impl From<ScriptDataReply> for MessageInstance {
    fn from(msg: ScriptDataReply) -> Self {
        MessageInstance::ScriptDataReply(msg)
    }
}

impl From<ScriptDataRequest> for MessageInstance {
    fn from(msg: ScriptDataRequest) -> Self {
        MessageInstance::ScriptDataRequest(msg)
    }
}

impl From<ScriptDialog> for MessageInstance {
    fn from(msg: ScriptDialog) -> Self {
        MessageInstance::ScriptDialog(msg)
    }
}

impl From<ScriptDialogReply> for MessageInstance {
    fn from(msg: ScriptDialogReply) -> Self {
        MessageInstance::ScriptDialogReply(msg)
    }
}

impl From<ScriptMailRegistration> for MessageInstance {
    fn from(msg: ScriptMailRegistration) -> Self {
        MessageInstance::ScriptMailRegistration(msg)
    }
}

impl From<ScriptQuestion> for MessageInstance {
    fn from(msg: ScriptQuestion) -> Self {
        MessageInstance::ScriptQuestion(msg)
    }
}

impl From<ScriptReset> for MessageInstance {
    fn from(msg: ScriptReset) -> Self {
        MessageInstance::ScriptReset(msg)
    }
}

impl From<ScriptRunningReply> for MessageInstance {
    fn from(msg: ScriptRunningReply) -> Self {
        MessageInstance::ScriptRunningReply(msg)
    }
}

impl From<ScriptSensorReply> for MessageInstance {
    fn from(msg: ScriptSensorReply) -> Self {
        MessageInstance::ScriptSensorReply(msg)
    }
}

impl From<ScriptSensorRequest> for MessageInstance {
    fn from(msg: ScriptSensorRequest) -> Self {
        MessageInstance::ScriptSensorRequest(msg)
    }
}

impl From<ScriptTeleportRequest> for MessageInstance {
    fn from(msg: ScriptTeleportRequest) -> Self {
        MessageInstance::ScriptTeleportRequest(msg)
    }
}

impl From<SendPostcard> for MessageInstance {
    fn from(msg: SendPostcard) -> Self {
        MessageInstance::SendPostcard(msg)
    }
}

impl From<SendXferPacket> for MessageInstance {
    fn from(msg: SendXferPacket) -> Self {
        MessageInstance::SendXferPacket(msg)
    }
}

impl From<SetAlwaysRun> for MessageInstance {
    fn from(msg: SetAlwaysRun) -> Self {
        MessageInstance::SetAlwaysRun(msg)
    }
}

impl From<SetCPURatio> for MessageInstance {
    fn from(msg: SetCPURatio) -> Self {
        MessageInstance::SetCPURatio(msg)
    }
}

impl From<SetFollowCamProperties> for MessageInstance {
    fn from(msg: SetFollowCamProperties) -> Self {
        MessageInstance::SetFollowCamProperties(msg)
    }
}

impl From<SetGroupAcceptNotices> for MessageInstance {
    fn from(msg: SetGroupAcceptNotices) -> Self {
        MessageInstance::SetGroupAcceptNotices(msg)
    }
}

impl From<SetGroupContribution> for MessageInstance {
    fn from(msg: SetGroupContribution) -> Self {
        MessageInstance::SetGroupContribution(msg)
    }
}

impl From<SetScriptRunning> for MessageInstance {
    fn from(msg: SetScriptRunning) -> Self {
        MessageInstance::SetScriptRunning(msg)
    }
}

impl From<SetSimPresenceInDatabase> for MessageInstance {
    fn from(msg: SetSimPresenceInDatabase) -> Self {
        MessageInstance::SetSimPresenceInDatabase(msg)
    }
}

impl From<SetSimStatusInDatabase> for MessageInstance {
    fn from(msg: SetSimStatusInDatabase) -> Self {
        MessageInstance::SetSimStatusInDatabase(msg)
    }
}

impl From<SetStartLocation> for MessageInstance {
    fn from(msg: SetStartLocation) -> Self {
        MessageInstance::SetStartLocation(msg)
    }
}

impl From<SetStartLocationRequest> for MessageInstance {
    fn from(msg: SetStartLocationRequest) -> Self {
        MessageInstance::SetStartLocationRequest(msg)
    }
}

impl From<SimCrashed> for MessageInstance {
    fn from(msg: SimCrashed) -> Self {
        MessageInstance::SimCrashed(msg)
    }
}

impl From<SimStats> for MessageInstance {
    fn from(msg: SimStats) -> Self {
        MessageInstance::SimStats(msg)
    }
}

impl From<SimStatus> for MessageInstance {
    fn from(msg: SimStatus) -> Self {
        MessageInstance::SimStatus(msg)
    }
}

impl From<SimWideDeletes> for MessageInstance {
    fn from(msg: SimWideDeletes) -> Self {
        MessageInstance::SimWideDeletes(msg)
    }
}

impl From<SimulatorLoad> for MessageInstance {
    fn from(msg: SimulatorLoad) -> Self {
        MessageInstance::SimulatorLoad(msg)
    }
}

impl From<SimulatorMapUpdate> for MessageInstance {
    fn from(msg: SimulatorMapUpdate) -> Self {
        MessageInstance::SimulatorMapUpdate(msg)
    }
}

impl From<SimulatorPresentAtLocation> for MessageInstance {
    fn from(msg: SimulatorPresentAtLocation) -> Self {
        MessageInstance::SimulatorPresentAtLocation(msg)
    }
}

impl From<SimulatorReady> for MessageInstance {
    fn from(msg: SimulatorReady) -> Self {
        MessageInstance::SimulatorReady(msg)
    }
}

impl From<SimulatorSetMap> for MessageInstance {
    fn from(msg: SimulatorSetMap) -> Self {
        MessageInstance::SimulatorSetMap(msg)
    }
}

impl From<SimulatorShutdownRequest> for MessageInstance {
    fn from(msg: SimulatorShutdownRequest) -> Self {
        MessageInstance::SimulatorShutdownRequest(msg)
    }
}

impl From<SimulatorViewerTimeMessage> for MessageInstance {
    fn from(msg: SimulatorViewerTimeMessage) -> Self {
        MessageInstance::SimulatorViewerTimeMessage(msg)
    }
}

impl From<SoundTrigger> for MessageInstance {
    fn from(msg: SoundTrigger) -> Self {
        MessageInstance::SoundTrigger(msg)
    }
}

impl From<StartAuction> for MessageInstance {
    fn from(msg: StartAuction) -> Self {
        MessageInstance::StartAuction(msg)
    }
}

impl From<StartGroupProposal> for MessageInstance {
    fn from(msg: StartGroupProposal) -> Self {
        MessageInstance::StartGroupProposal(msg)
    }
}

impl From<StartLure> for MessageInstance {
    fn from(msg: StartLure) -> Self {
        MessageInstance::StartLure(msg)
    }
}

impl From<StartPingCheck> for MessageInstance {
    fn from(msg: StartPingCheck) -> Self {
        MessageInstance::StartPingCheck(msg)
    }
}

impl From<StateSave> for MessageInstance {
    fn from(msg: StateSave) -> Self {
        MessageInstance::StateSave(msg)
    }
}

impl From<SubscribeLoad> for MessageInstance {
    fn from(msg: SubscribeLoad) -> Self {
        MessageInstance::SubscribeLoad(msg)
    }
}

impl From<SystemKickUser> for MessageInstance {
    fn from(msg: SystemKickUser) -> Self {
        MessageInstance::SystemKickUser(msg)
    }
}

impl From<SystemMessage> for MessageInstance {
    fn from(msg: SystemMessage) -> Self {
        MessageInstance::SystemMessage(msg)
    }
}

impl From<TallyVotes> for MessageInstance {
    fn from(msg: TallyVotes) -> Self {
        MessageInstance::TallyVotes(msg)
    }
}

impl From<TelehubInfo> for MessageInstance {
    fn from(msg: TelehubInfo) -> Self {
        MessageInstance::TelehubInfo(msg)
    }
}

impl From<TeleportCancel> for MessageInstance {
    fn from(msg: TeleportCancel) -> Self {
        MessageInstance::TeleportCancel(msg)
    }
}

impl From<TeleportFailed> for MessageInstance {
    fn from(msg: TeleportFailed) -> Self {
        MessageInstance::TeleportFailed(msg)
    }
}

impl From<TeleportFinish> for MessageInstance {
    fn from(msg: TeleportFinish) -> Self {
        MessageInstance::TeleportFinish(msg)
    }
}

impl From<TeleportLandingStatusChanged> for MessageInstance {
    fn from(msg: TeleportLandingStatusChanged) -> Self {
        MessageInstance::TeleportLandingStatusChanged(msg)
    }
}

impl From<TeleportLandmarkRequest> for MessageInstance {
    fn from(msg: TeleportLandmarkRequest) -> Self {
        MessageInstance::TeleportLandmarkRequest(msg)
    }
}

impl From<TeleportLocal> for MessageInstance {
    fn from(msg: TeleportLocal) -> Self {
        MessageInstance::TeleportLocal(msg)
    }
}

impl From<TeleportLocationRequest> for MessageInstance {
    fn from(msg: TeleportLocationRequest) -> Self {
        MessageInstance::TeleportLocationRequest(msg)
    }
}

impl From<TeleportLureRequest> for MessageInstance {
    fn from(msg: TeleportLureRequest) -> Self {
        MessageInstance::TeleportLureRequest(msg)
    }
}

impl From<TeleportProgress> for MessageInstance {
    fn from(msg: TeleportProgress) -> Self {
        MessageInstance::TeleportProgress(msg)
    }
}

impl From<TeleportRequest> for MessageInstance {
    fn from(msg: TeleportRequest) -> Self {
        MessageInstance::TeleportRequest(msg)
    }
}

impl From<TeleportStart> for MessageInstance {
    fn from(msg: TeleportStart) -> Self {
        MessageInstance::TeleportStart(msg)
    }
}

impl From<TerminateFriendship> for MessageInstance {
    fn from(msg: TerminateFriendship) -> Self {
        MessageInstance::TerminateFriendship(msg)
    }
}

impl From<TestMessage> for MessageInstance {
    fn from(msg: TestMessage) -> Self {
        MessageInstance::TestMessage(msg)
    }
}

impl From<TrackAgent> for MessageInstance {
    fn from(msg: TrackAgent) -> Self {
        MessageInstance::TrackAgent(msg)
    }
}

impl From<TransferAbort> for MessageInstance {
    fn from(msg: TransferAbort) -> Self {
        MessageInstance::TransferAbort(msg)
    }
}

impl From<TransferInfo> for MessageInstance {
    fn from(msg: TransferInfo) -> Self {
        MessageInstance::TransferInfo(msg)
    }
}

impl From<TransferInventory> for MessageInstance {
    fn from(msg: TransferInventory) -> Self {
        MessageInstance::TransferInventory(msg)
    }
}

impl From<TransferInventoryAck> for MessageInstance {
    fn from(msg: TransferInventoryAck) -> Self {
        MessageInstance::TransferInventoryAck(msg)
    }
}

impl From<TransferPacket> for MessageInstance {
    fn from(msg: TransferPacket) -> Self {
        MessageInstance::TransferPacket(msg)
    }
}

impl From<TransferRequest> for MessageInstance {
    fn from(msg: TransferRequest) -> Self {
        MessageInstance::TransferRequest(msg)
    }
}

impl From<UUIDGroupNameReply> for MessageInstance {
    fn from(msg: UUIDGroupNameReply) -> Self {
        MessageInstance::UUIDGroupNameReply(msg)
    }
}

impl From<UUIDGroupNameRequest> for MessageInstance {
    fn from(msg: UUIDGroupNameRequest) -> Self {
        MessageInstance::UUIDGroupNameRequest(msg)
    }
}

impl From<UUIDNameReply> for MessageInstance {
    fn from(msg: UUIDNameReply) -> Self {
        MessageInstance::UUIDNameReply(msg)
    }
}

impl From<UUIDNameRequest> for MessageInstance {
    fn from(msg: UUIDNameRequest) -> Self {
        MessageInstance::UUIDNameRequest(msg)
    }
}

impl From<Undo> for MessageInstance {
    fn from(msg: Undo) -> Self {
        MessageInstance::Undo(msg)
    }
}

impl From<UndoLand> for MessageInstance {
    fn from(msg: UndoLand) -> Self {
        MessageInstance::UndoLand(msg)
    }
}

impl From<UnsubscribeLoad> for MessageInstance {
    fn from(msg: UnsubscribeLoad) -> Self {
        MessageInstance::UnsubscribeLoad(msg)
    }
}

impl From<UpdateAttachment> for MessageInstance {
    fn from(msg: UpdateAttachment) -> Self {
        MessageInstance::UpdateAttachment(msg)
    }
}

impl From<UpdateCreateInventoryItem> for MessageInstance {
    fn from(msg: UpdateCreateInventoryItem) -> Self {
        MessageInstance::UpdateCreateInventoryItem(msg)
    }
}

impl From<UpdateGroupInfo> for MessageInstance {
    fn from(msg: UpdateGroupInfo) -> Self {
        MessageInstance::UpdateGroupInfo(msg)
    }
}

impl From<UpdateInventoryFolder> for MessageInstance {
    fn from(msg: UpdateInventoryFolder) -> Self {
        MessageInstance::UpdateInventoryFolder(msg)
    }
}

impl From<UpdateInventoryItem> for MessageInstance {
    fn from(msg: UpdateInventoryItem) -> Self {
        MessageInstance::UpdateInventoryItem(msg)
    }
}

impl From<UpdateMuteListEntry> for MessageInstance {
    fn from(msg: UpdateMuteListEntry) -> Self {
        MessageInstance::UpdateMuteListEntry(msg)
    }
}

impl From<UpdateParcel> for MessageInstance {
    fn from(msg: UpdateParcel) -> Self {
        MessageInstance::UpdateParcel(msg)
    }
}

impl From<UpdateSimulator> for MessageInstance {
    fn from(msg: UpdateSimulator) -> Self {
        MessageInstance::UpdateSimulator(msg)
    }
}

impl From<UpdateTaskInventory> for MessageInstance {
    fn from(msg: UpdateTaskInventory) -> Self {
        MessageInstance::UpdateTaskInventory(msg)
    }
}

impl From<UpdateUserInfo> for MessageInstance {
    fn from(msg: UpdateUserInfo) -> Self {
        MessageInstance::UpdateUserInfo(msg)
    }
}

impl From<UseCachedMuteList> for MessageInstance {
    fn from(msg: UseCachedMuteList) -> Self {
        MessageInstance::UseCachedMuteList(msg)
    }
}

impl From<UseCircuitCode> for MessageInstance {
    fn from(msg: UseCircuitCode) -> Self {
        MessageInstance::UseCircuitCode(msg)
    }
}

impl From<UserInfoReply> for MessageInstance {
    fn from(msg: UserInfoReply) -> Self {
        MessageInstance::UserInfoReply(msg)
    }
}

impl From<UserInfoRequest> for MessageInstance {
    fn from(msg: UserInfoRequest) -> Self {
        MessageInstance::UserInfoRequest(msg)
    }
}

impl From<UserReport> for MessageInstance {
    fn from(msg: UserReport) -> Self {
        MessageInstance::UserReport(msg)
    }
}

impl From<UserReportInternal> for MessageInstance {
    fn from(msg: UserReportInternal) -> Self {
        MessageInstance::UserReportInternal(msg)
    }
}

impl From<VelocityInterpolateOff> for MessageInstance {
    fn from(msg: VelocityInterpolateOff) -> Self {
        MessageInstance::VelocityInterpolateOff(msg)
    }
}

impl From<VelocityInterpolateOn> for MessageInstance {
    fn from(msg: VelocityInterpolateOn) -> Self {
        MessageInstance::VelocityInterpolateOn(msg)
    }
}

impl From<ViewerEffect> for MessageInstance {
    fn from(msg: ViewerEffect) -> Self {
        MessageInstance::ViewerEffect(msg)
    }
}

impl From<ViewerFrozenMessage> for MessageInstance {
    fn from(msg: ViewerFrozenMessage) -> Self {
        MessageInstance::ViewerFrozenMessage(msg)
    }
}

impl From<ViewerStartAuction> for MessageInstance {
    fn from(msg: ViewerStartAuction) -> Self {
        MessageInstance::ViewerStartAuction(msg)
    }
}

impl From<ViewerStats> for MessageInstance {
    fn from(msg: ViewerStats) -> Self {
        MessageInstance::ViewerStats(msg)
    }
}





// BLOCK IMPLEMENTATIONS

impl AbortXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AbortXfer_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            result: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AcceptCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptCallingCard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptCallingCard_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptCallingCard_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptFriendship_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AcceptFriendship_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ActivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ActivateGestures_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ActivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ActivateGestures_Data {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gesture_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ActivateGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ActivateGroup_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AddCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AddCircuitCode_CircuitCode {
            code: buffer.read_u32::<LittleEndian>()?,
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentAlertMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentAlertMessage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentAlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentAlertMessage_AlertData {
            modal: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentAnimation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentAnimation_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentAnimation_AnimationList {
            anim_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            start_anim: buffer.read_u8()? == 1,
        })
    }
}

impl AgentAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentCachedTexture_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentCachedTexture_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AgentCachedTexture_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentCachedTexture_WearableData {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
        })
    }
}

impl AgentCachedTextureResponse_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentCachedTextureResponse_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AgentCachedTextureResponse_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentCachedTextureResponse_WearableData {
            texture_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            active_group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentDataUpdateRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentDataUpdateRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentDropGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentDropGroup_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentFOV_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentFOV_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentFOV_FOVBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentFOV_FOVBlock {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            vertical_angle: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl AgentGroupDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentGroupDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentGroupDataUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentGroupDataUpdate_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
            group_insignia_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentHeightWidth_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentHeightWidth_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentHeightWidth_HeightWidthBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentHeightWidth_HeightWidthBlock {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            height: buffer.read_u16::<LittleEndian>()?,
            width: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl AgentIsNowWearing_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentIsNowWearing_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentIsNowWearing_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentIsNowWearing_WearableData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            wearable_type: buffer.read_u8()?,
        })
    }
}

impl AgentMovementComplete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentMovementComplete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentMovementComplete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentMovementComplete_Data {
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            region_handle: buffer.read_u64::<LittleEndian>()?,
            timestamp: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentMovementComplete_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentMovementComplete_SimData {
            channel_version: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentPause_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentPause_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentQuitCopy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentQuitCopy_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentQuitCopy_FuseBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentQuitCopy_FuseBlock {
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentRequestSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentRequestSit_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentRequestSit_TargetObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentRequestSit_TargetObject {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl AgentResume_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentResume_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentSetAppearance_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentSetAppearance_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl AgentSetAppearance_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentSetAppearance_WearableData {
            cache_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
        })
    }
}

impl AgentSetAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentSetAppearance_ObjectData {
            texture_entry: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentSetAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentSetAppearance_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl AgentSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentSit_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentThrottle_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentThrottle_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentThrottle_Throttle {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentThrottle_Throttle {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            throttles: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            body_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            head_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            state: buffer.read_u8()?,
            camera_center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            far: buffer.read_f32::<LittleEndian>()?,
            control_flags: buffer.read_u32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
        })
    }
}

impl AgentWearablesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentWearablesRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentWearablesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentWearablesUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentWearablesUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AgentWearablesUpdate_WearableData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            wearable_type: buffer.read_u8()?,
        })
    }
}

impl AlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AlertMessage_AlertData {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AlertMessage_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AlertMessage_AlertInfo {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AssetUploadComplete_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AssetUploadComplete_AssetBlock {
            uuid: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            success: buffer.read_u8()? == 1,
        })
    }
}

impl AssetUploadRequest_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AssetUploadRequest_AssetBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            tempfile: buffer.read_u8()? == 1,
            store_local: buffer.read_u8()? == 1,
            asset_data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AtomicPassObject_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AtomicPassObject_TaskData {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_needs_save: buffer.read_u8()? == 1,
        })
    }
}

impl AttachedSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AttachedSound_DataBlock {
            sound_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
        })
    }
}

impl AttachedSoundGainChange_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AttachedSoundGainChange_DataBlock {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl AvatarAnimation_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAnimation_Sender {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAnimation_AnimationList {
            anim_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            anim_sequence_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AvatarAnimation_AnimationSourceList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAnimation_AnimationSourceList {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarAppearance_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAppearance_Sender {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_trial: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAppearance_ObjectData {
            texture_entry: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarAppearance_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl AvatarClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarClassifiedReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarClassifiedReply_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarGroupsReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarGroupsReply_GroupData {
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_insignia_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarGroupsReply_NewGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarGroupsReply_NewGroupData {
            list_in_profile: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarInterestsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarInterestsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarInterestsReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarInterestsReply_PropertiesData {
            want_to_mask: buffer.read_u32::<LittleEndian>()?,
            want_to_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            skills_mask: buffer.read_u32::<LittleEndian>()?,
            skills_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            languages_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarInterestsUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarInterestsUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarInterestsUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarInterestsUpdate_PropertiesData {
            want_to_mask: buffer.read_u32::<LittleEndian>()?,
            want_to_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            skills_mask: buffer.read_u32::<LittleEndian>()?,
            skills_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            languages_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarNotesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarNotesReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarNotesReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarNotesReply_Data {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            notes: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarNotesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarNotesUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarNotesUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarNotesUpdate_Data {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            notes: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPickerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPickerReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerReply_Data {
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPickerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPickerRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerRequest_Data {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPickerRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_level: buffer.read_u8()?,
        })
    }
}

impl AvatarPickerRequestBackend_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPickerRequestBackend_Data {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPicksReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPicksReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPicksReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPicksReply_Data {
            pick_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pick_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPropertiesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesReply_PropertiesData {
            image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            fl_image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            partner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            about_text: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            fl_about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            born_on: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            profile_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter_member: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AvatarPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_level: buffer.read_u8()?,
            web_profiles_disabled: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarPropertiesUpdate_PropertiesData {
            image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            fl_image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            about_text: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            fl_about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
            profile_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarSitResponse_SitObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarSitResponse_SitObject {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarSitResponse_SitTransform {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarSitResponse_SitTransform {
            auto_pilot: buffer.read_u8()? == 1,
            sit_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sit_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            camera_eye_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_at_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            force_mouselook: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarTextureUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarTextureUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            textures_changed: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarTextureUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarTextureUpdate_WearableData {
            cache_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarTextureUpdate_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(AvatarTextureUpdate_TextureData {
            texture_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl BulkUpdateInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(BulkUpdateInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl BulkUpdateInventory_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(BulkUpdateInventory_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl BulkUpdateInventory_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(BulkUpdateInventory_ItemData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl BuyObjectInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(BuyObjectInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl BuyObjectInventory_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(BuyObjectInventory_Data {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CameraConstraint_CameraCollidePlane {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CameraConstraint_CameraCollidePlane {
            plane: Vector4::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl CancelAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CancelAuction_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeInventoryItemFlags_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChangeInventoryItemFlags_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeInventoryItemFlags_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChangeInventoryItemFlags_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ChangeUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChangeUserRights_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChangeUserRights_Rights {
            agent_related: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            related_rights: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ChatFromSimulator_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChatFromSimulator_ChatData {
            from_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            source_type: buffer.read_u8()?,
            chat_type: buffer.read_u8()?,
            audible: buffer.read_u8()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ChatFromViewer_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChatFromViewer_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChatFromViewer_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChatFromViewer_ChatData {
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_u8()?,
            channel: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ChatPass_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChatPass_ChatData {
            channel: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            source_type: buffer.read_u8()?,
            type_: buffer.read_u8()?,
            radius: buffer.read_f32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CheckParcelAuctions_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CheckParcelAuctions_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl CheckParcelSales_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CheckParcelSales_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl ChildAgentAlive_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentAlive_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentDying_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentDying_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentPositionUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentPositionUpdate_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_vel: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            changed_grid: buffer.read_u8()? == 1,
        })
    }
}

impl ChildAgentUnknown_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUnknown_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_vel: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            changed_grid: buffer.read_u8()? == 1,
            far: buffer.read_f32::<LittleEndian>()?,
            aspect: buffer.read_f32::<LittleEndian>()?,
            throttles: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            locomotion_state: buffer.read_u32::<LittleEndian>()?,
            head_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            body_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            control_flags: buffer.read_u32::<LittleEndian>()?,
            energy_level: buffer.read_f32::<LittleEndian>()?,
            god_level: buffer.read_u8()?,
            always_run: buffer.read_u8()? == 1,
            prey_agent: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_access: buffer.read_u8()?,
            agent_textures: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            active_group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
        })
    }
}

impl ChildAgentUpdate_AnimationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_AnimationData {
            animation: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_GranterBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_GranterBlock {
            granter_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_NVPairData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_NVPairData {
            nv_pairs: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ChildAgentUpdate_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl ChildAgentUpdate_AgentAccess {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_AgentAccess {
            agent_legacy_access: buffer.read_u8()?,
            agent_max_access: buffer.read_u8()?,
        })
    }
}

impl ChildAgentUpdate_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ChildAgentUpdate_AgentInfo {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ClassifiedDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedDelete_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedGodDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedGodDelete_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoReply_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creation_date: buffer.read_u32::<LittleEndian>()?,
            expiration_date: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate: buffer.read_u32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            parcel_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            classified_flags: buffer.read_u8()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ClassifiedInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoRequest_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClassifiedInfoUpdate_Data {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            category: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate: buffer.read_u32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            classified_flags: buffer.read_u8()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ClearFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ClearFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CoarseLocationUpdate_Location {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CoarseLocationUpdate_Location {
            x: buffer.read_u8()?,
            y: buffer.read_u8()?,
            z: buffer.read_u8()?,
        })
    }
}

impl CoarseLocationUpdate_Index {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CoarseLocationUpdate_Index {
            you: buffer.read_i16::<LittleEndian>()?,
            prey: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl CoarseLocationUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CoarseLocationUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CompleteAgentMovement_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CompleteAgentMovement_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CompleteAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CompleteAuction_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CompletePingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CompletePingCheck_PingID {
            ping_id: buffer.read_u8()?,
        })
    }
}

impl ConfirmAuctionStart_AuctionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ConfirmAuctionStart_AuctionData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            auction_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ConfirmEnableSimulator_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ConfirmEnableSimulator_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ConfirmXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ConfirmXferPacket_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CopyInventoryFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CopyInventoryFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CopyInventoryFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CopyInventoryFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CopyInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CopyInventoryItem_InventoryData {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            old_agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateGroupReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateGroupReply_ReplyData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateGroupRequest_GroupData {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            insignia_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl CreateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateInventoryItem_InventoryBlock {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            wearable_type: buffer.read_u8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateLandmarkForEvent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateLandmarkForEvent_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateLandmarkForEvent_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateLandmarkForEvent_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CreateLandmarkForEvent_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateLandmarkForEvent_InventoryBlock {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateNewOutfitAttachments_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateNewOutfitAttachments_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateNewOutfitAttachments_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateNewOutfitAttachments_HeaderData {
            new_folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateNewOutfitAttachments_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateNewOutfitAttachments_ObjectData {
            old_item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CreateTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            digest: {
                let mut raw = [0; 32];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CrossedRegion_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CrossedRegion_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CrossedRegion_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CrossedRegion_RegionData {
            sim_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            sim_port: buffer.read_u16::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            seed_capability: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CrossedRegion_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(CrossedRegion_Info {
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl DataHomeLocationReply_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DataHomeLocationReply_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl DataHomeLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DataHomeLocationRequest_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            kicked_from_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DataHomeLocationRequest_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DataHomeLocationRequest_AgentInfo {
            agent_effective_maturity: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DataServerLogout_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DataServerLogout_UserData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            viewer_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            disconnect: buffer.read_u8()? == 1,
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeRezAck_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeRezAck_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl DeRezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeRezObject_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeRezObject_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeRezObject_AgentBlock {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            destination: buffer.read_u8()?,
            destination_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            packet_count: buffer.read_u8()?,
            packet_number: buffer.read_u8()?,
        })
    }
}

impl DeRezObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeRezObject_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeactivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeactivateGestures_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeactivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeactivateGestures_Data {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gesture_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeclineCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeclineCallingCard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeclineCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeclineFriendship_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DeclineFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DenyTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DenyTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DerezContainer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DerezContainer_Data {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            delete: buffer.read_u8()? == 1,
        })
    }
}

impl DetachAttachmentIntoInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DetachAttachmentIntoInv_ObjectData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedQuery_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedQueryBackend_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedReply_QueryReplies {
            classified_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            classified_flags: buffer.read_u8()?,
            creation_date: buffer.read_u32::<LittleEndian>()?,
            expiration_date: buffer.read_u32::<LittleEndian>()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirClassifiedReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirEventsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirEventsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirEventsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirEventsReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirEventsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirEventsReply_QueryReplies {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            event_id: buffer.read_u32::<LittleEndian>()?,
            date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            unix_time: buffer.read_u32::<LittleEndian>()?,
            event_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirEventsReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirEventsReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirFindQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirFindQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirFindQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirFindQuery_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirFindQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirFindQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirFindQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirFindQueryBackend_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirGroupsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirGroupsReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirGroupsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirGroupsReply_QueryReplies {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            members: buffer.read_i32::<LittleEndian>()?,
            search_order: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl DirLandQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandQuery_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            search_type: buffer.read_u32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirLandQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandQueryBackend_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            search_type: buffer.read_u32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirLandReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirLandReply_QueryReplies {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            auction: buffer.read_u8()? == 1,
            for_sale: buffer.read_u8()? == 1,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPeopleReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPeopleReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPeopleReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPeopleReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPeopleReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPeopleReply_QueryReplies {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            online: buffer.read_u8()? == 1,
            reputation: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesQuery_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesQueryBackend_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesReply_QueryReplies {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            for_sale: buffer.read_u8()? == 1,
            auction: buffer.read_u8()? == 1,
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPlacesReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirPopularQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularQuery_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirPopularQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularQueryBackend_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirPopularReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(DirPopularReply_QueryReplies {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl EconomyData_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EconomyData_Info {
            object_capacity: buffer.read_i32::<LittleEndian>()?,
            object_count: buffer.read_i32::<LittleEndian>()?,
            price_energy_unit: buffer.read_i32::<LittleEndian>()?,
            price_object_claim: buffer.read_i32::<LittleEndian>()?,
            price_public_object_decay: buffer.read_i32::<LittleEndian>()?,
            price_public_object_delete: buffer.read_i32::<LittleEndian>()?,
            price_parcel_claim: buffer.read_i32::<LittleEndian>()?,
            price_parcel_claim_factor: buffer.read_f32::<LittleEndian>()?,
            price_upload: buffer.read_i32::<LittleEndian>()?,
            price_rent_light: buffer.read_i32::<LittleEndian>()?,
            teleport_min_price: buffer.read_i32::<LittleEndian>()?,
            teleport_price_exponent: buffer.read_f32::<LittleEndian>()?,
            energy_efficiency: buffer.read_f32::<LittleEndian>()?,
            price_object_rent: buffer.read_f32::<LittleEndian>()?,
            price_object_scale_factor: buffer.read_f32::<LittleEndian>()?,
            price_parcel_rent: buffer.read_i32::<LittleEndian>()?,
            price_group_create: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl EdgeDataPacket_EdgeData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EdgeDataPacket_EdgeData {
            layer_type: buffer.read_u8()?,
            direction: buffer.read_u8()?,
            layer_data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EjectGroupMemberReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberReply_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberReply_EjectData {
            success: buffer.read_u8()? == 1,
        })
    }
}

impl EjectGroupMemberRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberRequest_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectGroupMemberRequest_EjectData {
            ejectee_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectUser_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EjectUser_Data {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EmailMessageReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EmailMessageReply_DataBlock {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            more: buffer.read_u32::<LittleEndian>()?,
            time: buffer.read_u32::<LittleEndian>()?,
            from_address: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            mail_filter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EmailMessageRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EmailMessageRequest_DataBlock {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            from_address: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EnableSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EnableSimulator_SimulatorInfo {
            handle: buffer.read_u64::<LittleEndian>()?,
            ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl Error_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Error_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Error_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Error_Data {
            code: buffer.read_i32::<LittleEndian>()?,
            token: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            system: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EstateCovenantReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EstateCovenantReply_Data {
            covenant_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            covenant_timestamp: buffer.read_u32::<LittleEndian>()?,
            estate_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateCovenantRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EstateCovenantRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateOwnerMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EstateOwnerMessage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateOwnerMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EstateOwnerMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateOwnerMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EstateOwnerMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EventGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventGodDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventGodDelete_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventGodDelete_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventGodDelete_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventGodDelete_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl EventInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventInfoReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventInfoReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventInfoReply_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
            creator: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            category: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            date_utc: buffer.read_u32::<LittleEndian>()?,
            duration: buffer.read_u32::<LittleEndian>()?,
            cover: buffer.read_u32::<LittleEndian>()?,
            amount: buffer.read_u32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            global_pos: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            event_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventInfoRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventInfoRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventLocationReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventLocationReply_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventLocationReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventLocationReply_EventData {
            success: buffer.read_u8()? == 1,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl EventLocationRequest_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventLocationRequest_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventLocationRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventLocationRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventNotificationAddRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventNotificationAddRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventNotificationAddRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventNotificationAddRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventNotificationRemoveRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventNotificationRemoveRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventNotificationRemoveRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(EventNotificationRemoveRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl FeatureDisabled_FailureInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FeatureDisabled_FailureInfo {
            error_message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventory_InventoryData {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sort_order: buffer.read_i32::<LittleEndian>()?,
            fetch_folders: buffer.read_u8()? == 1,
            fetch_items: buffer.read_u8()? == 1,
        })
    }
}

impl FetchInventoryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventoryReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FetchInventoryReply_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl FindAgent_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FindAgent_AgentBlock {
            hunter: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            prey: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            space_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
        })
    }
}

impl FindAgent_LocationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FindAgent_LocationBlock {
            global_x: buffer.read_f64::<LittleEndian>()?,
            global_y: buffer.read_f64::<LittleEndian>()?,
        })
    }
}

impl ForceObjectSelect_Header {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ForceObjectSelect_Header {
            reset_list: buffer.read_u8()? == 1,
        })
    }
}

impl ForceObjectSelect_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ForceObjectSelect_Data {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ForceScriptControlRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ForceScriptControlRelease_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FormFriendship_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FormFriendship_AgentBlock {
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FreezeUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FreezeUser_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FreezeUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(FreezeUser_Data {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GenericMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GenericMessage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GenericMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GenericMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GenericMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GenericMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GetScriptRunning_Script {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodKickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodKickUser_UserInfo {
            god_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            kick_flags: buffer.read_u32::<LittleEndian>()?,
            reason: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GodUpdateRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodUpdateRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodUpdateRegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodUpdateRegionInfo_RegionInfo {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            price_per_meter: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_x: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_y: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GodlikeMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodlikeMessage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodlikeMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodlikeMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodlikeMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GodlikeMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GrantGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GrantGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantGodlikePowers_GrantData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GrantGodlikePowers_GrantData {
            god_level: buffer.read_u8()?,
            token: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GrantUserRights_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GrantUserRights_Rights {
            agent_related: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            related_rights: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountDetailsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountDetailsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountDetailsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountDetailsReply_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountDetailsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountDetailsReply_HistoryData {
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            amount: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountDetailsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountDetailsRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountDetailsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountDetailsRequest_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountSummaryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountSummaryReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountSummaryReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountSummaryReply_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            balance: buffer.read_i32::<LittleEndian>()?,
            total_credits: buffer.read_i32::<LittleEndian>()?,
            total_debits: buffer.read_i32::<LittleEndian>()?,
            object_tax_current: buffer.read_i32::<LittleEndian>()?,
            light_tax_current: buffer.read_i32::<LittleEndian>()?,
            land_tax_current: buffer.read_i32::<LittleEndian>()?,
            group_tax_current: buffer.read_i32::<LittleEndian>()?,
            parcel_dir_fee_current: buffer.read_i32::<LittleEndian>()?,
            object_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            light_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            land_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            group_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            parcel_dir_fee_estimate: buffer.read_i32::<LittleEndian>()?,
            non_exempt_members: buffer.read_i32::<LittleEndian>()?,
            last_tax_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            tax_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountSummaryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountSummaryRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountSummaryRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountSummaryRequest_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountTransactionsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountTransactionsReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountTransactionsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountTransactionsReply_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountTransactionsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountTransactionsReply_HistoryData {
            time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            user: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            item: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            amount: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountTransactionsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountTransactionsRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountTransactionsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupAccountTransactionsRequest_MoneyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupActiveProposalItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalItemReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_num_items: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupActiveProposalItemReply_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalItemReply_ProposalData {
            vote_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_initiator: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terse_date_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            start_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            end_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            already_voted: buffer.read_u8()? == 1,
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            majority: buffer.read_f32::<LittleEndian>()?,
            quorum: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupActiveProposalsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalsRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalsRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalsRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalsRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupActiveProposalsRequest_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupDataUpdate_AgentGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupDataUpdate_AgentGroupData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_powers: buffer.read_u64::<LittleEndian>()?,
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupMembersReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupMembersReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupMembersReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_count: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupMembersReply_MemberData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
            online_status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            agent_powers: buffer.read_u64::<LittleEndian>()?,
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            is_owner: buffer.read_u8()? == 1,
        })
    }
}

impl GroupMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupMembersRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticeAdd_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeAdd_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticeAdd_MessageBlock {
            to_group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dialog: buffer.read_u8()?,
            from_agent_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            binary_bucket: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupNoticeRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticeRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticeRequest_Data {
            group_notice_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticesListReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticesListReply_Data {
            notice_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            timestamp: buffer.read_u32::<LittleEndian>()?,
            from_name: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            has_attachment: buffer.read_u8()? == 1,
            asset_type: buffer.read_u8()?,
        })
    }
}

impl GroupNoticesListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticesListRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupNoticesListRequest_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProfileReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProfileReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            member_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers_mask: buffer.read_u64::<LittleEndian>()?,
            insignia_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            founder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            money: buffer.read_i32::<LittleEndian>()?,
            group_membership_count: buffer.read_i32::<LittleEndian>()?,
            group_roles_count: buffer.read_i32::<LittleEndian>()?,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
            owner_role: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProfileRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProfileRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProposalBallot_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProposalBallot_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProposalBallot_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupProposalBallot_ProposalData {
            proposal_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupRoleChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleChanges_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleChanges_RoleChange {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleChanges_RoleChange {
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            change: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleDataReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleDataReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleDataReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleDataReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_count: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleDataReply_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleDataReply_RoleData {
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers: buffer.read_u64::<LittleEndian>()?,
            members: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleDataRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleDataRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleDataRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleDataRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleMembersReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_pairs: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleMembersReply_MemberData {
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleMembersRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleUpdate_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupRoleUpdate_RoleData {
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers: buffer.read_u64::<LittleEndian>()?,
            update_type: buffer.read_u8()?,
        })
    }
}

impl GroupTitleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupTitleUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            title_role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupTitlesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupTitlesReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupTitlesReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupTitlesReply_GroupData {
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            selected: buffer.read_u8()? == 1,
        })
    }
}

impl GroupTitlesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupTitlesRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryItemReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_num_items: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupVoteHistoryItemReply_HistoryItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryItemReply_HistoryItemData {
            vote_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terse_date_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            start_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            end_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            vote_initiator: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_type: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            vote_result: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            majority: buffer.read_f32::<LittleEndian>()?,
            quorum: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupVoteHistoryItemReply_VoteItem {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryItemReply_VoteItem {
            candidate_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            num_votes: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupVoteHistoryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(GroupVoteHistoryRequest_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl HealthMessage_HealthData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(HealthMessage_HealthData {
            health: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ImageData_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImageData_ImageID {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            codec: buffer.read_u8()?,
            size: buffer.read_u32::<LittleEndian>()?,
            packets: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImageData_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImageData_ImageData {
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ImageNotInDatabase_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImageNotInDatabase_ImageID {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ImagePacket_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImagePacket_ImageID {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            packet: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImagePacket_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImagePacket_ImageData {
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ImprovedInstantMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImprovedInstantMessage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ImprovedInstantMessage_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImprovedInstantMessage_MessageBlock {
            from_group: buffer.read_u8()? == 1,
            to_agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            offline: buffer.read_u8()?,
            dialog: buffer.read_u8()?,
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            timestamp: buffer.read_u32::<LittleEndian>()?,
            from_agent_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            binary_bucket: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ImprovedTerseObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImprovedTerseObjectUpdate_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImprovedTerseObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ImprovedTerseObjectUpdate_ObjectData {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_entry: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InitiateDownload_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InitiateDownload_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InitiateDownload_FileData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InitiateDownload_FileData {
            sim_filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            viewer_filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InternalScriptMail_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InternalScriptMail_DataBlock {
            from: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            to: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            body: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InventoryAssetResponse_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InventoryAssetResponse_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_readable: buffer.read_u8()? == 1,
        })
    }
}

impl InventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            version: buffer.read_i32::<LittleEndian>()?,
            descendents: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl InventoryDescendents_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InventoryDescendents_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InventoryDescendents_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InventoryDescendents_ItemData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl InviteGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InviteGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InviteGroupRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupRequest_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InviteGroupRequest_InviteData {
            invitee_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupResponse_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(InviteGroupResponse_InviteData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            invitee_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl JoinGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(JoinGroupReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl JoinGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(JoinGroupReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl JoinGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(JoinGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl JoinGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(JoinGroupRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl KickUser_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(KickUser_TargetBlock {
            target_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl KickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(KickUser_UserInfo {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            reason: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl KickUserAck_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(KickUserAck_UserInfo {
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl KillChildAgents_IDBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(KillChildAgents_IDBlock {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl KillObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(KillObject_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl LandStatReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LandStatReply_RequestData {
            report_type: buffer.read_u32::<LittleEndian>()?,
            request_flags: buffer.read_u32::<LittleEndian>()?,
            total_object_count: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl LandStatReply_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LandStatReply_ReportData {
            task_local_id: buffer.read_u32::<LittleEndian>()?,
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_x: buffer.read_f32::<LittleEndian>()?,
            location_y: buffer.read_f32::<LittleEndian>()?,
            location_z: buffer.read_f32::<LittleEndian>()?,
            score: buffer.read_f32::<LittleEndian>()?,
            task_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            owner_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LandStatRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LandStatRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LandStatRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LandStatRequest_RequestData {
            report_type: buffer.read_u32::<LittleEndian>()?,
            request_flags: buffer.read_u32::<LittleEndian>()?,
            filter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl LayerData_LayerID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LayerData_LayerID {
            type_: buffer.read_u8()?,
        })
    }
}

impl LayerData_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LayerData_LayerData {
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LeaveGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LeaveGroupReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LeaveGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LeaveGroupReply_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl LeaveGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LeaveGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LeaveGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LeaveGroupRequest_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LinkInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LinkInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LinkInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LinkInventoryItem_InventoryBlock {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LiveHelpGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LiveHelpGroupReply_ReplyData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            selection: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LiveHelpGroupRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LiveHelpGroupRequest_RequestData {
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LoadURL_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LoadURL_Data {
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_is_group: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LogDwellTime_DwellInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogDwellTime_DwellInfo {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            duration: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
            avg_agents_in_view: buffer.read_u8()?,
            avg_viewer_fps: buffer.read_u8()?,
        })
    }
}

impl LogFailedMoneyTransaction_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogFailedMoneyTransaction_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            simulator_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            failure_type: buffer.read_u8()?,
        })
    }
}

impl LogParcelChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogParcelChanges_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogParcelChanges_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogParcelChanges_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl LogParcelChanges_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogParcelChanges_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_owner_group: buffer.read_u8()? == 1,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            action: buffer.read_i8()?,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogTextMessage_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogTextMessage_DataBlock {
            from_agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            to_agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            global_x: buffer.read_f64::<LittleEndian>()?,
            global_y: buffer.read_f64::<LittleEndian>()?,
            time: buffer.read_u32::<LittleEndian>()?,
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LogoutReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogoutReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogoutReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogoutReply_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogoutRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(LogoutRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MapBlockReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapBlockReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapBlockReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapBlockReply_Data {
            x: buffer.read_u16::<LittleEndian>()?,
            y: buffer.read_u16::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            water_height: buffer.read_u8()?,
            agents: buffer.read_u8()?,
            map_image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MapBlockRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapBlockRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapBlockRequest_PositionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapBlockRequest_PositionData {
            min_x: buffer.read_u16::<LittleEndian>()?,
            max_x: buffer.read_u16::<LittleEndian>()?,
            min_y: buffer.read_u16::<LittleEndian>()?,
            max_y: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapItemReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapItemReply_RequestData {
            item_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapItemReply_Data {
            x: buffer.read_u32::<LittleEndian>()?,
            y: buffer.read_u32::<LittleEndian>()?,
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            extra: buffer.read_i32::<LittleEndian>()?,
            extra2: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MapItemRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapItemRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapItemRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapItemRequest_RequestData {
            item_type: buffer.read_u32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl MapLayerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapLayerReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapLayerReply_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapLayerReply_LayerData {
            left: buffer.read_u32::<LittleEndian>()?,
            right: buffer.read_u32::<LittleEndian>()?,
            top: buffer.read_u32::<LittleEndian>()?,
            bottom: buffer.read_u32::<LittleEndian>()?,
            image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MapLayerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapLayerRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapNameRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapNameRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapNameRequest_NameData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MapNameRequest_NameData {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MeanCollisionAlert_MeanCollision {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MeanCollisionAlert_MeanCollision {
            victim: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            perp: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_u32::<LittleEndian>()?,
            mag: buffer.read_f32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
        })
    }
}

impl MergeParcel_MasterParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MergeParcel_MasterParcelData {
            master_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MergeParcel_SlaveParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MergeParcel_SlaveParcelData {
            slave_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ModifyLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ModifyLand_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ModifyLand_ModifyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ModifyLand_ModifyBlock {
            action: buffer.read_u8()?,
            brush_size: buffer.read_u8()?,
            seconds: buffer.read_f32::<LittleEndian>()?,
            height: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ModifyLand_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ModifyLand_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ModifyLand_ModifyBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ModifyLand_ModifyBlockExtended {
            brush_size: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl MoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_success: buffer.read_u8()? == 1,
            money_balance: buffer.read_i32::<LittleEndian>()?,
            square_meters_credit: buffer.read_i32::<LittleEndian>()?,
            square_meters_committed: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyBalanceReply_TransactionInfo {
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_source_group: buffer.read_u8()? == 1,
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_dest_group: buffer.read_u8()? == 1,
            amount: buffer.read_i32::<LittleEndian>()?,
            item_description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyBalanceRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyBalanceRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyBalanceRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyBalanceRequest_MoneyData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyTransferBackend_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyTransferBackend_MoneyData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            aggregate_perm_next_owner: buffer.read_u8()?,
            aggregate_perm_inventory: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyTransferRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyTransferRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyTransferRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoneyTransferRequest_MoneyData {
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            aggregate_perm_next_owner: buffer.read_u8()?,
            aggregate_perm_inventory: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            stamp: buffer.read_u8()? == 1,
        })
    }
}

impl MoveInventoryFolder_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveInventoryFolder_InventoryData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            stamp: buffer.read_u8()? == 1,
        })
    }
}

impl MoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MoveTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MultipleObjectUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MultipleObjectUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MultipleObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MultipleObjectUpdate_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MuteListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MuteListRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MuteListRequest_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MuteListRequest_MuteData {
            mute_crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MuteListUpdate_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(MuteListUpdate_MuteData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl NameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NameValuePair_TaskData {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl NameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NameValuePair_NameValueData {
            nv_pair: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl NearestLandingRegionReply_LandingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NearestLandingRegionReply_LandingRegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl NearestLandingRegionRequest_RequestingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NearestLandingRegionRequest_RequestingRegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl NearestLandingRegionUpdated_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NearestLandingRegionUpdated_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl NeighborList_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NeighborList_NeighborBlock {
            ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
            public_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            public_port: buffer.read_u16::<LittleEndian>()?,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
        })
    }
}

impl NetTest_NetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(NetTest_NetBlock {
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectAdd_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectAdd_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectAdd_ObjectData {
            p_code: buffer.read_u8()?,
            material: buffer.read_u8()?,
            add_flags: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            state: buffer.read_u8()?,
        })
    }
}

impl ObjectAttach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectAttach_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_point: buffer.read_u8()?,
        })
    }
}

impl ObjectAttach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectAttach_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectBuy_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            category_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectBuy_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectBuy_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ObjectCategory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectCategory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectCategory_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectCategory_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectClickAction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectClickAction_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectClickAction_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectClickAction_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            click_action: buffer.read_u8()?,
        })
    }
}

impl ObjectDeGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDeGrab_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDeGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDeGrab_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDeGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDeGrab_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            force: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectDelete_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDelete_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDelink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDelink_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDelink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDelink_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDescription_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDescription_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDescription_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDescription_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectDeselect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDeselect_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDeselect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDeselect_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDetach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDetach_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDetach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDetach_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDrop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDrop_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDrop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDrop_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDuplicate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDuplicate_SharedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDuplicate_SharedData {
            offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            duplicate_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDuplicate_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicateOnRay_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDuplicateOnRay_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            bypass_raycast: buffer.read_u8()? == 1,
            ray_end_is_intersection: buffer.read_u8()? == 1,
            copy_centers: buffer.read_u8()? == 1,
            copy_rotates: buffer.read_u8()? == 1,
            ray_target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            duplicate_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicateOnRay_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectDuplicateOnRay_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectExportSelected_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectExportSelected_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            volume_detail: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl ObjectExportSelected_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectExportSelected_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectExtraParams_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectExtraParams_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectExtraParams_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectExtraParams_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            param_type: buffer.read_u16::<LittleEndian>()?,
            param_in_use: buffer.read_u8()? == 1,
            param_size: buffer.read_u32::<LittleEndian>()?,
            param_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectFlagUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectFlagUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            use_physics: buffer.read_u8()? == 1,
            is_temporary: buffer.read_u8()? == 1,
            is_phantom: buffer.read_u8()? == 1,
            casts_shadows: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrab_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrab_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            grab_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrab_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectGrabUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrabUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGrabUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrabUpdate_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grab_offset_initial: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            grab_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            time_since_last: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectGrabUpdate_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGrabUpdate_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGroup_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGroup_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectGroup_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectImage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectImage_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectImage_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_entry: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectIncludeInSearch_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectIncludeInSearch_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectIncludeInSearch_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectIncludeInSearch_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            include_in_search: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectLink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectLink_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectLink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectLink_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectMaterial_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectMaterial_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectMaterial_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectMaterial_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            material: buffer.read_u8()?,
        })
    }
}

impl ObjectName_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectName_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectName_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectName_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectOwner_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectOwner_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectOwner_HeaderData {
            override_: buffer.read_u8()? == 1,
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectOwner_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectOwner_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectPermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPermissions_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectPermissions_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPermissions_HeaderData {
            override_: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectPermissions_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPermissions_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            field: buffer.read_u8()?,
            set: buffer.read_u8()?,
            mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectPosition_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPosition_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectPosition_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPosition_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectProperties_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creation_date: buffer.read_u64::<LittleEndian>()?,
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            ownership_cost: buffer.read_i32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            aggregate_perms: buffer.read_u8()?,
            aggregate_perm_textures: buffer.read_u8()?,
            aggregate_perm_textures_owner: buffer.read_u8()?,
            category: buffer.read_u32::<LittleEndian>()?,
            inventory_serial: buffer.read_i16::<LittleEndian>()?,
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            from_task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            last_owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            touch_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sit_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectPropertiesFamily_ObjectData {
            request_flags: buffer.read_u32::<LittleEndian>()?,
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            ownership_cost: buffer.read_i32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            last_owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectRotation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectRotation_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectRotation_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectRotation_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectSaleInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSaleInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSaleInfo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSaleInfo_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ObjectScale_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectScale_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectScale_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectScale_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectSelect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSelect_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSelect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSelect_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectShape_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectShape_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectShape_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectShape_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectSpinStart_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinStart_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinStart_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinStart_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinStop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinStop_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinStop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinStop_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectSpinUpdate_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdate_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdate_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
            state: buffer.read_u8()?,
            full_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            crc: buffer.read_u32::<LittleEndian>()?,
            p_code: buffer.read_u8()?,
            material: buffer.read_u8()?,
            click_action: buffer.read_u8()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            object_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parent_id: buffer.read_u32::<LittleEndian>()?,
            update_flags: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
            texture_entry: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_anim: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name_value: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            text_color: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            ps_block: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sound: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            radius: buffer.read_f32::<LittleEndian>()?,
            joint_type: buffer.read_u8()?,
            joint_pivot: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            joint_axis_or_anchor: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectUpdateCached_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdateCached_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdateCached_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdateCached_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
            update_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdateCompressed_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdateCompressed_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdateCompressed_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ObjectUpdateCompressed_ObjectData {
            update_flags: buffer.read_u32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl OfferCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(OfferCallingCard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OfferCallingCard_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(OfferCallingCard_AgentBlock {
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OfflineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(OfflineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OnlineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(OnlineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OpenCircuit_CircuitInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(OpenCircuit_CircuitInfo {
            ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl PacketAck_Packets {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PacketAck_Packets {
            id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListReply_Data {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListReply_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListReply_List {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelAccessListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListRequest_Data {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelAccessListUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListUpdate_Data {
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            sections: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListUpdate_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAccessListUpdate_List {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelAuctions_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelAuctions_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            winner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelBuy_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelBuy_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelBuy_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            remove_contribution: buffer.read_u8()? == 1,
            local_id: buffer.read_i32::<LittleEndian>()?,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelBuy_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelBuy_ParcelData {
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelBuyPass_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelBuyPass_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelBuyPass_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelBuyPass_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelClaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelClaim_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelClaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelClaim_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelClaim_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelClaim_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelDeedToGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDeedToGroup_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDeedToGroup_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDeedToGroup_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelDisableObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDisableObjects_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDisableObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDisableObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelDisableObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDisableObjects_TaskIDs {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDisableObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDisableObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDivide_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDivide_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDivide_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDivide_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelDwellReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDwellReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDwellReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDwellReply_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelDwellRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDwellRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDwellRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelDwellRequest_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodForceOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelGodForceOwner_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodForceOwner_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelGodForceOwner_Data {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelGodMarkAsContent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelGodMarkAsContent_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodMarkAsContent_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelGodMarkAsContent_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelInfoReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelInfoReply_Data {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            global_x: buffer.read_f32::<LittleEndian>()?,
            global_y: buffer.read_f32::<LittleEndian>()?,
            global_z: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            auction_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelInfoRequest_Data {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelJoin_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelJoin_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelJoin_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelJoin_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelMediaCommandMessage_CommandBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelMediaCommandMessage_CommandBlock {
            flags: buffer.read_u32::<LittleEndian>()?,
            command: buffer.read_u32::<LittleEndian>()?,
            time: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelMediaUpdate_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelMediaUpdate_DataBlock {
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
        })
    }
}

impl ParcelMediaUpdate_DataBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelMediaUpdate_DataBlockExtended {
            media_type: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_width: buffer.read_i32::<LittleEndian>()?,
            media_height: buffer.read_i32::<LittleEndian>()?,
            media_loop: buffer.read_u8()?,
        })
    }
}

impl ParcelObjectOwnersReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelObjectOwnersReply_Data {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            count: buffer.read_i32::<LittleEndian>()?,
            online_status: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelObjectOwnersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelObjectOwnersRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelObjectOwnersRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelObjectOwnersRequest_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelOverlay_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelOverlay_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ParcelProperties_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelProperties_ParcelData {
            request_result: buffer.read_i32::<LittleEndian>()?,
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            snap_selection: buffer.read_u8()? == 1,
            self_count: buffer.read_i32::<LittleEndian>()?,
            other_count: buffer.read_i32::<LittleEndian>()?,
            public_count: buffer.read_i32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            auction_id: buffer.read_u32::<LittleEndian>()?,
            claim_date: buffer.read_i32::<LittleEndian>()?,
            claim_price: buffer.read_i32::<LittleEndian>()?,
            rent_price: buffer.read_i32::<LittleEndian>()?,
            aabb_min: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            aabb_max: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            bitmap: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            area: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_u8()?,
            sim_wide_max_prims: buffer.read_i32::<LittleEndian>()?,
            sim_wide_total_prims: buffer.read_i32::<LittleEndian>()?,
            max_prims: buffer.read_i32::<LittleEndian>()?,
            total_prims: buffer.read_i32::<LittleEndian>()?,
            owner_prims: buffer.read_i32::<LittleEndian>()?,
            group_prims: buffer.read_i32::<LittleEndian>()?,
            other_prims: buffer.read_i32::<LittleEndian>()?,
            selected_prims: buffer.read_i32::<LittleEndian>()?,
            parcel_prim_bonus: buffer.read_f32::<LittleEndian>()?,
            other_clean_time: buffer.read_i32::<LittleEndian>()?,
            parcel_flags: buffer.read_u32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pass_price: buffer.read_i32::<LittleEndian>()?,
            pass_hours: buffer.read_f32::<LittleEndian>()?,
            category: buffer.read_u8()?,
            auth_buyer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            user_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            landing_type: buffer.read_u8()?,
            region_push_override: buffer.read_u8()? == 1,
            region_deny_anonymous: buffer.read_u8()? == 1,
            region_deny_identified: buffer.read_u8()? == 1,
            region_deny_transacted: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelProperties_AgeVerificationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelProperties_AgeVerificationBlock {
            region_deny_age_unverified: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesRequest_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
            snap_selection: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelPropertiesRequestByID_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesRequestByID_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesRequestByID_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesRequestByID_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesUpdate_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelPropertiesUpdate_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            parcel_flags: buffer.read_u32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pass_price: buffer.read_i32::<LittleEndian>()?,
            pass_hours: buffer.read_f32::<LittleEndian>()?,
            category: buffer.read_u8()?,
            auth_buyer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            user_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            landing_type: buffer.read_u8()?,
        })
    }
}

impl ParcelReclaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReclaim_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReclaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReclaim_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelRelease_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelRelease_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelRelease_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelRename_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelRename_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ParcelReturnObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReturnObjects_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReturnObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReturnObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelReturnObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReturnObjects_TaskIDs {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReturnObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelReturnObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSales_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSales_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            buyer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSelectObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSelectObjects_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSelectObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSelectObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelSelectObjects_ReturnIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSelectObjects_ReturnIDs {
            return_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSetOtherCleanTime_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSetOtherCleanTime_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSetOtherCleanTime_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ParcelSetOtherCleanTime_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            other_clean_time: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PayPriceReply_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PayPriceReply_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            default_pay_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PayPriceReply_ButtonData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PayPriceReply_ButtonData {
            pay_button: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PickDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickDelete_Data {
            pick_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickGodDelete_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickGodDelete_Data {
            pick_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickInfoReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickInfoReply_Data {
            pick_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            top_pick: buffer.read_u8()? == 1,
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            original_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            sort_order: buffer.read_i32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl PickInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PickInfoUpdate_Data {
            pick_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            top_pick: buffer.read_u8()? == 1,
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            sort_order: buffer.read_i32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl PlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesQuery_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesQuery_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesQuery_QueryData {
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl PlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesReply_TransactionData {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PlacesReply_QueryData {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            global_x: buffer.read_f32::<LittleEndian>()?,
            global_y: buffer.read_f32::<LittleEndian>()?,
            global_z: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PreloadSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PreloadSound_DataBlock {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sound_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PurgeInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PurgeInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PurgeInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(PurgeInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RebakeAvatarTextures_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RebakeAvatarTextures_TextureData {
            texture_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Redo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Redo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Redo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Redo_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandleRequest_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandleRequest_RequestBlock {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandshake_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandshake_RegionInfo {
            region_flags: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_owner: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_estate_manager: buffer.read_u8()? == 1,
            water_height: buffer.read_f32::<LittleEndian>()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            cache_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base0: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base1: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base2: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base3: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail0: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail1: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail2: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail3: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_start_height00: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height01: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height10: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height11: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range00: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range01: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range10: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range11: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl RegionHandshake_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandshake_RegionInfo2 {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandshake_RegionInfo3 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandshake_RegionInfo3 {
            cpu_class_id: buffer.read_i32::<LittleEndian>()?,
            cpu_ratio: buffer.read_i32::<LittleEndian>()?,
            colo_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_sku: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RegionHandshakeReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandshakeReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandshakeReply_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionHandshakeReply_RegionInfo {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RegionIDAndHandleReply_ReplyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionIDAndHandleReply_ReplyBlock {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl RegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionInfo_RegionInfo {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            max_agents: buffer.read_u8()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            object_bonus_factor: buffer.read_f32::<LittleEndian>()?,
            water_height: buffer.read_f32::<LittleEndian>()?,
            terrain_raise_limit: buffer.read_f32::<LittleEndian>()?,
            terrain_lower_limit: buffer.read_f32::<LittleEndian>()?,
            price_per_meter: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_x: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_y: buffer.read_i32::<LittleEndian>()?,
            use_estate_sun: buffer.read_u8()? == 1,
            sun_hour: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl RegionInfo_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionInfo_RegionInfo2 {
            product_sku: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            max_agents32: buffer.read_u32::<LittleEndian>()?,
            hard_max_agents: buffer.read_u32::<LittleEndian>()?,
            hard_max_objects: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RegionPresenceRequestByHandle_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionPresenceRequestByHandle_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl RegionPresenceRequestByRegionID_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionPresenceRequestByRegionID_RegionData {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionPresenceResponse_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RegionPresenceResponse_RegionData {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            internal_region_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            external_region_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            region_port: buffer.read_u16::<LittleEndian>()?,
            valid_until: buffer.read_f64::<LittleEndian>()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RemoveAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveAttachment_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveAttachment_AttachmentBlock {
            attachment_point: buffer.read_u8()?,
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryObjects_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryObjects_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryObjects_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryObjects_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveInventoryObjects_ItemData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            mute_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RemoveNameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveNameValuePair_TaskData {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveNameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveNameValuePair_NameValueData {
            nv_pair: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RemoveParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveParcel_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RemoveTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ReplyTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ReplyTaskInventory_InventoryData {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial: buffer.read_i16::<LittleEndian>()?,
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ReportAutosaveCrash_AutosaveData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ReportAutosaveCrash_AutosaveData {
            pid: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl RequestGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestGodlikePowers_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestGodlikePowers_RequestBlock {
            godlike: buffer.read_u8()? == 1,
            token: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestImage_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestImage_RequestImage {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestImage_RequestImage {
            image: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            discard_level: buffer.read_i8()?,
            download_priority: buffer.read_f32::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
        })
    }
}

impl RequestInventoryAsset_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestInventoryAsset_QueryData {
            query_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestMultipleObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestMultipleObjects_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestMultipleObjects_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestMultipleObjects_ObjectData {
            cache_miss_type: buffer.read_u8()?,
            id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestObjectPropertiesFamily_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestObjectPropertiesFamily_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestObjectPropertiesFamily_ObjectData {
            request_flags: buffer.read_u32::<LittleEndian>()?,
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestParcelTransfer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestParcelTransfer_Data {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl RequestParcelTransfer_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestParcelTransfer_RegionData {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestPayPrice_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestPayPrice_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RequestXfer_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            file_path: buffer.read_u8()?,
            delete_on_completion: buffer.read_u8()? == 1,
            use_big_packets: buffer.read_u8()? == 1,
            v_file_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            v_file_type: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl RetrieveInstantMessages_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RetrieveInstantMessages_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RevokePermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RevokePermissions_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RevokePermissions_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RevokePermissions_Data {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_permissions: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezMultipleAttachmentsFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezMultipleAttachmentsFromInv_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezMultipleAttachmentsFromInv_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezMultipleAttachmentsFromInv_HeaderData {
            compound_msg_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_objects: buffer.read_u8()?,
            first_detach_all: buffer.read_u8()? == 1,
        })
    }
}

impl RezMultipleAttachmentsFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezMultipleAttachmentsFromInv_ObjectData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_pt: buffer.read_u8()?,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObject_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObject_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObject_RezData {
            from_task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()? == 1,
            rez_selected: buffer.read_u8()? == 1,
            remove_item: buffer.read_u8()? == 1,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObject_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObject_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObjectFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObjectFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObjectFromNotecard_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObjectFromNotecard_RezData {
            from_task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()? == 1,
            rez_selected: buffer.read_u8()? == 1,
            remove_item: buffer.read_u8()? == 1,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObjectFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObjectFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObjectFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezObjectFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezRestoreToWorld_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezRestoreToWorld_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezRestoreToWorld_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezRestoreToWorld_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezScript_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezScript_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezScript_UpdateBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezScript_UpdateBlock {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl RezScript_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezScript_InventoryBlock {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezSingleAttachmentFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezSingleAttachmentFromInv_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezSingleAttachmentFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RezSingleAttachmentFromInv_ObjectData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_pt: buffer.read_u8()?,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RoutedMoneyBalanceReply_TargetBlock {
            target_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl RoutedMoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RoutedMoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_success: buffer.read_u8()? == 1,
            money_balance: buffer.read_i32::<LittleEndian>()?,
            square_meters_credit: buffer.read_i32::<LittleEndian>()?,
            square_meters_committed: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RoutedMoneyBalanceReply_TransactionInfo {
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_source_group: buffer.read_u8()? == 1,
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_dest_group: buffer.read_u8()? == 1,
            amount: buffer.read_i32::<LittleEndian>()?,
            item_description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RpcChannelReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcChannelReply_DataBlock {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RpcChannelRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcChannelRequest_DataBlock {
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RpcScriptReplyInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcScriptReplyInbound_DataBlock {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RpcScriptRequestInbound_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcScriptRequestInbound_TargetBlock {
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RpcScriptRequestInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcScriptRequestInbound_DataBlock {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RpcScriptRequestInboundForward_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(RpcScriptRequestInboundForward_DataBlock {
            rpc_server_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            rpc_server_port: buffer.read_u16::<LittleEndian>()?,
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SaveAssetIntoInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SaveAssetIntoInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SaveAssetIntoInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SaveAssetIntoInventory_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptAnswerYes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptAnswerYes_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptAnswerYes_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptAnswerYes_Data {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            questions: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ScriptControlChange_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptControlChange_Data {
            take_controls: buffer.read_u8()? == 1,
            controls: buffer.read_u32::<LittleEndian>()?,
            pass_to_agent: buffer.read_u8()? == 1,
        })
    }
}

impl ScriptDataReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDataReply_DataBlock {
            hash: buffer.read_u64::<LittleEndian>()?,
            reply: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDataRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDataRequest_DataBlock {
            hash: buffer.read_u64::<LittleEndian>()?,
            request_type: buffer.read_i8()?,
            request: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDialog_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDialog_Data {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            chat_channel: buffer.read_i32::<LittleEndian>()?,
            image_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialog_Buttons {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDialog_Buttons {
            button_label: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDialog_OwnerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDialog_OwnerData {
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialogReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDialogReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialogReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptDialogReply_Data {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            chat_channel: buffer.read_i32::<LittleEndian>()?,
            button_index: buffer.read_i32::<LittleEndian>()?,
            button_label: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptMailRegistration_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptMailRegistration_DataBlock {
            target_ip: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ScriptQuestion_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptQuestion_Data {
            task_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_owner: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            questions: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ScriptReset_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptReset_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptReset_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptReset_Script {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptRunningReply_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptRunningReply_Script {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            running: buffer.read_u8()? == 1,
        })
    }
}

impl ScriptSensorReply_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptSensorReply_Requester {
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptSensorReply_SensedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptSensorReply_SensedData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            velocity: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            range: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ScriptSensorRequest_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptSensorRequest_Requester {
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            search_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            search_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            search_dir: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            search_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            range: buffer.read_f32::<LittleEndian>()?,
            arc: buffer.read_f32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            search_regions: buffer.read_u8()?,
        })
    }
}

impl ScriptTeleportRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ScriptTeleportRequest_Data {
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SendPostcard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SendPostcard_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            to: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            from: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            msg: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl SendXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SendXferPacket_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SendXferPacket_DataPacket {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SendXferPacket_DataPacket {
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SetAlwaysRun_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetAlwaysRun_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            always_run: buffer.read_u8()? == 1,
        })
    }
}

impl SetCPURatio_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetCPURatio_Data {
            ratio: buffer.read_u8()?,
        })
    }
}

impl SetFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetFollowCamProperties_CameraProperty {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetFollowCamProperties_CameraProperty {
            type_: buffer.read_i32::<LittleEndian>()?,
            value: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl SetGroupAcceptNotices_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetGroupAcceptNotices_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetGroupAcceptNotices_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetGroupAcceptNotices_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            accept_notices: buffer.read_u8()? == 1,
        })
    }
}

impl SetGroupAcceptNotices_NewData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetGroupAcceptNotices_NewData {
            list_in_profile: buffer.read_u8()? == 1,
        })
    }
}

impl SetGroupContribution_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetGroupContribution_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetGroupContribution_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetGroupContribution_Data {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl SetScriptRunning_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetScriptRunning_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetScriptRunning_Script {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            running: buffer.read_u8()? == 1,
        })
    }
}

impl SetSimPresenceInDatabase_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetSimPresenceInDatabase_SimData {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            pid: buffer.read_i32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            time_to_live: buffer.read_i32::<LittleEndian>()?,
            status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SetSimStatusInDatabase_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetSimStatusInDatabase_Data {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            x: buffer.read_i32::<LittleEndian>()?,
            y: buffer.read_i32::<LittleEndian>()?,
            pid: buffer.read_i32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            time_to_live: buffer.read_i32::<LittleEndian>()?,
            status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SetStartLocation_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetStartLocation_StartLocationData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            location_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            location_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SetStartLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetStartLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetStartLocationRequest_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SetStartLocationRequest_StartLocationData {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            location_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            location_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimCrashed_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimCrashed_Data {
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimCrashed_Users {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimCrashed_Users {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimStats_Region {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimStats_Region {
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            object_capacity: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimStats_Stat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimStats_Stat {
            stat_id: buffer.read_u32::<LittleEndian>()?,
            stat_value: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl SimStats_PidStat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimStats_PidStat {
            pid: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl SimStatus_SimStatus {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimStatus_SimStatus {
            can_accept_agents: buffer.read_u8()? == 1,
            can_accept_tasks: buffer.read_u8()? == 1,
        })
    }
}

impl SimWideDeletes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimWideDeletes_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimWideDeletes_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimWideDeletes_DataBlock {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorLoad_SimulatorLoad {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorLoad_SimulatorLoad {
            time_dilation: buffer.read_f32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            can_accept_agents: buffer.read_u8()? == 1,
        })
    }
}

impl SimulatorLoad_AgentList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorLoad_AgentList {
            circuit_code: buffer.read_u32::<LittleEndian>()?,
            x: buffer.read_u8()?,
            y: buffer.read_u8()?,
        })
    }
}

impl SimulatorMapUpdate_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorMapUpdate_MapData {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorPresentAtLocation_SimulatorPublicHostBlock {
            port: buffer.read_u16::<LittleEndian>()?,
            simulator_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorPresentAtLocation_NeighborBlock {
            ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorPresentAtLocation_SimulatorBlock {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorPresentAtLocation_TelehubBlock {
            has_telehub: buffer.read_u8()? == 1,
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimulatorReady_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorReady_SimulatorBlock {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorReady_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorReady_TelehubBlock {
            has_telehub: buffer.read_u8()? == 1,
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimulatorSetMap_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorSetMap_MapData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            type_: buffer.read_i32::<LittleEndian>()?,
            map_image: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimulatorViewerTimeMessage_TimeInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SimulatorViewerTimeMessage_TimeInfo {
            usec_since_start: buffer.read_u64::<LittleEndian>()?,
            sec_per_day: buffer.read_u32::<LittleEndian>()?,
            sec_per_year: buffer.read_u32::<LittleEndian>()?,
            sun_direction: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sun_phase: buffer.read_f32::<LittleEndian>()?,
            sun_ang_velocity: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SoundTrigger_SoundData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SoundTrigger_SoundData {
            sound_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            gain: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl StartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartAuction_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartAuction_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl StartGroupProposal_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartGroupProposal_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartGroupProposal_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartGroupProposal_ProposalData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            quorum: buffer.read_i32::<LittleEndian>()?,
            majority: buffer.read_f32::<LittleEndian>()?,
            duration: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl StartLure_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartLure_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartLure_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartLure_Info {
            lure_type: buffer.read_u8()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl StartLure_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartLure_TargetData {
            target_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartPingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StartPingCheck_PingID {
            ping_id: buffer.read_u8()?,
            oldest_unacked: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl StateSave_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StateSave_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StateSave_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(StateSave_DataBlock {
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SystemKickUser_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SystemKickUser_AgentInfo {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SystemMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SystemMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            digest: {
                let mut raw = [0; 32];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SystemMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(SystemMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TelehubInfo_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TelehubInfo_TelehubBlock {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            telehub_rot: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl TelehubInfo_SpawnPointBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TelehubInfo_SpawnPointBlock {
            spawn_point_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportCancel_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportCancel_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportFailed_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportFailed_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            reason: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TeleportFailed_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportFailed_AlertInfo {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TeleportFinish_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportFinish_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            sim_ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            sim_port: buffer.read_u16::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            seed_capability: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
            region_size_x: buffer.read_u32::<LittleEndian>()?,
            region_size_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportLandingStatusChanged_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLandingStatusChanged_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl TeleportLandmarkRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLandmarkRequest_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            landmark_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportLocal_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLocal_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLocationRequest_Info {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportLureRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportLureRequest_Info {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            lure_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportProgress_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportProgress_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportProgress_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportProgress_Info {
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TeleportRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportRequest_Info {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportStart_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TeleportStart_Info {
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TerminateFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TerminateFriendship_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TerminateFriendship_ExBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TerminateFriendship_ExBlock {
            other_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TestMessage_TestBlock1 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TestMessage_TestBlock1 {
            test1: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TestMessage_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TestMessage_NeighborBlock {
            test0: buffer.read_u32::<LittleEndian>()?,
            test1: buffer.read_u32::<LittleEndian>()?,
            test2: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TrackAgent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TrackAgent_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TrackAgent_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TrackAgent_TargetData {
            prey_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferAbort_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferAbort_TransferInfo {
            transfer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl TransferInfo_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferInfo_TransferInfo {
            transfer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            target_type: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
            size: buffer.read_i32::<LittleEndian>()?,
            params: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TransferInventory_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferInventory_InfoBlock {
            source_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferInventory_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferInventory_InventoryBlock {
            inventory_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
        })
    }
}

impl TransferInventoryAck_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferInventoryAck_InfoBlock {
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            inventory_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferPacket_TransferData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferPacket_TransferData {
            transfer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            packet: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TransferRequest_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(TransferRequest_TransferInfo {
            transfer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            source_type: buffer.read_i32::<LittleEndian>()?,
            priority: buffer.read_f32::<LittleEndian>()?,
            params: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UUIDGroupNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UUIDGroupNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UUIDGroupNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UUIDGroupNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UUIDNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UUIDNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UUIDNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UUIDNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Undo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Undo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Undo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(Undo_ObjectData {
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UndoLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UndoLand_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateAttachment_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateAttachment_AttachmentBlock {
            attachment_point: buffer.read_u8()?,
        })
    }
}

impl UpdateAttachment_OperationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateAttachment_OperationData {
            add_item: buffer.read_u8()? == 1,
            use_existing_asset: buffer.read_u8()? == 1,
        })
    }
}

impl UpdateAttachment_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateAttachment_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateCreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateCreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_approved: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateCreateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateCreateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateGroupInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateGroupInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateGroupInfo_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateGroupInfo_GroupData {
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            charter: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            insignia_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl UpdateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            mute_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            mute_type: buffer.read_i32::<LittleEndian>()?,
            mute_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateParcel_ParcelData {
            parcel_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_owned: buffer.read_u8()? == 1,
            status: buffer.read_u8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            region_x: buffer.read_f32::<LittleEndian>()?,
            region_y: buffer.read_f32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            show_dir: buffer.read_u8()? == 1,
            is_for_sale: buffer.read_u8()? == 1,
            category: buffer.read_u8()?,
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sale_price: buffer.read_i32::<LittleEndian>()?,
            authorized_buyer_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl UpdateSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateSimulator_SimulatorInfo {
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
        })
    }
}

impl UpdateTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateTaskInventory_UpdateData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateTaskInventory_UpdateData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            key: buffer.read_u8()?,
        })
    }
}

impl UpdateTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateTaskInventory_InventoryData {
            item_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateUserInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateUserInfo_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateUserInfo_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UpdateUserInfo_UserData {
            im_via_e_mail: buffer.read_u8()? == 1,
            directory_visibility: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UseCachedMuteList_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UseCachedMuteList_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UseCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UseCircuitCode_CircuitCode {
            code: buffer.read_u32::<LittleEndian>()?,
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserInfoReply_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserInfoReply_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserInfoReply_UserData {
            im_via_e_mail: buffer.read_u8()? == 1,
            directory_visibility: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            e_mail: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UserInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserReport_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserReport_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserReport_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserReport_ReportData {
            report_type: buffer.read_u8()?,
            category: buffer.read_u8()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            check_flags: buffer.read_u8()?,
            screenshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuser_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuse_region_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            abuse_region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            summary: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            details: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            version_string: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UserReportInternal_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(UserReportInternal_ReportData {
            report_type: buffer.read_u8()?,
            category: buffer.read_u8()?,
            reporter_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            viewer_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            screenshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            last_owner_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuser_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuse_region_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            abuse_region_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            summary: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            details: {
                let n = buffer.read_u16::<LittleEndian>()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            version_string: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl VelocityInterpolateOff_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(VelocityInterpolateOff_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl VelocityInterpolateOn_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(VelocityInterpolateOn_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerEffect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerEffect_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerEffect_Effect {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerEffect_Effect {
            id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_u8()?,
            duration: buffer.read_f32::<LittleEndian>()?,
            color: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ViewerFrozenMessage_FrozenData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerFrozenMessage_FrozenData {
            data: buffer.read_u8()? == 1,
        })
    }
}

impl ViewerStartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStartAuction_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerStartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStartAuction_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerStats_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStats_AgentData {
            agent_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0u8; 16];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ip: {
                let mut raw = [0u8; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            start_time: buffer.read_u32::<LittleEndian>()?,
            run_time: buffer.read_f32::<LittleEndian>()?,
            sim_fps: buffer.read_f32::<LittleEndian>()?,
            fps: buffer.read_f32::<LittleEndian>()?,
            agents_in_view: buffer.read_u8()?,
            ping: buffer.read_f32::<LittleEndian>()?,
            meters_traveled: buffer.read_f64::<LittleEndian>()?,
            regions_visited: buffer.read_i32::<LittleEndian>()?,
            sys_ram: buffer.read_u32::<LittleEndian>()?,
            sys_os: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sys_cpu: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sys_gpu: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ViewerStats_DownloadTotals {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStats_DownloadTotals {
            world: buffer.read_u32::<LittleEndian>()?,
            objects: buffer.read_u32::<LittleEndian>()?,
            textures: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_NetStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStats_NetStats {
            bytes: buffer.read_u32::<LittleEndian>()?,
            packets: buffer.read_u32::<LittleEndian>()?,
            compressed: buffer.read_u32::<LittleEndian>()?,
            savings: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_FailStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStats_FailStats {
            send_packet: buffer.read_u32::<LittleEndian>()?,
            dropped: buffer.read_u32::<LittleEndian>()?,
            resent: buffer.read_u32::<LittleEndian>()?,
            failed_resends: buffer.read_u32::<LittleEndian>()?,
            off_circuit: buffer.read_u32::<LittleEndian>()?,
            invalid: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_MiscStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadError>
    where R: Read {
        Ok(ViewerStats_MiscStats {
            type_: buffer.read_u32::<LittleEndian>()?,
            value: buffer.read_f64::<LittleEndian>()?,
        })
    }
}





// MESSAGE IMPLEMENTATIONS

impl Message for AbortXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9d
        ])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_i32::<LittleEndian>(self.xfer_id.result)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block XferID
        let xfer_id = AbortXfer_XferID::read_from(buffer)?;
        Ok(MessageInstance::AbortXfer(AbortXfer { xfer_id: xfer_id }))
    }
}

impl Message for AcceptCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(self.transaction_block.transaction_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AcceptCallingCard_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = AcceptCallingCard_TransactionBlock::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(AcceptCallingCard_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::AcceptCallingCard(AcceptCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for AcceptFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x29
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(self.transaction_block.transaction_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AcceptFriendship_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = AcceptFriendship_TransactionBlock::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(AcceptFriendship_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::AcceptFriendship(AcceptFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for ActivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.gesture_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ActivateGestures_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ActivateGestures_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ActivateGestures(ActivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ActivateGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x70
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ActivateGroup_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ActivateGroup(ActivateGroup {
            agent_data: agent_data,
        }))
    }
}

impl Message for AddCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x02
        ])?;
        // Block CircuitCode
        buffer.write_u32::<LittleEndian>(self.circuit_code.code)?;
        buffer.write(self.circuit_code.session_id.as_bytes())?;
        buffer.write(self.circuit_code.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block CircuitCode
        let circuit_code = AddCircuitCode_CircuitCode::read_from(buffer)?;
        Ok(MessageInstance::AddCircuitCode(AddCircuitCode {
            circuit_code: circuit_code,
        }))
    }
}

impl Message for AgentAlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x87
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block AlertData
        buffer.write_u8(self.alert_data.modal as u8)?;
        buffer.write_u8(self.alert_data.message.len() as u8)?;
        buffer.write(&self.alert_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentAlertMessage_AgentData::read_from(buffer)?;
        // Block AlertData
        let alert_data = AgentAlertMessage_AlertData::read_from(buffer)?;
        Ok(MessageInstance::AgentAlertMessage(AgentAlertMessage {
            agent_data: agent_data,
            alert_data: alert_data,
        }))
    }
}

impl Message for AgentAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x05])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AnimationList
        buffer.write_u8(self.animation_list.len() as u8)?;
        for item in &self.animation_list {
            buffer.write(item.anim_id.as_bytes())?;
            buffer.write_u8(item.start_anim as u8)?;
        }
        // Block PhysicalAvatarEventList
        buffer.write_u8(self.physical_avatar_event_list.len() as u8)?;
        for item in &self.physical_avatar_event_list {
            buffer.write_u8(item.type_data.len() as u8)?;
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentAnimation_AgentData::read_from(buffer)?;
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = buffer.read_u8()?;
        for _ in 0.._animation_list_count {
            animation_list.push(AgentAnimation_AnimationList::read_from(buffer)?);
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = buffer.read_u8()?;
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list
                .push(AgentAnimation_PhysicalAvatarEventList::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentAnimation(AgentAnimation {
            agent_data: agent_data,
            animation_list: animation_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AgentCachedTexture {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x80
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentCachedTexture_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentCachedTexture_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentCachedTexture(AgentCachedTexture {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentCachedTextureResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x81
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.texture_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
            buffer.write_u8(item.host_name.len() as u8)?;
            buffer.write(&item.host_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentCachedTextureResponse_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentCachedTextureResponse_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentCachedTextureResponse(
            AgentCachedTextureResponse {
                agent_data: agent_data,
                wearable_data: wearable_data,
            },
        ))
    }
}

impl Message for AgentDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x83
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u8(self.agent_data.first_name.len() as u8)?;
        buffer.write(&self.agent_data.first_name[..])?;
        buffer.write_u8(self.agent_data.last_name.len() as u8)?;
        buffer.write(&self.agent_data.last_name[..])?;
        buffer.write_u8(self.agent_data.group_title.len() as u8)?;
        buffer.write(&self.agent_data.group_title[..])?;
        buffer.write(self.agent_data.active_group_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.agent_data.group_powers)?;
        buffer.write_u8(self.agent_data.group_name.len() as u8)?;
        buffer.write(&self.agent_data.group_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentDataUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDataUpdate(AgentDataUpdate {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentDataUpdateRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x82
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentDataUpdateRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDataUpdateRequest(
            AgentDataUpdateRequest {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for AgentDropGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x86
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentDropGroup_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDropGroup(AgentDropGroup {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentFOV {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x52
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code)?;
        // Block FOVBlock
        buffer.write_u32::<LittleEndian>(self.fov_block.gen_counter)?;
        buffer.write_f32::<LittleEndian>(self.fov_block.vertical_angle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentFOV_AgentData::read_from(buffer)?;
        // Block FOVBlock
        let fov_block = AgentFOV_FOVBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentFOV(AgentFOV {
            agent_data: agent_data,
            fov_block: fov_block,
        }))
    }
}

impl Message for AgentGroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x85
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
            buffer.write(item.group_insignia_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.contribution)?;
            buffer.write_u8(item.group_name.len() as u8)?;
            buffer.write(&item.group_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentGroupDataUpdate_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(AgentGroupDataUpdate_GroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentGroupDataUpdate(
            AgentGroupDataUpdate {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for AgentHeightWidth {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x53
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code)?;
        // Block HeightWidthBlock
        buffer.write_u32::<LittleEndian>(self.height_width_block.gen_counter)?;
        buffer.write_u16::<LittleEndian>(self.height_width_block.height)?;
        buffer.write_u16::<LittleEndian>(self.height_width_block.width)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentHeightWidth_AgentData::read_from(buffer)?;
        // Block HeightWidthBlock
        let height_width_block = AgentHeightWidth_HeightWidthBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentHeightWidth(AgentHeightWidth {
            agent_data: agent_data,
            height_width_block: height_width_block,
        }))
    }
}

impl Message for AgentIsNowWearing {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u8(item.wearable_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentIsNowWearing_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentIsNowWearing_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentIsNowWearing(AgentIsNowWearing {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentMovementComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xfa
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_f32::<LittleEndian>(self.data.position.x)?;

        buffer.write_f32::<LittleEndian>(self.data.position.y)?;

        buffer.write_f32::<LittleEndian>(self.data.position.z)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.data.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.data.look_at.z)?;
        buffer.write_u64::<LittleEndian>(self.data.region_handle)?;
        buffer.write_u32::<LittleEndian>(self.data.timestamp)?;
        // Block SimData
        buffer.write_u16::<LittleEndian>(self.sim_data.channel_version.len() as u16)?;
        buffer.write(&self.sim_data.channel_version[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentMovementComplete_AgentData::read_from(buffer)?;
        // Block Data
        let data = AgentMovementComplete_Data::read_from(buffer)?;
        // Block SimData
        let sim_data = AgentMovementComplete_SimData::read_from(buffer)?;
        Ok(MessageInstance::AgentMovementComplete(
            AgentMovementComplete {
                agent_data: agent_data,
                data: data,
                sim_data: sim_data,
            },
        ))
    }
}

impl Message for AgentPause {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentPause_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentPause(AgentPause {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentQuitCopy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x55
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FuseBlock
        buffer.write_u32::<LittleEndian>(self.fuse_block.viewer_circuit_code)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentQuitCopy_AgentData::read_from(buffer)?;
        // Block FuseBlock
        let fuse_block = AgentQuitCopy_FuseBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentQuitCopy(AgentQuitCopy {
            agent_data: agent_data,
            fuse_block: fuse_block,
        }))
    }
}

impl Message for AgentRequestSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x06])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TargetObject
        buffer.write(self.target_object.target_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.target_object.offset.x)?;

        buffer.write_f32::<LittleEndian>(self.target_object.offset.y)?;

        buffer.write_f32::<LittleEndian>(self.target_object.offset.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentRequestSit_AgentData::read_from(buffer)?;
        // Block TargetObject
        let target_object = AgentRequestSit_TargetObject::read_from(buffer)?;
        Ok(MessageInstance::AgentRequestSit(AgentRequestSit {
            agent_data: agent_data,
            target_object: target_object,
        }))
    }
}

impl Message for AgentResume {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentResume_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentResume(AgentResume {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentSetAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x54
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.cache_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
        }
        // Block ObjectData
        buffer.write_u16::<LittleEndian>(self.object_data.texture_entry.len() as u16)?;
        buffer.write(&self.object_data.texture_entry[..])?;
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentSetAppearance_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentSetAppearance_WearableData::read_from(buffer)?);
        }
        // Block ObjectData
        let object_data = AgentSetAppearance_ObjectData::read_from(buffer)?;
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(AgentSetAppearance_VisualParam::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentSetAppearance(AgentSetAppearance {
            agent_data: agent_data,
            wearable_data: wearable_data,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AgentSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x07])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentSit_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentSit(AgentSit {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentThrottle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x51
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code)?;
        // Block Throttle
        buffer.write_u32::<LittleEndian>(self.throttle.gen_counter)?;
        buffer.write_u8(self.throttle.throttles.len() as u8)?;
        buffer.write(&self.throttle.throttles[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentThrottle_AgentData::read_from(buffer)?;
        // Block Throttle
        let throttle = AgentThrottle_Throttle::read_from(buffer)?;
        Ok(MessageInstance::AgentThrottle(AgentThrottle {
            agent_data: agent_data,
            throttle: throttle,
        }))
    }
}

impl Message for AgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        let norm_body_rotation = if self.agent_data.body_rotation.scalar() >= 0. {
            self.agent_data.body_rotation.norm()
        } else {
            -self.agent_data.body_rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[0] / norm_body_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[1] / norm_body_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[2] / norm_body_rotation,
        )?;
        let norm_head_rotation = if self.agent_data.head_rotation.scalar() >= 0. {
            self.agent_data.head_rotation.norm()
        } else {
            -self.agent_data.head_rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[0] / norm_head_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[1] / norm_head_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[2] / norm_head_rotation,
        )?;
        buffer.write_u8(self.agent_data.state)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.far)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.control_flags)?;
        buffer.write_u8(self.agent_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentUpdate(AgentUpdate {
            agent_data: agent_data,
        }))
    }
}

impl Message for AgentWearablesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentWearablesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentWearablesRequest(
            AgentWearablesRequest {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for AgentWearablesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_u8(item.wearable_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AgentWearablesUpdate_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentWearablesUpdate_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentWearablesUpdate(
            AgentWearablesUpdate {
                agent_data: agent_data,
                wearable_data: wearable_data,
            },
        ))
    }
}

impl Message for AlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x86
        ])?;
        // Block AlertData
        buffer.write_u8(self.alert_data.message.len() as u8)?;
        buffer.write(&self.alert_data.message[..])?;
        // Block AlertInfo
        buffer.write_u8(self.alert_info.len() as u8)?;
        for item in &self.alert_info {
            buffer.write_u8(item.message.len() as u8)?;
            buffer.write(&item.message[..])?;
            buffer.write_u8(item.extra_params.len() as u8)?;
            buffer.write(&item.extra_params[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AlertData
        let alert_data = AlertMessage_AlertData::read_from(buffer)?;
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = buffer.read_u8()?;
        for _ in 0.._alert_info_count {
            alert_info.push(AlertMessage_AlertInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::AlertMessage(AlertMessage {
            alert_data: alert_data,
            alert_info: alert_info,
        }))
    }
}

impl Message for AssetUploadComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4e
        ])?;
        // Block AssetBlock
        buffer.write(self.asset_block.uuid.as_bytes())?;
        buffer.write_i8(self.asset_block.type_)?;
        buffer.write_u8(self.asset_block.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AssetBlock
        let asset_block = AssetUploadComplete_AssetBlock::read_from(buffer)?;
        Ok(MessageInstance::AssetUploadComplete(AssetUploadComplete {
            asset_block: asset_block,
        }))
    }
}

impl Message for AssetUploadRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4d
        ])?;
        // Block AssetBlock
        buffer.write(self.asset_block.transaction_id.as_bytes())?;
        buffer.write_i8(self.asset_block.type_)?;
        buffer.write_u8(self.asset_block.tempfile as u8)?;
        buffer.write_u8(self.asset_block.store_local as u8)?;
        buffer.write_u16::<LittleEndian>(self.asset_block.asset_data.len() as u16)?;
        buffer.write(&self.asset_block.asset_data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AssetBlock
        let asset_block = AssetUploadRequest_AssetBlock::read_from(buffer)?;
        Ok(MessageInstance::AssetUploadRequest(AssetUploadRequest {
            asset_block: asset_block,
        }))
    }
}

impl Message for AtomicPassObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x1c])?;
        // Block TaskData
        buffer.write(self.task_data.task_id.as_bytes())?;
        buffer.write_u8(self.task_data.attachment_needs_save as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TaskData
        let task_data = AtomicPassObject_TaskData::read_from(buffer)?;
        Ok(MessageInstance::AtomicPassObject(AtomicPassObject {
            task_data: task_data,
        }))
    }
}

impl Message for AttachedSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0d])?;
        // Block DataBlock
        buffer.write(self.data_block.sound_id.as_bytes())?;
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write(self.data_block.owner_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data_block.gain)?;
        buffer.write_u8(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = AttachedSound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::AttachedSound(AttachedSound {
            data_block: data_block,
        }))
    }
}

impl Message for AttachedSoundGainChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0e])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data_block.gain)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = AttachedSoundGainChange_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::AttachedSoundGainChange(
            AttachedSoundGainChange {
                data_block: data_block,
            },
        ))
    }
}

impl Message for AvatarAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x14])?;
        // Block Sender
        buffer.write(self.sender.id.as_bytes())?;
        // Block AnimationList
        buffer.write_u8(self.animation_list.len() as u8)?;
        for item in &self.animation_list {
            buffer.write(item.anim_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.anim_sequence_id)?;
        }
        // Block AnimationSourceList
        buffer.write_u8(self.animation_source_list.len() as u8)?;
        for item in &self.animation_source_list {
            buffer.write(item.object_id.as_bytes())?;
        }
        // Block PhysicalAvatarEventList
        buffer.write_u8(self.physical_avatar_event_list.len() as u8)?;
        for item in &self.physical_avatar_event_list {
            buffer.write_u8(item.type_data.len() as u8)?;
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Sender
        let sender = AvatarAnimation_Sender::read_from(buffer)?;
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = buffer.read_u8()?;
        for _ in 0.._animation_list_count {
            animation_list.push(AvatarAnimation_AnimationList::read_from(buffer)?);
        }
        // Block AnimationSourceList
        let mut animation_source_list = Vec::new();
        let _animation_source_list_count = buffer.read_u8()?;
        for _ in 0.._animation_source_list_count {
            animation_source_list.push(AvatarAnimation_AnimationSourceList::read_from(buffer)?);
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = buffer.read_u8()?;
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list
                .push(AvatarAnimation_PhysicalAvatarEventList::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarAnimation(AvatarAnimation {
            sender: sender,
            animation_list: animation_list,
            animation_source_list: animation_source_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AvatarAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9e
        ])?;
        // Block Sender
        buffer.write(self.sender.id.as_bytes())?;
        buffer.write_u8(self.sender.is_trial as u8)?;
        // Block ObjectData
        buffer.write_u16::<LittleEndian>(self.object_data.texture_entry.len() as u16)?;
        buffer.write(&self.object_data.texture_entry[..])?;
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Sender
        let sender = AvatarAppearance_Sender::read_from(buffer)?;
        // Block ObjectData
        let object_data = AvatarAppearance_ObjectData::read_from(buffer)?;
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(AvatarAppearance_VisualParam::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarAppearance(AvatarAppearance {
            sender: sender,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AvatarClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.target_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.classified_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarClassifiedReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarClassifiedReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarClassifiedReply(
            AvatarClassifiedReply {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for AvatarGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xad
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
            buffer.write_u8(item.group_title.len() as u8)?;
            buffer.write(&item.group_title[..])?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u8(item.group_name.len() as u8)?;
            buffer.write(&item.group_name[..])?;
            buffer.write(item.group_insignia_id.as_bytes())?;
        }
        // Block NewGroupData
        buffer.write_u8(self.new_group_data.list_in_profile as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarGroupsReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(AvatarGroupsReply_GroupData::read_from(buffer)?);
        }
        // Block NewGroupData
        let new_group_data = AvatarGroupsReply_NewGroupData::read_from(buffer)?;
        Ok(MessageInstance::AvatarGroupsReply(AvatarGroupsReply {
            agent_data: agent_data,
            group_data: group_data,
            new_group_data: new_group_data,
        }))
    }
}

impl Message for AvatarInterestsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xac
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block PropertiesData
        buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask)?;
        buffer.write_u8(self.properties_data.want_to_text.len() as u8)?;
        buffer.write(&self.properties_data.want_to_text[..])?;
        buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask)?;
        buffer.write_u8(self.properties_data.skills_text.len() as u8)?;
        buffer.write(&self.properties_data.skills_text[..])?;
        buffer.write_u8(self.properties_data.languages_text.len() as u8)?;
        buffer.write(&self.properties_data.languages_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarInterestsReply_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarInterestsReply_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarInterestsReply(
            AvatarInterestsReply {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarInterestsUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xaf
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block PropertiesData
        buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask)?;
        buffer.write_u8(self.properties_data.want_to_text.len() as u8)?;
        buffer.write(&self.properties_data.want_to_text[..])?;
        buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask)?;
        buffer.write_u8(self.properties_data.skills_text.len() as u8)?;
        buffer.write(&self.properties_data.skills_text[..])?;
        buffer.write_u8(self.properties_data.languages_text.len() as u8)?;
        buffer.write(&self.properties_data.languages_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarInterestsUpdate_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarInterestsUpdate_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarInterestsUpdate(
            AvatarInterestsUpdate {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarNotesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb0
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.data.notes.len() as u16)?;
        buffer.write(&self.data.notes[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarNotesReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarNotesReply_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarNotesReply(AvatarNotesReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarNotesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb1
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.data.notes.len() as u16)?;
        buffer.write(&self.data.notes[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarNotesUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarNotesUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarNotesUpdate(AvatarNotesUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.avatar_id.as_bytes())?;
            buffer.write_u8(item.first_name.len() as u8)?;
            buffer.write(&item.first_name[..])?;
            buffer.write_u8(item.last_name.len() as u8)?;
            buffer.write(&item.last_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPickerReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarPickerReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarPickerReply(AvatarPickerReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPickerRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarPickerRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarPickerRequest(AvatarPickerRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        buffer.write_u8(self.agent_data.god_level)?;
        // Block Data
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPickerRequestBackend_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarPickerRequestBackend_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarPickerRequestBackend(
            AvatarPickerRequestBackend {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for AvatarPicksReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb2
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.target_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.pick_id.as_bytes())?;
            buffer.write_u8(item.pick_name.len() as u8)?;
            buffer.write(&item.pick_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPicksReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarPicksReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarPicksReply(AvatarPicksReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPropertiesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xab
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block PropertiesData
        buffer.write(self.properties_data.image_id.as_bytes())?;
        buffer.write(self.properties_data.fl_image_id.as_bytes())?;
        buffer.write(self.properties_data.partner_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.properties_data.about_text.len() as u16)?;
        buffer.write(&self.properties_data.about_text[..])?;
        buffer.write_u8(self.properties_data.fl_about_text.len() as u8)?;
        buffer.write(&self.properties_data.fl_about_text[..])?;
        buffer.write_u8(self.properties_data.born_on.len() as u8)?;
        buffer.write(&self.properties_data.born_on[..])?;
        buffer.write_u8(self.properties_data.profile_url.len() as u8)?;
        buffer.write(&self.properties_data.profile_url[..])?;
        buffer.write_u8(self.properties_data.charter_member.len() as u8)?;
        buffer.write(&self.properties_data.charter_member[..])?;
        buffer.write_u32::<LittleEndian>(self.properties_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPropertiesReply_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarPropertiesReply_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesReply(
            AvatarPropertiesReply {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPropertiesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesRequest(
            AvatarPropertiesRequest {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for AvatarPropertiesRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xaa
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        buffer.write_u8(self.agent_data.god_level)?;
        buffer.write_u8(self.agent_data.web_profiles_disabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPropertiesRequestBackend_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesRequestBackend(
            AvatarPropertiesRequestBackend {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for AvatarPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xae
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block PropertiesData
        buffer.write(self.properties_data.image_id.as_bytes())?;
        buffer.write(self.properties_data.fl_image_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.properties_data.about_text.len() as u16)?;
        buffer.write(&self.properties_data.about_text[..])?;
        buffer.write_u8(self.properties_data.fl_about_text.len() as u8)?;
        buffer.write(&self.properties_data.fl_about_text[..])?;
        buffer.write_u8(self.properties_data.allow_publish as u8)?;
        buffer.write_u8(self.properties_data.mature_publish as u8)?;
        buffer.write_u8(self.properties_data.profile_url.len() as u8)?;
        buffer.write(&self.properties_data.profile_url[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarPropertiesUpdate_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarPropertiesUpdate_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesUpdate(
            AvatarPropertiesUpdate {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarSitResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x15])?;
        // Block SitObject
        buffer.write(self.sit_object.id.as_bytes())?;
        // Block SitTransform
        buffer.write_u8(self.sit_transform.auto_pilot as u8)?;
        buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.x)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.y)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.z)?;
        let norm_sit_rotation = if self.sit_transform.sit_rotation.scalar() >= 0. {
            self.sit_transform.sit_rotation.norm()
        } else {
            -self.sit_transform.sit_rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_rotation.coords[0] / norm_sit_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_rotation.coords[1] / norm_sit_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_rotation.coords[2] / norm_sit_rotation,
        )?;
        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.x)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.y)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.z)?;
        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.x)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.y)?;

        buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.z)?;
        buffer.write_u8(self.sit_transform.force_mouselook as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SitObject
        let sit_object = AvatarSitResponse_SitObject::read_from(buffer)?;
        // Block SitTransform
        let sit_transform = AvatarSitResponse_SitTransform::read_from(buffer)?;
        Ok(MessageInstance::AvatarSitResponse(AvatarSitResponse {
            sit_object: sit_object,
            sit_transform: sit_transform,
        }))
    }
}

impl Message for AvatarTextureUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x04
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u8(self.agent_data.textures_changed as u8)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.cache_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
            buffer.write_u8(item.host_name.len() as u8)?;
            buffer.write(&item.host_name[..])?;
        }
        // Block TextureData
        buffer.write_u8(self.texture_data.len() as u8)?;
        for item in &self.texture_data {
            buffer.write(item.texture_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = AvatarTextureUpdate_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AvatarTextureUpdate_WearableData::read_from(buffer)?);
        }
        // Block TextureData
        let mut texture_data = Vec::new();
        let _texture_data_count = buffer.read_u8()?;
        for _ in 0.._texture_data_count {
            texture_data.push(AvatarTextureUpdate_TextureData::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarTextureUpdate(AvatarTextureUpdate {
            agent_data: agent_data,
            wearable_data: wearable_data,
            texture_data: texture_data,
        }))
    }
}

impl Message for BulkUpdateInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x19
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = BulkUpdateInventory_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(BulkUpdateInventory_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(BulkUpdateInventory_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::BulkUpdateInventory(BulkUpdateInventory {
            agent_data: agent_data,
            folder_data: folder_data,
            item_data: item_data,
        }))
    }
}

impl Message for BuyObjectInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x67
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write(self.data.folder_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = BuyObjectInventory_AgentData::read_from(buffer)?;
        // Block Data
        let data = BuyObjectInventory_Data::read_from(buffer)?;
        Ok(MessageInstance::BuyObjectInventory(BuyObjectInventory {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for CameraConstraint {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x16])?;
        // Block CameraCollidePlane
        buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.x)?;

        buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.y)?;

        buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.z)?;

        buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.w)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block CameraCollidePlane
        let camera_collide_plane = CameraConstraint_CameraCollidePlane::read_from(buffer)?;
        Ok(MessageInstance::CameraConstraint(CameraConstraint {
            camera_collide_plane: camera_collide_plane,
        }))
    }
}

impl Message for CancelAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe8
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(CancelAuction_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::CancelAuction(CancelAuction {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ChangeInventoryItemFlags {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChangeInventoryItemFlags_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(ChangeInventoryItemFlags_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::ChangeInventoryItemFlags(
            ChangeInventoryItemFlags {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for ChangeUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x41
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Rights
        buffer.write_u8(self.rights.len() as u8)?;
        for item in &self.rights {
            buffer.write(item.agent_related.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.related_rights)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChangeUserRights_AgentData::read_from(buffer)?;
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = buffer.read_u8()?;
        for _ in 0.._rights_count {
            rights.push(ChangeUserRights_Rights::read_from(buffer)?);
        }
        Ok(MessageInstance::ChangeUserRights(ChangeUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for ChatFromSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8b
        ])?;
        // Block ChatData
        buffer.write_u8(self.chat_data.from_name.len() as u8)?;
        buffer.write(&self.chat_data.from_name[..])?;
        buffer.write(self.chat_data.source_id.as_bytes())?;
        buffer.write(self.chat_data.owner_id.as_bytes())?;
        buffer.write_u8(self.chat_data.source_type)?;
        buffer.write_u8(self.chat_data.chat_type)?;
        buffer.write_u8(self.chat_data.audible)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.x)?;

        buffer.write_f32::<LittleEndian>(self.chat_data.position.y)?;

        buffer.write_f32::<LittleEndian>(self.chat_data.position.z)?;
        buffer.write_u16::<LittleEndian>(self.chat_data.message.len() as u16)?;
        buffer.write(&self.chat_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ChatData
        let chat_data = ChatFromSimulator_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatFromSimulator(ChatFromSimulator {
            chat_data: chat_data,
        }))
    }
}

impl Message for ChatFromViewer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x50
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ChatData
        buffer.write_u16::<LittleEndian>(self.chat_data.message.len() as u16)?;
        buffer.write(&self.chat_data.message[..])?;
        buffer.write_u8(self.chat_data.type_)?;
        buffer.write_i32::<LittleEndian>(self.chat_data.channel)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChatFromViewer_AgentData::read_from(buffer)?;
        // Block ChatData
        let chat_data = ChatFromViewer_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatFromViewer(ChatFromViewer {
            agent_data: agent_data,
            chat_data: chat_data,
        }))
    }
}

impl Message for ChatPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xef
        ])?;
        // Block ChatData
        buffer.write_i32::<LittleEndian>(self.chat_data.channel)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.x)?;

        buffer.write_f32::<LittleEndian>(self.chat_data.position.y)?;

        buffer.write_f32::<LittleEndian>(self.chat_data.position.z)?;
        buffer.write(self.chat_data.id.as_bytes())?;
        buffer.write(self.chat_data.owner_id.as_bytes())?;
        buffer.write_u8(self.chat_data.name.len() as u8)?;
        buffer.write(&self.chat_data.name[..])?;
        buffer.write_u8(self.chat_data.source_type)?;
        buffer.write_u8(self.chat_data.type_)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.radius)?;
        buffer.write_u8(self.chat_data.sim_access)?;
        buffer.write_u16::<LittleEndian>(self.chat_data.message.len() as u16)?;
        buffer.write(&self.chat_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ChatData
        let chat_data = ChatPass_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatPass(ChatPass {
            chat_data: chat_data,
        }))
    }
}

impl Message for CheckParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe9
        ])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(CheckParcelAuctions_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::CheckParcelAuctions(CheckParcelAuctions {
            region_data: region_data,
        }))
    }
}

impl Message for CheckParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe1
        ])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(CheckParcelSales_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::CheckParcelSales(CheckParcelSales {
            region_data: region_data,
        }))
    }
}

impl Message for ChildAgentAlive {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x1a])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(self.agent_data.region_handle)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code)?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChildAgentAlive_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentAlive(ChildAgentAlive {
            agent_data: agent_data,
        }))
    }
}

impl Message for ChildAgentDying {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf0
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChildAgentDying_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentDying(ChildAgentDying {
            agent_data: agent_data,
        }))
    }
}

impl Message for ChildAgentPositionUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x1b])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(self.agent_data.region_handle)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code)?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.center.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.center.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z)?;
        buffer.write_u8(self.agent_data.changed_grid as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChildAgentPositionUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentPositionUpdate(
            ChildAgentPositionUpdate {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for ChildAgentUnknown {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf1
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChildAgentUnknown_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentUnknown(ChildAgentUnknown {
            agent_data: agent_data,
        }))
    }
}

impl Message for ChildAgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x19])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(self.agent_data.region_handle)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code)?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.center.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.center.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z)?;
        buffer.write_u8(self.agent_data.changed_grid as u8)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.far)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.aspect)?;
        buffer.write_u8(self.agent_data.throttles.len() as u8)?;
        buffer.write(&self.agent_data.throttles[..])?;
        buffer.write_u32::<LittleEndian>(self.agent_data.locomotion_state)?;
        let norm_head_rotation = if self.agent_data.head_rotation.scalar() >= 0. {
            self.agent_data.head_rotation.norm()
        } else {
            -self.agent_data.head_rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[0] / norm_head_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[1] / norm_head_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.head_rotation.coords[2] / norm_head_rotation,
        )?;
        let norm_body_rotation = if self.agent_data.body_rotation.scalar() >= 0. {
            self.agent_data.body_rotation.norm()
        } else {
            -self.agent_data.body_rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[0] / norm_body_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[1] / norm_body_rotation,
        )?;

        buffer.write_f32::<LittleEndian>(
            self.agent_data.body_rotation.coords[2] / norm_body_rotation,
        )?;
        buffer.write_u32::<LittleEndian>(self.agent_data.control_flags)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.energy_level)?;
        buffer.write_u8(self.agent_data.god_level)?;
        buffer.write_u8(self.agent_data.always_run as u8)?;
        buffer.write(self.agent_data.prey_agent.as_bytes())?;
        buffer.write_u8(self.agent_data.agent_access)?;
        buffer.write_u16::<LittleEndian>(self.agent_data.agent_textures.len() as u16)?;
        buffer.write(&self.agent_data.agent_textures[..])?;
        buffer.write(self.agent_data.active_group_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
        }
        // Block AnimationData
        buffer.write_u8(self.animation_data.len() as u8)?;
        for item in &self.animation_data {
            buffer.write(item.animation.as_bytes())?;
            buffer.write(item.object_id.as_bytes())?;
        }
        // Block GranterBlock
        buffer.write_u8(self.granter_block.len() as u8)?;
        for item in &self.granter_block {
            buffer.write(item.granter_id.as_bytes())?;
        }
        // Block NVPairData
        buffer.write_u8(self.nv_pair_data.len() as u8)?;
        for item in &self.nv_pair_data {
            buffer.write_u16::<LittleEndian>(item.nv_pairs.len() as u16)?;
            buffer.write(&item.nv_pairs[..])?;
        }
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        // Block AgentAccess
        buffer.write_u8(self.agent_access.len() as u8)?;
        for item in &self.agent_access {
            buffer.write_u8(item.agent_legacy_access)?;
            buffer.write_u8(item.agent_max_access)?;
        }
        // Block AgentInfo
        buffer.write_u8(self.agent_info.len() as u8)?;
        for item in &self.agent_info {
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ChildAgentUpdate_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(ChildAgentUpdate_GroupData::read_from(buffer)?);
        }
        // Block AnimationData
        let mut animation_data = Vec::new();
        let _animation_data_count = buffer.read_u8()?;
        for _ in 0.._animation_data_count {
            animation_data.push(ChildAgentUpdate_AnimationData::read_from(buffer)?);
        }
        // Block GranterBlock
        let mut granter_block = Vec::new();
        let _granter_block_count = buffer.read_u8()?;
        for _ in 0.._granter_block_count {
            granter_block.push(ChildAgentUpdate_GranterBlock::read_from(buffer)?);
        }
        // Block NVPairData
        let mut nv_pair_data = Vec::new();
        let _nv_pair_data_count = buffer.read_u8()?;
        for _ in 0.._nv_pair_data_count {
            nv_pair_data.push(ChildAgentUpdate_NVPairData::read_from(buffer)?);
        }
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(ChildAgentUpdate_VisualParam::read_from(buffer)?);
        }
        // Block AgentAccess
        let mut agent_access = Vec::new();
        let _agent_access_count = buffer.read_u8()?;
        for _ in 0.._agent_access_count {
            agent_access.push(ChildAgentUpdate_AgentAccess::read_from(buffer)?);
        }
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = buffer.read_u8()?;
        for _ in 0.._agent_info_count {
            agent_info.push(ChildAgentUpdate_AgentInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ChildAgentUpdate(ChildAgentUpdate {
            agent_data: agent_data,
            group_data: group_data,
            animation_data: animation_data,
            granter_block: granter_block,
            nv_pair_data: nv_pair_data,
            visual_param: visual_param,
            agent_access: agent_access,
            agent_info: agent_info,
        }))
    }
}

impl Message for ClassifiedDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ClassifiedDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedDelete(ClassifiedDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write(self.data.query_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ClassifiedGodDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedGodDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedGodDelete(ClassifiedGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.data.expiration_date)?;
        buffer.write_u32::<LittleEndian>(self.data.category)?;
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.data.desc.len() as u16)?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.parent_estate)?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_u8(self.data.sim_name.len() as u8)?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_u8(self.data.parcel_name.len() as u8)?;
        buffer.write(&self.data.parcel_name[..])?;
        buffer.write_u8(self.data.classified_flags)?;
        buffer.write_i32::<LittleEndian>(self.data.price_for_listing)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ClassifiedInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoReply(ClassifiedInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ClassifiedInfoRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoRequest(
            ClassifiedInfoRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ClassifiedInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x2d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.category)?;
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.data.desc.len() as u16)?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.parent_estate)?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_u8(self.data.classified_flags)?;
        buffer.write_i32::<LittleEndian>(self.data.price_for_listing)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ClassifiedInfoUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoUpdate(
            ClassifiedInfoUpdate {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ClearFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa0
        ])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = ClearFollowCamProperties_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ClearFollowCamProperties(
            ClearFollowCamProperties {
                object_data: object_data,
            },
        ))
    }
}

impl Message for CloseCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0xff, 0xFD
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::CloseCircuit(CloseCircuit {}))
    }
}

impl Message for CoarseLocationUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x06])?;
        // Block Location
        buffer.write_u8(self.location.len() as u8)?;
        for item in &self.location {
            buffer.write_u8(item.x)?;
            buffer.write_u8(item.y)?;
            buffer.write_u8(item.z)?;
        }
        // Block Index
        buffer.write_i16::<LittleEndian>(self.index.you)?;
        buffer.write_i16::<LittleEndian>(self.index.prey)?;
        // Block AgentData
        buffer.write_u8(self.agent_data.len() as u8)?;
        for item in &self.agent_data {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Location
        let mut location = Vec::new();
        let _location_count = buffer.read_u8()?;
        for _ in 0.._location_count {
            location.push(CoarseLocationUpdate_Location::read_from(buffer)?);
        }
        // Block Index
        let index = CoarseLocationUpdate_Index::read_from(buffer)?;
        // Block AgentData
        let mut agent_data = Vec::new();
        let _agent_data_count = buffer.read_u8()?;
        for _ in 0.._agent_data_count {
            agent_data.push(CoarseLocationUpdate_AgentData::read_from(buffer)?);
        }
        Ok(MessageInstance::CoarseLocationUpdate(
            CoarseLocationUpdate {
                location: location,
                index: index,
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for CompleteAgentMovement {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CompleteAgentMovement_AgentData::read_from(buffer)?;
        Ok(MessageInstance::CompleteAgentMovement(
            CompleteAgentMovement {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for CompleteAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe7
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(CompleteAuction_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::CompleteAuction(CompleteAuction {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for CompletePingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x02])?;
        // Block PingID
        buffer.write_u8(self.ping_id.ping_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block PingID
        let ping_id = CompletePingCheck_PingID::read_from(buffer)?;
        Ok(MessageInstance::CompletePingCheck(
            CompletePingCheck { ping_id: ping_id },
        ))
    }
}

impl Message for ConfirmAuctionStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe6
        ])?;
        // Block AuctionData
        buffer.write(self.auction_data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.auction_data.auction_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AuctionData
        let auction_data = ConfirmAuctionStart_AuctionData::read_from(buffer)?;
        Ok(MessageInstance::ConfirmAuctionStart(ConfirmAuctionStart {
            auction_data: auction_data,
        }))
    }
}

impl Message for ConfirmEnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x08])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ConfirmEnableSimulator_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ConfirmEnableSimulator(
            ConfirmEnableSimulator {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for ConfirmXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x13])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_u32::<LittleEndian>(self.xfer_id.packet)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block XferID
        let xfer_id = ConfirmXferPacket_XferID::read_from(buffer)?;
        Ok(MessageInstance::ConfirmXferPacket(
            ConfirmXferPacket { xfer_id: xfer_id },
        ))
    }
}

impl Message for CopyInventoryFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x09
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block NotecardData
        buffer.write(self.notecard_data.notecard_item_id.as_bytes())?;
        buffer.write(self.notecard_data.object_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CopyInventoryFromNotecard_AgentData::read_from(buffer)?;
        // Block NotecardData
        let notecard_data = CopyInventoryFromNotecard_NotecardData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(CopyInventoryFromNotecard_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::CopyInventoryFromNotecard(
            CopyInventoryFromNotecard {
                agent_data: agent_data,
                notecard_data: notecard_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for CopyInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.old_agent_id.as_bytes())?;
            buffer.write(item.old_item_id.as_bytes())?;
            buffer.write(item.new_folder_id.as_bytes())?;
            buffer.write_u8(item.new_name.len() as u8)?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CopyInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(CopyInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::CopyInventoryItem(CopyInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for CreateGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x54
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block ReplyData
        buffer.write(self.reply_data.group_id.as_bytes())?;
        buffer.write_u8(self.reply_data.success as u8)?;
        buffer.write_u8(self.reply_data.message.len() as u8)?;
        buffer.write(&self.reply_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateGroupReply_AgentData::read_from(buffer)?;
        // Block ReplyData
        let reply_data = CreateGroupReply_ReplyData::read_from(buffer)?;
        Ok(MessageInstance::CreateGroupReply(CreateGroupReply {
            agent_data: agent_data,
            reply_data: reply_data,
        }))
    }
}

impl Message for CreateGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x53
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.name.len() as u8)?;
        buffer.write(&self.group_data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.group_data.charter.len() as u16)?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.membership_fee)?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = CreateGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::CreateGroupRequest(CreateGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for CreateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x11
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write(self.folder_data.folder_id.as_bytes())?;
        buffer.write(self.folder_data.parent_id.as_bytes())?;
        buffer.write_i8(self.folder_data.type_)?;
        buffer.write_u8(self.folder_data.name.len() as u8)?;
        buffer.write(&self.folder_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let folder_data = CreateInventoryFolder_FolderData::read_from(buffer)?;
        Ok(MessageInstance::CreateInventoryFolder(
            CreateInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for CreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x31
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id)?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask)?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write_u8(self.inventory_block.wearable_type)?;
        buffer.write_u8(self.inventory_block.name.len() as u8)?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write_u8(self.inventory_block.description.len() as u8)?;
        buffer.write(&self.inventory_block.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = CreateInventoryItem_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateInventoryItem(CreateInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for CreateLandmarkForEvent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x32
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        // Block InventoryBlock
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write_u8(self.inventory_block.name.len() as u8)?;
        buffer.write(&self.inventory_block.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateLandmarkForEvent_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = CreateLandmarkForEvent_EventData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = CreateLandmarkForEvent_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateLandmarkForEvent(
            CreateLandmarkForEvent {
                agent_data: agent_data,
                event_data: event_data,
                inventory_block: inventory_block,
            },
        ))
    }
}

impl Message for CreateNewOutfitAttachments {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write(self.header_data.new_folder_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.old_item_id.as_bytes())?;
            buffer.write(item.old_folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CreateNewOutfitAttachments_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = CreateNewOutfitAttachments_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(CreateNewOutfitAttachments_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::CreateNewOutfitAttachments(
            CreateNewOutfitAttachments {
                agent_data: agent_data,
                header_data: header_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for CreateTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x88
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.end_point_id.as_bytes())?;
        buffer.write(&self.data_block.digest)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = CreateTrustedCircuit_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateTrustedCircuit(
            CreateTrustedCircuit {
                data_block: data_block,
            },
        ))
    }
}

impl Message for CrossedRegion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x07])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionData
        buffer.write(&self.region_data.sim_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.region_data.sim_port)?;
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.region_data.seed_capability.len() as u16)?;
        buffer.write(&self.region_data.seed_capability[..])?;
        // Block Info
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;

        buffer.write_f32::<LittleEndian>(self.info.position.y)?;

        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = CrossedRegion_AgentData::read_from(buffer)?;
        // Block RegionData
        let region_data = CrossedRegion_RegionData::read_from(buffer)?;
        // Block Info
        let info = CrossedRegion_Info::read_from(buffer)?;
        Ok(MessageInstance::CrossedRegion(CrossedRegion {
            agent_data: agent_data,
            region_data: region_data,
            info: info,
        }))
    }
}

impl Message for DataHomeLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x44
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;

        buffer.write_f32::<LittleEndian>(self.info.position.y)?;

        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = DataHomeLocationReply_Info::read_from(buffer)?;
        Ok(MessageInstance::DataHomeLocationReply(
            DataHomeLocationReply { info: info },
        ))
    }
}

impl Message for DataHomeLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x43
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.kicked_from_estate_id)?;
        // Block AgentInfo
        buffer.write_u32::<LittleEndian>(self.agent_info.agent_effective_maturity)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = DataHomeLocationRequest_Info::read_from(buffer)?;
        // Block AgentInfo
        let agent_info = DataHomeLocationRequest_AgentInfo::read_from(buffer)?;
        Ok(MessageInstance::DataHomeLocationRequest(
            DataHomeLocationRequest {
                info: info,
                agent_info: agent_info,
            },
        ))
    }
}

impl Message for DataServerLogout {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xfb
        ])?;
        // Block UserData
        buffer.write(self.user_data.agent_id.as_bytes())?;
        buffer.write(&self.user_data.viewer_ip.octets())?;
        buffer.write_u8(self.user_data.disconnect as u8)?;
        buffer.write(self.user_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UserData
        let user_data = DataServerLogout_UserData::read_from(buffer)?;
        Ok(MessageInstance::DataServerLogout(DataServerLogout {
            user_data: user_data,
        }))
    }
}

impl Message for DeRezAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x24
        ])?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        buffer.write_u8(self.transaction_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransactionData
        let transaction_data = DeRezAck_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::DeRezAck(DeRezAck {
            transaction_data: transaction_data,
        }))
    }
}

impl Message for DeRezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x23
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AgentBlock
        buffer.write(self.agent_block.group_id.as_bytes())?;
        buffer.write_u8(self.agent_block.destination)?;
        buffer.write(self.agent_block.destination_id.as_bytes())?;
        buffer.write(self.agent_block.transaction_id.as_bytes())?;
        buffer.write_u8(self.agent_block.packet_count)?;
        buffer.write_u8(self.agent_block.packet_number)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DeRezObject_AgentData::read_from(buffer)?;
        // Block AgentBlock
        let agent_block = DeRezObject_AgentBlock::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(DeRezObject_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::DeRezObject(DeRezObject {
            agent_data: agent_data,
            agent_block: agent_block,
            object_data: object_data,
        }))
    }
}

impl Message for DeactivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.gesture_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DeactivateGestures_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(DeactivateGestures_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::DeactivateGestures(DeactivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DeclineCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(self.transaction_block.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DeclineCallingCard_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = DeclineCallingCard_TransactionBlock::read_from(buffer)?;
        Ok(MessageInstance::DeclineCallingCard(DeclineCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for DeclineFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(self.transaction_block.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DeclineFriendship_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = DeclineFriendship_TransactionBlock::read_from(buffer)?;
        Ok(MessageInstance::DeclineFriendship(DeclineFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for DenyTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x89
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.end_point_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = DenyTrustedCircuit_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::DenyTrustedCircuit(DenyTrustedCircuit {
            data_block: data_block,
        }))
    }
}

impl Message for DerezContainer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x68
        ])?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_u8(self.data.delete as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = DerezContainer_Data::read_from(buffer)?;
        Ok(MessageInstance::DerezContainer(
            DerezContainer { data: data },
        ))
    }
}

impl Message for DetachAttachmentIntoInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8d
        ])?;
        // Block ObjectData
        buffer.write(self.object_data.agent_id.as_bytes())?;
        buffer.write(self.object_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = DetachAttachmentIntoInv_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::DetachAttachmentIntoInv(
            DetachAttachmentIntoInv {
                object_data: object_data,
            },
        ))
    }
}

impl Message for DirClassifiedQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x27
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_u32::<LittleEndian>(self.query_data.category)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirClassifiedQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirClassifiedQuery(DirClassifiedQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirClassifiedQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x28
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_u32::<LittleEndian>(self.query_data.category)?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirClassifiedQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirClassifiedQueryBackend(
            DirClassifiedQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x29
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.classified_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.classified_flags)?;
            buffer.write_u32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.expiration_date)?;
            buffer.write_i32::<LittleEndian>(item.price_for_listing)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirClassifiedReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirClassifiedReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirClassifiedReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirClassifiedReply(DirClassifiedReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirEventsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x25
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u32::<LittleEndian>(item.event_id)?;
            buffer.write_u8(item.date.len() as u8)?;
            buffer.write(&item.date[..])?;
            buffer.write_u32::<LittleEndian>(item.unix_time)?;
            buffer.write_u32::<LittleEndian>(item.event_flags)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirEventsReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirEventsReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirEventsReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirEventsReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirEventsReply(DirEventsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirFindQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirFindQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirFindQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirFindQuery(DirFindQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirFindQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x20
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirFindQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirFindQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirFindQueryBackend(DirFindQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x26
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u8(item.group_name.len() as u8)?;
            buffer.write(&item.group_name[..])?;
            buffer.write_i32::<LittleEndian>(item.members)?;
            buffer.write_f32::<LittleEndian>(item.search_order)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirGroupsReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirGroupsReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirGroupsReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirGroupsReply(DirGroupsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirLandQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x30
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_u32::<LittleEndian>(self.query_data.search_type)?;
        buffer.write_i32::<LittleEndian>(self.query_data.price)?;
        buffer.write_i32::<LittleEndian>(self.query_data.area)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirLandQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirLandQuery(DirLandQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x31
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_u32::<LittleEndian>(self.query_data.search_type)?;
        buffer.write_i32::<LittleEndian>(self.query_data.price)?;
        buffer.write_i32::<LittleEndian>(self.query_data.area)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirLandQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirLandQueryBackend(DirLandQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x32
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.auction as u8)?;
            buffer.write_u8(item.for_sale as u8)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirLandReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirLandReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirLandReply(DirLandReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirPeopleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x24
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write_u8(item.first_name.len() as u8)?;
            buffer.write(&item.first_name[..])?;
            buffer.write_u8(item.last_name.len() as u8)?;
            buffer.write(&item.last_name[..])?;
            buffer.write_u8(item.group.len() as u8)?;
            buffer.write(&item.group[..])?;
            buffer.write_u8(item.online as u8)?;
            buffer.write_i32::<LittleEndian>(item.reputation)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPeopleReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPeopleReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPeopleReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPeopleReply(DirPeopleReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirPlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x21
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write_u8(self.query_data.sim_name.len() as u8)?;
        buffer.write(&self.query_data.sim_name[..])?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPlacesQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPlacesQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPlacesQuery(DirPlacesQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x22
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write_u8(self.query_data.sim_name.len() as u8)?;
        buffer.write(&self.query_data.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPlacesQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPlacesQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPlacesQueryBackend(
            DirPlacesQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirPlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x23
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write_u8(self.query_data.len() as u8)?;
        for item in &self.query_data {
            buffer.write(item.query_id.as_bytes())?;
        }
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.for_sale as u8)?;
            buffer.write_u8(item.auction as u8)?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPlacesReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = buffer.read_u8()?;
        for _ in 0.._query_data_count {
            query_data.push(DirPlacesReply_QueryData::read_from(buffer)?);
        }
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPlacesReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirPlacesReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPlacesReply(DirPlacesReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirPopularQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x33
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPopularQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPopularQuery(DirPopularQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPopularQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x34
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPopularQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPopularQueryBackend(
            DirPopularQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirPopularReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x35
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = DirPopularReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPopularReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPopularReply(DirPopularReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DisableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x98
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::DisableSimulator(DisableSimulator {}))
    }
}

impl Message for EconomyData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x19
        ])?;
        // Block Info
        buffer.write_i32::<LittleEndian>(self.info.object_capacity)?;
        buffer.write_i32::<LittleEndian>(self.info.object_count)?;
        buffer.write_i32::<LittleEndian>(self.info.price_energy_unit)?;
        buffer.write_i32::<LittleEndian>(self.info.price_object_claim)?;
        buffer.write_i32::<LittleEndian>(self.info.price_public_object_decay)?;
        buffer.write_i32::<LittleEndian>(self.info.price_public_object_delete)?;
        buffer.write_i32::<LittleEndian>(self.info.price_parcel_claim)?;
        buffer.write_f32::<LittleEndian>(self.info.price_parcel_claim_factor)?;
        buffer.write_i32::<LittleEndian>(self.info.price_upload)?;
        buffer.write_i32::<LittleEndian>(self.info.price_rent_light)?;
        buffer.write_i32::<LittleEndian>(self.info.teleport_min_price)?;
        buffer.write_f32::<LittleEndian>(self.info.teleport_price_exponent)?;
        buffer.write_f32::<LittleEndian>(self.info.energy_efficiency)?;
        buffer.write_f32::<LittleEndian>(self.info.price_object_rent)?;
        buffer.write_f32::<LittleEndian>(self.info.price_object_scale_factor)?;
        buffer.write_i32::<LittleEndian>(self.info.price_parcel_rent)?;
        buffer.write_i32::<LittleEndian>(self.info.price_group_create)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = EconomyData_Info::read_from(buffer)?;
        Ok(MessageInstance::EconomyData(EconomyData { info: info }))
    }
}

impl Message for EconomyDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x18
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::EconomyDataRequest(EconomyDataRequest {}))
    }
}

impl Message for EdgeDataPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x18])?;
        // Block EdgeData
        buffer.write_u8(self.edge_data.layer_type)?;
        buffer.write_u8(self.edge_data.direction)?;
        buffer.write_u16::<LittleEndian>(self.edge_data.layer_data.len() as u16)?;
        buffer.write(&self.edge_data.layer_data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block EdgeData
        let edge_data = EdgeDataPacket_EdgeData::read_from(buffer)?;
        Ok(MessageInstance::EdgeDataPacket(EdgeDataPacket {
            edge_data: edge_data,
        }))
    }
}

impl Message for EjectGroupMemberReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block EjectData
        buffer.write_u8(self.eject_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EjectGroupMemberReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = EjectGroupMemberReply_GroupData::read_from(buffer)?;
        // Block EjectData
        let eject_data = EjectGroupMemberReply_EjectData::read_from(buffer)?;
        Ok(MessageInstance::EjectGroupMemberReply(
            EjectGroupMemberReply {
                agent_data: agent_data,
                group_data: group_data,
                eject_data: eject_data,
            },
        ))
    }
}

impl Message for EjectGroupMemberRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x59
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block EjectData
        buffer.write_u8(self.eject_data.len() as u8)?;
        for item in &self.eject_data {
            buffer.write(item.ejectee_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EjectGroupMemberRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = EjectGroupMemberRequest_GroupData::read_from(buffer)?;
        // Block EjectData
        let mut eject_data = Vec::new();
        let _eject_data_count = buffer.read_u8()?;
        for _ in 0.._eject_data_count {
            eject_data.push(EjectGroupMemberRequest_EjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::EjectGroupMemberRequest(
            EjectGroupMemberRequest {
                agent_data: agent_data,
                group_data: group_data,
                eject_data: eject_data,
            },
        ))
    }
}

impl Message for EjectUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa7
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EjectUser_AgentData::read_from(buffer)?;
        // Block Data
        let data = EjectUser_Data::read_from(buffer)?;
        Ok(MessageInstance::EjectUser(EjectUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for EmailMessageReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x50
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.more)?;
        buffer.write_u32::<LittleEndian>(self.data_block.time)?;
        buffer.write_u8(self.data_block.from_address.len() as u8)?;
        buffer.write(&self.data_block.from_address[..])?;
        buffer.write_u8(self.data_block.subject.len() as u8)?;
        buffer.write(&self.data_block.subject[..])?;
        buffer.write_u16::<LittleEndian>(self.data_block.data.len() as u16)?;
        buffer.write(&self.data_block.data[..])?;
        buffer.write_u8(self.data_block.mail_filter.len() as u8)?;
        buffer.write(&self.data_block.mail_filter[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = EmailMessageReply_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::EmailMessageReply(EmailMessageReply {
            data_block: data_block,
        }))
    }
}

impl Message for EmailMessageRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4f
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write_u8(self.data_block.from_address.len() as u8)?;
        buffer.write(&self.data_block.from_address[..])?;
        buffer.write_u8(self.data_block.subject.len() as u8)?;
        buffer.write(&self.data_block.subject[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = EmailMessageRequest_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::EmailMessageRequest(EmailMessageRequest {
            data_block: data_block,
        }))
    }
}

impl Message for EnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x97
        ])?;
        // Block SimulatorInfo
        buffer.write_u64::<LittleEndian>(self.simulator_info.handle)?;
        buffer.write(&self.simulator_info.ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.simulator_info.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimulatorInfo
        let simulator_info = EnableSimulator_SimulatorInfo::read_from(buffer)?;
        Ok(MessageInstance::EnableSimulator(EnableSimulator {
            simulator_info: simulator_info,
        }))
    }
}

impl Message for Error {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa7
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.code)?;
        buffer.write_u8(self.data.token.len() as u8)?;
        buffer.write(&self.data.token[..])?;
        buffer.write(self.data.id.as_bytes())?;
        buffer.write_u8(self.data.system.len() as u8)?;
        buffer.write(&self.data.system[..])?;
        buffer.write_u16::<LittleEndian>(self.data.message.len() as u16)?;
        buffer.write(&self.data.message[..])?;
        buffer.write_u16::<LittleEndian>(self.data.data.len() as u16)?;
        buffer.write(&self.data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = Error_AgentData::read_from(buffer)?;
        // Block Data
        let data = Error_Data::read_from(buffer)?;
        Ok(MessageInstance::Error(Error {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for EstateCovenantReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xcc
        ])?;
        // Block Data
        buffer.write(self.data.covenant_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.covenant_timestamp)?;
        buffer.write_u8(self.data.estate_name.len() as u8)?;
        buffer.write(&self.data.estate_name[..])?;
        buffer.write(self.data.estate_owner_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = EstateCovenantReply_Data::read_from(buffer)?;
        Ok(MessageInstance::EstateCovenantReply(
            EstateCovenantReply { data: data },
        ))
    }
}

impl Message for EstateCovenantRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xcb
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EstateCovenantRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::EstateCovenantRequest(
            EstateCovenantRequest {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for EstateOwnerMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x04
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write_u8(self.method_data.method.len() as u8)?;
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write_u8(item.parameter.len() as u8)?;
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EstateOwnerMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = EstateOwnerMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(EstateOwnerMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::EstateOwnerMessage(EstateOwnerMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for EventGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb7
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i32::<LittleEndian>(self.query_data.query_start)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EventGodDelete_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventGodDelete_EventData::read_from(buffer)?;
        // Block QueryData
        let query_data = EventGodDelete_QueryData::read_from(buffer)?;
        Ok(MessageInstance::EventGodDelete(EventGodDelete {
            agent_data: agent_data,
            event_data: event_data,
            query_data: query_data,
        }))
    }
}

impl Message for EventInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb4
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        buffer.write_u8(self.event_data.creator.len() as u8)?;
        buffer.write(&self.event_data.creator[..])?;
        buffer.write_u8(self.event_data.name.len() as u8)?;
        buffer.write(&self.event_data.name[..])?;
        buffer.write_u8(self.event_data.category.len() as u8)?;
        buffer.write(&self.event_data.category[..])?;
        buffer.write_u16::<LittleEndian>(self.event_data.desc.len() as u16)?;
        buffer.write(&self.event_data.desc[..])?;
        buffer.write_u8(self.event_data.date.len() as u8)?;
        buffer.write(&self.event_data.date[..])?;
        buffer.write_u32::<LittleEndian>(self.event_data.date_utc)?;
        buffer.write_u32::<LittleEndian>(self.event_data.duration)?;
        buffer.write_u32::<LittleEndian>(self.event_data.cover)?;
        buffer.write_u32::<LittleEndian>(self.event_data.amount)?;
        buffer.write_u8(self.event_data.sim_name.len() as u8)?;
        buffer.write(&self.event_data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(self.event_data.global_pos.x)?;

        buffer.write_f64::<LittleEndian>(self.event_data.global_pos.y)?;

        buffer.write_f64::<LittleEndian>(self.event_data.global_pos.z)?;
        buffer.write_u32::<LittleEndian>(self.event_data.event_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EventInfoReply_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventInfoReply_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventInfoReply(EventInfoReply {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb3
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EventInfoRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventInfoRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventInfoRequest(EventInfoRequest {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x34
        ])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block EventData
        buffer.write_u8(self.event_data.success as u8)?;
        buffer.write(self.event_data.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.event_data.region_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.event_data.region_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.event_data.region_pos.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block QueryData
        let query_data = EventLocationReply_QueryData::read_from(buffer)?;
        // Block EventData
        let event_data = EventLocationReply_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventLocationReply(EventLocationReply {
            query_data: query_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x33
        ])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block QueryData
        let query_data = EventLocationRequest_QueryData::read_from(buffer)?;
        // Block EventData
        let event_data = EventLocationRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventLocationRequest(
            EventLocationRequest {
                query_data: query_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for EventNotificationAddRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EventNotificationAddRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventNotificationAddRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventNotificationAddRequest(
            EventNotificationAddRequest {
                agent_data: agent_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for EventNotificationRemoveRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb6
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = EventNotificationRemoveRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventNotificationRemoveRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventNotificationRemoveRequest(
            EventNotificationRemoveRequest {
                agent_data: agent_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for FeatureDisabled {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x13
        ])?;
        // Block FailureInfo
        buffer.write_u8(self.failure_info.error_message.len() as u8)?;
        buffer.write(&self.failure_info.error_message[..])?;
        buffer.write(self.failure_info.agent_id.as_bytes())?;
        buffer.write(self.failure_info.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block FailureInfo
        let failure_info = FeatureDisabled_FailureInfo::read_from(buffer)?;
        Ok(MessageInstance::FeatureDisabled(FeatureDisabled {
            failure_info: failure_info,
        }))
    }
}

impl Message for FetchInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x17
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = FetchInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(FetchInventory_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::FetchInventory(FetchInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for FetchInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x15
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.sort_order)?;
        buffer.write_u8(self.inventory_data.fetch_folders as u8)?;
        buffer.write_u8(self.inventory_data.fetch_items as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = FetchInventoryDescendents_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = FetchInventoryDescendents_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::FetchInventoryDescendents(
            FetchInventoryDescendents {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for FetchInventoryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x18
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = FetchInventoryReply_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(FetchInventoryReply_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::FetchInventoryReply(FetchInventoryReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for FindAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x00
        ])?;
        // Block AgentBlock
        buffer.write(self.agent_block.hunter.as_bytes())?;
        buffer.write(self.agent_block.prey.as_bytes())?;
        buffer.write(&self.agent_block.space_ip.octets())?;
        // Block LocationBlock
        buffer.write_u8(self.location_block.len() as u8)?;
        for item in &self.location_block {
            buffer.write_f64::<LittleEndian>(item.global_x)?;
            buffer.write_f64::<LittleEndian>(item.global_y)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentBlock
        let agent_block = FindAgent_AgentBlock::read_from(buffer)?;
        // Block LocationBlock
        let mut location_block = Vec::new();
        let _location_block_count = buffer.read_u8()?;
        for _ in 0.._location_block_count {
            location_block.push(FindAgent_LocationBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::FindAgent(FindAgent {
            agent_block: agent_block,
            location_block: location_block,
        }))
    }
}

impl Message for ForceObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xcd
        ])?;
        // Block Header
        buffer.write_u8(self.header.reset_list as u8)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Header
        let header = ForceObjectSelect_Header::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ForceObjectSelect_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ForceObjectSelect(ForceObjectSelect {
            header: header,
            data: data,
        }))
    }
}

impl Message for ForceScriptControlRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc0
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ForceScriptControlRelease_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ForceScriptControlRelease(
            ForceScriptControlRelease {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for FormFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2b
        ])?;
        // Block AgentBlock
        buffer.write(self.agent_block.source_id.as_bytes())?;
        buffer.write(self.agent_block.dest_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentBlock
        let agent_block = FormFriendship_AgentBlock::read_from(buffer)?;
        Ok(MessageInstance::FormFriendship(FormFriendship {
            agent_block: agent_block,
        }))
    }
}

impl Message for FreezeUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa8
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = FreezeUser_AgentData::read_from(buffer)?;
        // Block Data
        let data = FreezeUser_Data::read_from(buffer)?;
        Ok(MessageInstance::FreezeUser(FreezeUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GenericMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x05
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write_u8(self.method_data.method.len() as u8)?;
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write_u8(item.parameter.len() as u8)?;
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GenericMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = GenericMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(GenericMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::GenericMessage(GenericMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for GetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf3
        ])?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Script
        let script = GetScriptRunning_Script::read_from(buffer)?;
        Ok(MessageInstance::GetScriptRunning(
            GetScriptRunning { script: script },
        ))
    }
}

impl Message for GodKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa5
        ])?;
        // Block UserInfo
        buffer.write(self.user_info.god_id.as_bytes())?;
        buffer.write(self.user_info.god_session_id.as_bytes())?;
        buffer.write(self.user_info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.user_info.kick_flags)?;
        buffer.write_u16::<LittleEndian>(self.user_info.reason.len() as u16)?;
        buffer.write(&self.user_info.reason[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UserInfo
        let user_info = GodKickUser_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::GodKickUser(GodKickUser {
            user_info: user_info,
        }))
    }
}

impl Message for GodUpdateRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write_u8(self.region_info.sim_name.len() as u8)?;
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.region_info.estate_id)?;
        buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id)?;
        buffer.write_u32::<LittleEndian>(self.region_info.region_flags)?;
        buffer.write_f32::<LittleEndian>(self.region_info.billable_factor)?;
        buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter)?;
        buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x)?;
        buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GodUpdateRegionInfo_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = GodUpdateRegionInfo_RegionInfo::read_from(buffer)?;
        Ok(MessageInstance::GodUpdateRegionInfo(GodUpdateRegionInfo {
            agent_data: agent_data,
            region_info: region_info,
        }))
    }
}

impl Message for GodlikeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x03
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write_u8(self.method_data.method.len() as u8)?;
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write_u8(item.parameter.len() as u8)?;
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GodlikeMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = GodlikeMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(GodlikeMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::GodlikeMessage(GodlikeMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for GrantGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x02
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GrantData
        buffer.write_u8(self.grant_data.god_level)?;
        buffer.write(self.grant_data.token.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GrantGodlikePowers_AgentData::read_from(buffer)?;
        // Block GrantData
        let grant_data = GrantGodlikePowers_GrantData::read_from(buffer)?;
        Ok(MessageInstance::GrantGodlikePowers(GrantGodlikePowers {
            agent_data: agent_data,
            grant_data: grant_data,
        }))
    }
}

impl Message for GrantUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x40
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Rights
        buffer.write_u8(self.rights.len() as u8)?;
        for item in &self.rights {
            buffer.write(item.agent_related.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.related_rights)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GrantUserRights_AgentData::read_from(buffer)?;
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = buffer.read_u8()?;
        for _ in 0.._rights_count {
            rights.push(GrantUserRights_Rights::read_from(buffer)?);
        }
        Ok(MessageInstance::GrantUserRights(GrantUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for GroupAccountDetailsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x64
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        buffer.write_u8(self.money_data.start_date.len() as u8)?;
        buffer.write(&self.money_data.start_date[..])?;
        // Block HistoryData
        buffer.write_u8(self.history_data.len() as u8)?;
        for item in &self.history_data {
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.amount)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountDetailsReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountDetailsReply_MoneyData::read_from(buffer)?;
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = buffer.read_u8()?;
        for _ in 0.._history_data_count {
            history_data.push(GroupAccountDetailsReply_HistoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupAccountDetailsReply(
            GroupAccountDetailsReply {
                agent_data: agent_data,
                money_data: money_data,
                history_data: history_data,
            },
        ))
    }
}

impl Message for GroupAccountDetailsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x63
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountDetailsRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountDetailsRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountDetailsRequest(
            GroupAccountDetailsRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountSummaryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x62
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        buffer.write_u8(self.money_data.start_date.len() as u8)?;
        buffer.write(&self.money_data.start_date[..])?;
        buffer.write_i32::<LittleEndian>(self.money_data.balance)?;
        buffer.write_i32::<LittleEndian>(self.money_data.total_credits)?;
        buffer.write_i32::<LittleEndian>(self.money_data.total_debits)?;
        buffer.write_i32::<LittleEndian>(self.money_data.object_tax_current)?;
        buffer.write_i32::<LittleEndian>(self.money_data.light_tax_current)?;
        buffer.write_i32::<LittleEndian>(self.money_data.land_tax_current)?;
        buffer.write_i32::<LittleEndian>(self.money_data.group_tax_current)?;
        buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_current)?;
        buffer.write_i32::<LittleEndian>(self.money_data.object_tax_estimate)?;
        buffer.write_i32::<LittleEndian>(self.money_data.light_tax_estimate)?;
        buffer.write_i32::<LittleEndian>(self.money_data.land_tax_estimate)?;
        buffer.write_i32::<LittleEndian>(self.money_data.group_tax_estimate)?;
        buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_estimate)?;
        buffer.write_i32::<LittleEndian>(self.money_data.non_exempt_members)?;
        buffer.write_u8(self.money_data.last_tax_date.len() as u8)?;
        buffer.write(&self.money_data.last_tax_date[..])?;
        buffer.write_u8(self.money_data.tax_date.len() as u8)?;
        buffer.write(&self.money_data.tax_date[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountSummaryReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountSummaryReply_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountSummaryReply(
            GroupAccountSummaryReply {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountSummaryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x61
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountSummaryRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountSummaryRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountSummaryRequest(
            GroupAccountSummaryRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountTransactionsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x66
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        buffer.write_u8(self.money_data.start_date.len() as u8)?;
        buffer.write(&self.money_data.start_date[..])?;
        // Block HistoryData
        buffer.write_u8(self.history_data.len() as u8)?;
        for item in &self.history_data {
            buffer.write_u8(item.time.len() as u8)?;
            buffer.write(&item.time[..])?;
            buffer.write_u8(item.user.len() as u8)?;
            buffer.write(&item.user[..])?;
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write_u8(item.item.len() as u8)?;
            buffer.write(&item.item[..])?;
            buffer.write_i32::<LittleEndian>(item.amount)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountTransactionsReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountTransactionsReply_MoneyData::read_from(buffer)?;
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = buffer.read_u8()?;
        for _ in 0.._history_data_count {
            history_data.push(GroupAccountTransactionsReply_HistoryData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::GroupAccountTransactionsReply(
            GroupAccountTransactionsReply {
                agent_data: agent_data,
                money_data: money_data,
                history_data: history_data,
            },
        ))
    }
}

impl Message for GroupAccountTransactionsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x65
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.money_data.interval_days)?;
        buffer.write_i32::<LittleEndian>(self.money_data.current_interval)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupAccountTransactionsRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountTransactionsRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountTransactionsRequest(
            GroupAccountTransactionsRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupActiveProposalItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x68
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items)?;
        // Block ProposalData
        buffer.write_u8(self.proposal_data.len() as u8)?;
        for item in &self.proposal_data {
            buffer.write(item.vote_id.as_bytes())?;
            buffer.write(item.vote_initiator.as_bytes())?;
            buffer.write_u8(item.terse_date_id.len() as u8)?;
            buffer.write(&item.terse_date_id[..])?;
            buffer.write_u8(item.start_date_time.len() as u8)?;
            buffer.write(&item.start_date_time[..])?;
            buffer.write_u8(item.end_date_time.len() as u8)?;
            buffer.write(&item.end_date_time[..])?;
            buffer.write_u8(item.already_voted as u8)?;
            buffer.write_u8(item.vote_cast.len() as u8)?;
            buffer.write(&item.vote_cast[..])?;
            buffer.write_f32::<LittleEndian>(item.majority)?;
            buffer.write_i32::<LittleEndian>(item.quorum)?;
            buffer.write_u8(item.proposal_text.len() as u8)?;
            buffer.write(&item.proposal_text[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupActiveProposalItemReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupActiveProposalItemReply_TransactionData::read_from(buffer)?;
        // Block ProposalData
        let mut proposal_data = Vec::new();
        let _proposal_data_count = buffer.read_u8()?;
        for _ in 0.._proposal_data_count {
            proposal_data.push(GroupActiveProposalItemReply_ProposalData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::GroupActiveProposalItemReply(
            GroupActiveProposalItemReply {
                agent_data: agent_data,
                transaction_data: transaction_data,
                proposal_data: proposal_data,
            },
        ))
    }
}

impl Message for GroupActiveProposalsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x67
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupActiveProposalsRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupActiveProposalsRequest_GroupData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupActiveProposalsRequest_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::GroupActiveProposalsRequest(
            GroupActiveProposalsRequest {
                agent_data: agent_data,
                group_data: group_data,
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for GroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x84
        ])?;
        // Block AgentGroupData
        buffer.write_u8(self.agent_group_data.len() as u8)?;
        for item in &self.agent_group_data {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.agent_powers)?;
            buffer.write_u8(item.group_title.len() as u8)?;
            buffer.write(&item.group_title[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentGroupData
        let mut agent_group_data = Vec::new();
        let _agent_group_data_count = buffer.read_u8()?;
        for _ in 0.._agent_group_data_count {
            agent_group_data.push(GroupDataUpdate_AgentGroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupDataUpdate(GroupDataUpdate {
            agent_group_data: agent_group_data,
        }))
    }
}

impl Message for GroupMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.member_count)?;
        // Block MemberData
        buffer.write_u8(self.member_data.len() as u8)?;
        for item in &self.member_data {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.contribution)?;
            buffer.write_u8(item.online_status.len() as u8)?;
            buffer.write(&item.online_status[..])?;
            buffer.write_u64::<LittleEndian>(item.agent_powers)?;
            buffer.write_u8(item.title.len() as u8)?;
            buffer.write(&item.title[..])?;
            buffer.write_u8(item.is_owner as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupMembersReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupMembersReply_GroupData::read_from(buffer)?;
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = buffer.read_u8()?;
        for _ in 0.._member_data_count {
            member_data.push(GroupMembersReply_MemberData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupMembersReply(GroupMembersReply {
            agent_data: agent_data,
            group_data: group_data,
            member_data: member_data,
        }))
    }
}

impl Message for GroupMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupMembersRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupMembersRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupMembersRequest(GroupMembersRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupNoticeAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block MessageBlock
        buffer.write(self.message_block.to_group_id.as_bytes())?;
        buffer.write(self.message_block.id.as_bytes())?;
        buffer.write_u8(self.message_block.dialog)?;
        buffer.write_u8(self.message_block.from_agent_name.len() as u8)?;
        buffer.write(&self.message_block.from_agent_name[..])?;
        buffer.write_u16::<LittleEndian>(self.message_block.message.len() as u16)?;
        buffer.write(&self.message_block.message[..])?;
        buffer.write_u16::<LittleEndian>(self.message_block.binary_bucket.len() as u16)?;
        buffer.write(&self.message_block.binary_bucket[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupNoticeAdd_AgentData::read_from(buffer)?;
        // Block MessageBlock
        let message_block = GroupNoticeAdd_MessageBlock::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticeAdd(GroupNoticeAdd {
            agent_data: agent_data,
            message_block: message_block,
        }))
    }
}

impl Message for GroupNoticeRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_notice_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupNoticeRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = GroupNoticeRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticeRequest(GroupNoticeRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GroupNoticesListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.notice_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.timestamp)?;
            buffer.write_u16::<LittleEndian>(item.from_name.len() as u16)?;
            buffer.write(&item.from_name[..])?;
            buffer.write_u16::<LittleEndian>(item.subject.len() as u16)?;
            buffer.write(&item.subject[..])?;
            buffer.write_u8(item.has_attachment as u8)?;
            buffer.write_u8(item.asset_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupNoticesListReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(GroupNoticesListReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupNoticesListReply(
            GroupNoticesListReply {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for GroupNoticesListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupNoticesListRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = GroupNoticesListRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticesListRequest(
            GroupNoticesListRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for GroupProfileReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x60
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u8(self.group_data.name.len() as u8)?;
        buffer.write(&self.group_data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.group_data.charter.len() as u16)?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write_u8(self.group_data.member_title.len() as u8)?;
        buffer.write(&self.group_data.member_title[..])?;
        buffer.write_u64::<LittleEndian>(self.group_data.powers_mask)?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write(self.group_data.founder_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.membership_fee)?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_i32::<LittleEndian>(self.group_data.money)?;
        buffer.write_i32::<LittleEndian>(self.group_data.group_membership_count)?;
        buffer.write_i32::<LittleEndian>(self.group_data.group_roles_count)?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        buffer.write(self.group_data.owner_role.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupProfileReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupProfileReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupProfileReply(GroupProfileReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupProfileRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupProfileRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupProfileRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupProfileRequest(GroupProfileRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupProposalBallot {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ProposalData
        buffer.write(self.proposal_data.proposal_id.as_bytes())?;
        buffer.write(self.proposal_data.group_id.as_bytes())?;
        buffer.write_u8(self.proposal_data.vote_cast.len() as u8)?;
        buffer.write(&self.proposal_data.vote_cast[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupProposalBallot_AgentData::read_from(buffer)?;
        // Block ProposalData
        let proposal_data = GroupProposalBallot_ProposalData::read_from(buffer)?;
        Ok(MessageInstance::GroupProposalBallot(GroupProposalBallot {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for GroupRoleChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x56
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RoleChange
        buffer.write_u8(self.role_change.len() as u8)?;
        for item in &self.role_change {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(item.member_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.change)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleChanges_AgentData::read_from(buffer)?;
        // Block RoleChange
        let mut role_change = Vec::new();
        let _role_change_count = buffer.read_u8()?;
        for _ in 0.._role_change_count {
            role_change.push(GroupRoleChanges_RoleChange::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleChanges(GroupRoleChanges {
            agent_data: agent_data,
            role_change: role_change,
        }))
    }
}

impl Message for GroupRoleDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x74
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.role_count)?;
        // Block RoleData
        buffer.write_u8(self.role_data.len() as u8)?;
        for item in &self.role_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.title.len() as u8)?;
            buffer.write(&item.title[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_u64::<LittleEndian>(item.powers)?;
            buffer.write_u32::<LittleEndian>(item.members)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleDataReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleDataReply_GroupData::read_from(buffer)?;
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = buffer.read_u8()?;
        for _ in 0.._role_data_count {
            role_data.push(GroupRoleDataReply_RoleData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleDataReply(GroupRoleDataReply {
            agent_data: agent_data,
            group_data: group_data,
            role_data: role_data,
        }))
    }
}

impl Message for GroupRoleDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x73
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleDataRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleDataRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupRoleDataRequest(
            GroupRoleDataRequest {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for GroupRoleMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x76
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.total_pairs)?;
        // Block MemberData
        buffer.write_u8(self.member_data.len() as u8)?;
        for item in &self.member_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(item.member_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleMembersReply_AgentData::read_from(buffer)?;
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = buffer.read_u8()?;
        for _ in 0.._member_data_count {
            member_data.push(GroupRoleMembersReply_MemberData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleMembersReply(
            GroupRoleMembersReply {
                agent_data: agent_data,
                member_data: member_data,
            },
        ))
    }
}

impl Message for GroupRoleMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x75
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleMembersRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleMembersRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupRoleMembersRequest(
            GroupRoleMembersRequest {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for GroupRoleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RoleData
        buffer.write_u8(self.role_data.len() as u8)?;
        for item in &self.role_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_u8(item.title.len() as u8)?;
            buffer.write(&item.title[..])?;
            buffer.write_u64::<LittleEndian>(item.powers)?;
            buffer.write_u8(item.update_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupRoleUpdate_AgentData::read_from(buffer)?;
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = buffer.read_u8()?;
        for _ in 0.._role_data_count {
            role_data.push(GroupRoleUpdate_RoleData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleUpdate(GroupRoleUpdate {
            agent_data: agent_data,
            role_data: role_data,
        }))
    }
}

impl Message for GroupTitleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x79
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.title_role_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupTitleUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::GroupTitleUpdate(GroupTitleUpdate {
            agent_data: agent_data,
        }))
    }
}

impl Message for GroupTitlesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x78
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write_u8(item.title.len() as u8)?;
            buffer.write(&item.title[..])?;
            buffer.write(item.role_id.as_bytes())?;
            buffer.write_u8(item.selected as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupTitlesReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(GroupTitlesReply_GroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupTitlesReply(GroupTitlesReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupTitlesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x77
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupTitlesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::GroupTitlesRequest(GroupTitlesRequest {
            agent_data: agent_data,
        }))
    }
}

impl Message for GroupVoteHistoryItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items)?;
        // Block HistoryItemData
        buffer.write(self.history_item_data.vote_id.as_bytes())?;
        buffer.write_u8(self.history_item_data.terse_date_id.len() as u8)?;
        buffer.write(&self.history_item_data.terse_date_id[..])?;
        buffer.write_u8(self.history_item_data.start_date_time.len() as u8)?;
        buffer.write(&self.history_item_data.start_date_time[..])?;
        buffer.write_u8(self.history_item_data.end_date_time.len() as u8)?;
        buffer.write(&self.history_item_data.end_date_time[..])?;
        buffer.write(self.history_item_data.vote_initiator.as_bytes())?;
        buffer.write_u8(self.history_item_data.vote_type.len() as u8)?;
        buffer.write(&self.history_item_data.vote_type[..])?;
        buffer.write_u8(self.history_item_data.vote_result.len() as u8)?;
        buffer.write(&self.history_item_data.vote_result[..])?;
        buffer.write_f32::<LittleEndian>(self.history_item_data.majority)?;
        buffer.write_i32::<LittleEndian>(self.history_item_data.quorum)?;
        buffer.write_u16::<LittleEndian>(self.history_item_data.proposal_text.len() as u16)?;
        buffer.write(&self.history_item_data.proposal_text[..])?;
        // Block VoteItem
        buffer.write_u8(self.vote_item.len() as u8)?;
        for item in &self.vote_item {
            buffer.write(item.candidate_id.as_bytes())?;
            buffer.write_u8(item.vote_cast.len() as u8)?;
            buffer.write(&item.vote_cast[..])?;
            buffer.write_i32::<LittleEndian>(item.num_votes)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupVoteHistoryItemReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupVoteHistoryItemReply_TransactionData::read_from(buffer)?;
        // Block HistoryItemData
        let history_item_data = GroupVoteHistoryItemReply_HistoryItemData::read_from(buffer)?;
        // Block VoteItem
        let mut vote_item = Vec::new();
        let _vote_item_count = buffer.read_u8()?;
        for _ in 0.._vote_item_count {
            vote_item.push(GroupVoteHistoryItemReply_VoteItem::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupVoteHistoryItemReply(
            GroupVoteHistoryItemReply {
                agent_data: agent_data,
                transaction_data: transaction_data,
                history_item_data: history_item_data,
                vote_item: vote_item,
            },
        ))
    }
}

impl Message for GroupVoteHistoryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x69
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = GroupVoteHistoryRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupVoteHistoryRequest_GroupData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupVoteHistoryRequest_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::GroupVoteHistoryRequest(
            GroupVoteHistoryRequest {
                agent_data: agent_data,
                group_data: group_data,
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for HealthMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8a
        ])?;
        // Block HealthData
        buffer.write_f32::<LittleEndian>(self.health_data.health)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block HealthData
        let health_data = HealthMessage_HealthData::read_from(buffer)?;
        Ok(MessageInstance::HealthMessage(HealthMessage {
            health_data: health_data,
        }))
    }
}

impl Message for ImageData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x09])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        buffer.write_u8(self.image_id.codec)?;
        buffer.write_u32::<LittleEndian>(self.image_id.size)?;
        buffer.write_u16::<LittleEndian>(self.image_id.packets)?;
        // Block ImageData
        buffer.write_u16::<LittleEndian>(self.image_data.data.len() as u16)?;
        buffer.write(&self.image_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ImageID
        let image_id = ImageData_ImageID::read_from(buffer)?;
        // Block ImageData
        let image_data = ImageData_ImageData::read_from(buffer)?;
        Ok(MessageInstance::ImageData(ImageData {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for ImageNotInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x56
        ])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ImageID
        let image_id = ImageNotInDatabase_ImageID::read_from(buffer)?;
        Ok(MessageInstance::ImageNotInDatabase(
            ImageNotInDatabase { image_id: image_id },
        ))
    }
}

impl Message for ImagePacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0a])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.image_id.packet)?;
        // Block ImageData
        buffer.write_u16::<LittleEndian>(self.image_data.data.len() as u16)?;
        buffer.write(&self.image_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ImageID
        let image_id = ImagePacket_ImageID::read_from(buffer)?;
        // Block ImageData
        let image_data = ImagePacket_ImageData::read_from(buffer)?;
        Ok(MessageInstance::ImagePacket(ImagePacket {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for ImprovedInstantMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xfe
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MessageBlock
        buffer.write_u8(self.message_block.from_group as u8)?;
        buffer.write(self.message_block.to_agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.message_block.parent_estate_id)?;
        buffer.write(self.message_block.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.message_block.position.x)?;

        buffer.write_f32::<LittleEndian>(self.message_block.position.y)?;

        buffer.write_f32::<LittleEndian>(self.message_block.position.z)?;
        buffer.write_u8(self.message_block.offline)?;
        buffer.write_u8(self.message_block.dialog)?;
        buffer.write(self.message_block.id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.message_block.timestamp)?;
        buffer.write_u8(self.message_block.from_agent_name.len() as u8)?;
        buffer.write(&self.message_block.from_agent_name[..])?;
        buffer.write_u16::<LittleEndian>(self.message_block.message.len() as u16)?;
        buffer.write(&self.message_block.message[..])?;
        buffer.write_u16::<LittleEndian>(self.message_block.binary_bucket.len() as u16)?;
        buffer.write(&self.message_block.binary_bucket[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ImprovedInstantMessage_AgentData::read_from(buffer)?;
        // Block MessageBlock
        let message_block = ImprovedInstantMessage_MessageBlock::read_from(buffer)?;
        Ok(MessageInstance::ImprovedInstantMessage(
            ImprovedInstantMessage {
                agent_data: agent_data,
                message_block: message_block,
            },
        ))
    }
}

impl Message for ImprovedTerseObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0f])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.region_data.time_dilation)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u8(item.data.len() as u8)?;
            buffer.write(&item.data[..])?;
            buffer.write_u16::<LittleEndian>(item.texture_entry.len() as u16)?;
            buffer.write(&item.texture_entry[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = ImprovedTerseObjectUpdate_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ImprovedTerseObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ImprovedTerseObjectUpdate(
            ImprovedTerseObjectUpdate {
                region_data: region_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for InitiateDownload {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x93
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block FileData
        buffer.write_u8(self.file_data.sim_filename.len() as u8)?;
        buffer.write(&self.file_data.sim_filename[..])?;
        buffer.write_u8(self.file_data.viewer_filename.len() as u8)?;
        buffer.write(&self.file_data.viewer_filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = InitiateDownload_AgentData::read_from(buffer)?;
        // Block FileData
        let file_data = InitiateDownload_FileData::read_from(buffer)?;
        Ok(MessageInstance::InitiateDownload(InitiateDownload {
            agent_data: agent_data,
            file_data: file_data,
        }))
    }
}

impl Message for InternalScriptMail {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x10])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.from.len() as u8)?;
        buffer.write(&self.data_block.from[..])?;
        buffer.write(self.data_block.to.as_bytes())?;
        buffer.write_u8(self.data_block.subject.len() as u8)?;
        buffer.write(&self.data_block.subject[..])?;
        buffer.write_u16::<LittleEndian>(self.data_block.body.len() as u16)?;
        buffer.write(&self.data_block.body[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = InternalScriptMail_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::InternalScriptMail(InternalScriptMail {
            data_block: data_block,
        }))
    }
}

impl Message for InventoryAssetResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1b
        ])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(self.query_data.asset_id.as_bytes())?;
        buffer.write_u8(self.query_data.is_readable as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block QueryData
        let query_data = InventoryAssetResponse_QueryData::read_from(buffer)?;
        Ok(MessageInstance::InventoryAssetResponse(
            InventoryAssetResponse {
                query_data: query_data,
            },
        ))
    }
}

impl Message for InventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x16
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.folder_id.as_bytes())?;
        buffer.write(self.agent_data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.version)?;
        buffer.write_i32::<LittleEndian>(self.agent_data.descendents)?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = InventoryDescendents_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(InventoryDescendents_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(InventoryDescendents_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::InventoryDescendents(
            InventoryDescendents {
                agent_data: agent_data,
                folder_data: folder_data,
                item_data: item_data,
            },
        ))
    }
}

impl Message for InviteGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block InviteData
        buffer.write_u8(self.invite_data.len() as u8)?;
        for item in &self.invite_data {
            buffer.write(item.invitee_id.as_bytes())?;
            buffer.write(item.role_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = InviteGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = InviteGroupRequest_GroupData::read_from(buffer)?;
        // Block InviteData
        let mut invite_data = Vec::new();
        let _invite_data_count = buffer.read_u8()?;
        for _ in 0.._invite_data_count {
            invite_data.push(InviteGroupRequest_InviteData::read_from(buffer)?);
        }
        Ok(MessageInstance::InviteGroupRequest(InviteGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
            invite_data: invite_data,
        }))
    }
}

impl Message for InviteGroupResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5e
        ])?;
        // Block InviteData
        buffer.write(self.invite_data.agent_id.as_bytes())?;
        buffer.write(self.invite_data.invitee_id.as_bytes())?;
        buffer.write(self.invite_data.group_id.as_bytes())?;
        buffer.write(self.invite_data.role_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.invite_data.membership_fee)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block InviteData
        let invite_data = InviteGroupResponse_InviteData::read_from(buffer)?;
        Ok(MessageInstance::InviteGroupResponse(InviteGroupResponse {
            invite_data: invite_data,
        }))
    }
}

impl Message for JoinGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x58
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u8(self.group_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = JoinGroupReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = JoinGroupReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::JoinGroupReply(JoinGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for JoinGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x57
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = JoinGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = JoinGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::JoinGroupRequest(JoinGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for KickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa3
        ])?;
        // Block TargetBlock
        buffer.write(&self.target_block.target_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.target_block.target_port)?;
        // Block UserInfo
        buffer.write(self.user_info.agent_id.as_bytes())?;
        buffer.write(self.user_info.session_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.user_info.reason.len() as u16)?;
        buffer.write(&self.user_info.reason[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TargetBlock
        let target_block = KickUser_TargetBlock::read_from(buffer)?;
        // Block UserInfo
        let user_info = KickUser_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::KickUser(KickUser {
            target_block: target_block,
            user_info: user_info,
        }))
    }
}

impl Message for KickUserAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa4
        ])?;
        // Block UserInfo
        buffer.write(self.user_info.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.user_info.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UserInfo
        let user_info = KickUserAck_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::KickUserAck(KickUserAck {
            user_info: user_info,
        }))
    }
}

impl Message for KillChildAgents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf2
        ])?;
        // Block IDBlock
        buffer.write(self.id_block.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block IDBlock
        let id_block = KillChildAgents_IDBlock::read_from(buffer)?;
        Ok(MessageInstance::KillChildAgents(
            KillChildAgents { id_block: id_block },
        ))
    }
}

impl Message for KillObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x10])?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(KillObject_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::KillObject(KillObject {
            object_data: object_data,
        }))
    }
}

impl Message for LandStatReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa6
        ])?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(self.request_data.report_type)?;
        buffer.write_u32::<LittleEndian>(self.request_data.request_flags)?;
        buffer.write_u32::<LittleEndian>(self.request_data.total_object_count)?;
        // Block ReportData
        buffer.write_u8(self.report_data.len() as u8)?;
        for item in &self.report_data {
            buffer.write_u32::<LittleEndian>(item.task_local_id)?;
            buffer.write(item.task_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.location_x)?;
            buffer.write_f32::<LittleEndian>(item.location_y)?;
            buffer.write_f32::<LittleEndian>(item.location_z)?;
            buffer.write_f32::<LittleEndian>(item.score)?;
            buffer.write_u8(item.task_name.len() as u8)?;
            buffer.write(&item.task_name[..])?;
            buffer.write_u8(item.owner_name.len() as u8)?;
            buffer.write(&item.owner_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RequestData
        let request_data = LandStatReply_RequestData::read_from(buffer)?;
        // Block ReportData
        let mut report_data = Vec::new();
        let _report_data_count = buffer.read_u8()?;
        for _ in 0.._report_data_count {
            report_data.push(LandStatReply_ReportData::read_from(buffer)?);
        }
        Ok(MessageInstance::LandStatReply(LandStatReply {
            request_data: request_data,
            report_data: report_data,
        }))
    }
}

impl Message for LandStatRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(self.request_data.report_type)?;
        buffer.write_u32::<LittleEndian>(self.request_data.request_flags)?;
        buffer.write_u8(self.request_data.filter.len() as u8)?;
        buffer.write(&self.request_data.filter[..])?;
        buffer.write_i32::<LittleEndian>(self.request_data.parcel_local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LandStatRequest_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = LandStatRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::LandStatRequest(LandStatRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for LayerData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0b])?;
        // Block LayerID
        buffer.write_u8(self.layer_id.type_)?;
        // Block LayerData
        buffer.write_u16::<LittleEndian>(self.layer_data.data.len() as u16)?;
        buffer.write(&self.layer_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block LayerID
        let layer_id = LayerData_LayerID::read_from(buffer)?;
        // Block LayerData
        let layer_data = LayerData_LayerData::read_from(buffer)?;
        Ok(MessageInstance::LayerData(LayerData {
            layer_id: layer_id,
            layer_data: layer_data,
        }))
    }
}

impl Message for LeaveGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u8(self.group_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LeaveGroupReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = LeaveGroupReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::LeaveGroupReply(LeaveGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for LeaveGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x5b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LeaveGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = LeaveGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::LeaveGroupRequest(LeaveGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for LinkInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xaa
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id)?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write(self.inventory_block.old_item_id.as_bytes())?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write_u8(self.inventory_block.name.len() as u8)?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write_u8(self.inventory_block.description.len() as u8)?;
        buffer.write(&self.inventory_block.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LinkInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = LinkInventoryItem_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::LinkInventoryItem(LinkInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for LiveHelpGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7c
        ])?;
        // Block ReplyData
        buffer.write(self.reply_data.request_id.as_bytes())?;
        buffer.write(self.reply_data.group_id.as_bytes())?;
        buffer.write_u8(self.reply_data.selection.len() as u8)?;
        buffer.write(&self.reply_data.selection[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ReplyData
        let reply_data = LiveHelpGroupReply_ReplyData::read_from(buffer)?;
        Ok(MessageInstance::LiveHelpGroupReply(LiveHelpGroupReply {
            reply_data: reply_data,
        }))
    }
}

impl Message for LiveHelpGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x7b
        ])?;
        // Block RequestData
        buffer.write(self.request_data.request_id.as_bytes())?;
        buffer.write(self.request_data.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RequestData
        let request_data = LiveHelpGroupRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::LiveHelpGroupRequest(
            LiveHelpGroupRequest {
                request_data: request_data,
            },
        ))
    }
}

impl Message for LoadURL {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc2
        ])?;
        // Block Data
        buffer.write_u8(self.data.object_name.len() as u8)?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_u8(self.data.owner_is_group as u8)?;
        buffer.write_u8(self.data.message.len() as u8)?;
        buffer.write(&self.data.message[..])?;
        buffer.write_u8(self.data.url.len() as u8)?;
        buffer.write(&self.data.url[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = LoadURL_Data::read_from(buffer)?;
        Ok(MessageInstance::LoadURL(LoadURL { data: data }))
    }
}

impl Message for LogDwellTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x12
        ])?;
        // Block DwellInfo
        buffer.write(self.dwell_info.agent_id.as_bytes())?;
        buffer.write(self.dwell_info.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.dwell_info.duration)?;
        buffer.write_u8(self.dwell_info.sim_name.len() as u8)?;
        buffer.write(&self.dwell_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.dwell_info.region_x)?;
        buffer.write_u32::<LittleEndian>(self.dwell_info.region_y)?;
        buffer.write_u8(self.dwell_info.avg_agents_in_view)?;
        buffer.write_u8(self.dwell_info.avg_viewer_fps)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DwellInfo
        let dwell_info = LogDwellTime_DwellInfo::read_from(buffer)?;
        Ok(MessageInstance::LogDwellTime(LogDwellTime {
            dwell_info: dwell_info,
        }))
    }
}

impl Message for LogFailedMoneyTransaction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x14
        ])?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.transaction_data.transaction_time)?;
        buffer.write_i32::<LittleEndian>(self.transaction_data.transaction_type)?;
        buffer.write(self.transaction_data.source_id.as_bytes())?;
        buffer.write(self.transaction_data.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_data.flags)?;
        buffer.write_i32::<LittleEndian>(self.transaction_data.amount)?;
        buffer.write(&self.transaction_data.simulator_ip.octets())?;
        buffer.write_u32::<LittleEndian>(self.transaction_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.transaction_data.grid_y)?;
        buffer.write_u8(self.transaction_data.failure_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransactionData
        let transaction_data = LogFailedMoneyTransaction_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::LogFailedMoneyTransaction(
            LogFailedMoneyTransaction {
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for LogParcelChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe0
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.is_owner_group as u8)?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
            buffer.write_i8(item.action)?;
            buffer.write(item.transaction_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LogParcelChanges_AgentData::read_from(buffer)?;
        // Block RegionData
        let region_data = LogParcelChanges_RegionData::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(LogParcelChanges_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::LogParcelChanges(LogParcelChanges {
            agent_data: agent_data,
            region_data: region_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for LogTextMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x87
        ])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write(item.from_agent_id.as_bytes())?;
            buffer.write(item.to_agent_id.as_bytes())?;
            buffer.write_f64::<LittleEndian>(item.global_x)?;
            buffer.write_f64::<LittleEndian>(item.global_y)?;
            buffer.write_u32::<LittleEndian>(item.time)?;
            buffer.write_u16::<LittleEndian>(item.message.len() as u16)?;
            buffer.write(&item.message[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(LogTextMessage_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::LogTextMessage(LogTextMessage {
            data_block: data_block,
        }))
    }
}

impl Message for LogoutReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xfd
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LogoutReply_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(LogoutReply_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::LogoutReply(LogoutReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for LogoutRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xfc
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = LogoutRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::LogoutRequest(LogoutRequest {
            agent_data: agent_data,
        }))
    }
}

impl Message for MapBlockReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x99
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u16::<LittleEndian>(item.x)?;
            buffer.write_u16::<LittleEndian>(item.y)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.access)?;
            buffer.write_u32::<LittleEndian>(item.region_flags)?;
            buffer.write_u8(item.water_height)?;
            buffer.write_u8(item.agents)?;
            buffer.write(item.map_image_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapBlockReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(MapBlockReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::MapBlockReply(MapBlockReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for MapBlockRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x97
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block PositionData
        buffer.write_u16::<LittleEndian>(self.position_data.min_x)?;
        buffer.write_u16::<LittleEndian>(self.position_data.max_x)?;
        buffer.write_u16::<LittleEndian>(self.position_data.min_y)?;
        buffer.write_u16::<LittleEndian>(self.position_data.max_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapBlockRequest_AgentData::read_from(buffer)?;
        // Block PositionData
        let position_data = MapBlockRequest_PositionData::read_from(buffer)?;
        Ok(MessageInstance::MapBlockRequest(MapBlockRequest {
            agent_data: agent_data,
            position_data: position_data,
        }))
    }
}

impl Message for MapItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(self.request_data.item_type)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u32::<LittleEndian>(item.x)?;
            buffer.write_u32::<LittleEndian>(item.y)?;
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.extra)?;
            buffer.write_i32::<LittleEndian>(item.extra2)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapItemReply_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = MapItemReply_RequestData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(MapItemReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::MapItemReply(MapItemReply {
            agent_data: agent_data,
            request_data: request_data,
            data: data,
        }))
    }
}

impl Message for MapItemRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(self.request_data.item_type)?;
        buffer.write_u64::<LittleEndian>(self.request_data.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapItemRequest_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = MapItemRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::MapItemRequest(MapItemRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for MapLayerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x96
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block LayerData
        buffer.write_u8(self.layer_data.len() as u8)?;
        for item in &self.layer_data {
            buffer.write_u32::<LittleEndian>(item.left)?;
            buffer.write_u32::<LittleEndian>(item.right)?;
            buffer.write_u32::<LittleEndian>(item.top)?;
            buffer.write_u32::<LittleEndian>(item.bottom)?;
            buffer.write(item.image_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapLayerReply_AgentData::read_from(buffer)?;
        // Block LayerData
        let mut layer_data = Vec::new();
        let _layer_data_count = buffer.read_u8()?;
        for _ in 0.._layer_data_count {
            layer_data.push(MapLayerReply_LayerData::read_from(buffer)?);
        }
        Ok(MessageInstance::MapLayerReply(MapLayerReply {
            agent_data: agent_data,
            layer_data: layer_data,
        }))
    }
}

impl Message for MapLayerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x95
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapLayerRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::MapLayerRequest(MapLayerRequest {
            agent_data: agent_data,
        }))
    }
}

impl Message for MapNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x98
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block NameData
        buffer.write_u8(self.name_data.name.len() as u8)?;
        buffer.write(&self.name_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MapNameRequest_AgentData::read_from(buffer)?;
        // Block NameData
        let name_data = MapNameRequest_NameData::read_from(buffer)?;
        Ok(MessageInstance::MapNameRequest(MapNameRequest {
            agent_data: agent_data,
            name_data: name_data,
        }))
    }
}

impl Message for MeanCollisionAlert {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x88
        ])?;
        // Block MeanCollision
        buffer.write_u8(self.mean_collision.len() as u8)?;
        for item in &self.mean_collision {
            buffer.write(item.victim.as_bytes())?;
            buffer.write(item.perp.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.time)?;
            buffer.write_f32::<LittleEndian>(item.mag)?;
            buffer.write_u8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MeanCollision
        let mut mean_collision = Vec::new();
        let _mean_collision_count = buffer.read_u8()?;
        for _ in 0.._mean_collision_count {
            mean_collision.push(MeanCollisionAlert_MeanCollision::read_from(buffer)?);
        }
        Ok(MessageInstance::MeanCollisionAlert(MeanCollisionAlert {
            mean_collision: mean_collision,
        }))
    }
}

impl Message for MergeParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xdf
        ])?;
        // Block MasterParcelData
        buffer.write(self.master_parcel_data.master_id.as_bytes())?;
        // Block SlaveParcelData
        buffer.write_u8(self.slave_parcel_data.len() as u8)?;
        for item in &self.slave_parcel_data {
            buffer.write(item.slave_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MasterParcelData
        let master_parcel_data = MergeParcel_MasterParcelData::read_from(buffer)?;
        // Block SlaveParcelData
        let mut slave_parcel_data = Vec::new();
        let _slave_parcel_data_count = buffer.read_u8()?;
        for _ in 0.._slave_parcel_data_count {
            slave_parcel_data.push(MergeParcel_SlaveParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::MergeParcel(MergeParcel {
            master_parcel_data: master_parcel_data,
            slave_parcel_data: slave_parcel_data,
        }))
    }
}

impl Message for ModifyLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ModifyBlock
        buffer.write_u8(self.modify_block.action)?;
        buffer.write_u8(self.modify_block.brush_size)?;
        buffer.write_f32::<LittleEndian>(self.modify_block.seconds)?;
        buffer.write_f32::<LittleEndian>(self.modify_block.height)?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write_i32::<LittleEndian>(item.local_id)?;
            buffer.write_f32::<LittleEndian>(item.west)?;
            buffer.write_f32::<LittleEndian>(item.south)?;
            buffer.write_f32::<LittleEndian>(item.east)?;
            buffer.write_f32::<LittleEndian>(item.north)?;
        }
        // Block ModifyBlockExtended
        buffer.write_u8(self.modify_block_extended.len() as u8)?;
        for item in &self.modify_block_extended {
            buffer.write_f32::<LittleEndian>(item.brush_size)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ModifyLand_AgentData::read_from(buffer)?;
        // Block ModifyBlock
        let modify_block = ModifyLand_ModifyBlock::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ModifyLand_ParcelData::read_from(buffer)?);
        }
        // Block ModifyBlockExtended
        let mut modify_block_extended = Vec::new();
        let _modify_block_extended_count = buffer.read_u8()?;
        for _ in 0.._modify_block_extended_count {
            modify_block_extended.push(ModifyLand_ModifyBlockExtended::read_from(buffer)?);
        }
        Ok(MessageInstance::ModifyLand(ModifyLand {
            agent_data: agent_data,
            modify_block: modify_block,
            parcel_data: parcel_data,
            modify_block_extended: modify_block_extended,
        }))
    }
}

impl Message for MoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3a
        ])?;
        // Block MoneyData
        buffer.write(self.money_data.agent_id.as_bytes())?;
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u8(self.money_data.transaction_success as u8)?;
        buffer.write_i32::<LittleEndian>(self.money_data.money_balance)?;
        buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit)?;
        buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed)?;
        buffer.write_u8(self.money_data.description.len() as u8)?;
        buffer.write(&self.money_data.description[..])?;
        // Block TransactionInfo
        buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type)?;
        buffer.write(self.transaction_info.source_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_source_group as u8)?;
        buffer.write(self.transaction_info.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_dest_group as u8)?;
        buffer.write_i32::<LittleEndian>(self.transaction_info.amount)?;
        buffer.write_u8(self.transaction_info.item_description.len() as u8)?;
        buffer.write(&self.transaction_info.item_description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MoneyData
        let money_data = MoneyBalanceReply_MoneyData::read_from(buffer)?;
        // Block TransactionInfo
        let transaction_info = MoneyBalanceReply_TransactionInfo::read_from(buffer)?;
        Ok(MessageInstance::MoneyBalanceReply(MoneyBalanceReply {
            money_data: money_data,
            transaction_info: transaction_info,
        }))
    }
}

impl Message for MoneyBalanceRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x39
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MoneyBalanceRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = MoneyBalanceRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyBalanceRequest(MoneyBalanceRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for MoneyTransferBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x38
        ])?;
        // Block MoneyData
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.money_data.transaction_time)?;
        buffer.write(self.money_data.source_id.as_bytes())?;
        buffer.write(self.money_data.dest_id.as_bytes())?;
        buffer.write_u8(self.money_data.flags)?;
        buffer.write_i32::<LittleEndian>(self.money_data.amount)?;
        buffer.write_u8(self.money_data.aggregate_perm_next_owner)?;
        buffer.write_u8(self.money_data.aggregate_perm_inventory)?;
        buffer.write_i32::<LittleEndian>(self.money_data.transaction_type)?;
        buffer.write(self.money_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.money_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.money_data.grid_y)?;
        buffer.write_u8(self.money_data.description.len() as u8)?;
        buffer.write(&self.money_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MoneyData
        let money_data = MoneyTransferBackend_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyTransferBackend(
            MoneyTransferBackend {
                money_data: money_data,
            },
        ))
    }
}

impl Message for MoneyTransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x37
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.source_id.as_bytes())?;
        buffer.write(self.money_data.dest_id.as_bytes())?;
        buffer.write_u8(self.money_data.flags)?;
        buffer.write_i32::<LittleEndian>(self.money_data.amount)?;
        buffer.write_u8(self.money_data.aggregate_perm_next_owner)?;
        buffer.write_u8(self.money_data.aggregate_perm_inventory)?;
        buffer.write_i32::<LittleEndian>(self.money_data.transaction_type)?;
        buffer.write_u8(self.money_data.description.len() as u8)?;
        buffer.write(&self.money_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MoneyTransferRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = MoneyTransferRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyTransferRequest(
            MoneyTransferRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for MoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x13
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.stamp as u8)?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MoveInventoryFolder_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(MoveInventoryFolder_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::MoveInventoryFolder(MoveInventoryFolder {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.stamp as u8)?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write_u8(item.new_name.len() as u8)?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MoveInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(MoveInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::MoveInventoryItem(MoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x20
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.folder_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(self.inventory_data.local_id)?;
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MoveTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = MoveTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::MoveTaskInventory(MoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MultipleObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x02])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.type_)?;
            buffer.write_u8(item.data.len() as u8)?;
            buffer.write(&item.data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MultipleObjectUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(MultipleObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::MultipleObjectUpdate(
            MultipleObjectUpdate {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for MuteListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x06
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write_u32::<LittleEndian>(self.mute_data.mute_crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = MuteListRequest_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = MuteListRequest_MuteData::read_from(buffer)?;
        Ok(MessageInstance::MuteListRequest(MuteListRequest {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for MuteListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3e
        ])?;
        // Block MuteData
        buffer.write(self.mute_data.agent_id.as_bytes())?;
        buffer.write_u8(self.mute_data.filename.len() as u8)?;
        buffer.write(&self.mute_data.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MuteData
        let mute_data = MuteListUpdate_MuteData::read_from(buffer)?;
        Ok(MessageInstance::MuteListUpdate(MuteListUpdate {
            mute_data: mute_data,
        }))
    }
}

impl Message for NameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x49
        ])?;
        // Block TaskData
        buffer.write(self.task_data.id.as_bytes())?;
        // Block NameValueData
        buffer.write_u8(self.name_value_data.len() as u8)?;
        for item in &self.name_value_data {
            buffer.write_u16::<LittleEndian>(item.nv_pair.len() as u16)?;
            buffer.write(&item.nv_pair[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TaskData
        let task_data = NameValuePair_TaskData::read_from(buffer)?;
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = buffer.read_u8()?;
        for _ in 0.._name_value_data_count {
            name_value_data.push(NameValuePair_NameValueData::read_from(buffer)?);
        }
        Ok(MessageInstance::NameValuePair(NameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for NearestLandingRegionReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x91
        ])?;
        // Block LandingRegionData
        buffer.write_u64::<LittleEndian>(self.landing_region_data.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block LandingRegionData
        let landing_region_data = NearestLandingRegionReply_LandingRegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionReply(
            NearestLandingRegionReply {
                landing_region_data: landing_region_data,
            },
        ))
    }
}

impl Message for NearestLandingRegionRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x90
        ])?;
        // Block RequestingRegionData
        buffer.write_u64::<LittleEndian>(self.requesting_region_data.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RequestingRegionData
        let requesting_region_data =
            NearestLandingRegionRequest_RequestingRegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionRequest(
            NearestLandingRegionRequest {
                requesting_region_data: requesting_region_data,
            },
        ))
    }
}

impl Message for NearestLandingRegionUpdated {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x92
        ])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = NearestLandingRegionUpdated_RegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionUpdated(
            NearestLandingRegionUpdated {
                region_data: region_data,
            },
        ))
    }
}

impl Message for NeighborList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x03])?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write(&self.neighbor_block[i].ip.octets())?;
            buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port)?;
            buffer.write(&self.neighbor_block[i].public_ip.octets())?;
            buffer.write_u16::<LittleEndian>(self.neighbor_block[i].public_port)?;
            buffer.write(self.neighbor_block[i].region_id.as_bytes())?;
            buffer.write_u8(self.neighbor_block[i].name.len() as u8)?;
            buffer.write(&self.neighbor_block[i].name[..])?;
            buffer.write_u8(self.neighbor_block[i].sim_access)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block NeighborBlock
        let neighbor_block = ArrayVec::from([
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
        ]);
        Ok(MessageInstance::NeighborList(NeighborList {
            neighbor_block: neighbor_block,
        }))
    }
}

impl Message for NetTest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x46
        ])?;
        // Block NetBlock
        buffer.write_u16::<LittleEndian>(self.net_block.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block NetBlock
        let net_block = NetTest_NetBlock::read_from(buffer)?;
        Ok(MessageInstance::NetTest(NetTest {
            net_block: net_block,
        }))
    }
}

impl Message for ObjectAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x01])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.p_code)?;
        buffer.write_u8(self.object_data.material)?;
        buffer.write_u32::<LittleEndian>(self.object_data.add_flags)?;
        buffer.write_u8(self.object_data.path_curve)?;
        buffer.write_u8(self.object_data.profile_curve)?;
        buffer.write_u16::<LittleEndian>(self.object_data.path_begin)?;
        buffer.write_u16::<LittleEndian>(self.object_data.path_end)?;
        buffer.write_u8(self.object_data.path_scale_x)?;
        buffer.write_u8(self.object_data.path_scale_y)?;
        buffer.write_u8(self.object_data.path_shear_x)?;
        buffer.write_u8(self.object_data.path_shear_y)?;
        buffer.write_i8(self.object_data.path_twist)?;
        buffer.write_i8(self.object_data.path_twist_begin)?;
        buffer.write_i8(self.object_data.path_radius_offset)?;
        buffer.write_i8(self.object_data.path_taper_x)?;
        buffer.write_i8(self.object_data.path_taper_y)?;
        buffer.write_u8(self.object_data.path_revolutions)?;
        buffer.write_i8(self.object_data.path_skew)?;
        buffer.write_u16::<LittleEndian>(self.object_data.profile_begin)?;
        buffer.write_u16::<LittleEndian>(self.object_data.profile_end)?;
        buffer.write_u16::<LittleEndian>(self.object_data.profile_hollow)?;
        buffer.write_u8(self.object_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(self.object_data.ray_start.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.ray_start.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.z)?;
        buffer.write(self.object_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.object_data.ray_end_is_intersection)?;
        buffer.write_f32::<LittleEndian>(self.object_data.scale.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.scale.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.scale.z)?;
        let norm_rotation = if self.object_data.rotation.scalar() >= 0. {
            self.object_data.rotation.norm()
        } else {
            -self.object_data.rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[0] / norm_rotation)?;

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[1] / norm_rotation)?;

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[2] / norm_rotation)?;
        buffer.write_u8(self.object_data.state)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectAdd_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectAdd_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectAdd(ObjectAdd {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectAttach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x70
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.attachment_point)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            let norm_rotation = if item.rotation.scalar() >= 0. {
                item.rotation.norm()
            } else {
                -item.rotation.norm()
            };

            buffer.write_f32::<LittleEndian>(item.rotation.coords[0] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[1] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[2] / norm_rotation)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectAttach_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectAttach_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectAttach(ObjectAttach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x66
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.category_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectBuy_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectBuy_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectBuy(ObjectBuy {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectCategory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u32::<LittleEndian>(item.category)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectCategory_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectCategory_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectCategory(ObjectCategory {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectClickAction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.click_action)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectClickAction_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectClickAction_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectClickAction(ObjectClickAction {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDeGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x77
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.local_id)?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;

            buffer.write_f32::<LittleEndian>(item.position.y)?;

            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;

            buffer.write_f32::<LittleEndian>(item.normal.y)?;

            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;

            buffer.write_f32::<LittleEndian>(item.binormal.y)?;

            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDeGrab_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectDeGrab_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectDeGrab_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDeGrab(ObjectDeGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x59
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.force as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDelete_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDelete_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDelete(ObjectDelete {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDelink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x74
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDelink_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDelink_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDelink(ObjectDelink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDescription {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDescription_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDescription_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDescription(ObjectDescription {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDeselect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDeselect_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDeselect_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDeselect(ObjectDeselect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDetach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x71
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDetach_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDetach_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDetach(ObjectDetach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDrop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x72
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDrop_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDrop_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDrop(ObjectDrop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block SharedData
        buffer.write_f32::<LittleEndian>(self.shared_data.offset.x)?;

        buffer.write_f32::<LittleEndian>(self.shared_data.offset.y)?;

        buffer.write_f32::<LittleEndian>(self.shared_data.offset.z)?;
        buffer.write_u32::<LittleEndian>(self.shared_data.duplicate_flags)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDuplicate_AgentData::read_from(buffer)?;
        // Block SharedData
        let shared_data = ObjectDuplicate_SharedData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDuplicate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDuplicate(ObjectDuplicate {
            agent_data: agent_data,
            shared_data: shared_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicateOnRay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.x)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.y)?;

        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.z)?;
        buffer.write_u8(self.agent_data.bypass_raycast as u8)?;
        buffer.write_u8(self.agent_data.ray_end_is_intersection as u8)?;
        buffer.write_u8(self.agent_data.copy_centers as u8)?;
        buffer.write_u8(self.agent_data.copy_rotates as u8)?;
        buffer.write(self.agent_data.ray_target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.duplicate_flags)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectDuplicateOnRay_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDuplicateOnRay_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDuplicateOnRay(
            ObjectDuplicateOnRay {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectExportSelected {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(self.agent_data.volume_detail)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectExportSelected_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectExportSelected_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectExportSelected(
            ObjectExportSelected {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectExtraParams {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x63
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u16::<LittleEndian>(item.param_type)?;
            buffer.write_u8(item.param_in_use as u8)?;
            buffer.write_u32::<LittleEndian>(item.param_size)?;
            buffer.write_u8(item.param_data.len() as u8)?;
            buffer.write(&item.param_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectExtraParams_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectExtraParams_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectExtraParams(ObjectExtraParams {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectFlagUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.object_local_id)?;
        buffer.write_u8(self.agent_data.use_physics as u8)?;
        buffer.write_u8(self.agent_data.is_temporary as u8)?;
        buffer.write_u8(self.agent_data.is_phantom as u8)?;
        buffer.write_u8(self.agent_data.casts_shadows as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectFlagUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ObjectFlagUpdate(ObjectFlagUpdate {
            agent_data: agent_data,
        }))
    }
}

impl Message for ObjectGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x75
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.local_id)?;
        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.z)?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;

            buffer.write_f32::<LittleEndian>(item.position.y)?;

            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;

            buffer.write_f32::<LittleEndian>(item.normal.y)?;

            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;

            buffer.write_f32::<LittleEndian>(item.binormal.y)?;

            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectGrab_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectGrab_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectGrab_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGrab(ObjectGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectGrabUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x76
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.z)?;
        buffer.write_f32::<LittleEndian>(self.object_data.grab_position.x)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_position.y)?;

        buffer.write_f32::<LittleEndian>(self.object_data.grab_position.z)?;
        buffer.write_u32::<LittleEndian>(self.object_data.time_since_last)?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;

            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;

            buffer.write_f32::<LittleEndian>(item.position.y)?;

            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;

            buffer.write_f32::<LittleEndian>(item.normal.y)?;

            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;

            buffer.write_f32::<LittleEndian>(item.binormal.y)?;

            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectGrabUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectGrabUpdate_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectGrabUpdate_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGrabUpdate(ObjectGrabUpdate {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x65
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectGroup_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectGroup_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGroup(ObjectGroup {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x60
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.media_url.len() as u8)?;
            buffer.write(&item.media_url[..])?;
            buffer.write_u16::<LittleEndian>(item.texture_entry.len() as u16)?;
            buffer.write(&item.texture_entry[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectImage_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectImage_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectImage(ObjectImage {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectIncludeInSearch {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa8
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.include_in_search as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectIncludeInSearch_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectIncludeInSearch_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectIncludeInSearch(
            ObjectIncludeInSearch {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectLink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x73
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectLink_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectLink_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectLink(ObjectLink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectMaterial {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x61
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.material)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectMaterial_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectMaterial_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectMaterial(ObjectMaterial {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectName {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectName_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectName_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectName(ObjectName {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x64
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write_u8(self.header_data.override_ as u8)?;
        buffer.write(self.header_data.owner_id.as_bytes())?;
        buffer.write(self.header_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectOwner_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = ObjectOwner_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectOwner_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectOwner(ObjectOwner {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectPermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x69
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write_u8(self.header_data.override_ as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.field)?;
            buffer.write_u8(item.set)?;
            buffer.write_u32::<LittleEndian>(item.mask)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectPermissions_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = ObjectPermissions_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectPermissions_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectPermissions(ObjectPermissions {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectPosition {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;

            buffer.write_f32::<LittleEndian>(item.position.y)?;

            buffer.write_f32::<LittleEndian>(item.position.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectPosition_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectPosition_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectPosition(ObjectPosition {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x09])?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_i32::<LittleEndian>(item.ownership_cost)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.aggregate_perms)?;
            buffer.write_u8(item.aggregate_perm_textures)?;
            buffer.write_u8(item.aggregate_perm_textures_owner)?;
            buffer.write_u32::<LittleEndian>(item.category)?;
            buffer.write_i16::<LittleEndian>(item.inventory_serial)?;
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.from_task_id.as_bytes())?;
            buffer.write(item.last_owner_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_u8(item.touch_name.len() as u8)?;
            buffer.write(&item.touch_name[..])?;
            buffer.write_u8(item.sit_name.len() as u8)?;
            buffer.write(&item.sit_name[..])?;
            buffer.write_u8(item.texture_id.len() as u8)?;
            buffer.write(&item.texture_id[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectProperties_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectProperties(ObjectProperties {
            object_data: object_data,
        }))
    }
}

impl Message for ObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0a])?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.request_flags)?;
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write(self.object_data.owner_id.as_bytes())?;
        buffer.write(self.object_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.object_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask)?;
        buffer.write_i32::<LittleEndian>(self.object_data.ownership_cost)?;
        buffer.write_u8(self.object_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.object_data.sale_price)?;
        buffer.write_u32::<LittleEndian>(self.object_data.category)?;
        buffer.write(self.object_data.last_owner_id.as_bytes())?;
        buffer.write_u8(self.object_data.name.len() as u8)?;
        buffer.write(&self.object_data.name[..])?;
        buffer.write_u8(self.object_data.description.len() as u8)?;
        buffer.write(&self.object_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = ObjectPropertiesFamily_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectPropertiesFamily(
            ObjectPropertiesFamily {
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectRotation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            let norm_rotation = if item.rotation.scalar() >= 0. {
                item.rotation.norm()
            } else {
                -item.rotation.norm()
            };

            buffer.write_f32::<LittleEndian>(item.rotation.coords[0] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[1] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[2] / norm_rotation)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectRotation_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectRotation_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectRotation(ObjectRotation {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSaleInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectSaleInfo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectSaleInfo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectSaleInfo(ObjectSaleInfo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectScale {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x5c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_f32::<LittleEndian>(item.scale.x)?;

            buffer.write_f32::<LittleEndian>(item.scale.y)?;

            buffer.write_f32::<LittleEndian>(item.scale.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectScale_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectScale_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectScale(ObjectScale {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x6e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectSelect_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectSelect_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectSelect(ObjectSelect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectShape {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x62
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.path_curve)?;
            buffer.write_u8(item.profile_curve)?;
            buffer.write_u16::<LittleEndian>(item.path_begin)?;
            buffer.write_u16::<LittleEndian>(item.path_end)?;
            buffer.write_u8(item.path_scale_x)?;
            buffer.write_u8(item.path_scale_y)?;
            buffer.write_u8(item.path_shear_x)?;
            buffer.write_u8(item.path_shear_y)?;
            buffer.write_i8(item.path_twist)?;
            buffer.write_i8(item.path_twist_begin)?;
            buffer.write_i8(item.path_radius_offset)?;
            buffer.write_i8(item.path_taper_x)?;
            buffer.write_i8(item.path_taper_y)?;
            buffer.write_u8(item.path_revolutions)?;
            buffer.write_i8(item.path_skew)?;
            buffer.write_u16::<LittleEndian>(item.profile_begin)?;
            buffer.write_u16::<LittleEndian>(item.profile_end)?;
            buffer.write_u16::<LittleEndian>(item.profile_hollow)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectShape_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectShape_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectShape(ObjectShape {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x78
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectSpinStart_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinStart_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinStart(ObjectSpinStart {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinStop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectSpinStop_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinStop_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinStop(ObjectSpinStop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x79
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        let norm_rotation = if self.object_data.rotation.scalar() >= 0. {
            self.object_data.rotation.norm()
        } else {
            -self.object_data.rotation.norm()
        };

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[0] / norm_rotation)?;

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[1] / norm_rotation)?;

        buffer.write_f32::<LittleEndian>(self.object_data.rotation.coords[2] / norm_rotation)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ObjectSpinUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinUpdate_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinUpdate(ObjectSpinUpdate {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0c])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.region_data.time_dilation)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
            buffer.write_u8(item.state)?;
            buffer.write(item.full_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
            buffer.write_u8(item.p_code)?;
            buffer.write_u8(item.material)?;
            buffer.write_u8(item.click_action)?;
            buffer.write_f32::<LittleEndian>(item.scale.x)?;

            buffer.write_f32::<LittleEndian>(item.scale.y)?;

            buffer.write_f32::<LittleEndian>(item.scale.z)?;
            buffer.write_u8(item.object_data.len() as u8)?;
            buffer.write(&item.object_data[..])?;
            buffer.write_u32::<LittleEndian>(item.parent_id)?;
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
            buffer.write_u8(item.path_curve)?;
            buffer.write_u8(item.profile_curve)?;
            buffer.write_u16::<LittleEndian>(item.path_begin)?;
            buffer.write_u16::<LittleEndian>(item.path_end)?;
            buffer.write_u8(item.path_scale_x)?;
            buffer.write_u8(item.path_scale_y)?;
            buffer.write_u8(item.path_shear_x)?;
            buffer.write_u8(item.path_shear_y)?;
            buffer.write_i8(item.path_twist)?;
            buffer.write_i8(item.path_twist_begin)?;
            buffer.write_i8(item.path_radius_offset)?;
            buffer.write_i8(item.path_taper_x)?;
            buffer.write_i8(item.path_taper_y)?;
            buffer.write_u8(item.path_revolutions)?;
            buffer.write_i8(item.path_skew)?;
            buffer.write_u16::<LittleEndian>(item.profile_begin)?;
            buffer.write_u16::<LittleEndian>(item.profile_end)?;
            buffer.write_u16::<LittleEndian>(item.profile_hollow)?;
            buffer.write_u16::<LittleEndian>(item.texture_entry.len() as u16)?;
            buffer.write(&item.texture_entry[..])?;
            buffer.write_u8(item.texture_anim.len() as u8)?;
            buffer.write(&item.texture_anim[..])?;
            buffer.write_u16::<LittleEndian>(item.name_value.len() as u16)?;
            buffer.write(&item.name_value[..])?;
            buffer.write_u16::<LittleEndian>(item.data.len() as u16)?;
            buffer.write(&item.data[..])?;
            buffer.write_u8(item.text.len() as u8)?;
            buffer.write(&item.text[..])?;
            buffer.write(&item.text_color)?;
            buffer.write_u8(item.media_url.len() as u8)?;
            buffer.write(&item.media_url[..])?;
            buffer.write_u8(item.ps_block.len() as u8)?;
            buffer.write(&item.ps_block[..])?;
            buffer.write_u8(item.extra_params.len() as u8)?;
            buffer.write(&item.extra_params[..])?;
            buffer.write(item.sound.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.gain)?;
            buffer.write_u8(item.flags)?;
            buffer.write_f32::<LittleEndian>(item.radius)?;
            buffer.write_u8(item.joint_type)?;
            buffer.write_f32::<LittleEndian>(item.joint_pivot.x)?;

            buffer.write_f32::<LittleEndian>(item.joint_pivot.y)?;

            buffer.write_f32::<LittleEndian>(item.joint_pivot.z)?;
            buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.x)?;

            buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.y)?;

            buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = ObjectUpdate_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdate(ObjectUpdate {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdateCached {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0e])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.region_data.time_dilation)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = ObjectUpdateCached_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdateCached_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdateCached(ObjectUpdateCached {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdateCompressed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x0d])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.region_data.time_dilation)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
            buffer.write_u16::<LittleEndian>(item.data.len() as u16)?;
            buffer.write(&item.data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = ObjectUpdateCompressed_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdateCompressed_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdateCompressed(
            ObjectUpdateCompressed {
                region_data: region_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for OfferCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AgentBlock
        buffer.write(self.agent_block.dest_id.as_bytes())?;
        buffer.write(self.agent_block.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = OfferCallingCard_AgentData::read_from(buffer)?;
        // Block AgentBlock
        let agent_block = OfferCallingCard_AgentBlock::read_from(buffer)?;
        Ok(MessageInstance::OfferCallingCard(OfferCallingCard {
            agent_data: agent_data,
            agent_block: agent_block,
        }))
    }
}

impl Message for OfflineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x43
        ])?;
        // Block AgentBlock
        buffer.write_u8(self.agent_block.len() as u8)?;
        for item in &self.agent_block {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = buffer.read_u8()?;
        for _ in 0.._agent_block_count {
            agent_block.push(OfflineNotification_AgentBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::OfflineNotification(OfflineNotification {
            agent_block: agent_block,
        }))
    }
}

impl Message for OnlineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x42
        ])?;
        // Block AgentBlock
        buffer.write_u8(self.agent_block.len() as u8)?;
        for item in &self.agent_block {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = buffer.read_u8()?;
        for _ in 0.._agent_block_count {
            agent_block.push(OnlineNotification_AgentBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::OnlineNotification(OnlineNotification {
            agent_block: agent_block,
        }))
    }
}

impl Message for OpenCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0xff, 0xFC
        ])?;
        // Block CircuitInfo
        buffer.write(&self.circuit_info.ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.circuit_info.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block CircuitInfo
        let circuit_info = OpenCircuit_CircuitInfo::read_from(buffer)?;
        Ok(MessageInstance::OpenCircuit(OpenCircuit {
            circuit_info: circuit_info,
        }))
    }
}

impl Message for PacketAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0xff, 0xFB
        ])?;
        // Block Packets
        buffer.write_u8(self.packets.len() as u8)?;
        for item in &self.packets {
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Packets
        let mut packets = Vec::new();
        let _packets_count = buffer.read_u8()?;
        for _ in 0.._packets_count {
            packets.push(PacketAck_Packets::read_from(buffer)?);
        }
        Ok(MessageInstance::PacketAck(PacketAck { packets: packets }))
    }
}

impl Message for ParcelAccessListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd8
        ])?;
        // Block Data
        buffer.write(self.data.agent_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        // Block List
        buffer.write_u8(self.list.len() as u8)?;
        for item in &self.list {
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.time)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = ParcelAccessListReply_Data::read_from(buffer)?;
        // Block List
        let mut list = Vec::new();
        let _list_count = buffer.read_u8()?;
        for _ in 0.._list_count {
            list.push(ParcelAccessListReply_List::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAccessListReply(
            ParcelAccessListReply {
                data: data,
                list: list,
            },
        ))
    }
}

impl Message for ParcelAccessListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd7
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelAccessListRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelAccessListRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelAccessListRequest(
            ParcelAccessListRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ParcelAccessListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.transaction_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_i32::<LittleEndian>(self.data.sections)?;
        // Block List
        buffer.write_u8(self.list.len() as u8)?;
        for item in &self.list {
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.time)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelAccessListUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelAccessListUpdate_Data::read_from(buffer)?;
        // Block List
        let mut list = Vec::new();
        let _list_count = buffer.read_u8()?;
        for _ in 0.._list_count {
            list.push(ParcelAccessListUpdate_List::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAccessListUpdate(
            ParcelAccessListUpdate {
                agent_data: agent_data,
                data: data,
                list: list,
            },
        ))
    }
}

impl Message for ParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xea
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.winner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelAuctions_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAuctions(ParcelAuctions {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.is_group_owned as u8)?;
        buffer.write_u8(self.data.remove_contribution as u8)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.price)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.area)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelBuy_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelBuy_Data::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelBuy_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelBuy(ParcelBuy {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelBuyPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xce
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelBuyPass_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelBuyPass_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelBuyPass(ParcelBuyPass {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelClaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd1
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.is_group_owned as u8)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write_f32::<LittleEndian>(item.west)?;
            buffer.write_f32::<LittleEndian>(item.south)?;
            buffer.write_f32::<LittleEndian>(item.east)?;
            buffer.write_f32::<LittleEndian>(item.north)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelClaim_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelClaim_Data::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelClaim_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelClaim(ParcelClaim {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDeedToGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xcf
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelDeedToGroup_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDeedToGroup_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDeedToGroup(ParcelDeedToGroup {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelDisableObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.return_type)?;
        // Block TaskIDs
        buffer.write_u8(self.task_i_ds.len() as u8)?;
        for item in &self.task_i_ds {
            buffer.write(item.task_id.as_bytes())?;
        }
        // Block OwnerIDs
        buffer.write_u8(self.owner_i_ds.len() as u8)?;
        for item in &self.owner_i_ds {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelDisableObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelDisableObjects_ParcelData::read_from(buffer)?;
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = buffer.read_u8()?;
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(ParcelDisableObjects_TaskIDs::read_from(buffer)?);
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = buffer.read_u8()?;
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(ParcelDisableObjects_OwnerIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelDisableObjects(
            ParcelDisableObjects {
                agent_data: agent_data,
                parcel_data: parcel_data,
                task_i_ds: task_i_ds,
                owner_i_ds: owner_i_ds,
            },
        ))
    }
}

impl Message for ParcelDivide {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd3
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelDivide_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelDivide_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelDivide(ParcelDivide {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDwellReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xdb
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data.dwell)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelDwellReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDwellReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDwellReply(ParcelDwellReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelDwellRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xda
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelDwellRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDwellRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDwellRequest(ParcelDwellRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelGodForceOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd6
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelGodForceOwner_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelGodForceOwner_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelGodForceOwner(ParcelGodForceOwner {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelGodMarkAsContent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe3
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelGodMarkAsContent_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelGodMarkAsContent_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelGodMarkAsContent(
            ParcelGodMarkAsContent {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x37
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        buffer.write_u8(self.data.desc.len() as u8)?;
        buffer.write(&self.data.desc[..])?;
        buffer.write_i32::<LittleEndian>(self.data.actual_area)?;
        buffer.write_i32::<LittleEndian>(self.data.billable_area)?;
        buffer.write_u8(self.data.flags)?;
        buffer.write_f32::<LittleEndian>(self.data.global_x)?;
        buffer.write_f32::<LittleEndian>(self.data.global_y)?;
        buffer.write_f32::<LittleEndian>(self.data.global_z)?;
        buffer.write_u8(self.data.sim_name.len() as u8)?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data.dwell)?;
        buffer.write_i32::<LittleEndian>(self.data.sale_price)?;
        buffer.write_i32::<LittleEndian>(self.data.auction_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelInfoReply(ParcelInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x36
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.parcel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelInfoRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelInfoRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelInfoRequest(ParcelInfoRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelJoin {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd2
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelJoin_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelJoin_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelJoin(ParcelJoin {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelMediaCommandMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa3
        ])?;
        // Block CommandBlock
        buffer.write_u32::<LittleEndian>(self.command_block.flags)?;
        buffer.write_u32::<LittleEndian>(self.command_block.command)?;
        buffer.write_f32::<LittleEndian>(self.command_block.time)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block CommandBlock
        let command_block = ParcelMediaCommandMessage_CommandBlock::read_from(buffer)?;
        Ok(MessageInstance::ParcelMediaCommandMessage(
            ParcelMediaCommandMessage {
                command_block: command_block,
            },
        ))
    }
}

impl Message for ParcelMediaUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa4
        ])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.media_url.len() as u8)?;
        buffer.write(&self.data_block.media_url[..])?;
        buffer.write(self.data_block.media_id.as_bytes())?;
        buffer.write_u8(self.data_block.media_auto_scale)?;
        // Block DataBlockExtended
        buffer.write_u8(self.data_block_extended.media_type.len() as u8)?;
        buffer.write(&self.data_block_extended.media_type[..])?;
        buffer.write_u8(self.data_block_extended.media_desc.len() as u8)?;
        buffer.write(&self.data_block_extended.media_desc[..])?;
        buffer.write_i32::<LittleEndian>(self.data_block_extended.media_width)?;
        buffer.write_i32::<LittleEndian>(self.data_block_extended.media_height)?;
        buffer.write_u8(self.data_block_extended.media_loop)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = ParcelMediaUpdate_DataBlock::read_from(buffer)?;
        // Block DataBlockExtended
        let data_block_extended = ParcelMediaUpdate_DataBlockExtended::read_from(buffer)?;
        Ok(MessageInstance::ParcelMediaUpdate(ParcelMediaUpdate {
            data_block: data_block,
            data_block_extended: data_block_extended,
        }))
    }
}

impl Message for ParcelObjectOwnersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x39
        ])?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.is_group_owned as u8)?;
            buffer.write_i32::<LittleEndian>(item.count)?;
            buffer.write_u8(item.online_status as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ParcelObjectOwnersReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelObjectOwnersReply(
            ParcelObjectOwnersReply { data: data },
        ))
    }
}

impl Message for ParcelObjectOwnersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x38
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelObjectOwnersRequest_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelObjectOwnersRequest_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelObjectOwnersRequest(
            ParcelObjectOwnersRequest {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelOverlay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc4
        ])?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id)?;
        buffer.write_u16::<LittleEndian>(self.parcel_data.data.len() as u16)?;
        buffer.write(&self.parcel_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let parcel_data = ParcelOverlay_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelOverlay(ParcelOverlay {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x17])?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.request_result)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id)?;
        buffer.write_u8(self.parcel_data.snap_selection as u8)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.self_count)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.other_count)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.public_count)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write(self.parcel_data.owner_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.is_group_owned as u8)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.auction_id)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.claim_date)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.claim_price)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.rent_price)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.z)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.z)?;
        buffer.write_u16::<LittleEndian>(self.parcel_data.bitmap.len() as u16)?;
        buffer.write(&self.parcel_data.bitmap[..])?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.area)?;
        buffer.write_u8(self.parcel_data.status)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_max_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_total_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.max_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.total_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.owner_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.group_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.other_prims)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.selected_prims)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.parcel_prim_bonus)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price)?;
        buffer.write_u8(self.parcel_data.name.len() as u8)?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write_u8(self.parcel_data.desc.len() as u8)?;
        buffer.write(&self.parcel_data.desc[..])?;
        buffer.write_u8(self.parcel_data.music_url.len() as u8)?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write_u8(self.parcel_data.media_url.len() as u8)?;
        buffer.write(&self.parcel_data.media_url[..])?;
        buffer.write(self.parcel_data.media_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.media_auto_scale)?;
        buffer.write(self.parcel_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours)?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.auth_buyer_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z)?;
        buffer.write_u8(self.parcel_data.landing_type)?;
        buffer.write_u8(self.parcel_data.region_push_override as u8)?;
        buffer.write_u8(self.parcel_data.region_deny_anonymous as u8)?;
        buffer.write_u8(self.parcel_data.region_deny_identified as u8)?;
        buffer.write_u8(self.parcel_data.region_deny_transacted as u8)?;
        // Block AgeVerificationBlock
        buffer.write_u8(self.age_verification_block.region_deny_age_unverified as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let parcel_data = ParcelProperties_ParcelData::read_from(buffer)?;
        // Block AgeVerificationBlock
        let age_verification_block = ParcelProperties_AgeVerificationBlock::read_from(buffer)?;
        Ok(MessageInstance::ParcelProperties(ParcelProperties {
            parcel_data: parcel_data,
            age_verification_block: age_verification_block,
        }))
    }
}

impl Message for ParcelPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        buffer.write_u8(self.parcel_data.snap_selection as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelPropertiesRequest_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesRequest_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesRequest(
            ParcelPropertiesRequest {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelPropertiesRequestByID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelPropertiesRequestByID_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesRequestByID_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesRequestByID(
            ParcelPropertiesRequestByID {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc6
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price)?;
        buffer.write_u8(self.parcel_data.name.len() as u8)?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write_u8(self.parcel_data.desc.len() as u8)?;
        buffer.write(&self.parcel_data.desc[..])?;
        buffer.write_u8(self.parcel_data.music_url.len() as u8)?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write_u8(self.parcel_data.media_url.len() as u8)?;
        buffer.write(&self.parcel_data.media_url[..])?;
        buffer.write(self.parcel_data.media_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.media_auto_scale)?;
        buffer.write(self.parcel_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours)?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.auth_buyer_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z)?;
        buffer.write_u8(self.parcel_data.landing_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelPropertiesUpdate_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesUpdate_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesUpdate(
            ParcelPropertiesUpdate {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelReclaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd0
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelReclaim_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelReclaim_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelReclaim(ParcelReclaim {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xd4
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelRelease_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelRelease_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelRelease(ParcelRelease {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelRename {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x92
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write_u8(item.new_name.len() as u8)?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelRename_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelRename(ParcelRename {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelReturnObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc7
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.return_type)?;
        // Block TaskIDs
        buffer.write_u8(self.task_i_ds.len() as u8)?;
        for item in &self.task_i_ds {
            buffer.write(item.task_id.as_bytes())?;
        }
        // Block OwnerIDs
        buffer.write_u8(self.owner_i_ds.len() as u8)?;
        for item in &self.owner_i_ds {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelReturnObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelReturnObjects_ParcelData::read_from(buffer)?;
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = buffer.read_u8()?;
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(ParcelReturnObjects_TaskIDs::read_from(buffer)?);
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = buffer.read_u8()?;
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(ParcelReturnObjects_OwnerIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelReturnObjects(ParcelReturnObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            task_i_ds: task_i_ds,
            owner_i_ds: owner_i_ds,
        }))
    }
}

impl Message for ParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe2
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.buyer_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelSales_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelSales(ParcelSales {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelSelectObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xca
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.return_type)?;
        // Block ReturnIDs
        buffer.write_u8(self.return_i_ds.len() as u8)?;
        for item in &self.return_i_ds {
            buffer.write(item.return_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelSelectObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelSelectObjects_ParcelData::read_from(buffer)?;
        // Block ReturnIDs
        let mut return_i_ds = Vec::new();
        let _return_i_ds_count = buffer.read_u8()?;
        for _ in 0.._return_i_ds_count {
            return_i_ds.push(ParcelSelectObjects_ReturnIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelSelectObjects(ParcelSelectObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            return_i_ds: return_i_ds,
        }))
    }
}

impl Message for ParcelSetOtherCleanTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc8
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ParcelSetOtherCleanTime_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelSetOtherCleanTime_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelSetOtherCleanTime(
            ParcelSetOtherCleanTime {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for PayPriceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa2
        ])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.object_data.default_pay_price)?;
        // Block ButtonData
        buffer.write_u8(self.button_data.len() as u8)?;
        for item in &self.button_data {
            buffer.write_i32::<LittleEndian>(item.pay_button)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = PayPriceReply_ObjectData::read_from(buffer)?;
        // Block ButtonData
        let mut button_data = Vec::new();
        let _button_data_count = buffer.read_u8()?;
        for _ in 0.._button_data_count {
            button_data.push(PayPriceReply_ButtonData::read_from(buffer)?);
        }
        Ok(MessageInstance::PayPriceReply(PayPriceReply {
            object_data: object_data,
            button_data: button_data,
        }))
    }
}

impl Message for PickDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xba
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PickDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::PickDelete(PickDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xbb
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.query_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PickGodDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickGodDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::PickGodDelete(PickGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb8
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u8(self.data.top_pick as u8)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.data.desc.len() as u16)?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_u8(self.data.user.len() as u8)?;
        buffer.write(&self.data.user[..])?;
        buffer.write_u8(self.data.original_name.len() as u8)?;
        buffer.write(&self.data.original_name[..])?;
        buffer.write_u8(self.data.sim_name.len() as u8)?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_i32::<LittleEndian>(self.data.sort_order)?;
        buffer.write_u8(self.data.enabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PickInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::PickInfoReply(PickInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xb9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u8(self.data.top_pick as u8)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u8(self.data.name.len() as u8)?;
        buffer.write(&self.data.name[..])?;
        buffer.write_u16::<LittleEndian>(self.data.desc.len() as u16)?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;

        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_i32::<LittleEndian>(self.data.sort_order)?;
        buffer.write_u8(self.data.enabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PickInfoUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickInfoUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::PickInfoUpdate(PickInfoUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        // Block QueryData
        buffer.write_u8(self.query_data.query_text.len() as u8)?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.query_flags)?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write_u8(self.query_data.sim_name.len() as u8)?;
        buffer.write(&self.query_data.sim_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PlacesQuery_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = PlacesQuery_TransactionData::read_from(buffer)?;
        // Block QueryData
        let query_data = PlacesQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::PlacesQuery(PlacesQuery {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for PlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x1e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block TransactionData
        buffer.write(self.transaction_data.transaction_id.as_bytes())?;
        // Block QueryData
        buffer.write_u8(self.query_data.len() as u8)?;
        for item in &self.query_data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.desc.len() as u8)?;
            buffer.write(&item.desc[..])?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
            buffer.write_i32::<LittleEndian>(item.billable_area)?;
            buffer.write_u8(item.flags)?;
            buffer.write_f32::<LittleEndian>(item.global_x)?;
            buffer.write_f32::<LittleEndian>(item.global_y)?;
            buffer.write_f32::<LittleEndian>(item.global_z)?;
            buffer.write_u8(item.sim_name.len() as u8)?;
            buffer.write(&item.sim_name[..])?;
            buffer.write(item.snapshot_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
            buffer.write_i32::<LittleEndian>(item.price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PlacesReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = PlacesReply_TransactionData::read_from(buffer)?;
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = buffer.read_u8()?;
        for _ in 0.._query_data_count {
            query_data.push(PlacesReply_QueryData::read_from(buffer)?);
        }
        Ok(MessageInstance::PlacesReply(PlacesReply {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for PreloadSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0f])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.sound_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(PreloadSound_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::PreloadSound(PreloadSound {
            data_block: data_block,
        }))
    }
}

impl Message for PurgeInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = PurgeInventoryDescendents_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = PurgeInventoryDescendents_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::PurgeInventoryDescendents(
            PurgeInventoryDescendents {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for RebakeAvatarTextures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x57
        ])?;
        // Block TextureData
        buffer.write(self.texture_data.texture_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TextureData
        let texture_data = RebakeAvatarTextures_TextureData::read_from(buffer)?;
        Ok(MessageInstance::RebakeAvatarTextures(
            RebakeAvatarTextures {
                texture_data: texture_data,
            },
        ))
    }
}

impl Message for Redo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = Redo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(Redo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::Redo(Redo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for RegionHandleRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x35
        ])?;
        // Block RequestBlock
        buffer.write(self.request_block.region_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RequestBlock
        let request_block = RegionHandleRequest_RequestBlock::read_from(buffer)?;
        Ok(MessageInstance::RegionHandleRequest(RegionHandleRequest {
            request_block: request_block,
        }))
    }
}

impl Message for RegionHandshake {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x94
        ])?;
        // Block RegionInfo
        buffer.write_u32::<LittleEndian>(self.region_info.region_flags)?;
        buffer.write_u8(self.region_info.sim_access)?;
        buffer.write_u8(self.region_info.sim_name.len() as u8)?;
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write(self.region_info.sim_owner.as_bytes())?;
        buffer.write_u8(self.region_info.is_estate_manager as u8)?;
        buffer.write_f32::<LittleEndian>(self.region_info.water_height)?;
        buffer.write_f32::<LittleEndian>(self.region_info.billable_factor)?;
        buffer.write(self.region_info.cache_id.as_bytes())?;
        buffer.write(self.region_info.terrain_base0.as_bytes())?;
        buffer.write(self.region_info.terrain_base1.as_bytes())?;
        buffer.write(self.region_info.terrain_base2.as_bytes())?;
        buffer.write(self.region_info.terrain_base3.as_bytes())?;
        buffer.write(self.region_info.terrain_detail0.as_bytes())?;
        buffer.write(self.region_info.terrain_detail1.as_bytes())?;
        buffer.write(self.region_info.terrain_detail2.as_bytes())?;
        buffer.write(self.region_info.terrain_detail3.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height00)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height01)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height10)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height11)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range00)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range01)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range10)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range11)?;
        // Block RegionInfo2
        buffer.write(self.region_info2.region_id.as_bytes())?;
        // Block RegionInfo3
        buffer.write_i32::<LittleEndian>(self.region_info3.cpu_class_id)?;
        buffer.write_i32::<LittleEndian>(self.region_info3.cpu_ratio)?;
        buffer.write_u8(self.region_info3.colo_name.len() as u8)?;
        buffer.write(&self.region_info3.colo_name[..])?;
        buffer.write_u8(self.region_info3.product_sku.len() as u8)?;
        buffer.write(&self.region_info3.product_sku[..])?;
        buffer.write_u8(self.region_info3.product_name.len() as u8)?;
        buffer.write(&self.region_info3.product_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionInfo
        let region_info = RegionHandshake_RegionInfo::read_from(buffer)?;
        // Block RegionInfo2
        let region_info2 = RegionHandshake_RegionInfo2::read_from(buffer)?;
        // Block RegionInfo3
        let region_info3 = RegionHandshake_RegionInfo3::read_from(buffer)?;
        Ok(MessageInstance::RegionHandshake(RegionHandshake {
            region_info: region_info,
            region_info2: region_info2,
            region_info3: region_info3,
        }))
    }
}

impl Message for RegionHandshakeReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x95
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write_u32::<LittleEndian>(self.region_info.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RegionHandshakeReply_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = RegionHandshakeReply_RegionInfo::read_from(buffer)?;
        Ok(MessageInstance::RegionHandshakeReply(
            RegionHandshakeReply {
                agent_data: agent_data,
                region_info: region_info,
            },
        ))
    }
}

impl Message for RegionIDAndHandleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x36
        ])?;
        // Block ReplyBlock
        buffer.write(self.reply_block.region_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.reply_block.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ReplyBlock
        let reply_block = RegionIDAndHandleReply_ReplyBlock::read_from(buffer)?;
        Ok(MessageInstance::RegionIDAndHandleReply(
            RegionIDAndHandleReply {
                reply_block: reply_block,
            },
        ))
    }
}

impl Message for RegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write_u8(self.region_info.sim_name.len() as u8)?;
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.region_info.estate_id)?;
        buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id)?;
        buffer.write_u32::<LittleEndian>(self.region_info.region_flags)?;
        buffer.write_u8(self.region_info.sim_access)?;
        buffer.write_u8(self.region_info.max_agents)?;
        buffer.write_f32::<LittleEndian>(self.region_info.billable_factor)?;
        buffer.write_f32::<LittleEndian>(self.region_info.object_bonus_factor)?;
        buffer.write_f32::<LittleEndian>(self.region_info.water_height)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_raise_limit)?;
        buffer.write_f32::<LittleEndian>(self.region_info.terrain_lower_limit)?;
        buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter)?;
        buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x)?;
        buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y)?;
        buffer.write_u8(self.region_info.use_estate_sun as u8)?;
        buffer.write_f32::<LittleEndian>(self.region_info.sun_hour)?;
        // Block RegionInfo2
        buffer.write_u8(self.region_info2.product_sku.len() as u8)?;
        buffer.write(&self.region_info2.product_sku[..])?;
        buffer.write_u8(self.region_info2.product_name.len() as u8)?;
        buffer.write(&self.region_info2.product_name[..])?;
        buffer.write_u32::<LittleEndian>(self.region_info2.max_agents32)?;
        buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_agents)?;
        buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_objects)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RegionInfo_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = RegionInfo_RegionInfo::read_from(buffer)?;
        // Block RegionInfo2
        let region_info2 = RegionInfo_RegionInfo2::read_from(buffer)?;
        Ok(MessageInstance::RegionInfo(RegionInfo {
            agent_data: agent_data,
            region_info: region_info,
            region_info2: region_info2,
        }))
    }
}

impl Message for RegionPresenceRequestByHandle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0f
        ])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceRequestByHandle_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::RegionPresenceRequestByHandle(
            RegionPresenceRequestByHandle {
                region_data: region_data,
            },
        ))
    }
}

impl Message for RegionPresenceRequestByRegionID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0e
        ])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write(item.region_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceRequestByRegionID_RegionData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::RegionPresenceRequestByRegionID(
            RegionPresenceRequestByRegionID {
                region_data: region_data,
            },
        ))
    }
}

impl Message for RegionPresenceResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x10
        ])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write(item.region_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
            buffer.write(&item.internal_region_ip.octets())?;
            buffer.write(&item.external_region_ip.octets())?;
            buffer.write_u16::<LittleEndian>(item.region_port)?;
            buffer.write_f64::<LittleEndian>(item.valid_until)?;
            buffer.write_u8(item.message.len() as u8)?;
            buffer.write(&item.message[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceResponse_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::RegionPresenceResponse(
            RegionPresenceResponse {
                region_data: region_data,
            },
        ))
    }
}

impl Message for RemoveAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AttachmentBlock
        buffer.write_u8(self.attachment_block.attachment_point)?;
        buffer.write(self.attachment_block.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveAttachment_AgentData::read_from(buffer)?;
        // Block AttachmentBlock
        let attachment_block = RemoveAttachment_AttachmentBlock::read_from(buffer)?;
        Ok(MessageInstance::RemoveAttachment(RemoveAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
        }))
    }
}

impl Message for RemoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x14
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(RemoveInventoryFolder_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryFolder(
            RemoveInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for RemoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(RemoveInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryItem(RemoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveInventoryObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveInventoryObjects_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(RemoveInventoryObjects_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(RemoveInventoryObjects_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryObjects(
            RemoveInventoryObjects {
                agent_data: agent_data,
                folder_data: folder_data,
                item_data: item_data,
            },
        ))
    }
}

impl Message for RemoveMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x08
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write(self.mute_data.mute_id.as_bytes())?;
        buffer.write_u8(self.mute_data.mute_name.len() as u8)?;
        buffer.write(&self.mute_data.mute_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveMuteListEntry_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = RemoveMuteListEntry_MuteData::read_from(buffer)?;
        Ok(MessageInstance::RemoveMuteListEntry(RemoveMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for RemoveNameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4a
        ])?;
        // Block TaskData
        buffer.write(self.task_data.id.as_bytes())?;
        // Block NameValueData
        buffer.write_u8(self.name_value_data.len() as u8)?;
        for item in &self.name_value_data {
            buffer.write_u16::<LittleEndian>(item.nv_pair.len() as u16)?;
            buffer.write(&item.nv_pair[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TaskData
        let task_data = RemoveNameValuePair_TaskData::read_from(buffer)?;
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = buffer.read_u8()?;
        for _ in 0.._name_value_data_count {
            name_value_data.push(RemoveNameValuePair_NameValueData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveNameValuePair(RemoveNameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for RemoveParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xde
        ])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(RemoveParcel_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveParcel(RemoveParcel {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for RemoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(self.inventory_data.local_id)?;
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RemoveTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RemoveTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RemoveTaskInventory(RemoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ReplyTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x22
        ])?;
        // Block InventoryData
        buffer.write(self.inventory_data.task_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(self.inventory_data.serial)?;
        buffer.write_u8(self.inventory_data.filename.len() as u8)?;
        buffer.write(&self.inventory_data.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block InventoryData
        let inventory_data = ReplyTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::ReplyTaskInventory(ReplyTaskInventory {
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ReportAutosaveCrash {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x80
        ])?;
        // Block AutosaveData
        buffer.write_i32::<LittleEndian>(self.autosave_data.pid)?;
        buffer.write_i32::<LittleEndian>(self.autosave_data.status)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AutosaveData
        let autosave_data = ReportAutosaveCrash_AutosaveData::read_from(buffer)?;
        Ok(MessageInstance::ReportAutosaveCrash(ReportAutosaveCrash {
            autosave_data: autosave_data,
        }))
    }
}

impl Message for RequestGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x01
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestBlock
        buffer.write_u8(self.request_block.godlike as u8)?;
        buffer.write(self.request_block.token.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestGodlikePowers_AgentData::read_from(buffer)?;
        // Block RequestBlock
        let request_block = RequestGodlikePowers_RequestBlock::read_from(buffer)?;
        Ok(MessageInstance::RequestGodlikePowers(
            RequestGodlikePowers {
                agent_data: agent_data,
                request_block: request_block,
            },
        ))
    }
}

impl Message for RequestImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x08])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestImage
        buffer.write_u8(self.request_image.len() as u8)?;
        for item in &self.request_image {
            buffer.write(item.image.as_bytes())?;
            buffer.write_i8(item.discard_level)?;
            buffer.write_f32::<LittleEndian>(item.download_priority)?;
            buffer.write_u32::<LittleEndian>(item.packet)?;
            buffer.write_u8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestImage_AgentData::read_from(buffer)?;
        // Block RequestImage
        let mut request_image = Vec::new();
        let _request_image_count = buffer.read_u8()?;
        for _ in 0.._request_image_count {
            request_image.push(RequestImage_RequestImage::read_from(buffer)?);
        }
        Ok(MessageInstance::RequestImage(RequestImage {
            agent_data: agent_data,
            request_image: request_image,
        }))
    }
}

impl Message for RequestInventoryAsset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1a
        ])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(self.query_data.agent_id.as_bytes())?;
        buffer.write(self.query_data.owner_id.as_bytes())?;
        buffer.write(self.query_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block QueryData
        let query_data = RequestInventoryAsset_QueryData::read_from(buffer)?;
        Ok(MessageInstance::RequestInventoryAsset(
            RequestInventoryAsset {
                query_data: query_data,
            },
        ))
    }
}

impl Message for RequestMultipleObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x03])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u8(item.cache_miss_type)?;
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestMultipleObjects_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(RequestMultipleObjects_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::RequestMultipleObjects(
            RequestMultipleObjects {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RequestObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x05])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.request_flags)?;
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestObjectPropertiesFamily_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = RequestObjectPropertiesFamily_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RequestObjectPropertiesFamily(
            RequestObjectPropertiesFamily {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RequestParcelTransfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xdc
        ])?;
        // Block Data
        buffer.write(self.data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.transaction_time)?;
        buffer.write(self.data.source_id.as_bytes())?;
        buffer.write(self.data.dest_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_u8(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.transaction_type)?;
        buffer.write_i32::<LittleEndian>(self.data.amount)?;
        buffer.write_i32::<LittleEndian>(self.data.billable_area)?;
        buffer.write_i32::<LittleEndian>(self.data.actual_area)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block RegionData
        buffer.write(self.region_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.region_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.region_data.grid_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = RequestParcelTransfer_Data::read_from(buffer)?;
        // Block RegionData
        let region_data = RequestParcelTransfer_RegionData::read_from(buffer)?;
        Ok(MessageInstance::RequestParcelTransfer(
            RequestParcelTransfer {
                data: data,
                region_data: region_data,
            },
        ))
    }
}

impl Message for RequestPayPrice {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa1
        ])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = RequestPayPrice_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RequestPayPrice(RequestPayPrice {
            object_data: object_data,
        }))
    }
}

impl Message for RequestRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestRegionInfo_AgentData::read_from(buffer)?;
        Ok(MessageInstance::RequestRegionInfo(RequestRegionInfo {
            agent_data: agent_data,
        }))
    }
}

impl Message for RequestTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x21
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(self.inventory_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RequestTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RequestTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RequestTaskInventory(
            RequestTaskInventory {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for RequestTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8a
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::RequestTrustedCircuit(
            RequestTrustedCircuit {},
        ))
    }
}

impl Message for RequestXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9c
        ])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_u8(self.xfer_id.filename.len() as u8)?;
        buffer.write(&self.xfer_id.filename[..])?;
        buffer.write_u8(self.xfer_id.file_path)?;
        buffer.write_u8(self.xfer_id.delete_on_completion as u8)?;
        buffer.write_u8(self.xfer_id.use_big_packets as u8)?;
        buffer.write(self.xfer_id.v_file_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(self.xfer_id.v_file_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block XferID
        let xfer_id = RequestXfer_XferID::read_from(buffer)?;
        Ok(MessageInstance::RequestXfer(
            RequestXfer { xfer_id: xfer_id },
        ))
    }
}

impl Message for RetrieveInstantMessages {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xff
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RetrieveInstantMessages_AgentData::read_from(buffer)?;
        Ok(MessageInstance::RetrieveInstantMessages(
            RetrieveInstantMessages {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for RevokePermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc1
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.object_permissions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RevokePermissions_AgentData::read_from(buffer)?;
        // Block Data
        let data = RevokePermissions_Data::read_from(buffer)?;
        Ok(MessageInstance::RevokePermissions(RevokePermissions {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for RezMultipleAttachmentsFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write(self.header_data.compound_msg_id.as_bytes())?;
        buffer.write_u8(self.header_data.total_objects)?;
        buffer.write_u8(self.header_data.first_detach_all as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.attachment_pt)?;
            buffer.write_u32::<LittleEndian>(item.item_flags)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezMultipleAttachmentsFromInv_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = RezMultipleAttachmentsFromInv_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(RezMultipleAttachmentsFromInv_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::RezMultipleAttachmentsFromInv(
            RezMultipleAttachmentsFromInv {
                agent_data: agent_data,
                header_data: header_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x25
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RezData
        buffer.write(self.rez_data.from_task_id.as_bytes())?;
        buffer.write_u8(self.rez_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z)?;
        buffer.write(self.rez_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.rez_data.ray_end_is_intersection as u8)?;
        buffer.write_u8(self.rez_data.rez_selected as u8)?;
        buffer.write_u8(self.rez_data.remove_item as u8)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.item_flags)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask)?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask)?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price)?;
        buffer.write_u8(self.inventory_data.name.len() as u8)?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write_u8(self.inventory_data.description.len() as u8)?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezObject_AgentData::read_from(buffer)?;
        // Block RezData
        let rez_data = RezObject_RezData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RezObject_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RezObject(RezObject {
            agent_data: agent_data,
            rez_data: rez_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RezObjectFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x26
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RezData
        buffer.write(self.rez_data.from_task_id.as_bytes())?;
        buffer.write_u8(self.rez_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y)?;

        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z)?;
        buffer.write(self.rez_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.rez_data.ray_end_is_intersection as u8)?;
        buffer.write_u8(self.rez_data.rez_selected as u8)?;
        buffer.write_u8(self.rez_data.remove_item as u8)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.item_flags)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask)?;
        // Block NotecardData
        buffer.write(self.notecard_data.notecard_item_id.as_bytes())?;
        buffer.write(self.notecard_data.object_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezObjectFromNotecard_AgentData::read_from(buffer)?;
        // Block RezData
        let rez_data = RezObjectFromNotecard_RezData::read_from(buffer)?;
        // Block NotecardData
        let notecard_data = RezObjectFromNotecard_NotecardData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(RezObjectFromNotecard_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::RezObjectFromNotecard(
            RezObjectFromNotecard {
                agent_data: agent_data,
                rez_data: rez_data,
                notecard_data: notecard_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for RezRestoreToWorld {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa9
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask)?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price)?;
        buffer.write_u8(self.inventory_data.name.len() as u8)?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write_u8(self.inventory_data.description.len() as u8)?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezRestoreToWorld_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RezRestoreToWorld_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RezRestoreToWorld(RezRestoreToWorld {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RezScript {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x30
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block UpdateBlock
        buffer.write_u32::<LittleEndian>(self.update_block.object_local_id)?;
        buffer.write_u8(self.update_block.enabled as u8)?;
        // Block InventoryBlock
        buffer.write(self.inventory_block.item_id.as_bytes())?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.creator_id.as_bytes())?;
        buffer.write(self.inventory_block.owner_id.as_bytes())?;
        buffer.write(self.inventory_block.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask)?;
        buffer.write_u8(self.inventory_block.group_owned as u8)?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.flags)?;
        buffer.write_u8(self.inventory_block.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.inventory_block.sale_price)?;
        buffer.write_u8(self.inventory_block.name.len() as u8)?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write_u8(self.inventory_block.description.len() as u8)?;
        buffer.write(&self.inventory_block.description[..])?;
        buffer.write_i32::<LittleEndian>(self.inventory_block.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezScript_AgentData::read_from(buffer)?;
        // Block UpdateBlock
        let update_block = RezScript_UpdateBlock::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = RezScript_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::RezScript(RezScript {
            agent_data: agent_data,
            update_block: update_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for RezSingleAttachmentFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.item_id.as_bytes())?;
        buffer.write(self.object_data.owner_id.as_bytes())?;
        buffer.write_u8(self.object_data.attachment_pt)?;
        buffer.write_u32::<LittleEndian>(self.object_data.item_flags)?;
        buffer.write_u32::<LittleEndian>(self.object_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask)?;
        buffer.write_u8(self.object_data.name.len() as u8)?;
        buffer.write(&self.object_data.name[..])?;
        buffer.write_u8(self.object_data.description.len() as u8)?;
        buffer.write(&self.object_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = RezSingleAttachmentFromInv_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = RezSingleAttachmentFromInv_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RezSingleAttachmentFromInv(
            RezSingleAttachmentFromInv {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RoutedMoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3b
        ])?;
        // Block TargetBlock
        buffer.write(&self.target_block.target_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.target_block.target_port)?;
        // Block MoneyData
        buffer.write(self.money_data.agent_id.as_bytes())?;
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u8(self.money_data.transaction_success as u8)?;
        buffer.write_i32::<LittleEndian>(self.money_data.money_balance)?;
        buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit)?;
        buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed)?;
        buffer.write_u8(self.money_data.description.len() as u8)?;
        buffer.write(&self.money_data.description[..])?;
        // Block TransactionInfo
        buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type)?;
        buffer.write(self.transaction_info.source_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_source_group as u8)?;
        buffer.write(self.transaction_info.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_dest_group as u8)?;
        buffer.write_i32::<LittleEndian>(self.transaction_info.amount)?;
        buffer.write_u8(self.transaction_info.item_description.len() as u8)?;
        buffer.write(&self.transaction_info.item_description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TargetBlock
        let target_block = RoutedMoneyBalanceReply_TargetBlock::read_from(buffer)?;
        // Block MoneyData
        let money_data = RoutedMoneyBalanceReply_MoneyData::read_from(buffer)?;
        // Block TransactionInfo
        let transaction_info = RoutedMoneyBalanceReply_TransactionInfo::read_from(buffer)?;
        Ok(MessageInstance::RoutedMoneyBalanceReply(
            RoutedMoneyBalanceReply {
                target_block: target_block,
                money_data: money_data,
                transaction_info: transaction_info,
            },
        ))
    }
}

impl Message for RpcChannelReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9e
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = RpcChannelReply_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcChannelReply(RpcChannelReply {
            data_block: data_block,
        }))
    }
}

impl Message for RpcChannelRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9d
        ])?;
        // Block DataBlock
        buffer.write_u32::<LittleEndian>(self.data_block.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.data_block.grid_y)?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = RpcChannelRequest_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcChannelRequest(RpcChannelRequest {
            data_block: data_block,
        }))
    }
}

impl Message for RpcScriptReplyInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa1
        ])?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write_u16::<LittleEndian>(self.data_block.string_value.len() as u16)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = RpcScriptReplyInbound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptReplyInbound(
            RpcScriptReplyInbound {
                data_block: data_block,
            },
        ))
    }
}

impl Message for RpcScriptRequestInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9f
        ])?;
        // Block TargetBlock
        buffer.write_u32::<LittleEndian>(self.target_block.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.target_block.grid_y)?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write_u16::<LittleEndian>(self.data_block.string_value.len() as u16)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TargetBlock
        let target_block = RpcScriptRequestInbound_TargetBlock::read_from(buffer)?;
        // Block DataBlock
        let data_block = RpcScriptRequestInbound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptRequestInbound(
            RpcScriptRequestInbound {
                target_block: target_block,
                data_block: data_block,
            },
        ))
    }
}

impl Message for RpcScriptRequestInboundForward {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa0
        ])?;
        // Block DataBlock
        buffer.write(&self.data_block.rpc_server_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.data_block.rpc_server_port)?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write_u16::<LittleEndian>(self.data_block.string_value.len() as u16)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = RpcScriptRequestInboundForward_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptRequestInboundForward(
            RpcScriptRequestInboundForward {
                data_block: data_block,
            },
        ))
    }
}

impl Message for SaveAssetIntoInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x10
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.new_asset_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SaveAssetIntoInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = SaveAssetIntoInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::SaveAssetIntoInventory(
            SaveAssetIntoInventory {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for ScriptAnswerYes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x84
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.task_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.questions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ScriptAnswerYes_AgentData::read_from(buffer)?;
        // Block Data
        let data = ScriptAnswerYes_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptAnswerYes(ScriptAnswerYes {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ScriptControlChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xbd
        ])?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u8(item.take_controls as u8)?;
            buffer.write_u32::<LittleEndian>(item.controls)?;
            buffer.write_u8(item.pass_to_agent as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ScriptControlChange_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptControlChange(
            ScriptControlChange { data: data },
        ))
    }
}

impl Message for ScriptDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x52
        ])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write_u64::<LittleEndian>(item.hash)?;
            buffer.write_u16::<LittleEndian>(item.reply.len() as u16)?;
            buffer.write(&item.reply[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(ScriptDataReply_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDataReply(ScriptDataReply {
            data_block: data_block,
        }))
    }
}

impl Message for ScriptDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x51
        ])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write_u64::<LittleEndian>(item.hash)?;
            buffer.write_i8(item.request_type)?;
            buffer.write_u16::<LittleEndian>(item.request.len() as u16)?;
            buffer.write(&item.request[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(ScriptDataRequest_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDataRequest(ScriptDataRequest {
            data_block: data_block,
        }))
    }
}

impl Message for ScriptDialog {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xbe
        ])?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_u8(self.data.first_name.len() as u8)?;
        buffer.write(&self.data.first_name[..])?;
        buffer.write_u8(self.data.last_name.len() as u8)?;
        buffer.write(&self.data.last_name[..])?;
        buffer.write_u8(self.data.object_name.len() as u8)?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write_u16::<LittleEndian>(self.data.message.len() as u16)?;
        buffer.write(&self.data.message[..])?;
        buffer.write_i32::<LittleEndian>(self.data.chat_channel)?;
        buffer.write(self.data.image_id.as_bytes())?;
        // Block Buttons
        buffer.write_u8(self.buttons.len() as u8)?;
        for item in &self.buttons {
            buffer.write_u8(item.button_label.len() as u8)?;
            buffer.write(&item.button_label[..])?;
        }
        // Block OwnerData
        buffer.write_u8(self.owner_data.len() as u8)?;
        for item in &self.owner_data {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = ScriptDialog_Data::read_from(buffer)?;
        // Block Buttons
        let mut buttons = Vec::new();
        let _buttons_count = buffer.read_u8()?;
        for _ in 0.._buttons_count {
            buttons.push(ScriptDialog_Buttons::read_from(buffer)?);
        }
        // Block OwnerData
        let mut owner_data = Vec::new();
        let _owner_data_count = buffer.read_u8()?;
        for _ in 0.._owner_data_count {
            owner_data.push(ScriptDialog_OwnerData::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDialog(ScriptDialog {
            data: data,
            buttons: buttons,
            owner_data: owner_data,
        }))
    }
}

impl Message for ScriptDialogReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xbf
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.chat_channel)?;
        buffer.write_i32::<LittleEndian>(self.data.button_index)?;
        buffer.write_u8(self.data.button_label.len() as u8)?;
        buffer.write(&self.data.button_label[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ScriptDialogReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ScriptDialogReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptDialogReply(ScriptDialogReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ScriptMailRegistration {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0xa2
        ])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.target_ip.len() as u8)?;
        buffer.write(&self.data_block.target_ip[..])?;
        buffer.write_u16::<LittleEndian>(self.data_block.target_port)?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block DataBlock
        let data_block = ScriptMailRegistration_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::ScriptMailRegistration(
            ScriptMailRegistration {
                data_block: data_block,
            },
        ))
    }
}

impl Message for ScriptQuestion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xbc
        ])?;
        // Block Data
        buffer.write(self.data.task_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write_u8(self.data.object_name.len() as u8)?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write_u8(self.data.object_owner.len() as u8)?;
        buffer.write(&self.data.object_owner[..])?;
        buffer.write_i32::<LittleEndian>(self.data.questions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = ScriptQuestion_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptQuestion(
            ScriptQuestion { data: data },
        ))
    }
}

impl Message for ScriptReset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf6
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ScriptReset_AgentData::read_from(buffer)?;
        // Block Script
        let script = ScriptReset_Script::read_from(buffer)?;
        Ok(MessageInstance::ScriptReset(ScriptReset {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for ScriptRunningReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf4
        ])?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        buffer.write_u8(self.script.running as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Script
        let script = ScriptRunningReply_Script::read_from(buffer)?;
        Ok(MessageInstance::ScriptRunningReply(
            ScriptRunningReply { script: script },
        ))
    }
}

impl Message for ScriptSensorReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf8
        ])?;
        // Block Requester
        buffer.write(self.requester.source_id.as_bytes())?;
        // Block SensedData
        buffer.write_u8(self.sensed_data.len() as u8)?;
        for item in &self.sensed_data {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;

            buffer.write_f32::<LittleEndian>(item.position.y)?;

            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.velocity.x)?;

            buffer.write_f32::<LittleEndian>(item.velocity.y)?;

            buffer.write_f32::<LittleEndian>(item.velocity.z)?;
            let norm_rotation = if item.rotation.scalar() >= 0. {
                item.rotation.norm()
            } else {
                -item.rotation.norm()
            };

            buffer.write_f32::<LittleEndian>(item.rotation.coords[0] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[1] / norm_rotation)?;

            buffer.write_f32::<LittleEndian>(item.rotation.coords[2] / norm_rotation)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.range)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Requester
        let requester = ScriptSensorReply_Requester::read_from(buffer)?;
        // Block SensedData
        let mut sensed_data = Vec::new();
        let _sensed_data_count = buffer.read_u8()?;
        for _ in 0.._sensed_data_count {
            sensed_data.push(ScriptSensorReply_SensedData::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptSensorReply(ScriptSensorReply {
            requester: requester,
            sensed_data: sensed_data,
        }))
    }
}

impl Message for ScriptSensorRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf7
        ])?;
        // Block Requester
        buffer.write(self.requester.source_id.as_bytes())?;
        buffer.write(self.requester.request_id.as_bytes())?;
        buffer.write(self.requester.search_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.requester.search_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.requester.search_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.requester.search_pos.z)?;
        let norm_search_dir = if self.requester.search_dir.scalar() >= 0. {
            self.requester.search_dir.norm()
        } else {
            -self.requester.search_dir.norm()
        };

        buffer.write_f32::<LittleEndian>(self.requester.search_dir.coords[0] / norm_search_dir)?;

        buffer.write_f32::<LittleEndian>(self.requester.search_dir.coords[1] / norm_search_dir)?;

        buffer.write_f32::<LittleEndian>(self.requester.search_dir.coords[2] / norm_search_dir)?;
        buffer.write_u8(self.requester.search_name.len() as u8)?;
        buffer.write(&self.requester.search_name[..])?;
        buffer.write_i32::<LittleEndian>(self.requester.type_)?;
        buffer.write_f32::<LittleEndian>(self.requester.range)?;
        buffer.write_f32::<LittleEndian>(self.requester.arc)?;
        buffer.write_u64::<LittleEndian>(self.requester.region_handle)?;
        buffer.write_u8(self.requester.search_regions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Requester
        let requester = ScriptSensorRequest_Requester::read_from(buffer)?;
        Ok(MessageInstance::ScriptSensorRequest(ScriptSensorRequest {
            requester: requester,
        }))
    }
}

impl Message for ScriptTeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xc3
        ])?;
        // Block Data
        buffer.write_u8(self.data.object_name.len() as u8)?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write_u8(self.data.sim_name.len() as u8)?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f32::<LittleEndian>(self.data.sim_position.x)?;

        buffer.write_f32::<LittleEndian>(self.data.sim_position.y)?;

        buffer.write_f32::<LittleEndian>(self.data.sim_position.z)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.data.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.data.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = ScriptTeleportRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptTeleportRequest(
            ScriptTeleportRequest { data: data },
        ))
    }
}

impl Message for SendPostcard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x9c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.asset_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.x)?;

        buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.y)?;

        buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.z)?;
        buffer.write_u8(self.agent_data.to.len() as u8)?;
        buffer.write(&self.agent_data.to[..])?;
        buffer.write_u8(self.agent_data.from.len() as u8)?;
        buffer.write(&self.agent_data.from[..])?;
        buffer.write_u8(self.agent_data.name.len() as u8)?;
        buffer.write(&self.agent_data.name[..])?;
        buffer.write_u8(self.agent_data.subject.len() as u8)?;
        buffer.write(&self.agent_data.subject[..])?;
        buffer.write_u16::<LittleEndian>(self.agent_data.msg.len() as u16)?;
        buffer.write(&self.agent_data.msg[..])?;
        buffer.write_u8(self.agent_data.allow_publish as u8)?;
        buffer.write_u8(self.agent_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SendPostcard_AgentData::read_from(buffer)?;
        Ok(MessageInstance::SendPostcard(SendPostcard {
            agent_data: agent_data,
        }))
    }
}

impl Message for SendXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x12])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_u32::<LittleEndian>(self.xfer_id.packet)?;
        // Block DataPacket
        buffer.write_u16::<LittleEndian>(self.data_packet.data.len() as u16)?;
        buffer.write(&self.data_packet.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block XferID
        let xfer_id = SendXferPacket_XferID::read_from(buffer)?;
        // Block DataPacket
        let data_packet = SendXferPacket_DataPacket::read_from(buffer)?;
        Ok(MessageInstance::SendXferPacket(SendXferPacket {
            xfer_id: xfer_id,
            data_packet: data_packet,
        }))
    }
}

impl Message for SetAlwaysRun {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x58
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.always_run as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SetAlwaysRun_AgentData::read_from(buffer)?;
        Ok(MessageInstance::SetAlwaysRun(SetAlwaysRun {
            agent_data: agent_data,
        }))
    }
}

impl Message for SetCPURatio {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x47
        ])?;
        // Block Data
        buffer.write_u8(self.data.ratio)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = SetCPURatio_Data::read_from(buffer)?;
        Ok(MessageInstance::SetCPURatio(SetCPURatio { data: data }))
    }
}

impl Message for SetFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9f
        ])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        // Block CameraProperty
        buffer.write_u8(self.camera_property.len() as u8)?;
        for item in &self.camera_property {
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ObjectData
        let object_data = SetFollowCamProperties_ObjectData::read_from(buffer)?;
        // Block CameraProperty
        let mut camera_property = Vec::new();
        let _camera_property_count = buffer.read_u8()?;
        for _ in 0.._camera_property_count {
            camera_property.push(SetFollowCamProperties_CameraProperty::read_from(buffer)?);
        }
        Ok(MessageInstance::SetFollowCamProperties(
            SetFollowCamProperties {
                object_data: object_data,
                camera_property: camera_property,
            },
        ))
    }
}

impl Message for SetGroupAcceptNotices {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x72
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.accept_notices as u8)?;
        // Block NewData
        buffer.write_u8(self.new_data.list_in_profile as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SetGroupAcceptNotices_AgentData::read_from(buffer)?;
        // Block Data
        let data = SetGroupAcceptNotices_Data::read_from(buffer)?;
        // Block NewData
        let new_data = SetGroupAcceptNotices_NewData::read_from(buffer)?;
        Ok(MessageInstance::SetGroupAcceptNotices(
            SetGroupAcceptNotices {
                agent_data: agent_data,
                data: data,
                new_data: new_data,
            },
        ))
    }
}

impl Message for SetGroupContribution {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x71
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.contribution)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SetGroupContribution_AgentData::read_from(buffer)?;
        // Block Data
        let data = SetGroupContribution_Data::read_from(buffer)?;
        Ok(MessageInstance::SetGroupContribution(
            SetGroupContribution {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for SetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xf5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        buffer.write_u8(self.script.running as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SetScriptRunning_AgentData::read_from(buffer)?;
        // Block Script
        let script = SetScriptRunning_Script::read_from(buffer)?;
        Ok(MessageInstance::SetScriptRunning(SetScriptRunning {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for SetSimPresenceInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x17
        ])?;
        // Block SimData
        buffer.write(self.sim_data.region_id.as_bytes())?;
        buffer.write_u8(self.sim_data.host_name.len() as u8)?;
        buffer.write(&self.sim_data.host_name[..])?;
        buffer.write_u32::<LittleEndian>(self.sim_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.sim_data.grid_y)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.pid)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.agent_count)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.time_to_live)?;
        buffer.write_u8(self.sim_data.status.len() as u8)?;
        buffer.write(&self.sim_data.status[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimData
        let sim_data = SetSimPresenceInDatabase_SimData::read_from(buffer)?;
        Ok(MessageInstance::SetSimPresenceInDatabase(
            SetSimPresenceInDatabase { sim_data: sim_data },
        ))
    }
}

impl Message for SetSimStatusInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x16
        ])?;
        // Block Data
        buffer.write(self.data.region_id.as_bytes())?;
        buffer.write_u8(self.data.host_name.len() as u8)?;
        buffer.write(&self.data.host_name[..])?;
        buffer.write_i32::<LittleEndian>(self.data.x)?;
        buffer.write_i32::<LittleEndian>(self.data.y)?;
        buffer.write_i32::<LittleEndian>(self.data.pid)?;
        buffer.write_i32::<LittleEndian>(self.data.agent_count)?;
        buffer.write_i32::<LittleEndian>(self.data.time_to_live)?;
        buffer.write_u8(self.data.status.len() as u8)?;
        buffer.write(&self.data.status[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = SetSimStatusInDatabase_Data::read_from(buffer)?;
        Ok(MessageInstance::SetSimStatusInDatabase(
            SetSimStatusInDatabase { data: data },
        ))
    }
}

impl Message for SetStartLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x45
        ])?;
        // Block StartLocationData
        buffer.write(self.start_location_data.agent_id.as_bytes())?;
        buffer.write(self.start_location_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.start_location_data.location_id)?;
        buffer.write_u64::<LittleEndian>(self.start_location_data.region_handle)?;
        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z)?;
        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block StartLocationData
        let start_location_data = SetStartLocation_StartLocationData::read_from(buffer)?;
        Ok(MessageInstance::SetStartLocation(SetStartLocation {
            start_location_data: start_location_data,
        }))
    }
}

impl Message for SetStartLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x44
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block StartLocationData
        buffer.write_u8(self.start_location_data.sim_name.len() as u8)?;
        buffer.write(&self.start_location_data.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.start_location_data.location_id)?;
        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z)?;
        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SetStartLocationRequest_AgentData::read_from(buffer)?;
        // Block StartLocationData
        let start_location_data = SetStartLocationRequest_StartLocationData::read_from(buffer)?;
        Ok(MessageInstance::SetStartLocationRequest(
            SetStartLocationRequest {
                agent_data: agent_data,
                start_location_data: start_location_data,
            },
        ))
    }
}

impl Message for SimCrashed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x48
        ])?;
        // Block Data
        buffer.write_u32::<LittleEndian>(self.data.region_x)?;
        buffer.write_u32::<LittleEndian>(self.data.region_y)?;
        // Block Users
        buffer.write_u8(self.users.len() as u8)?;
        for item in &self.users {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Data
        let data = SimCrashed_Data::read_from(buffer)?;
        // Block Users
        let mut users = Vec::new();
        let _users_count = buffer.read_u8()?;
        for _ in 0.._users_count {
            users.push(SimCrashed_Users::read_from(buffer)?);
        }
        Ok(MessageInstance::SimCrashed(SimCrashed {
            data: data,
            users: users,
        }))
    }
}

impl Message for SimStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x8c
        ])?;
        // Block Region
        buffer.write_u32::<LittleEndian>(self.region.region_x)?;
        buffer.write_u32::<LittleEndian>(self.region.region_y)?;
        buffer.write_u32::<LittleEndian>(self.region.region_flags)?;
        buffer.write_u32::<LittleEndian>(self.region.object_capacity)?;
        // Block Stat
        buffer.write_u8(self.stat.len() as u8)?;
        for item in &self.stat {
            buffer.write_u32::<LittleEndian>(item.stat_id)?;
            buffer.write_f32::<LittleEndian>(item.stat_value)?;
        }
        // Block PidStat
        buffer.write_i32::<LittleEndian>(self.pid_stat.pid)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Region
        let region = SimStats_Region::read_from(buffer)?;
        // Block Stat
        let mut stat = Vec::new();
        let _stat_count = buffer.read_u8()?;
        for _ in 0.._stat_count {
            stat.push(SimStats_Stat::read_from(buffer)?);
        }
        // Block PidStat
        let pid_stat = SimStats_PidStat::read_from(buffer)?;
        Ok(MessageInstance::SimStats(SimStats {
            region: region,
            stat: stat,
            pid_stat: pid_stat,
        }))
    }
}

impl Message for SimStatus {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x0c])?;
        // Block SimStatus
        buffer.write_u8(self.sim_status.can_accept_agents as u8)?;
        buffer.write_u8(self.sim_status.can_accept_tasks as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimStatus
        let sim_status = SimStatus_SimStatus::read_from(buffer)?;
        Ok(MessageInstance::SimStatus(SimStatus {
            sim_status: sim_status,
        }))
    }
}

impl Message for SimWideDeletes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x81
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block DataBlock
        buffer.write(self.data_block.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = SimWideDeletes_AgentData::read_from(buffer)?;
        // Block DataBlock
        let data_block = SimWideDeletes_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::SimWideDeletes(SimWideDeletes {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for SimulatorLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0c
        ])?;
        // Block SimulatorLoad
        buffer.write_f32::<LittleEndian>(self.simulator_load.time_dilation)?;
        buffer.write_i32::<LittleEndian>(self.simulator_load.agent_count)?;
        buffer.write_u8(self.simulator_load.can_accept_agents as u8)?;
        // Block AgentList
        buffer.write_u8(self.agent_list.len() as u8)?;
        for item in &self.agent_list {
            buffer.write_u32::<LittleEndian>(item.circuit_code)?;
            buffer.write_u8(item.x)?;
            buffer.write_u8(item.y)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimulatorLoad
        let simulator_load = SimulatorLoad_SimulatorLoad::read_from(buffer)?;
        // Block AgentList
        let mut agent_list = Vec::new();
        let _agent_list_count = buffer.read_u8()?;
        for _ in 0.._agent_list_count {
            agent_list.push(SimulatorLoad_AgentList::read_from(buffer)?);
        }
        Ok(MessageInstance::SimulatorLoad(SimulatorLoad {
            simulator_load: simulator_load,
            agent_list: agent_list,
        }))
    }
}

impl Message for SimulatorMapUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x05
        ])?;
        // Block MapData
        buffer.write_u32::<LittleEndian>(self.map_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MapData
        let map_data = SimulatorMapUpdate_MapData::read_from(buffer)?;
        Ok(MessageInstance::SimulatorMapUpdate(
            SimulatorMapUpdate { map_data: map_data },
        ))
    }
}

impl Message for SimulatorPresentAtLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0b
        ])?;
        // Block SimulatorPublicHostBlock
        buffer.write_u16::<LittleEndian>(self.simulator_public_host_block.port)?;
        buffer.write(&self.simulator_public_host_block.simulator_ip.octets())?;
        buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_y)?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write(&self.neighbor_block[i].ip.octets())?;
            buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port)?;
        }
        // Block SimulatorBlock
        buffer.write_u8(self.simulator_block.sim_name.len() as u8)?;
        buffer.write(&self.simulator_block.sim_name[..])?;
        buffer.write_u8(self.simulator_block.sim_access)?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags)?;
        buffer.write(self.simulator_block.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id)?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id)?;
        // Block TelehubBlock
        buffer.write_u8(self.telehub_block.len() as u8)?;
        for item in &self.telehub_block {
            buffer.write_u8(item.has_telehub as u8)?;
            buffer.write_f32::<LittleEndian>(item.telehub_pos.x)?;

            buffer.write_f32::<LittleEndian>(item.telehub_pos.y)?;

            buffer.write_f32::<LittleEndian>(item.telehub_pos.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimulatorPublicHostBlock
        let simulator_public_host_block =
            SimulatorPresentAtLocation_SimulatorPublicHostBlock::read_from(buffer)?;
        // Block NeighborBlock
        let neighbor_block = ArrayVec::from([
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
        ]);
        // Block SimulatorBlock
        let simulator_block = SimulatorPresentAtLocation_SimulatorBlock::read_from(buffer)?;
        // Block TelehubBlock
        let mut telehub_block = Vec::new();
        let _telehub_block_count = buffer.read_u8()?;
        for _ in 0.._telehub_block_count {
            telehub_block.push(SimulatorPresentAtLocation_TelehubBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::SimulatorPresentAtLocation(
            SimulatorPresentAtLocation {
                simulator_public_host_block: simulator_public_host_block,
                neighbor_block: neighbor_block,
                simulator_block: simulator_block,
                telehub_block: telehub_block,
            },
        ))
    }
}

impl Message for SimulatorReady {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x09
        ])?;
        // Block SimulatorBlock
        buffer.write_u8(self.simulator_block.sim_name.len() as u8)?;
        buffer.write(&self.simulator_block.sim_name[..])?;
        buffer.write_u8(self.simulator_block.sim_access)?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags)?;
        buffer.write(self.simulator_block.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id)?;
        buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id)?;
        // Block TelehubBlock
        buffer.write_u8(self.telehub_block.has_telehub as u8)?;
        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimulatorBlock
        let simulator_block = SimulatorReady_SimulatorBlock::read_from(buffer)?;
        // Block TelehubBlock
        let telehub_block = SimulatorReady_TelehubBlock::read_from(buffer)?;
        Ok(MessageInstance::SimulatorReady(SimulatorReady {
            simulator_block: simulator_block,
            telehub_block: telehub_block,
        }))
    }
}

impl Message for SimulatorSetMap {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x06
        ])?;
        // Block MapData
        buffer.write_u64::<LittleEndian>(self.map_data.region_handle)?;
        buffer.write_i32::<LittleEndian>(self.map_data.type_)?;
        buffer.write(self.map_data.map_image.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MapData
        let map_data = SimulatorSetMap_MapData::read_from(buffer)?;
        Ok(MessageInstance::SimulatorSetMap(
            SimulatorSetMap { map_data: map_data },
        ))
    }
}

impl Message for SimulatorShutdownRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0d
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::SimulatorShutdownRequest(
            SimulatorShutdownRequest {},
        ))
    }
}

impl Message for SimulatorViewerTimeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x96
        ])?;
        // Block TimeInfo
        buffer.write_u64::<LittleEndian>(self.time_info.usec_since_start)?;
        buffer.write_u32::<LittleEndian>(self.time_info.sec_per_day)?;
        buffer.write_u32::<LittleEndian>(self.time_info.sec_per_year)?;
        buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.x)?;

        buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.y)?;

        buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.z)?;
        buffer.write_f32::<LittleEndian>(self.time_info.sun_phase)?;
        buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.x)?;

        buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.y)?;

        buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TimeInfo
        let time_info = SimulatorViewerTimeMessage_TimeInfo::read_from(buffer)?;
        Ok(MessageInstance::SimulatorViewerTimeMessage(
            SimulatorViewerTimeMessage {
                time_info: time_info,
            },
        ))
    }
}

impl Message for SoundTrigger {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x1d])?;
        // Block SoundData
        buffer.write(self.sound_data.sound_id.as_bytes())?;
        buffer.write(self.sound_data.owner_id.as_bytes())?;
        buffer.write(self.sound_data.object_id.as_bytes())?;
        buffer.write(self.sound_data.parent_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.sound_data.handle)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.position.x)?;

        buffer.write_f32::<LittleEndian>(self.sound_data.position.y)?;

        buffer.write_f32::<LittleEndian>(self.sound_data.position.z)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.gain)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SoundData
        let sound_data = SoundTrigger_SoundData::read_from(buffer)?;
        Ok(MessageInstance::SoundTrigger(SoundTrigger {
            sound_data: sound_data,
        }))
    }
}

impl Message for StartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe5
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block ParcelData
        buffer.write(self.parcel_data.parcel_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.name.len() as u8)?;
        buffer.write(&self.parcel_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = StartAuction_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = StartAuction_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::StartAuction(StartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for StartGroupProposal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ProposalData
        buffer.write(self.proposal_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.proposal_data.quorum)?;
        buffer.write_f32::<LittleEndian>(self.proposal_data.majority)?;
        buffer.write_i32::<LittleEndian>(self.proposal_data.duration)?;
        buffer.write_u8(self.proposal_data.proposal_text.len() as u8)?;
        buffer.write(&self.proposal_data.proposal_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = StartGroupProposal_AgentData::read_from(buffer)?;
        // Block ProposalData
        let proposal_data = StartGroupProposal_ProposalData::read_from(buffer)?;
        Ok(MessageInstance::StartGroupProposal(StartGroupProposal {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for StartLure {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x46
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write_u8(self.info.lure_type)?;
        buffer.write_u8(self.info.message.len() as u8)?;
        buffer.write(&self.info.message[..])?;
        // Block TargetData
        buffer.write_u8(self.target_data.len() as u8)?;
        for item in &self.target_data {
            buffer.write(item.target_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = StartLure_AgentData::read_from(buffer)?;
        // Block Info
        let info = StartLure_Info::read_from(buffer)?;
        // Block TargetData
        let mut target_data = Vec::new();
        let _target_data_count = buffer.read_u8()?;
        for _ in 0.._target_data_count {
            target_data.push(StartLure_TargetData::read_from(buffer)?);
        }
        Ok(MessageInstance::StartLure(StartLure {
            agent_data: agent_data,
            info: info,
            target_data: target_data,
        }))
    }
}

impl Message for StartPingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x01])?;
        // Block PingID
        buffer.write_u8(self.ping_id.ping_id)?;
        buffer.write_u32::<LittleEndian>(self.ping_id.oldest_unacked)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block PingID
        let ping_id = StartPingCheck_PingID::read_from(buffer)?;
        Ok(MessageInstance::StartPingCheck(
            StartPingCheck { ping_id: ping_id },
        ))
    }
}

impl Message for StateSave {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block DataBlock
        buffer.write_u8(self.data_block.filename.len() as u8)?;
        buffer.write(&self.data_block.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = StateSave_AgentData::read_from(buffer)?;
        // Block DataBlock
        let data_block = StateSave_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::StateSave(StateSave {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for SubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x07
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::SubscribeLoad(SubscribeLoad {}))
    }
}

impl Message for SystemKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xa6
        ])?;
        // Block AgentInfo
        buffer.write_u8(self.agent_info.len() as u8)?;
        for item in &self.agent_info {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = buffer.read_u8()?;
        for _ in 0.._agent_info_count {
            agent_info.push(SystemKickUser_AgentInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::SystemKickUser(SystemKickUser {
            agent_info: agent_info,
        }))
    }
}

impl Message for SystemMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x94
        ])?;
        // Block MethodData
        buffer.write_u8(self.method_data.method.len() as u8)?;
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        buffer.write(&self.method_data.digest)?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write_u8(item.parameter.len() as u8)?;
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block MethodData
        let method_data = SystemMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(SystemMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::SystemMessage(SystemMessage {
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for TallyVotes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x6d
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::TallyVotes(TallyVotes {}))
    }
}

impl Message for TelehubInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x0a
        ])?;
        // Block TelehubBlock
        buffer.write(self.telehub_block.object_id.as_bytes())?;
        buffer.write_u8(self.telehub_block.object_name.len() as u8)?;
        buffer.write(&self.telehub_block.object_name[..])?;
        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x)?;

        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y)?;

        buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z)?;
        let norm_telehub_rot = if self.telehub_block.telehub_rot.scalar() >= 0. {
            self.telehub_block.telehub_rot.norm()
        } else {
            -self.telehub_block.telehub_rot.norm()
        };

        buffer
            .write_f32::<LittleEndian>(self.telehub_block.telehub_rot.coords[0] / norm_telehub_rot)?;

        buffer
            .write_f32::<LittleEndian>(self.telehub_block.telehub_rot.coords[1] / norm_telehub_rot)?;

        buffer
            .write_f32::<LittleEndian>(self.telehub_block.telehub_rot.coords[2] / norm_telehub_rot)?;
        // Block SpawnPointBlock
        buffer.write_u8(self.spawn_point_block.len() as u8)?;
        for item in &self.spawn_point_block {
            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.x)?;

            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.y)?;

            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TelehubBlock
        let telehub_block = TelehubInfo_TelehubBlock::read_from(buffer)?;
        // Block SpawnPointBlock
        let mut spawn_point_block = Vec::new();
        let _spawn_point_block_count = buffer.read_u8()?;
        for _ in 0.._spawn_point_block_count {
            spawn_point_block.push(TelehubInfo_SpawnPointBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::TelehubInfo(TelehubInfo {
            telehub_block: telehub_block,
            spawn_point_block: spawn_point_block,
        }))
    }
}

impl Message for TeleportCancel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x48
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportCancel_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportCancel(
            TeleportCancel { info: info },
        ))
    }
}

impl Message for TeleportFailed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4a
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u8(self.info.reason.len() as u8)?;
        buffer.write(&self.info.reason[..])?;
        // Block AlertInfo
        buffer.write_u8(self.alert_info.len() as u8)?;
        for item in &self.alert_info {
            buffer.write_u8(item.message.len() as u8)?;
            buffer.write(&item.message[..])?;
            buffer.write_u8(item.extra_params.len() as u8)?;
            buffer.write(&item.extra_params[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportFailed_Info::read_from(buffer)?;
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = buffer.read_u8()?;
        for _ in 0.._alert_info_count {
            alert_info.push(TeleportFailed_AlertInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::TeleportFailed(TeleportFailed {
            info: info,
            alert_info: alert_info,
        }))
    }
}

impl Message for TeleportFinish {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x45
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.location_id)?;
        buffer.write(&self.info.sim_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.info.sim_port)?;
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write_u16::<LittleEndian>(self.info.seed_capability.len() as u16)?;
        buffer.write(&self.info.seed_capability[..])?;
        buffer.write_u8(self.info.sim_access)?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        buffer.write_u32::<LittleEndian>(self.info.region_size_x)?;
        buffer.write_u32::<LittleEndian>(self.info.region_size_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportFinish_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportFinish(
            TeleportFinish { info: info },
        ))
    }
}

impl Message for TeleportLandingStatusChanged {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x93
        ])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(self.region_data.region_handle)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block RegionData
        let region_data = TeleportLandingStatusChanged_RegionData::read_from(buffer)?;
        Ok(MessageInstance::TeleportLandingStatusChanged(
            TeleportLandingStatusChanged {
                region_data: region_data,
            },
        ))
    }
}

impl Message for TeleportLandmarkRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x41
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        buffer.write(self.info.landmark_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportLandmarkRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLandmarkRequest(
            TeleportLandmarkRequest { info: info },
        ))
    }
}

impl Message for TeleportLocal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x40
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.location_id)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;

        buffer.write_f32::<LittleEndian>(self.info.position.y)?;

        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportLocal_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLocal(TeleportLocal { info: info }))
    }
}

impl Message for TeleportLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;

        buffer.write_f32::<LittleEndian>(self.info.position.y)?;

        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = TeleportLocationRequest_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportLocationRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLocationRequest(
            TeleportLocationRequest {
                agent_data: agent_data,
                info: info,
            },
        ))
    }
}

impl Message for TeleportLureRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x47
        ])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        buffer.write(self.info.lure_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportLureRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLureRequest(
            TeleportLureRequest { info: info },
        ))
    }
}

impl Message for TeleportProgress {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x42
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Info
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        buffer.write_u8(self.info.message.len() as u8)?;
        buffer.write(&self.info.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = TeleportProgress_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportProgress_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportProgress(TeleportProgress {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for TeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x3e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write(self.info.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;

        buffer.write_f32::<LittleEndian>(self.info.position.y)?;

        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;

        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = TeleportRequest_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportRequest(TeleportRequest {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for TeleportStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x49
        ])?;
        // Block Info
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block Info
        let info = TeleportStart_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportStart(TeleportStart { info: info }))
    }
}

impl Message for TerminateFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x2c
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ExBlock
        buffer.write(self.ex_block.other_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = TerminateFriendship_AgentData::read_from(buffer)?;
        // Block ExBlock
        let ex_block = TerminateFriendship_ExBlock::read_from(buffer)?;
        Ok(MessageInstance::TerminateFriendship(TerminateFriendship {
            agent_data: agent_data,
            ex_block: ex_block,
        }))
    }
}

impl Message for TestMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x01
        ])?;
        // Block TestBlock1
        buffer.write_u32::<LittleEndian>(self.test_block1.test1)?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test0)?;
            buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test1)?;
            buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test2)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TestBlock1
        let test_block1 = TestMessage_TestBlock1::read_from(buffer)?;
        // Block NeighborBlock
        let neighbor_block = ArrayVec::from([
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
        ]);
        Ok(MessageInstance::TestMessage(TestMessage {
            test_block1: test_block1,
            neighbor_block: neighbor_block,
        }))
    }
}

impl Message for TrackAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x82
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TargetData
        buffer.write(self.target_data.prey_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = TrackAgent_AgentData::read_from(buffer)?;
        // Block TargetData
        let target_data = TrackAgent_TargetData::read_from(buffer)?;
        Ok(MessageInstance::TrackAgent(TrackAgent {
            agent_data: agent_data,
            target_data: target_data,
        }))
    }
}

impl Message for TransferAbort {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9b
        ])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransferInfo
        let transfer_info = TransferAbort_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferAbort(TransferAbort {
            transfer_info: transfer_info,
        }))
    }
}

impl Message for TransferInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x9a
        ])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type)?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.target_type)?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.status)?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.size)?;
        buffer.write_u16::<LittleEndian>(self.transfer_info.params.len() as u16)?;
        buffer.write(&self.transfer_info.params[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransferInfo
        let transfer_info = TransferInfo_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferInfo(TransferInfo {
            transfer_info: transfer_info,
        }))
    }
}

impl Message for TransferInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x27
        ])?;
        // Block InfoBlock
        buffer.write(self.info_block.source_id.as_bytes())?;
        buffer.write(self.info_block.dest_id.as_bytes())?;
        buffer.write(self.info_block.transaction_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u8(self.inventory_block.len() as u8)?;
        for item in &self.inventory_block {
            buffer.write(item.inventory_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block InfoBlock
        let info_block = TransferInventory_InfoBlock::read_from(buffer)?;
        // Block InventoryBlock
        let mut inventory_block = Vec::new();
        let _inventory_block_count = buffer.read_u8()?;
        for _ in 0.._inventory_block_count {
            inventory_block.push(TransferInventory_InventoryBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::TransferInventory(TransferInventory {
            info_block: info_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for TransferInventoryAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x28
        ])?;
        // Block InfoBlock
        buffer.write(self.info_block.transaction_id.as_bytes())?;
        buffer.write(self.info_block.inventory_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block InfoBlock
        let info_block = TransferInventoryAck_InfoBlock::read_from(buffer)?;
        Ok(MessageInstance::TransferInventoryAck(
            TransferInventoryAck {
                info_block: info_block,
            },
        ))
    }
}

impl Message for TransferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0x11])?;
        // Block TransferData
        buffer.write(self.transfer_data.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.transfer_data.channel_type)?;
        buffer.write_i32::<LittleEndian>(self.transfer_data.packet)?;
        buffer.write_i32::<LittleEndian>(self.transfer_data.status)?;
        buffer.write_u16::<LittleEndian>(self.transfer_data.data.len() as u16)?;
        buffer.write(&self.transfer_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransferData
        let transfer_data = TransferPacket_TransferData::read_from(buffer)?;
        Ok(MessageInstance::TransferPacket(TransferPacket {
            transfer_data: transfer_data,
        }))
    }
}

impl Message for TransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x99
        ])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type)?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.source_type)?;
        buffer.write_f32::<LittleEndian>(self.transfer_info.priority)?;
        buffer.write_u16::<LittleEndian>(self.transfer_info.params.len() as u16)?;
        buffer.write(&self.transfer_info.params[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block TransferInfo
        let transfer_info = TransferRequest_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferRequest(TransferRequest {
            transfer_info: transfer_info,
        }))
    }
}

impl Message for UUIDGroupNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xee
        ])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
            buffer.write_u8(item.group_name.len() as u8)?;
            buffer.write(&item.group_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDGroupNameReply_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDGroupNameReply(UUIDGroupNameReply {
            uuid_name_block: uuid_name_block,
        }))
    }
}

impl Message for UUIDGroupNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xed
        ])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDGroupNameRequest_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDGroupNameRequest(
            UUIDGroupNameRequest {
                uuid_name_block: uuid_name_block,
            },
        ))
    }
}

impl Message for UUIDNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xec
        ])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
            buffer.write_u8(item.first_name.len() as u8)?;
            buffer.write(&item.first_name[..])?;
            buffer.write_u8(item.last_name.len() as u8)?;
            buffer.write(&item.last_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDNameReply_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDNameReply(UUIDNameReply {
            uuid_name_block: uuid_name_block,
        }))
    }
}

impl Message for UUIDNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xeb
        ])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDNameRequest_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDNameRequest(UUIDNameRequest {
            uuid_name_block: uuid_name_block,
        }))
    }
}

impl Message for Undo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = Undo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(Undo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::Undo(Undo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for UndoLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x4d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UndoLand_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UndoLand(UndoLand {
            agent_data: agent_data,
        }))
    }
}

impl Message for UnsubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x08
        ])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        Ok(MessageInstance::UnsubscribeLoad(UnsubscribeLoad {}))
    }
}

impl Message for UpdateAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x4b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AttachmentBlock
        buffer.write_u8(self.attachment_block.attachment_point)?;
        // Block OperationData
        buffer.write_u8(self.operation_data.add_item as u8)?;
        buffer.write_u8(self.operation_data.use_existing_asset as u8)?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask)?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.asset_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price)?;
        buffer.write_u8(self.inventory_data.name.len() as u8)?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write_u8(self.inventory_data.description.len() as u8)?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateAttachment_AgentData::read_from(buffer)?;
        // Block AttachmentBlock
        let attachment_block = UpdateAttachment_AttachmentBlock::read_from(buffer)?;
        // Block OperationData
        let operation_data = UpdateAttachment_OperationData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = UpdateAttachment_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::UpdateAttachment(UpdateAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
            operation_data: operation_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateCreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0b
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u8(self.agent_data.sim_approved as u8)?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateCreateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(UpdateCreateInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateCreateInventoryItem(
            UpdateCreateInventoryItem {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for UpdateGroupInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x55
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.group_data.charter.len() as u16)?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.membership_fee)?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateGroupInfo_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = UpdateGroupInfo_GroupData::read_from(buffer)?;
        Ok(MessageInstance::UpdateGroupInfo(UpdateGroupInfo {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for UpdateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x12
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(UpdateInventoryFolder_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateInventoryFolder(
            UpdateInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for UpdateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x0a
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.transaction_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.name.len() as u8)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.description.len() as u8)?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(UpdateInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateInventoryItem(UpdateInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x07
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write(self.mute_data.mute_id.as_bytes())?;
        buffer.write_u8(self.mute_data.mute_name.len() as u8)?;
        buffer.write(&self.mute_data.mute_name[..])?;
        buffer.write_i32::<LittleEndian>(self.mute_data.mute_type)?;
        buffer.write_u32::<LittleEndian>(self.mute_data.mute_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateMuteListEntry_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = UpdateMuteListEntry_MuteData::read_from(buffer)?;
        Ok(MessageInstance::UpdateMuteListEntry(UpdateMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for UpdateParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xdd
        ])?;
        // Block ParcelData
        buffer.write(self.parcel_data.parcel_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.parcel_data.region_handle)?;
        buffer.write(self.parcel_data.owner_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.group_owned as u8)?;
        buffer.write_u8(self.parcel_data.status)?;
        buffer.write_u8(self.parcel_data.name.len() as u8)?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write_u8(self.parcel_data.description.len() as u8)?;
        buffer.write(&self.parcel_data.description[..])?;
        buffer.write_u8(self.parcel_data.music_url.len() as u8)?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.region_x)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.region_y)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.actual_area)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.billable_area)?;
        buffer.write_u8(self.parcel_data.show_dir as u8)?;
        buffer.write_u8(self.parcel_data.is_for_sale as u8)?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y)?;

        buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price)?;
        buffer.write(self.parcel_data.authorized_buyer_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.allow_publish as u8)?;
        buffer.write_u8(self.parcel_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ParcelData
        let parcel_data = UpdateParcel_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::UpdateParcel(UpdateParcel {
            parcel_data: parcel_data,
        }))
    }
}

impl Message for UpdateSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x11
        ])?;
        // Block SimulatorInfo
        buffer.write(self.simulator_info.region_id.as_bytes())?;
        buffer.write_u8(self.simulator_info.sim_name.len() as u8)?;
        buffer.write(&self.simulator_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.simulator_info.estate_id)?;
        buffer.write_u8(self.simulator_info.sim_access)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block SimulatorInfo
        let simulator_info = UpdateSimulator_SimulatorInfo::read_from(buffer)?;
        Ok(MessageInstance::UpdateSimulator(UpdateSimulator {
            simulator_info: simulator_info,
        }))
    }
}

impl Message for UpdateTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x1e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block UpdateData
        buffer.write_u32::<LittleEndian>(self.update_data.local_id)?;
        buffer.write_u8(self.update_data.key)?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask)?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price)?;
        buffer.write_u8(self.inventory_data.name.len() as u8)?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write_u8(self.inventory_data.description.len() as u8)?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateTaskInventory_AgentData::read_from(buffer)?;
        // Block UpdateData
        let update_data = UpdateTaskInventory_UpdateData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = UpdateTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::UpdateTaskInventory(UpdateTaskInventory {
            agent_data: agent_data,
            update_data: update_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateUserInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x91
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block UserData
        buffer.write_u8(self.user_data.im_via_e_mail as u8)?;
        buffer.write_u8(self.user_data.directory_visibility.len() as u8)?;
        buffer.write(&self.user_data.directory_visibility[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UpdateUserInfo_AgentData::read_from(buffer)?;
        // Block UserData
        let user_data = UpdateUserInfo_UserData::read_from(buffer)?;
        Ok(MessageInstance::UpdateUserInfo(UpdateUserInfo {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for UseCachedMuteList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x3f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UseCachedMuteList_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UseCachedMuteList(UseCachedMuteList {
            agent_data: agent_data,
        }))
    }
}

impl Message for UseCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x03
        ])?;
        // Block CircuitCode
        buffer.write_u32::<LittleEndian>(self.circuit_code.code)?;
        buffer.write(self.circuit_code.session_id.as_bytes())?;
        buffer.write(self.circuit_code.id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block CircuitCode
        let circuit_code = UseCircuitCode_CircuitCode::read_from(buffer)?;
        Ok(MessageInstance::UseCircuitCode(UseCircuitCode {
            circuit_code: circuit_code,
        }))
    }
}

impl Message for UserInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x90
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block UserData
        buffer.write_u8(self.user_data.im_via_e_mail as u8)?;
        buffer.write_u8(self.user_data.directory_visibility.len() as u8)?;
        buffer.write(&self.user_data.directory_visibility[..])?;
        buffer.write_u16::<LittleEndian>(self.user_data.e_mail.len() as u16)?;
        buffer.write(&self.user_data.e_mail[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UserInfoReply_AgentData::read_from(buffer)?;
        // Block UserData
        let user_data = UserInfoReply_UserData::read_from(buffer)?;
        Ok(MessageInstance::UserInfoReply(UserInfoReply {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for UserInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x01, 0x8f
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UserInfoRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UserInfoRequest(UserInfoRequest {
            agent_data: agent_data,
        }))
    }
}

impl Message for UserReport {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x85
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ReportData
        buffer.write_u8(self.report_data.report_type)?;
        buffer.write_u8(self.report_data.category)?;
        buffer.write_f32::<LittleEndian>(self.report_data.position.x)?;

        buffer.write_f32::<LittleEndian>(self.report_data.position.y)?;

        buffer.write_f32::<LittleEndian>(self.report_data.position.z)?;
        buffer.write_u8(self.report_data.check_flags)?;
        buffer.write(self.report_data.screenshot_id.as_bytes())?;
        buffer.write(self.report_data.object_id.as_bytes())?;
        buffer.write(self.report_data.abuser_id.as_bytes())?;
        buffer.write_u8(self.report_data.abuse_region_name.len() as u8)?;
        buffer.write(&self.report_data.abuse_region_name[..])?;
        buffer.write(self.report_data.abuse_region_id.as_bytes())?;
        buffer.write_u8(self.report_data.summary.len() as u8)?;
        buffer.write(&self.report_data.summary[..])?;
        buffer.write_u16::<LittleEndian>(self.report_data.details.len() as u16)?;
        buffer.write(&self.report_data.details[..])?;
        buffer.write_u8(self.report_data.version_string.len() as u8)?;
        buffer.write(&self.report_data.version_string[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = UserReport_AgentData::read_from(buffer)?;
        // Block ReportData
        let report_data = UserReport_ReportData::read_from(buffer)?;
        Ok(MessageInstance::UserReport(UserReport {
            agent_data: agent_data,
            report_data: report_data,
        }))
    }
}

impl Message for UserReportInternal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x15
        ])?;
        // Block ReportData
        buffer.write_u8(self.report_data.report_type)?;
        buffer.write_u8(self.report_data.category)?;
        buffer.write(self.report_data.reporter_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.x)?;

        buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.y)?;

        buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.z)?;
        buffer.write_f32::<LittleEndian>(self.report_data.agent_position.x)?;

        buffer.write_f32::<LittleEndian>(self.report_data.agent_position.y)?;

        buffer.write_f32::<LittleEndian>(self.report_data.agent_position.z)?;
        buffer.write(self.report_data.screenshot_id.as_bytes())?;
        buffer.write(self.report_data.object_id.as_bytes())?;
        buffer.write(self.report_data.owner_id.as_bytes())?;
        buffer.write(self.report_data.last_owner_id.as_bytes())?;
        buffer.write(self.report_data.creator_id.as_bytes())?;
        buffer.write(self.report_data.region_id.as_bytes())?;
        buffer.write(self.report_data.abuser_id.as_bytes())?;
        buffer.write_u8(self.report_data.abuse_region_name.len() as u8)?;
        buffer.write(&self.report_data.abuse_region_name[..])?;
        buffer.write(self.report_data.abuse_region_id.as_bytes())?;
        buffer.write_u8(self.report_data.summary.len() as u8)?;
        buffer.write(&self.report_data.summary[..])?;
        buffer.write_u16::<LittleEndian>(self.report_data.details.len() as u16)?;
        buffer.write(&self.report_data.details[..])?;
        buffer.write_u8(self.report_data.version_string.len() as u8)?;
        buffer.write(&self.report_data.version_string[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block ReportData
        let report_data = UserReportInternal_ReportData::read_from(buffer)?;
        Ok(MessageInstance::UserReportInternal(UserReportInternal {
            report_data: report_data,
        }))
    }
}

impl Message for VelocityInterpolateOff {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7e
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = VelocityInterpolateOff_AgentData::read_from(buffer)?;
        Ok(MessageInstance::VelocityInterpolateOff(
            VelocityInterpolateOff {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for VelocityInterpolateOn {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x7d
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = VelocityInterpolateOn_AgentData::read_from(buffer)?;
        Ok(MessageInstance::VelocityInterpolateOn(
            VelocityInterpolateOn {
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for ViewerEffect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[0xff, 0x11])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Effect
        buffer.write_u8(self.effect.len() as u8)?;
        for item in &self.effect {
            buffer.write(item.id.as_bytes())?;
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write_u8(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.duration)?;
            buffer.write(&item.color)?;
            buffer.write_u8(item.type_data.len() as u8)?;
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ViewerEffect_AgentData::read_from(buffer)?;
        // Block Effect
        let mut effect = Vec::new();
        let _effect_count = buffer.read_u8()?;
        for _ in 0.._effect_count {
            effect.push(ViewerEffect_Effect::read_from(buffer)?);
        }
        Ok(MessageInstance::ViewerEffect(ViewerEffect {
            agent_data: agent_data,
            effect: effect,
        }))
    }
}

impl Message for ViewerFrozenMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x89
        ])?;
        // Block FrozenData
        buffer.write_u8(self.frozen_data.data as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block FrozenData
        let frozen_data = ViewerFrozenMessage_FrozenData::read_from(buffer)?;
        Ok(MessageInstance::ViewerFrozenMessage(ViewerFrozenMessage {
            frozen_data: frozen_data,
        }))
    }
}

impl Message for ViewerStartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0xe4
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ViewerStartAuction_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ViewerStartAuction_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ViewerStartAuction(ViewerStartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ViewerStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where W: Write {
        // Write the message number.
        buffer.write(&[
            0xff, 0xff, 0x00, 0x83
        ])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(&self.agent_data.ip.octets())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.start_time)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.run_time)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.sim_fps)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.fps)?;
        buffer.write_u8(self.agent_data.agents_in_view)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ping)?;
        buffer.write_f64::<LittleEndian>(self.agent_data.meters_traveled)?;
        buffer.write_i32::<LittleEndian>(self.agent_data.regions_visited)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.sys_ram)?;
        buffer.write_u8(self.agent_data.sys_os.len() as u8)?;
        buffer.write(&self.agent_data.sys_os[..])?;
        buffer.write_u8(self.agent_data.sys_cpu.len() as u8)?;
        buffer.write(&self.agent_data.sys_cpu[..])?;
        buffer.write_u8(self.agent_data.sys_gpu.len() as u8)?;
        buffer.write(&self.agent_data.sys_gpu[..])?;
        // Block DownloadTotals
        buffer.write_u32::<LittleEndian>(self.download_totals.world)?;
        buffer.write_u32::<LittleEndian>(self.download_totals.objects)?;
        buffer.write_u32::<LittleEndian>(self.download_totals.textures)?;
        // Block NetStats
        for i in 0..2 {
            buffer.write_u32::<LittleEndian>(self.net_stats[i].bytes)?;
            buffer.write_u32::<LittleEndian>(self.net_stats[i].packets)?;
            buffer.write_u32::<LittleEndian>(self.net_stats[i].compressed)?;
            buffer.write_u32::<LittleEndian>(self.net_stats[i].savings)?;
        }
        // Block FailStats
        buffer.write_u32::<LittleEndian>(self.fail_stats.send_packet)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.dropped)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.resent)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.failed_resends)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.off_circuit)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.invalid)?;
        // Block MiscStats
        buffer.write_u8(self.misc_stats.len() as u8)?;
        for item in &self.misc_stats {
            buffer.write_u32::<LittleEndian>(item.type_)?;
            buffer.write_f64::<LittleEndian>(item.value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadError>
    where R: Read {
        // Block AgentData
        let agent_data = ViewerStats_AgentData::read_from(buffer)?;
        // Block DownloadTotals
        let download_totals = ViewerStats_DownloadTotals::read_from(buffer)?;
        // Block NetStats
        let net_stats = ArrayVec::from([
            ViewerStats_NetStats::read_from(buffer)?,
            ViewerStats_NetStats::read_from(buffer)?,
        ]);
        // Block FailStats
        let fail_stats = ViewerStats_FailStats::read_from(buffer)?;
        // Block MiscStats
        let mut misc_stats = Vec::new();
        let _misc_stats_count = buffer.read_u8()?;
        for _ in 0.._misc_stats_count {
            misc_stats.push(ViewerStats_MiscStats::read_from(buffer)?);
        }
        Ok(MessageInstance::ViewerStats(ViewerStats {
            agent_data: agent_data,
            download_totals: download_totals,
            net_stats: net_stats,
            fail_stats: fail_stats,
            misc_stats: misc_stats,
        }))
    }
}
