#![allow(non_snake_case)]
#![allow(non_camel_case_types)]

///
/// THIS FILE WAS AUTOGENERATED.
/// DON'T EDIT MANUALLY!
/// If you want to change the file, edit the generator script `generate/generate.rb`.
///

use {Vector3, Vector4, Quaternion, UnitQuaternion, Ip4Addr, IpPort, Uuid, WriteMessageResult, Message};
use errors::ReadMessageError;
use std::io::{Read, Write};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
pub fn read_message<R: ?Sized>(buffer: &mut R, message_num: u32) -> Result<MessageInstance, ReadMessageError>
where
    R: Read,
{
    match message_num {
        0x0100ffff => return TestMessage::read_from(buffer),
        0xFBffffff => return PacketAck::read_from(buffer),
        0xFCffffff => return OpenCircuit::read_from(buffer),
        0xFDffffff => return CloseCircuit::read_from(buffer),
        0x00000001 => return StartPingCheck::read_from(buffer),
        0x00000002 => return CompletePingCheck::read_from(buffer),
        0x0200ffff => return AddCircuitCode::read_from(buffer),
        0x0300ffff => return UseCircuitCode::read_from(buffer),
        0x00000003 => return NeighborList::read_from(buffer),
        0x0400ffff => return AvatarTextureUpdate::read_from(buffer),
        0x0500ffff => return SimulatorMapUpdate::read_from(buffer),
        0x0600ffff => return SimulatorSetMap::read_from(buffer),
        0x0700ffff => return SubscribeLoad::read_from(buffer),
        0x0800ffff => return UnsubscribeLoad::read_from(buffer),
        0x0900ffff => return SimulatorReady::read_from(buffer),
        0x0a00ffff => return TelehubInfo::read_from(buffer),
        0x0b00ffff => return SimulatorPresentAtLocation::read_from(buffer),
        0x0c00ffff => return SimulatorLoad::read_from(buffer),
        0x0d00ffff => return SimulatorShutdownRequest::read_from(buffer),
        0x0e00ffff => return RegionPresenceRequestByRegionID::read_from(buffer),
        0x0f00ffff => return RegionPresenceRequestByHandle::read_from(buffer),
        0x1000ffff => return RegionPresenceResponse::read_from(buffer),
        0x1100ffff => return UpdateSimulator::read_from(buffer),
        0x1200ffff => return LogDwellTime::read_from(buffer),
        0x1300ffff => return FeatureDisabled::read_from(buffer),
        0x1400ffff => return LogFailedMoneyTransaction::read_from(buffer),
        0x1500ffff => return UserReportInternal::read_from(buffer),
        0x1600ffff => return SetSimStatusInDatabase::read_from(buffer),
        0x1700ffff => return SetSimPresenceInDatabase::read_from(buffer),
        0x1800ffff => return EconomyDataRequest::read_from(buffer),
        0x1900ffff => return EconomyData::read_from(buffer),
        0x1a00ffff => return AvatarPickerRequest::read_from(buffer),
        0x1b00ffff => return AvatarPickerRequestBackend::read_from(buffer),
        0x1c00ffff => return AvatarPickerReply::read_from(buffer),
        0x1d00ffff => return PlacesQuery::read_from(buffer),
        0x1e00ffff => return PlacesReply::read_from(buffer),
        0x1f00ffff => return DirFindQuery::read_from(buffer),
        0x2000ffff => return DirFindQueryBackend::read_from(buffer),
        0x2100ffff => return DirPlacesQuery::read_from(buffer),
        0x2200ffff => return DirPlacesQueryBackend::read_from(buffer),
        0x2300ffff => return DirPlacesReply::read_from(buffer),
        0x2400ffff => return DirPeopleReply::read_from(buffer),
        0x2500ffff => return DirEventsReply::read_from(buffer),
        0x2600ffff => return DirGroupsReply::read_from(buffer),
        0x2700ffff => return DirClassifiedQuery::read_from(buffer),
        0x2800ffff => return DirClassifiedQueryBackend::read_from(buffer),
        0x2900ffff => return DirClassifiedReply::read_from(buffer),
        0x2a00ffff => return AvatarClassifiedReply::read_from(buffer),
        0x2b00ffff => return ClassifiedInfoRequest::read_from(buffer),
        0x2c00ffff => return ClassifiedInfoReply::read_from(buffer),
        0x2d00ffff => return ClassifiedInfoUpdate::read_from(buffer),
        0x2e00ffff => return ClassifiedDelete::read_from(buffer),
        0x2f00ffff => return ClassifiedGodDelete::read_from(buffer),
        0x3000ffff => return DirLandQuery::read_from(buffer),
        0x3100ffff => return DirLandQueryBackend::read_from(buffer),
        0x3200ffff => return DirLandReply::read_from(buffer),
        0x3300ffff => return DirPopularQuery::read_from(buffer),
        0x3400ffff => return DirPopularQueryBackend::read_from(buffer),
        0x3500ffff => return DirPopularReply::read_from(buffer),
        0x3600ffff => return ParcelInfoRequest::read_from(buffer),
        0x3700ffff => return ParcelInfoReply::read_from(buffer),
        0x3800ffff => return ParcelObjectOwnersRequest::read_from(buffer),
        0x3900ffff => return ParcelObjectOwnersReply::read_from(buffer),
        0x3a00ffff => return GroupNoticesListRequest::read_from(buffer),
        0x3b00ffff => return GroupNoticesListReply::read_from(buffer),
        0x3c00ffff => return GroupNoticeRequest::read_from(buffer),
        0x3d00ffff => return GroupNoticeAdd::read_from(buffer),
        0x3e00ffff => return TeleportRequest::read_from(buffer),
        0x3f00ffff => return TeleportLocationRequest::read_from(buffer),
        0x4000ffff => return TeleportLocal::read_from(buffer),
        0x4100ffff => return TeleportLandmarkRequest::read_from(buffer),
        0x4200ffff => return TeleportProgress::read_from(buffer),
        0x4300ffff => return DataHomeLocationRequest::read_from(buffer),
        0x4400ffff => return DataHomeLocationReply::read_from(buffer),
        0x4500ffff => return TeleportFinish::read_from(buffer),
        0x4600ffff => return StartLure::read_from(buffer),
        0x4700ffff => return TeleportLureRequest::read_from(buffer),
        0x4800ffff => return TeleportCancel::read_from(buffer),
        0x4900ffff => return TeleportStart::read_from(buffer),
        0x4a00ffff => return TeleportFailed::read_from(buffer),
        0x4b00ffff => return Undo::read_from(buffer),
        0x4c00ffff => return Redo::read_from(buffer),
        0x4d00ffff => return UndoLand::read_from(buffer),
        0x4e00ffff => return AgentPause::read_from(buffer),
        0x4f00ffff => return AgentResume::read_from(buffer),
        0x00000004 => return AgentUpdate::read_from(buffer),
        0x5000ffff => return ChatFromViewer::read_from(buffer),
        0x5100ffff => return AgentThrottle::read_from(buffer),
        0x5200ffff => return AgentFOV::read_from(buffer),
        0x5300ffff => return AgentHeightWidth::read_from(buffer),
        0x5400ffff => return AgentSetAppearance::read_from(buffer),
        0x00000005 => return AgentAnimation::read_from(buffer),
        0x00000006 => return AgentRequestSit::read_from(buffer),
        0x00000007 => return AgentSit::read_from(buffer),
        0x5500ffff => return AgentQuitCopy::read_from(buffer),
        0x00000008 => return RequestImage::read_from(buffer),
        0x5600ffff => return ImageNotInDatabase::read_from(buffer),
        0x5700ffff => return RebakeAvatarTextures::read_from(buffer),
        0x5800ffff => return SetAlwaysRun::read_from(buffer),
        0x000001ff => return ObjectAdd::read_from(buffer),
        0x5900ffff => return ObjectDelete::read_from(buffer),
        0x5a00ffff => return ObjectDuplicate::read_from(buffer),
        0x5b00ffff => return ObjectDuplicateOnRay::read_from(buffer),
        0x000002ff => return MultipleObjectUpdate::read_from(buffer),
        0x000003ff => return RequestMultipleObjects::read_from(buffer),
        0x000004ff => return ObjectPosition::read_from(buffer),
        0x5c00ffff => return ObjectScale::read_from(buffer),
        0x5d00ffff => return ObjectRotation::read_from(buffer),
        0x5e00ffff => return ObjectFlagUpdate::read_from(buffer),
        0x5f00ffff => return ObjectClickAction::read_from(buffer),
        0x6000ffff => return ObjectImage::read_from(buffer),
        0x6100ffff => return ObjectMaterial::read_from(buffer),
        0x6200ffff => return ObjectShape::read_from(buffer),
        0x6300ffff => return ObjectExtraParams::read_from(buffer),
        0x6400ffff => return ObjectOwner::read_from(buffer),
        0x6500ffff => return ObjectGroup::read_from(buffer),
        0x6600ffff => return ObjectBuy::read_from(buffer),
        0x6700ffff => return BuyObjectInventory::read_from(buffer),
        0x6800ffff => return DerezContainer::read_from(buffer),
        0x6900ffff => return ObjectPermissions::read_from(buffer),
        0x6a00ffff => return ObjectSaleInfo::read_from(buffer),
        0x6b00ffff => return ObjectName::read_from(buffer),
        0x6c00ffff => return ObjectDescription::read_from(buffer),
        0x6d00ffff => return ObjectCategory::read_from(buffer),
        0x6e00ffff => return ObjectSelect::read_from(buffer),
        0x6f00ffff => return ObjectDeselect::read_from(buffer),
        0x7000ffff => return ObjectAttach::read_from(buffer),
        0x7100ffff => return ObjectDetach::read_from(buffer),
        0x7200ffff => return ObjectDrop::read_from(buffer),
        0x7300ffff => return ObjectLink::read_from(buffer),
        0x7400ffff => return ObjectDelink::read_from(buffer),
        0x7500ffff => return ObjectGrab::read_from(buffer),
        0x7600ffff => return ObjectGrabUpdate::read_from(buffer),
        0x7700ffff => return ObjectDeGrab::read_from(buffer),
        0x7800ffff => return ObjectSpinStart::read_from(buffer),
        0x7900ffff => return ObjectSpinUpdate::read_from(buffer),
        0x7a00ffff => return ObjectSpinStop::read_from(buffer),
        0x7b00ffff => return ObjectExportSelected::read_from(buffer),
        0x7c00ffff => return ModifyLand::read_from(buffer),
        0x7d00ffff => return VelocityInterpolateOn::read_from(buffer),
        0x7e00ffff => return VelocityInterpolateOff::read_from(buffer),
        0x7f00ffff => return StateSave::read_from(buffer),
        0x8000ffff => return ReportAutosaveCrash::read_from(buffer),
        0x8100ffff => return SimWideDeletes::read_from(buffer),
        0x000005ff => return RequestObjectPropertiesFamily::read_from(buffer),
        0x8200ffff => return TrackAgent::read_from(buffer),
        0x8300ffff => return ViewerStats::read_from(buffer),
        0x8400ffff => return ScriptAnswerYes::read_from(buffer),
        0x8500ffff => return UserReport::read_from(buffer),
        0x8600ffff => return AlertMessage::read_from(buffer),
        0x8700ffff => return AgentAlertMessage::read_from(buffer),
        0x8800ffff => return MeanCollisionAlert::read_from(buffer),
        0x8900ffff => return ViewerFrozenMessage::read_from(buffer),
        0x8a00ffff => return HealthMessage::read_from(buffer),
        0x8b00ffff => return ChatFromSimulator::read_from(buffer),
        0x8c00ffff => return SimStats::read_from(buffer),
        0x8d00ffff => return RequestRegionInfo::read_from(buffer),
        0x8e00ffff => return RegionInfo::read_from(buffer),
        0x8f00ffff => return GodUpdateRegionInfo::read_from(buffer),
        0x9000ffff => return NearestLandingRegionRequest::read_from(buffer),
        0x9100ffff => return NearestLandingRegionReply::read_from(buffer),
        0x9200ffff => return NearestLandingRegionUpdated::read_from(buffer),
        0x9300ffff => return TeleportLandingStatusChanged::read_from(buffer),
        0x9400ffff => return RegionHandshake::read_from(buffer),
        0x9500ffff => return RegionHandshakeReply::read_from(buffer),
        0x000006ff => return CoarseLocationUpdate::read_from(buffer),
        0x00000009 => return ImageData::read_from(buffer),
        0x0000000a => return ImagePacket::read_from(buffer),
        0x0000000b => return LayerData::read_from(buffer),
        0x0000000c => return ObjectUpdate::read_from(buffer),
        0x0000000d => return ObjectUpdateCompressed::read_from(buffer),
        0x0000000e => return ObjectUpdateCached::read_from(buffer),
        0x0000000f => return ImprovedTerseObjectUpdate::read_from(buffer),
        0x00000010 => return KillObject::read_from(buffer),
        0x000007ff => return CrossedRegion::read_from(buffer),
        0x9600ffff => return SimulatorViewerTimeMessage::read_from(buffer),
        0x9700ffff => return EnableSimulator::read_from(buffer),
        0x9800ffff => return DisableSimulator::read_from(buffer),
        0x000008ff => return ConfirmEnableSimulator::read_from(buffer),
        0x9900ffff => return TransferRequest::read_from(buffer),
        0x9a00ffff => return TransferInfo::read_from(buffer),
        0x00000011 => return TransferPacket::read_from(buffer),
        0x9b00ffff => return TransferAbort::read_from(buffer),
        0x9c00ffff => return RequestXfer::read_from(buffer),
        0x00000012 => return SendXferPacket::read_from(buffer),
        0x00000013 => return ConfirmXferPacket::read_from(buffer),
        0x9d00ffff => return AbortXfer::read_from(buffer),
        0x00000014 => return AvatarAnimation::read_from(buffer),
        0x9e00ffff => return AvatarAppearance::read_from(buffer),
        0x00000015 => return AvatarSitResponse::read_from(buffer),
        0x9f00ffff => return SetFollowCamProperties::read_from(buffer),
        0xa000ffff => return ClearFollowCamProperties::read_from(buffer),
        0x00000016 => return CameraConstraint::read_from(buffer),
        0x000009ff => return ObjectProperties::read_from(buffer),
        0x00000aff => return ObjectPropertiesFamily::read_from(buffer),
        0xa100ffff => return RequestPayPrice::read_from(buffer),
        0xa200ffff => return PayPriceReply::read_from(buffer),
        0xa300ffff => return KickUser::read_from(buffer),
        0xa400ffff => return KickUserAck::read_from(buffer),
        0xa500ffff => return GodKickUser::read_from(buffer),
        0xa600ffff => return SystemKickUser::read_from(buffer),
        0xa700ffff => return EjectUser::read_from(buffer),
        0xa800ffff => return FreezeUser::read_from(buffer),
        0xa900ffff => return AvatarPropertiesRequest::read_from(buffer),
        0xaa00ffff => return AvatarPropertiesRequestBackend::read_from(buffer),
        0xab00ffff => return AvatarPropertiesReply::read_from(buffer),
        0xac00ffff => return AvatarInterestsReply::read_from(buffer),
        0xad00ffff => return AvatarGroupsReply::read_from(buffer),
        0xae00ffff => return AvatarPropertiesUpdate::read_from(buffer),
        0xaf00ffff => return AvatarInterestsUpdate::read_from(buffer),
        0xb000ffff => return AvatarNotesReply::read_from(buffer),
        0xb100ffff => return AvatarNotesUpdate::read_from(buffer),
        0xb200ffff => return AvatarPicksReply::read_from(buffer),
        0xb300ffff => return EventInfoRequest::read_from(buffer),
        0xb400ffff => return EventInfoReply::read_from(buffer),
        0xb500ffff => return EventNotificationAddRequest::read_from(buffer),
        0xb600ffff => return EventNotificationRemoveRequest::read_from(buffer),
        0xb700ffff => return EventGodDelete::read_from(buffer),
        0xb800ffff => return PickInfoReply::read_from(buffer),
        0xb900ffff => return PickInfoUpdate::read_from(buffer),
        0xba00ffff => return PickDelete::read_from(buffer),
        0xbb00ffff => return PickGodDelete::read_from(buffer),
        0xbc00ffff => return ScriptQuestion::read_from(buffer),
        0xbd00ffff => return ScriptControlChange::read_from(buffer),
        0xbe00ffff => return ScriptDialog::read_from(buffer),
        0xbf00ffff => return ScriptDialogReply::read_from(buffer),
        0xc000ffff => return ForceScriptControlRelease::read_from(buffer),
        0xc100ffff => return RevokePermissions::read_from(buffer),
        0xc200ffff => return LoadURL::read_from(buffer),
        0xc300ffff => return ScriptTeleportRequest::read_from(buffer),
        0xc400ffff => return ParcelOverlay::read_from(buffer),
        0x00000bff => return ParcelPropertiesRequest::read_from(buffer),
        0xc500ffff => return ParcelPropertiesRequestByID::read_from(buffer),
        0x00000017 => return ParcelProperties::read_from(buffer),
        0xc600ffff => return ParcelPropertiesUpdate::read_from(buffer),
        0xc700ffff => return ParcelReturnObjects::read_from(buffer),
        0xc800ffff => return ParcelSetOtherCleanTime::read_from(buffer),
        0xc900ffff => return ParcelDisableObjects::read_from(buffer),
        0xca00ffff => return ParcelSelectObjects::read_from(buffer),
        0xcb00ffff => return EstateCovenantRequest::read_from(buffer),
        0xcc00ffff => return EstateCovenantReply::read_from(buffer),
        0xcd00ffff => return ForceObjectSelect::read_from(buffer),
        0xce00ffff => return ParcelBuyPass::read_from(buffer),
        0xcf00ffff => return ParcelDeedToGroup::read_from(buffer),
        0xd000ffff => return ParcelReclaim::read_from(buffer),
        0xd100ffff => return ParcelClaim::read_from(buffer),
        0xd200ffff => return ParcelJoin::read_from(buffer),
        0xd300ffff => return ParcelDivide::read_from(buffer),
        0xd400ffff => return ParcelRelease::read_from(buffer),
        0xd500ffff => return ParcelBuy::read_from(buffer),
        0xd600ffff => return ParcelGodForceOwner::read_from(buffer),
        0xd700ffff => return ParcelAccessListRequest::read_from(buffer),
        0xd800ffff => return ParcelAccessListReply::read_from(buffer),
        0xd900ffff => return ParcelAccessListUpdate::read_from(buffer),
        0xda00ffff => return ParcelDwellRequest::read_from(buffer),
        0xdb00ffff => return ParcelDwellReply::read_from(buffer),
        0xdc00ffff => return RequestParcelTransfer::read_from(buffer),
        0xdd00ffff => return UpdateParcel::read_from(buffer),
        0xde00ffff => return RemoveParcel::read_from(buffer),
        0xdf00ffff => return MergeParcel::read_from(buffer),
        0xe000ffff => return LogParcelChanges::read_from(buffer),
        0xe100ffff => return CheckParcelSales::read_from(buffer),
        0xe200ffff => return ParcelSales::read_from(buffer),
        0xe300ffff => return ParcelGodMarkAsContent::read_from(buffer),
        0xe400ffff => return ViewerStartAuction::read_from(buffer),
        0xe500ffff => return StartAuction::read_from(buffer),
        0xe600ffff => return ConfirmAuctionStart::read_from(buffer),
        0xe700ffff => return CompleteAuction::read_from(buffer),
        0xe800ffff => return CancelAuction::read_from(buffer),
        0xe900ffff => return CheckParcelAuctions::read_from(buffer),
        0xea00ffff => return ParcelAuctions::read_from(buffer),
        0xeb00ffff => return UUIDNameRequest::read_from(buffer),
        0xec00ffff => return UUIDNameReply::read_from(buffer),
        0xed00ffff => return UUIDGroupNameRequest::read_from(buffer),
        0xee00ffff => return UUIDGroupNameReply::read_from(buffer),
        0xef00ffff => return ChatPass::read_from(buffer),
        0x00000018 => return EdgeDataPacket::read_from(buffer),
        0x00000cff => return SimStatus::read_from(buffer),
        0x00000019 => return ChildAgentUpdate::read_from(buffer),
        0x0000001a => return ChildAgentAlive::read_from(buffer),
        0x0000001b => return ChildAgentPositionUpdate::read_from(buffer),
        0xf000ffff => return ChildAgentDying::read_from(buffer),
        0xf100ffff => return ChildAgentUnknown::read_from(buffer),
        0x0000001c => return AtomicPassObject::read_from(buffer),
        0xf200ffff => return KillChildAgents::read_from(buffer),
        0xf300ffff => return GetScriptRunning::read_from(buffer),
        0xf400ffff => return ScriptRunningReply::read_from(buffer),
        0xf500ffff => return SetScriptRunning::read_from(buffer),
        0xf600ffff => return ScriptReset::read_from(buffer),
        0xf700ffff => return ScriptSensorRequest::read_from(buffer),
        0xf800ffff => return ScriptSensorReply::read_from(buffer),
        0xf900ffff => return CompleteAgentMovement::read_from(buffer),
        0xfa00ffff => return AgentMovementComplete::read_from(buffer),
        0xfb00ffff => return DataServerLogout::read_from(buffer),
        0xfc00ffff => return LogoutRequest::read_from(buffer),
        0xfd00ffff => return LogoutReply::read_from(buffer),
        0xfe00ffff => return ImprovedInstantMessage::read_from(buffer),
        0xff00ffff => return RetrieveInstantMessages::read_from(buffer),
        0x0001ffff => return FindAgent::read_from(buffer),
        0x0101ffff => return RequestGodlikePowers::read_from(buffer),
        0x0201ffff => return GrantGodlikePowers::read_from(buffer),
        0x0301ffff => return GodlikeMessage::read_from(buffer),
        0x0401ffff => return EstateOwnerMessage::read_from(buffer),
        0x0501ffff => return GenericMessage::read_from(buffer),
        0x0601ffff => return MuteListRequest::read_from(buffer),
        0x0701ffff => return UpdateMuteListEntry::read_from(buffer),
        0x0801ffff => return RemoveMuteListEntry::read_from(buffer),
        0x0901ffff => return CopyInventoryFromNotecard::read_from(buffer),
        0x0a01ffff => return UpdateInventoryItem::read_from(buffer),
        0x0b01ffff => return UpdateCreateInventoryItem::read_from(buffer),
        0x0c01ffff => return MoveInventoryItem::read_from(buffer),
        0x0d01ffff => return CopyInventoryItem::read_from(buffer),
        0x0e01ffff => return RemoveInventoryItem::read_from(buffer),
        0x0f01ffff => return ChangeInventoryItemFlags::read_from(buffer),
        0x1001ffff => return SaveAssetIntoInventory::read_from(buffer),
        0x1101ffff => return CreateInventoryFolder::read_from(buffer),
        0x1201ffff => return UpdateInventoryFolder::read_from(buffer),
        0x1301ffff => return MoveInventoryFolder::read_from(buffer),
        0x1401ffff => return RemoveInventoryFolder::read_from(buffer),
        0x1501ffff => return FetchInventoryDescendents::read_from(buffer),
        0x1601ffff => return InventoryDescendents::read_from(buffer),
        0x1701ffff => return FetchInventory::read_from(buffer),
        0x1801ffff => return FetchInventoryReply::read_from(buffer),
        0x1901ffff => return BulkUpdateInventory::read_from(buffer),
        0x1a01ffff => return RequestInventoryAsset::read_from(buffer),
        0x1b01ffff => return InventoryAssetResponse::read_from(buffer),
        0x1c01ffff => return RemoveInventoryObjects::read_from(buffer),
        0x1d01ffff => return PurgeInventoryDescendents::read_from(buffer),
        0x1e01ffff => return UpdateTaskInventory::read_from(buffer),
        0x1f01ffff => return RemoveTaskInventory::read_from(buffer),
        0x2001ffff => return MoveTaskInventory::read_from(buffer),
        0x2101ffff => return RequestTaskInventory::read_from(buffer),
        0x2201ffff => return ReplyTaskInventory::read_from(buffer),
        0x2301ffff => return DeRezObject::read_from(buffer),
        0x2401ffff => return DeRezAck::read_from(buffer),
        0x2501ffff => return RezObject::read_from(buffer),
        0x2601ffff => return RezObjectFromNotecard::read_from(buffer),
        0x2701ffff => return TransferInventory::read_from(buffer),
        0x2801ffff => return TransferInventoryAck::read_from(buffer),
        0x2901ffff => return AcceptFriendship::read_from(buffer),
        0x2a01ffff => return DeclineFriendship::read_from(buffer),
        0x2b01ffff => return FormFriendship::read_from(buffer),
        0x2c01ffff => return TerminateFriendship::read_from(buffer),
        0x2d01ffff => return OfferCallingCard::read_from(buffer),
        0x2e01ffff => return AcceptCallingCard::read_from(buffer),
        0x2f01ffff => return DeclineCallingCard::read_from(buffer),
        0x3001ffff => return RezScript::read_from(buffer),
        0x3101ffff => return CreateInventoryItem::read_from(buffer),
        0x3201ffff => return CreateLandmarkForEvent::read_from(buffer),
        0x3301ffff => return EventLocationRequest::read_from(buffer),
        0x3401ffff => return EventLocationReply::read_from(buffer),
        0x3501ffff => return RegionHandleRequest::read_from(buffer),
        0x3601ffff => return RegionIDAndHandleReply::read_from(buffer),
        0x3701ffff => return MoneyTransferRequest::read_from(buffer),
        0x3801ffff => return MoneyTransferBackend::read_from(buffer),
        0x3901ffff => return MoneyBalanceRequest::read_from(buffer),
        0x3a01ffff => return MoneyBalanceReply::read_from(buffer),
        0x3b01ffff => return RoutedMoneyBalanceReply::read_from(buffer),
        0x3c01ffff => return ActivateGestures::read_from(buffer),
        0x3d01ffff => return DeactivateGestures::read_from(buffer),
        0x3e01ffff => return MuteListUpdate::read_from(buffer),
        0x3f01ffff => return UseCachedMuteList::read_from(buffer),
        0x4001ffff => return GrantUserRights::read_from(buffer),
        0x4101ffff => return ChangeUserRights::read_from(buffer),
        0x4201ffff => return OnlineNotification::read_from(buffer),
        0x4301ffff => return OfflineNotification::read_from(buffer),
        0x4401ffff => return SetStartLocationRequest::read_from(buffer),
        0x4501ffff => return SetStartLocation::read_from(buffer),
        0x4601ffff => return NetTest::read_from(buffer),
        0x4701ffff => return SetCPURatio::read_from(buffer),
        0x4801ffff => return SimCrashed::read_from(buffer),
        0x4901ffff => return NameValuePair::read_from(buffer),
        0x4a01ffff => return RemoveNameValuePair::read_from(buffer),
        0x4b01ffff => return UpdateAttachment::read_from(buffer),
        0x4c01ffff => return RemoveAttachment::read_from(buffer),
        0x0000001d => return SoundTrigger::read_from(buffer),
        0x00000dff => return AttachedSound::read_from(buffer),
        0x00000eff => return AttachedSoundGainChange::read_from(buffer),
        0x00000fff => return PreloadSound::read_from(buffer),
        0x4d01ffff => return AssetUploadRequest::read_from(buffer),
        0x4e01ffff => return AssetUploadComplete::read_from(buffer),
        0x4f01ffff => return EmailMessageRequest::read_from(buffer),
        0x5001ffff => return EmailMessageReply::read_from(buffer),
        0x000010ff => return InternalScriptMail::read_from(buffer),
        0x5101ffff => return ScriptDataRequest::read_from(buffer),
        0x5201ffff => return ScriptDataReply::read_from(buffer),
        0x5301ffff => return CreateGroupRequest::read_from(buffer),
        0x5401ffff => return CreateGroupReply::read_from(buffer),
        0x5501ffff => return UpdateGroupInfo::read_from(buffer),
        0x5601ffff => return GroupRoleChanges::read_from(buffer),
        0x5701ffff => return JoinGroupRequest::read_from(buffer),
        0x5801ffff => return JoinGroupReply::read_from(buffer),
        0x5901ffff => return EjectGroupMemberRequest::read_from(buffer),
        0x5a01ffff => return EjectGroupMemberReply::read_from(buffer),
        0x5b01ffff => return LeaveGroupRequest::read_from(buffer),
        0x5c01ffff => return LeaveGroupReply::read_from(buffer),
        0x5d01ffff => return InviteGroupRequest::read_from(buffer),
        0x5e01ffff => return InviteGroupResponse::read_from(buffer),
        0x5f01ffff => return GroupProfileRequest::read_from(buffer),
        0x6001ffff => return GroupProfileReply::read_from(buffer),
        0x6101ffff => return GroupAccountSummaryRequest::read_from(buffer),
        0x6201ffff => return GroupAccountSummaryReply::read_from(buffer),
        0x6301ffff => return GroupAccountDetailsRequest::read_from(buffer),
        0x6401ffff => return GroupAccountDetailsReply::read_from(buffer),
        0x6501ffff => return GroupAccountTransactionsRequest::read_from(buffer),
        0x6601ffff => return GroupAccountTransactionsReply::read_from(buffer),
        0x6701ffff => return GroupActiveProposalsRequest::read_from(buffer),
        0x6801ffff => return GroupActiveProposalItemReply::read_from(buffer),
        0x6901ffff => return GroupVoteHistoryRequest::read_from(buffer),
        0x6a01ffff => return GroupVoteHistoryItemReply::read_from(buffer),
        0x6b01ffff => return StartGroupProposal::read_from(buffer),
        0x6c01ffff => return GroupProposalBallot::read_from(buffer),
        0x6d01ffff => return TallyVotes::read_from(buffer),
        0x6e01ffff => return GroupMembersRequest::read_from(buffer),
        0x6f01ffff => return GroupMembersReply::read_from(buffer),
        0x7001ffff => return ActivateGroup::read_from(buffer),
        0x7101ffff => return SetGroupContribution::read_from(buffer),
        0x7201ffff => return SetGroupAcceptNotices::read_from(buffer),
        0x7301ffff => return GroupRoleDataRequest::read_from(buffer),
        0x7401ffff => return GroupRoleDataReply::read_from(buffer),
        0x7501ffff => return GroupRoleMembersRequest::read_from(buffer),
        0x7601ffff => return GroupRoleMembersReply::read_from(buffer),
        0x7701ffff => return GroupTitlesRequest::read_from(buffer),
        0x7801ffff => return GroupTitlesReply::read_from(buffer),
        0x7901ffff => return GroupTitleUpdate::read_from(buffer),
        0x7a01ffff => return GroupRoleUpdate::read_from(buffer),
        0x7b01ffff => return LiveHelpGroupRequest::read_from(buffer),
        0x7c01ffff => return LiveHelpGroupReply::read_from(buffer),
        0x7d01ffff => return AgentWearablesRequest::read_from(buffer),
        0x7e01ffff => return AgentWearablesUpdate::read_from(buffer),
        0x7f01ffff => return AgentIsNowWearing::read_from(buffer),
        0x8001ffff => return AgentCachedTexture::read_from(buffer),
        0x8101ffff => return AgentCachedTextureResponse::read_from(buffer),
        0x8201ffff => return AgentDataUpdateRequest::read_from(buffer),
        0x8301ffff => return AgentDataUpdate::read_from(buffer),
        0x8401ffff => return GroupDataUpdate::read_from(buffer),
        0x8501ffff => return AgentGroupDataUpdate::read_from(buffer),
        0x8601ffff => return AgentDropGroup::read_from(buffer),
        0x8701ffff => return LogTextMessage::read_from(buffer),
        0x000011ff => return ViewerEffect::read_from(buffer),
        0x8801ffff => return CreateTrustedCircuit::read_from(buffer),
        0x8901ffff => return DenyTrustedCircuit::read_from(buffer),
        0x8a01ffff => return RequestTrustedCircuit::read_from(buffer),
        0x8b01ffff => return RezSingleAttachmentFromInv::read_from(buffer),
        0x8c01ffff => return RezMultipleAttachmentsFromInv::read_from(buffer),
        0x8d01ffff => return DetachAttachmentIntoInv::read_from(buffer),
        0x8e01ffff => return CreateNewOutfitAttachments::read_from(buffer),
        0x8f01ffff => return UserInfoRequest::read_from(buffer),
        0x9001ffff => return UserInfoReply::read_from(buffer),
        0x9101ffff => return UpdateUserInfo::read_from(buffer),
        0x9201ffff => return ParcelRename::read_from(buffer),
        0x9301ffff => return InitiateDownload::read_from(buffer),
        0x9401ffff => return SystemMessage::read_from(buffer),
        0x9501ffff => return MapLayerRequest::read_from(buffer),
        0x9601ffff => return MapLayerReply::read_from(buffer),
        0x9701ffff => return MapBlockRequest::read_from(buffer),
        0x9801ffff => return MapNameRequest::read_from(buffer),
        0x9901ffff => return MapBlockReply::read_from(buffer),
        0x9a01ffff => return MapItemRequest::read_from(buffer),
        0x9b01ffff => return MapItemReply::read_from(buffer),
        0x9c01ffff => return SendPostcard::read_from(buffer),
        0x9d01ffff => return RpcChannelRequest::read_from(buffer),
        0x9e01ffff => return RpcChannelReply::read_from(buffer),
        0x9f01ffff => return RpcScriptRequestInbound::read_from(buffer),
        0xa001ffff => return RpcScriptRequestInboundForward::read_from(buffer),
        0xa101ffff => return RpcScriptReplyInbound::read_from(buffer),
        0xa201ffff => return ScriptMailRegistration::read_from(buffer),
        0xa301ffff => return ParcelMediaCommandMessage::read_from(buffer),
        0xa401ffff => return ParcelMediaUpdate::read_from(buffer),
        0xa501ffff => return LandStatRequest::read_from(buffer),
        0xa601ffff => return LandStatReply::read_from(buffer),
        0xa701ffff => return Error::read_from(buffer),
        0xa801ffff => return ObjectIncludeInSearch::read_from(buffer),
        0xa901ffff => return RezRestoreToWorld::read_from(buffer),
        0xaa01ffff => return LinkInventoryItem::read_from(buffer),
        _ => return Err(ReadMessageError::UnknownMessageNumber(message_num)),
    }
}

#[derive(Debug)]
pub struct TestMessage_TestBlock1 {
    pub test1: u32,
}

#[derive(Debug)]
pub struct TestMessage_NeighborBlock {
    pub test0: u32,
    pub test1: u32,
    pub test2: u32,
}


#[derive(Debug)]
pub struct TestMessage {
    pub test_block1: TestMessage_TestBlock1,
    pub neighbor_block: [TestMessage_NeighborBlock; 4],
}


#[derive(Debug)]
pub struct PacketAck_Packets {
    pub id: u32,
}

/// Packet Ack - Ack a list of packets sent reliable
#[derive(Debug)]
pub struct PacketAck {
    pub packets: Vec<PacketAck_Packets>,
}


#[derive(Debug)]
pub struct OpenCircuit_CircuitInfo {
    pub ip: Ip4Addr,
    pub port: IpPort,
}

/// OpenCircuit - Tells the recipient's messaging system to open the descibed circuit
#[derive(Debug)]
pub struct OpenCircuit {
    pub circuit_info: OpenCircuit_CircuitInfo,
}


/// CloseCircuit - Tells the recipient's messaging system to close the descibed circuit
#[derive(Debug)]
pub struct CloseCircuit {}


#[derive(Debug)]
pub struct StartPingCheck_PingID {
    pub ping_id: u8,
    pub oldest_unacked: u32,
}

/// StartPingCheck - used to measure circuit ping times
/// PingID is used to determine how backlogged the ping was that was
/// returned (or how hosed the other side is)
#[derive(Debug)]
pub struct StartPingCheck {
    pub ping_id: StartPingCheck_PingID,
}


#[derive(Debug)]
pub struct CompletePingCheck_PingID {
    pub ping_id: u8,
}


#[derive(Debug)]
pub struct CompletePingCheck {
    pub ping_id: CompletePingCheck_PingID,
}


#[derive(Debug)]
pub struct AddCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub agent_id: Uuid,
}

/// space->sim
/// sim->sim
/// AddCircuitCode - Tells the recipient's messaging system that this code
/// is for a legal circuit
#[derive(Debug)]
pub struct AddCircuitCode {
    pub circuit_code: AddCircuitCode_CircuitCode,
}


#[derive(Debug)]
pub struct UseCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub id: Uuid,
}

/// viewer->sim
/// UseCircuitCode - Attempts to provide the recipient with IP and Port
/// info. In the case of viewers, the id is the session id. For other
/// machines it may be null. The session id will always be the session
/// id of the process, which every server will generate on startup and
/// the viewer will be handed after login.
#[derive(Debug)]
pub struct UseCircuitCode {
    pub circuit_code: UseCircuitCode_CircuitCode,
}


#[derive(Debug)]
pub struct NeighborList_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: IpPort,
    pub public_ip: Ip4Addr,
    pub public_port: IpPort,
    pub region_id: Uuid,
    pub name: Vec<u8>,
    pub sim_access: u8,
}

/// Neighbor List - Passed anytime neighbors change
#[derive(Debug)]
pub struct NeighborList {
    pub neighbor_block: [NeighborList_NeighborBlock; 4],
}


#[derive(Debug)]
pub struct AvatarTextureUpdate_AgentData {
    pub agent_id: Uuid,
    pub textures_changed: bool,
}

#[derive(Debug)]
pub struct AvatarTextureUpdate_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarTextureUpdate_TextureData {
    pub texture_id: Uuid,
}

/// AvatarTextureUpdate
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct AvatarTextureUpdate {
    pub agent_data: AvatarTextureUpdate_AgentData,
    pub wearable_data: Vec<AvatarTextureUpdate_WearableData>,
    pub texture_data: Vec<AvatarTextureUpdate_TextureData>,
}


#[derive(Debug)]
pub struct SimulatorMapUpdate_MapData {
    pub flags: u32,
}

/// SimulatorMapUpdate
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct SimulatorMapUpdate {
    pub map_data: SimulatorMapUpdate_MapData,
}


#[derive(Debug)]
pub struct SimulatorSetMap_MapData {
    pub region_handle: u64,
    pub type_: i32,
    pub map_image: Uuid,
}

/// SimulatorSetMap
/// simulator -> dataserver
/// reliable
/// Used to upload a map image into the database (currently used only for Land For Sale)
#[derive(Debug)]
pub struct SimulatorSetMap {
    pub map_data: SimulatorSetMap_MapData,
}


/// SubscribeLoad
/// spaceserver -> simulator
/// reliable
#[derive(Debug)]
pub struct SubscribeLoad {}


/// UnsubscribeLoad
/// spaceserver -> simulator
/// reliable
#[derive(Debug)]
pub struct UnsubscribeLoad {}


#[derive(Debug)]
pub struct SimulatorReady_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

#[derive(Debug)]
pub struct SimulatorReady_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

/// SimulatorReady - indicates the sim has finished loading its state
/// and is ready to receive updates from others
#[derive(Debug)]
pub struct SimulatorReady {
    pub simulator_block: SimulatorReady_SimulatorBlock,
    pub telehub_block: SimulatorReady_TelehubBlock,
}


#[derive(Debug)]
pub struct TelehubInfo_TelehubBlock {
    pub object_id: Uuid,
    pub object_name: Vec<u8>,
    pub telehub_pos: Vector3<f32>,
    pub telehub_rot: Quaternion<f32>,
}

#[derive(Debug)]
pub struct TelehubInfo_SpawnPointBlock {
    pub spawn_point_pos: Vector3<f32>,
}

/// TelehubInfo - fill in the UI for telehub creation floater.
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct TelehubInfo {
    pub telehub_block: TelehubInfo_TelehubBlock,
    pub spawn_point_block: Vec<TelehubInfo_SpawnPointBlock>,
}


#[derive(Debug)]
pub struct SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    pub port: IpPort,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: IpPort,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

/// SimulatorPresentAtLocation - indicates that the sim is present at a grid
/// location and passes what it believes its neighbors are
#[derive(Debug)]
pub struct SimulatorPresentAtLocation {
    pub simulator_public_host_block: SimulatorPresentAtLocation_SimulatorPublicHostBlock,
    pub neighbor_block: [SimulatorPresentAtLocation_NeighborBlock; 4],
    pub simulator_block: SimulatorPresentAtLocation_SimulatorBlock,
    pub telehub_block: Vec<SimulatorPresentAtLocation_TelehubBlock>,
}


#[derive(Debug)]
pub struct SimulatorLoad_SimulatorLoad {
    pub time_dilation: f32,
    pub agent_count: i32,
    pub can_accept_agents: bool,
}

#[derive(Debug)]
pub struct SimulatorLoad_AgentList {
    pub circuit_code: u32,
    pub x: u8,
    pub y: u8,
}

/// SimulatorLoad
/// simulator -> spaceserver
/// reliable
#[derive(Debug)]
pub struct SimulatorLoad {
    pub simulator_load: SimulatorLoad_SimulatorLoad,
    pub agent_list: Vec<SimulatorLoad_AgentList>,
}


/// Simulator Shutdown Request - Tells spaceserver that a simulator is trying to shutdown
#[derive(Debug)]
pub struct SimulatorShutdownRequest {}


#[derive(Debug)]
pub struct RegionPresenceRequestByRegionID_RegionData {
    pub region_id: Uuid,
}

/// sim -> dataserver
#[derive(Debug)]
pub struct RegionPresenceRequestByRegionID {
    pub region_data: Vec<RegionPresenceRequestByRegionID_RegionData>,
}


#[derive(Debug)]
pub struct RegionPresenceRequestByHandle_RegionData {
    pub region_handle: u64,
}

/// sim -> dataserver
#[derive(Debug)]
pub struct RegionPresenceRequestByHandle {
    pub region_data: Vec<RegionPresenceRequestByHandle_RegionData>,
}


#[derive(Debug)]
pub struct RegionPresenceResponse_RegionData {
    pub region_id: Uuid,
    pub region_handle: u64,
    pub internal_region_ip: Ip4Addr,
    pub external_region_ip: Ip4Addr,
    pub region_port: IpPort,
    pub valid_until: f64,
    pub message: Vec<u8>,
}

/// dataserver -> sim
#[derive(Debug)]
pub struct RegionPresenceResponse {
    pub region_data: Vec<RegionPresenceResponse_RegionData>,
}


#[derive(Debug)]
pub struct UpdateSimulator_SimulatorInfo {
    pub region_id: Uuid,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub sim_access: u8,
}

/// Updates SimName, EstateID and SimAccess using RegionID as a key
#[derive(Debug)]
pub struct UpdateSimulator {
    pub simulator_info: UpdateSimulator_SimulatorInfo,
}


#[derive(Debug)]
pub struct LogDwellTime_DwellInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub duration: f32,
    pub sim_name: Vec<u8>,
    pub region_x: u32,
    pub region_y: u32,
    pub avg_agents_in_view: u8,
    pub avg_viewer_fps: u8,
}

/// record dwell time.
#[derive(Debug)]
pub struct LogDwellTime {
    pub dwell_info: LogDwellTime_DwellInfo,
}


#[derive(Debug)]
pub struct FeatureDisabled_FailureInfo {
    pub error_message: Vec<u8>,
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

/// Disabled feature response message
#[derive(Debug)]
pub struct FeatureDisabled {
    pub failure_info: FeatureDisabled_FailureInfo,
}


#[derive(Debug)]
pub struct LogFailedMoneyTransaction_TransactionData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
    pub failure_type: u8,
}

/// record lost money transactions.  This message could be generated
/// from either the simulator or the dataserver, depending on how
/// the transaction failed.
#[derive(Debug)]
pub struct LogFailedMoneyTransaction {
    pub transaction_data: LogFailedMoneyTransaction_TransactionData,
}


#[derive(Debug)]
pub struct UserReportInternal_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub reporter_id: Uuid,
    pub viewer_position: Vector3<f32>,
    pub agent_position: Vector3<f32>,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub last_owner_id: Uuid,
    pub creator_id: Uuid,
    pub region_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

/// complaint/bug-report - sim -> dataserver. see UserReport for details.
/// reliable
#[derive(Debug)]
pub struct UserReportInternal {
    pub report_data: UserReportInternal_ReportData,
}


#[derive(Debug)]
pub struct SetSimStatusInDatabase_Data {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub x: i32,
    pub y: i32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

/// SetSimStatusInDatabase
/// alters the "simulator" table in the database
/// sim -> dataserver
/// reliable
#[derive(Debug)]
pub struct SetSimStatusInDatabase {
    pub data: SetSimStatusInDatabase_Data,
}


#[derive(Debug)]
pub struct SetSimPresenceInDatabase_SimData {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub grid_x: u32,
    pub grid_y: u32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

/// SetSimPresenceInDatabase
/// updates the "presence" table in the database to ensure
/// that a given simulator is present and valid for a set amount of
/// time
#[derive(Debug)]
pub struct SetSimPresenceInDatabase {
    pub sim_data: SetSimPresenceInDatabase_SimData,
}


/// once we use local stats, this will include a region handle
#[derive(Debug)]
pub struct EconomyDataRequest {}


#[derive(Debug)]
pub struct EconomyData_Info {
    pub object_capacity: i32,
    pub object_count: i32,
    pub price_energy_unit: i32,
    pub price_object_claim: i32,
    pub price_public_object_decay: i32,
    pub price_public_object_delete: i32,
    pub price_parcel_claim: i32,
    pub price_parcel_claim_factor: f32,
    pub price_upload: i32,
    pub price_rent_light: i32,
    pub teleport_min_price: i32,
    pub teleport_price_exponent: f32,
    pub energy_efficiency: f32,
    pub price_object_rent: f32,
    pub price_object_scale_factor: f32,
    pub price_parcel_rent: i32,
    pub price_group_create: i32,
}

/// dataserver to sim, response w/ econ data
#[derive(Debug)]
pub struct EconomyData {
    pub info: EconomyData_Info,
}


#[derive(Debug)]
pub struct AvatarPickerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPickerRequest_Data {
    pub name: Vec<u8>,
}

/// AvatarPickerRequest
/// Get a list of names to select a person
/// viewer -> sim -> data
/// reliable
#[derive(Debug)]
pub struct AvatarPickerRequest {
    pub agent_data: AvatarPickerRequest_AgentData,
    pub data: AvatarPickerRequest_Data,
}


#[derive(Debug)]
pub struct AvatarPickerRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
    pub god_level: u8,
}

#[derive(Debug)]
pub struct AvatarPickerRequestBackend_Data {
    pub name: Vec<u8>,
}

/// backend implementation which tracks if the user is a god.
#[derive(Debug)]
pub struct AvatarPickerRequestBackend {
    pub agent_data: AvatarPickerRequestBackend_AgentData,
    pub data: AvatarPickerRequestBackend_Data,
}


#[derive(Debug)]
pub struct AvatarPickerReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPickerReply_Data {
    pub avatar_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

/// AvatarPickerReply
/// List of names to select a person
/// reliable
#[derive(Debug)]
pub struct AvatarPickerReply {
    pub agent_data: AvatarPickerReply_AgentData,
    pub data: Vec<AvatarPickerReply_Data>,
}


#[derive(Debug)]
pub struct PlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesQuery_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesQuery_QueryData {
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
}

/// PlacesQuery
/// Used for getting a list of places for the group land panel
/// and the user land holdings panel.  NOT for the directory.
#[derive(Debug)]
pub struct PlacesQuery {
    pub agent_data: PlacesQuery_AgentData,
    pub transaction_data: PlacesQuery_TransactionData,
    pub query_data: PlacesQuery_QueryData,
}


#[derive(Debug)]
pub struct PlacesReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesReply_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesReply_QueryData {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub price: i32,
}

/// PlacesReply
/// dataserver -> simulator -> viewer
/// If the user has specified a location, use that to compute
/// global x,y,z.  Otherwise, use center of the AABB.
/// reliable
///{	ProductSKU		Variable	1	}
#[derive(Debug)]
pub struct PlacesReply {
    pub agent_data: PlacesReply_AgentData,
    pub transaction_data: PlacesReply_TransactionData,
    pub query_data: Vec<PlacesReply_QueryData>,
}


#[derive(Debug)]
pub struct DirFindQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirFindQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

/// DirFindQuery viewer->sim
/// Message to start asking questions for the directory
#[derive(Debug)]
pub struct DirFindQuery {
    pub agent_data: DirFindQuery_AgentData,
    pub query_data: DirFindQuery_QueryData,
}


#[derive(Debug)]
pub struct DirFindQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirFindQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

/// DirFindQueryBackend sim->data
/// Trusted message generated by receipt of DirFindQuery to sim.
#[derive(Debug)]
pub struct DirFindQueryBackend {
    pub agent_data: DirFindQueryBackend_AgentData,
    pub query_data: DirFindQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub query_start: i32,
}

/// DirPlacesQuery viewer->sim
/// Used for the Find directory of places
#[derive(Debug)]
pub struct DirPlacesQuery {
    pub agent_data: DirPlacesQuery_AgentData,
    pub query_data: DirPlacesQuery_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

/// DirPlacesQueryBackend sim->dataserver
/// Used for the Find directory of places.
#[derive(Debug)]
pub struct DirPlacesQueryBackend {
    pub agent_data: DirPlacesQueryBackend_AgentData,
    pub query_data: DirPlacesQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub for_sale: bool,
    pub auction: bool,
    pub dwell: f32,
}

#[derive(Debug)]
pub struct DirPlacesReply_StatusData {
    pub status: u32,
}

/// DirPlacesReply dataserver->sim->viewer
/// If the user has specified a location, use that to compute
/// global x,y,z.  Otherwise, use center of the AABB.
/// reliable
#[derive(Debug)]
pub struct DirPlacesReply {
    pub agent_data: DirPlacesReply_AgentData,
    pub query_data: Vec<DirPlacesReply_QueryData>,
    pub query_replies: Vec<DirPlacesReply_QueryReplies>,
    pub status_data: Vec<DirPlacesReply_StatusData>,
}


#[derive(Debug)]
pub struct DirPeopleReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPeopleReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPeopleReply_QueryReplies {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group: Vec<u8>,
    pub online: bool,
    pub reputation: i32,
}

/// DirPeopleReply
#[derive(Debug)]
pub struct DirPeopleReply {
    pub agent_data: DirPeopleReply_AgentData,
    pub query_data: DirPeopleReply_QueryData,
    pub query_replies: Vec<DirPeopleReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirEventsReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirEventsReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirEventsReply_QueryReplies {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub event_id: u32,
    pub date: Vec<u8>,
    pub unix_time: u32,
    pub event_flags: u32,
}

#[derive(Debug)]
pub struct DirEventsReply_StatusData {
    pub status: u32,
}

/// DirEventsReply
#[derive(Debug)]
pub struct DirEventsReply {
    pub agent_data: DirEventsReply_AgentData,
    pub query_data: DirEventsReply_QueryData,
    pub query_replies: Vec<DirEventsReply_QueryReplies>,
    pub status_data: Vec<DirEventsReply_StatusData>,
}


#[derive(Debug)]
pub struct DirGroupsReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirGroupsReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirGroupsReply_QueryReplies {
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub members: i32,
    pub search_order: f32,
}

/// DirGroupsReply
/// dataserver -> userserver -> viewer
/// reliable
#[derive(Debug)]
pub struct DirGroupsReply {
    pub agent_data: DirGroupsReply_AgentData,
    pub query_data: DirGroupsReply_QueryData,
    pub query_replies: Vec<DirGroupsReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirClassifiedQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub query_start: i32,
}

/// DirClassifiedQuery viewer->sim
/// reliable
#[derive(Debug)]
pub struct DirClassifiedQuery {
    pub agent_data: DirClassifiedQuery_AgentData,
    pub query_data: DirClassifiedQuery_QueryData,
}


#[derive(Debug)]
pub struct DirClassifiedQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

/// DirClassifiedQueryBackend sim->dataserver
/// reliable
#[derive(Debug)]
pub struct DirClassifiedQueryBackend {
    pub agent_data: DirClassifiedQueryBackend_AgentData,
    pub query_data: DirClassifiedQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirClassifiedReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedReply_QueryReplies {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
    pub classified_flags: u8,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub price_for_listing: i32,
}

#[derive(Debug)]
pub struct DirClassifiedReply_StatusData {
    pub status: u32,
}

/// DirClassifiedReply dataserver->sim->viewer
/// reliable
#[derive(Debug)]
pub struct DirClassifiedReply {
    pub agent_data: DirClassifiedReply_AgentData,
    pub query_data: DirClassifiedReply_QueryData,
    pub query_replies: Vec<DirClassifiedReply_QueryReplies>,
    pub status_data: Vec<DirClassifiedReply_StatusData>,
}


#[derive(Debug)]
pub struct AvatarClassifiedReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarClassifiedReply_Data {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
}

/// AvatarClassifiedReply
/// dataserver -> simulator -> viewer
/// Send the header information for this avatar's classifieds
/// This fills in the tabs of the Classifieds panel.
/// reliable
#[derive(Debug)]
pub struct AvatarClassifiedReply {
    pub agent_data: AvatarClassifiedReply_AgentData,
    pub data: Vec<AvatarClassifiedReply_Data>,
}


#[derive(Debug)]
pub struct ClassifiedInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoRequest_Data {
    pub classified_id: Uuid,
}

/// ClassifiedInfoRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct ClassifiedInfoRequest {
    pub agent_data: ClassifiedInfoRequest_AgentData,
    pub data: ClassifiedInfoRequest_Data,
}


#[derive(Debug)]
pub struct ClassifiedInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoReply_Data {
    pub classified_id: Uuid,
    pub creator_id: Uuid,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub parcel_name: Vec<u8>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

/// ClassifiedInfoReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct ClassifiedInfoReply {
    pub agent_data: ClassifiedInfoReply_AgentData,
    pub data: ClassifiedInfoReply_Data,
}


#[derive(Debug)]
pub struct ClassifiedInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoUpdate_Data {
    pub classified_id: Uuid,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

/// ClassifiedInfoUpdate
/// Update a classified.  ParcelID and EstateID are set
/// on the simulator as the message passes through.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct ClassifiedInfoUpdate {
    pub agent_data: ClassifiedInfoUpdate_AgentData,
    pub data: ClassifiedInfoUpdate_Data,
}


#[derive(Debug)]
pub struct ClassifiedDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedDelete_Data {
    pub classified_id: Uuid,
}

/// ClassifiedDelete
/// Delete a classified from the database.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct ClassifiedDelete {
    pub agent_data: ClassifiedDelete_AgentData,
    pub data: ClassifiedDelete_Data,
}


#[derive(Debug)]
pub struct ClassifiedGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedGodDelete_Data {
    pub classified_id: Uuid,
    pub query_id: Uuid,
}

/// ClassifiedGodDelete
/// Delete a classified from the database.
/// QueryID is needed so database can send a repeat list of
/// classified.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct ClassifiedGodDelete {
    pub agent_data: ClassifiedGodDelete_AgentData,
    pub data: ClassifiedGodDelete_Data,
}


#[derive(Debug)]
pub struct DirLandQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
}

/// DirLandQuery viewer->sim
/// Special query for the land for sale/auction panel.
/// reliable
#[derive(Debug)]
pub struct DirLandQuery {
    pub agent_data: DirLandQuery_AgentData,
    pub query_data: DirLandQuery_QueryData,
}


#[derive(Debug)]
pub struct DirLandQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

/// DirLandQueryBackend sim->dataserver
/// Special query for the land for sale/auction panel.
#[derive(Debug)]
pub struct DirLandQueryBackend {
    pub agent_data: DirLandQueryBackend_AgentData,
    pub query_data: DirLandQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirLandReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub auction: bool,
    pub for_sale: bool,
    pub sale_price: i32,
    pub actual_area: i32,
}

/// DirLandReply
/// dataserver -> simulator -> viewer
/// reliable
///{	ProductSKU		Variable 1	}
#[derive(Debug)]
pub struct DirLandReply {
    pub agent_data: DirLandReply_AgentData,
    pub query_data: DirLandReply_QueryData,
    pub query_replies: Vec<DirLandReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirPopularQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
}

/// DEPRECATED: DirPopularQuery viewer->sim
/// Special query for the land for sale/auction panel.
/// reliable
#[derive(Debug)]
pub struct DirPopularQuery {
    pub agent_data: DirPopularQuery_AgentData,
    pub query_data: DirPopularQuery_QueryData,
}


#[derive(Debug)]
pub struct DirPopularQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

/// DEPRECATED: DirPopularQueryBackend sim->dataserver
/// Special query for the land for sale/auction panel.
/// reliable
#[derive(Debug)]
pub struct DirPopularQueryBackend {
    pub agent_data: DirPopularQueryBackend_AgentData,
    pub query_data: DirPopularQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPopularReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub dwell: f32,
}

/// DEPRECATED: DirPopularReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct DirPopularReply {
    pub agent_data: DirPopularReply_AgentData,
    pub query_data: DirPopularReply_QueryData,
    pub query_replies: Vec<DirPopularReply_QueryReplies>,
}


#[derive(Debug)]
pub struct ParcelInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelInfoRequest_Data {
    pub parcel_id: Uuid,
}

/// ParcelInfoRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct ParcelInfoRequest {
    pub agent_data: ParcelInfoRequest_AgentData,
    pub data: ParcelInfoRequest_Data,
}


#[derive(Debug)]
pub struct ParcelInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelInfoReply_Data {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub sale_price: i32,
    pub auction_id: i32,
}

/// ParcelInfoReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct ParcelInfoReply {
    pub agent_data: ParcelInfoReply_AgentData,
    pub data: ParcelInfoReply_Data,
}


#[derive(Debug)]
pub struct ParcelObjectOwnersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelObjectOwnersRequest_ParcelData {
    pub local_id: i32,
}

/// ParcelObjectOwnersRequest
/// viewer -> simulator
/// reliable
#[derive(Debug)]
pub struct ParcelObjectOwnersRequest {
    pub agent_data: ParcelObjectOwnersRequest_AgentData,
    pub parcel_data: ParcelObjectOwnersRequest_ParcelData,
}


#[derive(Debug)]
pub struct ParcelObjectOwnersReply_Data {
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub count: i32,
    pub online_status: bool,
}

/// ParcelObjectOwnersReply
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct ParcelObjectOwnersReply {
    pub data: Vec<ParcelObjectOwnersReply_Data>,
}


#[derive(Debug)]
pub struct GroupNoticesListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticesListRequest_Data {
    pub group_id: Uuid,
}

/// GroupNoticeListRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupNoticesListRequest {
    pub agent_data: GroupNoticesListRequest_AgentData,
    pub data: GroupNoticesListRequest_Data,
}


#[derive(Debug)]
pub struct GroupNoticesListReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticesListReply_Data {
    pub notice_id: Uuid,
    pub timestamp: u32,
    pub from_name: Vec<u8>,
    pub subject: Vec<u8>,
    pub has_attachment: bool,
    pub asset_type: u8,
}

/// GroupNoticesListReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct GroupNoticesListReply {
    pub agent_data: GroupNoticesListReply_AgentData,
    pub data: Vec<GroupNoticesListReply_Data>,
}


#[derive(Debug)]
pub struct GroupNoticeRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticeRequest_Data {
    pub group_notice_id: Uuid,
}

/// GroupNoticeRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupNoticeRequest {
    pub agent_data: GroupNoticeRequest_AgentData,
    pub data: GroupNoticeRequest_Data,
}


#[derive(Debug)]
pub struct GroupNoticeAdd_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticeAdd_MessageBlock {
    pub to_group_id: Uuid,
    pub id: Uuid,
    pub dialog: u8,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

/// GroupNoticeAdd
/// Add a group notice.
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupNoticeAdd {
    pub agent_data: GroupNoticeAdd_AgentData,
    pub message_block: GroupNoticeAdd_MessageBlock,
}


#[derive(Debug)]
pub struct TeleportRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportRequest_Info {
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

/// TeleportRequest
/// viewer -> sim specifying exact teleport destination
#[derive(Debug)]
pub struct TeleportRequest {
    pub agent_data: TeleportRequest_AgentData,
    pub info: TeleportRequest_Info,
}


#[derive(Debug)]
pub struct TeleportLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportLocationRequest_Info {
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

/// TeleportLocationRequest
/// viewer -> sim specifying exact teleport destination
#[derive(Debug)]
pub struct TeleportLocationRequest {
    pub agent_data: TeleportLocationRequest_AgentData,
    pub info: TeleportLocationRequest_Info,
}


#[derive(Debug)]
pub struct TeleportLocal_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub teleport_flags: u32,
}

/// TeleportLocal
/// sim -> viewer reply telling the viewer that we've successfully TP'd
/// to somewhere else within the sim
#[derive(Debug)]
pub struct TeleportLocal {
    pub info: TeleportLocal_Info,
}


#[derive(Debug)]
pub struct TeleportLandmarkRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub landmark_id: Uuid,
}

/// TeleportLandmarkRequest viewer->sim
/// teleport to landmark asset ID destination. use LLUUD::null for home.
#[derive(Debug)]
pub struct TeleportLandmarkRequest {
    pub info: TeleportLandmarkRequest_Info,
}


#[derive(Debug)]
pub struct TeleportProgress_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportProgress_Info {
    pub teleport_flags: u32,
    pub message: Vec<u8>,
}

/// TeleportProgress sim->viewer
/// Tell the agent how the teleport is going.
#[derive(Debug)]
pub struct TeleportProgress {
    pub agent_data: TeleportProgress_AgentData,
    pub info: TeleportProgress_Info,
}


#[derive(Debug)]
pub struct DataHomeLocationRequest_Info {
    pub agent_id: Uuid,
    pub kicked_from_estate_id: u32,
}

#[derive(Debug)]
pub struct DataHomeLocationRequest_AgentInfo {
    pub agent_effective_maturity: u32,
}

/// DataHomeLocationRequest sim->data
/// Request
#[derive(Debug)]
pub struct DataHomeLocationRequest {
    pub info: DataHomeLocationRequest_Info,
    pub agent_info: DataHomeLocationRequest_AgentInfo,
}


#[derive(Debug)]
pub struct DataHomeLocationReply_Info {
    pub agent_id: Uuid,
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

/// DataHomeLocationReply data->sim
/// response is the location of agent home.
#[derive(Debug)]
pub struct DataHomeLocationReply {
    pub info: DataHomeLocationReply_Info,
}


#[derive(Debug)]
pub struct TeleportFinish_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub sim_ip: Ip4Addr,
    pub sim_port: IpPort,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
    pub sim_access: u8,
    pub teleport_flags: u32,
}

/// TeleportFinish sim->viewer
/// called when all of the information has been collected and readied for
/// the agent.
#[derive(Debug)]
pub struct TeleportFinish {
    pub info: TeleportFinish_Info,
}


#[derive(Debug)]
pub struct StartLure_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StartLure_Info {
    pub lure_type: u8,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct StartLure_TargetData {
    pub target_id: Uuid,
}

/// StartLure viewer->sim
/// Sent from viewer to the local simulator to lure target id to near
/// agent id. This will generate an instant message that will be routed
/// through the space server and out to the userserver. When that IM
/// goes through the userserver and the TargetID is online, the
/// userserver will send an InitializeLure to the spaceserver. When that
/// packet is acked, the original instant message is finally forwarded to
/// TargetID.
#[derive(Debug)]
pub struct StartLure {
    pub agent_data: StartLure_AgentData,
    pub info: StartLure_Info,
    pub target_data: Vec<StartLure_TargetData>,
}


#[derive(Debug)]
pub struct TeleportLureRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub lure_id: Uuid,
    pub teleport_flags: u32,
}

/// TeleportLureRequest viewer->sim
/// Message from target of lure to begin the teleport process on the
/// local simulator.
#[derive(Debug)]
pub struct TeleportLureRequest {
    pub info: TeleportLureRequest_Info,
}


#[derive(Debug)]
pub struct TeleportCancel_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// TeleportCancel viewer->sim
/// reliable
#[derive(Debug)]
pub struct TeleportCancel {
    pub info: TeleportCancel_Info,
}


#[derive(Debug)]
pub struct TeleportStart_Info {
    pub teleport_flags: u32,
}

/// TeleportStart sim->viewer
/// announce a successful teleport request to the viewer.
#[derive(Debug)]
pub struct TeleportStart {
    pub info: TeleportStart_Info,
}


#[derive(Debug)]
pub struct TeleportFailed_Info {
    pub agent_id: Uuid,
    pub reason: Vec<u8>,
}

#[derive(Debug)]
pub struct TeleportFailed_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

/// TeleportFailed somewhere->sim->viewer
/// announce failure of teleport request
#[derive(Debug)]
pub struct TeleportFailed {
    pub info: TeleportFailed_Info,
    pub alert_info: Vec<TeleportFailed_AlertInfo>,
}


#[derive(Debug)]
pub struct Undo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct Undo_ObjectData {
    pub object_id: Uuid,
}

/// Undo
#[derive(Debug)]
pub struct Undo {
    pub agent_data: Undo_AgentData,
    pub object_data: Vec<Undo_ObjectData>,
}


#[derive(Debug)]
pub struct Redo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct Redo_ObjectData {
    pub object_id: Uuid,
}

/// Redo
#[derive(Debug)]
pub struct Redo {
    pub agent_data: Redo_AgentData,
    pub object_data: Vec<Redo_ObjectData>,
}


#[derive(Debug)]
pub struct UndoLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// UndoLand
#[derive(Debug)]
pub struct UndoLand {
    pub agent_data: UndoLand_AgentData,
}


#[derive(Debug)]
pub struct AgentPause_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

/// AgentPause - viewer occasionally will block, inform simulator of this fact
#[derive(Debug)]
pub struct AgentPause {
    pub agent_data: AgentPause_AgentData,
}


#[derive(Debug)]
pub struct AgentResume_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

/// AgentResume - unblock the agent
#[derive(Debug)]
pub struct AgentResume {
    pub agent_data: AgentResume_AgentData,
}


#[derive(Debug)]
pub struct AgentUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub body_rotation: Quaternion<f32>,
    pub head_rotation: Quaternion<f32>,
    pub state: u8,
    pub camera_center: Vector3<f32>,
    pub camera_at_axis: Vector3<f32>,
    pub camera_left_axis: Vector3<f32>,
    pub camera_up_axis: Vector3<f32>,
    pub far: f32,
    pub control_flags: u32,
    pub flags: u8,
}

/// AgentUpdate - Camera info sent from viewer to simulator
/// or, more simply, two axes and compute cross product
/// State data is temporary, indicates current behavior state:
///	0 = walking
///  1 = mouselook
///  2 = typing
///
/// Center is region local (JNC 8.16.2001)
/// Camera center is region local (JNC 8.29.2001)
#[derive(Debug)]
pub struct AgentUpdate {
    pub agent_data: AgentUpdate_AgentData,
}


#[derive(Debug)]
pub struct ChatFromViewer_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChatFromViewer_ChatData {
    pub message: Vec<u8>,
    pub type_: u8,
    pub channel: i32,
}

/// ChatFromViewer
/// Specifies the text to be said and the "type",
/// normal speech, shout, whisper.
/// with the specified radius
#[derive(Debug)]
pub struct ChatFromViewer {
    pub agent_data: ChatFromViewer_AgentData,
    pub chat_data: ChatFromViewer_ChatData,
}


#[derive(Debug)]
pub struct AgentThrottle_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentThrottle_Throttle {
    pub gen_counter: u32,
    pub throttles: Vec<u8>,
}

/// AgentThrottle
#[derive(Debug)]
pub struct AgentThrottle {
    pub agent_data: AgentThrottle_AgentData,
    pub throttle: AgentThrottle_Throttle,
}


#[derive(Debug)]
pub struct AgentFOV_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentFOV_FOVBlock {
    pub gen_counter: u32,
    pub vertical_angle: f32,
}

/// AgentFOV - Update to agent's field of view, angle is vertical, single F32 float in radians
#[derive(Debug)]
pub struct AgentFOV {
    pub agent_data: AgentFOV_AgentData,
    pub fov_block: AgentFOV_FOVBlock,
}


#[derive(Debug)]
pub struct AgentHeightWidth_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentHeightWidth_HeightWidthBlock {
    pub gen_counter: u32,
    pub height: u16,
    pub width: u16,
}

/// AgentHeightWidth - Update to height and aspect, sent as height/width to save space
/// Usually sent when window resized or created
#[derive(Debug)]
pub struct AgentHeightWidth {
    pub agent_data: AgentHeightWidth_AgentData,
    pub height_width_block: AgentHeightWidth_HeightWidthBlock,
}


#[derive(Debug)]
pub struct AgentSetAppearance_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
    pub size: Vector3<f32>,
}

#[derive(Debug)]
pub struct AgentSetAppearance_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
}

#[derive(Debug)]
pub struct AgentSetAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentSetAppearance_VisualParam {
    pub param_value: u8,
}

/// AgentSetAppearance - Update to agent appearance
#[derive(Debug)]
pub struct AgentSetAppearance {
    pub agent_data: AgentSetAppearance_AgentData,
    pub wearable_data: Vec<AgentSetAppearance_WearableData>,
    pub object_data: AgentSetAppearance_ObjectData,
    pub visual_param: Vec<AgentSetAppearance_VisualParam>,
}


#[derive(Debug)]
pub struct AgentAnimation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentAnimation_AnimationList {
    pub anim_id: Uuid,
    pub start_anim: bool,
}

#[derive(Debug)]
pub struct AgentAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}

/// AgentAnimation - Update animation state
/// viewer --> simulator
#[derive(Debug)]
pub struct AgentAnimation {
    pub agent_data: AgentAnimation_AgentData,
    pub animation_list: Vec<AgentAnimation_AnimationList>,
    pub physical_avatar_event_list: Vec<AgentAnimation_PhysicalAvatarEventList>,
}


#[derive(Debug)]
pub struct AgentRequestSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentRequestSit_TargetObject {
    pub target_id: Uuid,
    pub offset: Vector3<f32>,
}

/// AgentRequestSit - Try to sit on an object
#[derive(Debug)]
pub struct AgentRequestSit {
    pub agent_data: AgentRequestSit_AgentData,
    pub target_object: AgentRequestSit_TargetObject,
}


#[derive(Debug)]
pub struct AgentSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// AgentSit - Actually sit on object
#[derive(Debug)]
pub struct AgentSit {
    pub agent_data: AgentSit_AgentData,
}


#[derive(Debug)]
pub struct AgentQuitCopy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentQuitCopy_FuseBlock {
    pub viewer_circuit_code: u32,
}

/// quit message sent between simulators
#[derive(Debug)]
pub struct AgentQuitCopy {
    pub agent_data: AgentQuitCopy_AgentData,
    pub fuse_block: AgentQuitCopy_FuseBlock,
}


#[derive(Debug)]
pub struct RequestImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestImage_RequestImage {
    pub image: Uuid,
    pub discard_level: i8,
    pub download_priority: f32,
    pub packet: u32,
    pub type_: u8,
}


#[derive(Debug)]
pub struct RequestImage {
    pub agent_data: RequestImage_AgentData,
    pub request_image: Vec<RequestImage_RequestImage>,
}


#[derive(Debug)]
pub struct ImageNotInDatabase_ImageID {
    pub id: Uuid,
}

/// ImageNotInDatabase
/// Simulator informs viewer that a requsted image definitely does not exist in the asset database
#[derive(Debug)]
pub struct ImageNotInDatabase {
    pub image_id: ImageNotInDatabase_ImageID,
}


#[derive(Debug)]
pub struct RebakeAvatarTextures_TextureData {
    pub texture_id: Uuid,
}

/// RebakeAvatarTextures
/// simulator -> viewer request when a temporary baked avatar texture is not found
#[derive(Debug)]
pub struct RebakeAvatarTextures {
    pub texture_data: RebakeAvatarTextures_TextureData,
}


#[derive(Debug)]
pub struct SetAlwaysRun_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub always_run: bool,
}

/// SetAlwaysRun
/// Lets the viewer choose between running and walking
#[derive(Debug)]
pub struct SetAlwaysRun {
    pub agent_data: SetAlwaysRun_AgentData,
}


#[derive(Debug)]
pub struct ObjectAdd_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectAdd_ObjectData {
    pub p_code: u8,
    pub material: u8,
    pub add_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: u8,
    pub scale: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub state: u8,
}


#[derive(Debug)]
pub struct ObjectAdd {
    pub agent_data: ObjectAdd_AgentData,
    pub object_data: ObjectAdd_ObjectData,
}


#[derive(Debug)]
pub struct ObjectDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub force: bool,
}

#[derive(Debug)]
pub struct ObjectDelete_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDelete
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectDelete {
    pub agent_data: ObjectDelete_AgentData,
    pub object_data: Vec<ObjectDelete_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDuplicate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDuplicate_SharedData {
    pub offset: Vector3<f32>,
    pub duplicate_flags: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicate_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDuplicate
/// viewer -> simulator
/// Makes a copy of a set of objects, offset by a given amount
#[derive(Debug)]
pub struct ObjectDuplicate {
    pub agent_data: ObjectDuplicate_AgentData,
    pub shared_data: ObjectDuplicate_SharedData,
    pub object_data: Vec<ObjectDuplicate_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDuplicateOnRay_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub bypass_raycast: bool,
    pub ray_end_is_intersection: bool,
    pub copy_centers: bool,
    pub copy_rotates: bool,
    pub ray_target_id: Uuid,
    pub duplicate_flags: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicateOnRay_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDuplicateOnRay
/// viewer -> simulator
/// Makes a copy of an object, using the add object raycast
/// code to abut it to other objects.
#[derive(Debug)]
pub struct ObjectDuplicateOnRay {
    pub agent_data: ObjectDuplicateOnRay_AgentData,
    pub object_data: Vec<ObjectDuplicateOnRay_ObjectData>,
}


#[derive(Debug)]
pub struct MultipleObjectUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MultipleObjectUpdate_ObjectData {
    pub object_local_id: u32,
    pub type_: u8,
    pub data: Vec<u8>,
}

/// MultipleObjectUpdate
/// viewer -> simulator
/// updates position, rotation and scale in one message
/// positions sent as region-local floats
#[derive(Debug)]
pub struct MultipleObjectUpdate {
    pub agent_data: MultipleObjectUpdate_AgentData,
    pub object_data: Vec<MultipleObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct RequestMultipleObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestMultipleObjects_ObjectData {
    pub cache_miss_type: u8,
    pub id: u32,
}

/// RequestMultipleObjects
/// viewer -> simulator
/// reliable
///
/// When the viewer gets a local_id/crc for an object that
/// it either doesn't have, or doesn't have the current version
/// of, it sends this upstream get get an update.
///
/// CacheMissType 0 => full object (viewer doesn't have it)
/// CacheMissType 1 => CRC mismatch only
#[derive(Debug)]
pub struct RequestMultipleObjects {
    pub agent_data: RequestMultipleObjects_AgentData,
    pub object_data: Vec<RequestMultipleObjects_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectPosition_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectPosition_ObjectData {
    pub object_local_id: u32,
    pub position: Vector3<f32>,
}

/// DEPRECATED: ObjectPosition
/// == Old Behavior ==
/// Set the position on objects
///
/// == Reason for deprecation ==
/// Unused code path was removed in the move to Havok4
/// Object position, scale and rotation messages were already unified
/// to MultipleObjectUpdate and this message was unused cruft.
///
/// == New Location ==
/// MultipleObjectUpdate can be used instead.
#[derive(Debug)]
pub struct ObjectPosition {
    pub agent_data: ObjectPosition_AgentData,
    pub object_data: Vec<ObjectPosition_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectScale_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectScale_ObjectData {
    pub object_local_id: u32,
    pub scale: Vector3<f32>,
}

/// DEPRECATED: ObjectScale
/// == Old Behavior ==
/// Set the scale on objects
///
/// == Reason for deprecation ==
/// Unused code path was removed in the move to Havok4
/// Object position, scale and rotation messages were already unified
/// to MultipleObjectUpdate and this message was unused cruft.
///
/// == New Location ==
/// MultipleObjectUpdate can be used instead.
#[derive(Debug)]
pub struct ObjectScale {
    pub agent_data: ObjectScale_AgentData,
    pub object_data: Vec<ObjectScale_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectRotation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectRotation_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

/// ObjectRotation
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectRotation {
    pub agent_data: ObjectRotation_AgentData,
    pub object_data: Vec<ObjectRotation_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectFlagUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub object_local_id: u32,
    pub use_physics: bool,
    pub is_temporary: bool,
    pub is_phantom: bool,
    pub casts_shadows: bool,
}

/// ObjectFlagUpdate
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectFlagUpdate {
    pub agent_data: ObjectFlagUpdate_AgentData,
}


#[derive(Debug)]
pub struct ObjectClickAction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectClickAction_ObjectData {
    pub object_local_id: u32,
    pub click_action: u8,
}

/// ObjectClickAction
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectClickAction {
    pub agent_data: ObjectClickAction_AgentData,
    pub object_data: Vec<ObjectClickAction_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectImage_ObjectData {
    pub object_local_id: u32,
    pub media_url: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

/// ObjectImage
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectImage {
    pub agent_data: ObjectImage_AgentData,
    pub object_data: Vec<ObjectImage_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectMaterial_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectMaterial_ObjectData {
    pub object_local_id: u32,
    pub material: u8,
}


#[derive(Debug)]
pub struct ObjectMaterial {
    pub agent_data: ObjectMaterial_AgentData,
    pub object_data: Vec<ObjectMaterial_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectShape_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectShape_ObjectData {
    pub object_local_id: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
}


#[derive(Debug)]
pub struct ObjectShape {
    pub agent_data: ObjectShape_AgentData,
    pub object_data: Vec<ObjectShape_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectExtraParams_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectExtraParams_ObjectData {
    pub object_local_id: u32,
    pub param_type: u16,
    pub param_in_use: bool,
    pub param_size: u32,
    pub param_data: Vec<u8>,
}


#[derive(Debug)]
pub struct ObjectExtraParams {
    pub agent_data: ObjectExtraParams_AgentData,
    pub object_data: Vec<ObjectExtraParams_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectOwner_HeaderData {
    pub override_: bool,
    pub owner_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectOwner_ObjectData {
    pub object_local_id: u32,
}

/// ObjectOwner
/// To make public, set OwnerID to LLUUID::null.
/// TODO: Eliminate god-bit. Maybe not. God-bit is ok, because it's
/// known on the server.
#[derive(Debug)]
pub struct ObjectOwner {
    pub agent_data: ObjectOwner_AgentData,
    pub header_data: ObjectOwner_HeaderData,
    pub object_data: Vec<ObjectOwner_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGroup_ObjectData {
    pub object_local_id: u32,
}

/// ObjectGroup
/// To make the object part of no group, set GroupID = LLUUID::null.
/// This call only works if objectid.ownerid == agentid.
#[derive(Debug)]
pub struct ObjectGroup {
    pub agent_data: ObjectGroup_AgentData,
    pub object_data: Vec<ObjectGroup_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub category_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectBuy_ObjectData {
    pub object_local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

/// Attempt to buy an object. This will only pack root objects.
#[derive(Debug)]
pub struct ObjectBuy {
    pub agent_data: ObjectBuy_AgentData,
    pub object_data: Vec<ObjectBuy_ObjectData>,
}


#[derive(Debug)]
pub struct BuyObjectInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct BuyObjectInventory_Data {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub folder_id: Uuid,
}

/// buy object inventory. If the transaction succeeds, it will add
/// inventory to the agent, and potentially remove the original.
#[derive(Debug)]
pub struct BuyObjectInventory {
    pub agent_data: BuyObjectInventory_AgentData,
    pub data: BuyObjectInventory_Data,
}


#[derive(Debug)]
pub struct DerezContainer_Data {
    pub object_id: Uuid,
    pub delete: bool,
}

/// sim -> viewer
/// Used to propperly handle buying asset containers
#[derive(Debug)]
pub struct DerezContainer {
    pub data: DerezContainer_Data,
}


#[derive(Debug)]
pub struct ObjectPermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectPermissions_HeaderData {
    pub override_: bool,
}

#[derive(Debug)]
pub struct ObjectPermissions_ObjectData {
    pub object_local_id: u32,
    pub field: u8,
    pub set: u8,
    pub mask: u32,
}

/// ObjectPermissions
/// Field - see llpermissionsflags.h
/// If Set is true, tries to turn on bits in mask.
/// If set is false, tries to turn off bits in mask.
/// BUG: This just forces the permissions field.
#[derive(Debug)]
pub struct ObjectPermissions {
    pub agent_data: ObjectPermissions_AgentData,
    pub header_data: ObjectPermissions_HeaderData,
    pub object_data: Vec<ObjectPermissions_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectSaleInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSaleInfo_ObjectData {
    pub local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

/// set object sale information
#[derive(Debug)]
pub struct ObjectSaleInfo {
    pub agent_data: ObjectSaleInfo_AgentData,
    pub object_data: Vec<ObjectSaleInfo_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectName_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectName_ObjectData {
    pub local_id: u32,
    pub name: Vec<u8>,
}

/// set object names
#[derive(Debug)]
pub struct ObjectName {
    pub agent_data: ObjectName_AgentData,
    pub object_data: Vec<ObjectName_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDescription_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDescription_ObjectData {
    pub local_id: u32,
    pub description: Vec<u8>,
}

/// set object descriptions
#[derive(Debug)]
pub struct ObjectDescription {
    pub agent_data: ObjectDescription_AgentData,
    pub object_data: Vec<ObjectDescription_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectCategory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectCategory_ObjectData {
    pub local_id: u32,
    pub category: u32,
}

/// set object category
#[derive(Debug)]
pub struct ObjectCategory {
    pub agent_data: ObjectCategory_AgentData,
    pub object_data: Vec<ObjectCategory_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectSelect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSelect_ObjectData {
    pub object_local_id: u32,
}


#[derive(Debug)]
pub struct ObjectSelect {
    pub agent_data: ObjectSelect_AgentData,
    pub object_data: Vec<ObjectSelect_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDeselect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDeselect_ObjectData {
    pub object_local_id: u32,
}


#[derive(Debug)]
pub struct ObjectDeselect {
    pub agent_data: ObjectDeselect_AgentData,
    pub object_data: Vec<ObjectDeselect_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectAttach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub attachment_point: u8,
}

#[derive(Debug)]
pub struct ObjectAttach_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

/// ObjectAttach
#[derive(Debug)]
pub struct ObjectAttach {
    pub agent_data: ObjectAttach_AgentData,
    pub object_data: Vec<ObjectAttach_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDetach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDetach_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDetach -- derezzes an attachment, marking its item in your inventory as not "(worn)"
#[derive(Debug)]
pub struct ObjectDetach {
    pub agent_data: ObjectDetach_AgentData,
    pub object_data: Vec<ObjectDetach_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDrop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDrop_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDrop -- drops an attachment from your avatar onto the ground
#[derive(Debug)]
pub struct ObjectDrop {
    pub agent_data: ObjectDrop_AgentData,
    pub object_data: Vec<ObjectDrop_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectLink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectLink_ObjectData {
    pub object_local_id: u32,
}

/// ObjectLink
#[derive(Debug)]
pub struct ObjectLink {
    pub agent_data: ObjectLink_AgentData,
    pub object_data: Vec<ObjectLink_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDelink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDelink_ObjectData {
    pub object_local_id: u32,
}

/// ObjectDelink
#[derive(Debug)]
pub struct ObjectDelink {
    pub agent_data: ObjectDelink_AgentData,
    pub object_data: Vec<ObjectDelink_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGrab_ObjectData {
    pub local_id: u32,
    pub grab_offset: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

/// ObjectGrab
#[derive(Debug)]
pub struct ObjectGrab {
    pub agent_data: ObjectGrab_AgentData,
    pub object_data: ObjectGrab_ObjectData,
    pub surface_info: Vec<ObjectGrab_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectGrabUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGrabUpdate_ObjectData {
    pub object_id: Uuid,
    pub grab_offset_initial: Vector3<f32>,
    pub grab_position: Vector3<f32>,
    pub time_since_last: u32,
}

#[derive(Debug)]
pub struct ObjectGrabUpdate_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}


#[derive(Debug)]
pub struct ObjectGrabUpdate {
    pub agent_data: ObjectGrabUpdate_AgentData,
    pub object_data: ObjectGrabUpdate_ObjectData,
    pub surface_info: Vec<ObjectGrabUpdate_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectDeGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDeGrab_ObjectData {
    pub local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDeGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

/// ObjectDeGrab
#[derive(Debug)]
pub struct ObjectDeGrab {
    pub agent_data: ObjectDeGrab_AgentData,
    pub object_data: ObjectDeGrab_ObjectData,
    pub surface_info: Vec<ObjectDeGrab_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectSpinStart_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStart_ObjectData {
    pub object_id: Uuid,
}

/// ObjectSpinStart
#[derive(Debug)]
pub struct ObjectSpinStart {
    pub agent_data: ObjectSpinStart_AgentData,
    pub object_data: ObjectSpinStart_ObjectData,
}


#[derive(Debug)]
pub struct ObjectSpinUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinUpdate_ObjectData {
    pub object_id: Uuid,
    pub rotation: Quaternion<f32>,
}

/// ObjectSpinUpdate
#[derive(Debug)]
pub struct ObjectSpinUpdate {
    pub agent_data: ObjectSpinUpdate_AgentData,
    pub object_data: ObjectSpinUpdate_ObjectData,
}


#[derive(Debug)]
pub struct ObjectSpinStop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStop_ObjectData {
    pub object_id: Uuid,
}

/// ObjectSpinStop
#[derive(Debug)]
pub struct ObjectSpinStop {
    pub agent_data: ObjectSpinStop_AgentData,
    pub object_data: ObjectSpinStop_ObjectData,
}


#[derive(Debug)]
pub struct ObjectExportSelected_AgentData {
    pub agent_id: Uuid,
    pub request_id: Uuid,
    pub volume_detail: i16,
}

#[derive(Debug)]
pub struct ObjectExportSelected_ObjectData {
    pub object_id: Uuid,
}

/// Export selected objects
/// viewer->sim
#[derive(Debug)]
pub struct ObjectExportSelected {
    pub agent_data: ObjectExportSelected_AgentData,
    pub object_data: Vec<ObjectExportSelected_ObjectData>,
}


#[derive(Debug)]
pub struct ModifyLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ModifyLand_ModifyBlock {
    pub action: u8,
    pub brush_size: u8,
    pub seconds: f32,
    pub height: f32,
}

#[derive(Debug)]
pub struct ModifyLand_ParcelData {
    pub local_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

#[derive(Debug)]
pub struct ModifyLand_ModifyBlockExtended {
    pub brush_size: f32,
}

/// ModifyLand - sent to modify a piece of land on a simulator.
/// viewer -> sim
#[derive(Debug)]
pub struct ModifyLand {
    pub agent_data: ModifyLand_AgentData,
    pub modify_block: ModifyLand_ModifyBlock,
    pub parcel_data: Vec<ModifyLand_ParcelData>,
    pub modify_block_extended: Vec<ModifyLand_ModifyBlockExtended>,
}


#[derive(Debug)]
pub struct VelocityInterpolateOn_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// VelocityInterpolateOn
/// viewer->sim
/// requires administrative access
#[derive(Debug)]
pub struct VelocityInterpolateOn {
    pub agent_data: VelocityInterpolateOn_AgentData,
}


#[derive(Debug)]
pub struct VelocityInterpolateOff_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// VelocityInterpolateOff
/// viewer->sim
/// requires administrative access
#[derive(Debug)]
pub struct VelocityInterpolateOff {
    pub agent_data: VelocityInterpolateOff_AgentData,
}


#[derive(Debug)]
pub struct StateSave_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StateSave_DataBlock {
    pub filename: Vec<u8>,
}

/// Save State
/// viewer->sim
/// requires administrative access
#[derive(Debug)]
pub struct StateSave {
    pub agent_data: StateSave_AgentData,
    pub data_block: StateSave_DataBlock,
}


#[derive(Debug)]
pub struct ReportAutosaveCrash_AutosaveData {
    pub pid: i32,
    pub status: i32,
}

/// ReportAutosaveCrash
/// sim->launcher
#[derive(Debug)]
pub struct ReportAutosaveCrash {
    pub autosave_data: ReportAutosaveCrash_AutosaveData,
}


#[derive(Debug)]
pub struct SimWideDeletes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SimWideDeletes_DataBlock {
    pub target_id: Uuid,
    pub flags: u32,
}

/// SimWideDeletes
#[derive(Debug)]
pub struct SimWideDeletes {
    pub agent_data: SimWideDeletes_AgentData,
    pub data_block: SimWideDeletes_DataBlock,
}


#[derive(Debug)]
pub struct RequestObjectPropertiesFamily_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
}

/// RequestObjectPropertiesFamily
/// Ask for extended information, such as creator, permissions, resources, etc.
/// Medium frequency because it is driven by mouse hovering over objects, which
/// occurs at high rates.
#[derive(Debug)]
pub struct RequestObjectPropertiesFamily {
    pub agent_data: RequestObjectPropertiesFamily_AgentData,
    pub object_data: RequestObjectPropertiesFamily_ObjectData,
}


#[derive(Debug)]
pub struct TrackAgent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TrackAgent_TargetData {
    pub prey_id: Uuid,
}

/// Track agent - this information is used when sending out the
/// coarse location update so that we know who you are tracking.
/// To stop tracking - send a null uuid as the prey.
#[derive(Debug)]
pub struct TrackAgent {
    pub agent_data: TrackAgent_AgentData,
    pub target_data: TrackAgent_TargetData,
}


#[derive(Debug)]
pub struct ViewerStats_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub ip: Ip4Addr,
    pub start_time: u32,
    pub run_time: f32,
    pub sim_fps: f32,
    pub fps: f32,
    pub agents_in_view: u8,
    pub ping: f32,
    pub meters_traveled: f64,
    pub regions_visited: i32,
    pub sys_ram: u32,
    pub sys_os: Vec<u8>,
    pub sys_cpu: Vec<u8>,
    pub sys_gpu: Vec<u8>,
}

#[derive(Debug)]
pub struct ViewerStats_DownloadTotals {
    pub world: u32,
    pub objects: u32,
    pub textures: u32,
}

#[derive(Debug)]
pub struct ViewerStats_NetStats {
    pub bytes: u32,
    pub packets: u32,
    pub compressed: u32,
    pub savings: u32,
}

#[derive(Debug)]
pub struct ViewerStats_FailStats {
    pub send_packet: u32,
    pub dropped: u32,
    pub resent: u32,
    pub failed_resends: u32,
    pub off_circuit: u32,
    pub invalid: u32,
}

#[derive(Debug)]
pub struct ViewerStats_MiscStats {
    pub type_: u32,
    pub value: f64,
}


#[derive(Debug)]
pub struct ViewerStats {
    pub agent_data: ViewerStats_AgentData,
    pub download_totals: ViewerStats_DownloadTotals,
    pub net_stats: [ViewerStats_NetStats; 2],
    pub fail_stats: ViewerStats_FailStats,
    pub misc_stats: Vec<ViewerStats_MiscStats>,
}


#[derive(Debug)]
pub struct ScriptAnswerYes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptAnswerYes_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub questions: i32,
}

/// ScriptAnswerYes
/// reliable
#[derive(Debug)]
pub struct ScriptAnswerYes {
    pub agent_data: ScriptAnswerYes_AgentData,
    pub data: ScriptAnswerYes_Data,
}


#[derive(Debug)]
pub struct UserReport_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UserReport_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub position: Vector3<f32>,
    pub check_flags: u8,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

/// complaint/bug-report
/// reliable
#[derive(Debug)]
pub struct UserReport {
    pub agent_data: UserReport_AgentData,
    pub report_data: UserReport_ReportData,
}


#[derive(Debug)]
pub struct AlertMessage_AlertData {
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct AlertMessage_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

/// AlertMessage
/// Specifies the text to be posted in an alert dialog
#[derive(Debug)]
pub struct AlertMessage {
    pub alert_data: AlertMessage_AlertData,
    pub alert_info: Vec<AlertMessage_AlertInfo>,
}


#[derive(Debug)]
pub struct AgentAlertMessage_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AgentAlertMessage_AlertData {
    pub modal: bool,
    pub message: Vec<u8>,
}

/// Send an AlertMessage to the named agent.
/// usually dataserver->simulator
#[derive(Debug)]
pub struct AgentAlertMessage {
    pub agent_data: AgentAlertMessage_AgentData,
    pub alert_data: AgentAlertMessage_AlertData,
}


#[derive(Debug)]
pub struct MeanCollisionAlert_MeanCollision {
    pub victim: Uuid,
    pub perp: Uuid,
    pub time: u32,
    pub mag: f32,
    pub type_: u8,
}

/// MeanCollisionAlert
/// Specifies the text to be posted in an alert dialog
#[derive(Debug)]
pub struct MeanCollisionAlert {
    pub mean_collision: Vec<MeanCollisionAlert_MeanCollision>,
}


#[derive(Debug)]
pub struct ViewerFrozenMessage_FrozenData {
    pub data: bool,
}

/// ViewerFrozenMessage
/// Specifies the text to be posted in an alert dialog
#[derive(Debug)]
pub struct ViewerFrozenMessage {
    pub frozen_data: ViewerFrozenMessage_FrozenData,
}


#[derive(Debug)]
pub struct HealthMessage_HealthData {
    pub health: f32,
}

/// Health Message
/// Tells viewer what agent health is
#[derive(Debug)]
pub struct HealthMessage {
    pub health_data: HealthMessage_HealthData,
}


#[derive(Debug)]
pub struct ChatFromSimulator_ChatData {
    pub from_name: Vec<u8>,
    pub source_id: Uuid,
    pub owner_id: Uuid,
    pub source_type: u8,
    pub chat_type: u8,
    pub audible: u8,
    pub position: Vector3<f32>,
    pub message: Vec<u8>,
}

/// ChatFromSimulator
/// Chat text to appear on a user's screen
/// Position is region local.
/// Viewer can optionally use position to animate
/// If audible is CHAT_NOT_AUDIBLE, message will not be valid
#[derive(Debug)]
pub struct ChatFromSimulator {
    pub chat_data: ChatFromSimulator_ChatData,
}


#[derive(Debug)]
pub struct SimStats_Region {
    pub region_x: u32,
    pub region_y: u32,
    pub region_flags: u32,
    pub object_capacity: u32,
}

#[derive(Debug)]
pub struct SimStats_Stat {
    pub stat_id: u32,
    pub stat_value: f32,
}

#[derive(Debug)]
pub struct SimStats_PidStat {
    pub pid: i32,
}

/// Simulator statistics packet (goes out to viewer and dataserver/spaceserver)
#[derive(Debug)]
pub struct SimStats {
    pub region: SimStats_Region,
    pub stat: Vec<SimStats_Stat>,
    pub pid_stat: SimStats_PidStat,
}


#[derive(Debug)]
pub struct RequestRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct RequestRegionInfo {
    pub agent_data: RequestRegionInfo_AgentData,
}


#[derive(Debug)]
pub struct RegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub sim_access: u8,
    pub max_agents: u8,
    pub billable_factor: f32,
    pub object_bonus_factor: f32,
    pub water_height: f32,
    pub terrain_raise_limit: f32,
    pub terrain_lower_limit: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
    pub use_estate_sun: bool,
    pub sun_hour: f32,
}

#[derive(Debug)]
pub struct RegionInfo_RegionInfo2 {
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
    pub max_agents32: u32,
    pub hard_max_agents: u32,
    pub hard_max_objects: u32,
}

/// RegionInfo
/// Used to populate UI for both region/estate floater
/// and god tools floater
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct RegionInfo {
    pub agent_data: RegionInfo_AgentData,
    pub region_info: RegionInfo_RegionInfo,
    pub region_info2: RegionInfo_RegionInfo2,
}


#[derive(Debug)]
pub struct GodUpdateRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GodUpdateRegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub billable_factor: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
}

/// GodUpdateRegionInfo
/// Sent from viewer to sim after a god has changed some
/// of the parameters in the god tools floater
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct GodUpdateRegionInfo {
    pub agent_data: GodUpdateRegionInfo_AgentData,
    pub region_info: GodUpdateRegionInfo_RegionInfo,
}


#[derive(Debug)]
pub struct NearestLandingRegionRequest_RequestingRegionData {
    pub region_handle: u64,
}

///NearestLandingRegionRequest
///sim->dataserver
///Sent from the region to the data server
///to request the most up to date region for the requesting
///region to redirect teleports to
#[derive(Debug)]
pub struct NearestLandingRegionRequest {
    pub requesting_region_data: NearestLandingRegionRequest_RequestingRegionData,
}


#[derive(Debug)]
pub struct NearestLandingRegionReply_LandingRegionData {
    pub region_handle: u64,
}

///NearestLandingPointReply
///dataserver->sim
///Sent from the data server to a region in reply
///to the redirectregion request stating which region
///the requesting region should redirect teleports to if necessary
#[derive(Debug)]
pub struct NearestLandingRegionReply {
    pub landing_region_data: NearestLandingRegionReply_LandingRegionData,
}


#[derive(Debug)]
pub struct NearestLandingRegionUpdated_RegionData {
    pub region_handle: u64,
}

///NearestLandingPointUpdated
///sim->dataserver
///Sent from a region to the data server
///to have the dataserver note/clear in the db
///that the region has updated it's nearest landing point
#[derive(Debug)]
pub struct NearestLandingRegionUpdated {
    pub region_data: NearestLandingRegionUpdated_RegionData,
}


#[derive(Debug)]
pub struct TeleportLandingStatusChanged_RegionData {
    pub region_handle: u64,
}

///TeleportLandingStatusChanged
///sim->dataserver
///Sent from the region to the data server
///to note that the region's teleportation landing status has changed
#[derive(Debug)]
pub struct TeleportLandingStatusChanged {
    pub region_data: TeleportLandingStatusChanged_RegionData,
}


#[derive(Debug)]
pub struct RegionHandshake_RegionInfo {
    pub region_flags: u32,
    pub sim_access: u8,
    pub sim_name: Vec<u8>,
    pub sim_owner: Uuid,
    pub is_estate_manager: bool,
    pub water_height: f32,
    pub billable_factor: f32,
    pub cache_id: Uuid,
    pub terrain_base0: Uuid,
    pub terrain_base1: Uuid,
    pub terrain_base2: Uuid,
    pub terrain_base3: Uuid,
    pub terrain_detail0: Uuid,
    pub terrain_detail1: Uuid,
    pub terrain_detail2: Uuid,
    pub terrain_detail3: Uuid,
    pub terrain_start_height00: f32,
    pub terrain_start_height01: f32,
    pub terrain_start_height10: f32,
    pub terrain_start_height11: f32,
    pub terrain_height_range00: f32,
    pub terrain_height_range01: f32,
    pub terrain_height_range10: f32,
    pub terrain_height_range11: f32,
}

#[derive(Debug)]
pub struct RegionHandshake_RegionInfo2 {
    pub region_id: Uuid,
}

#[derive(Debug)]
pub struct RegionHandshake_RegionInfo3 {
    pub cpu_class_id: i32,
    pub cpu_ratio: i32,
    pub colo_name: Vec<u8>,
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
}

/// RegionHandshake
/// Sent by region to viewer after it has received UseCircuitCode
/// from that viewer.
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct RegionHandshake {
    pub region_info: RegionHandshake_RegionInfo,
    pub region_info2: RegionHandshake_RegionInfo2,
    pub region_info3: RegionHandshake_RegionInfo3,
}


#[derive(Debug)]
pub struct RegionHandshakeReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RegionHandshakeReply_RegionInfo {
    pub flags: u32,
}

/// RegionHandshakeReply
/// viewer -> sim
/// reliable
/// Sent after viewer has initialized the (pre-existing)
/// LLViewerRegion with the name, access level, etc. and
/// has loaded the cache for the region.
/// After the simulator receives this, it will start sending
/// data about objects.
#[derive(Debug)]
pub struct RegionHandshakeReply {
    pub agent_data: RegionHandshakeReply_AgentData,
    pub region_info: RegionHandshakeReply_RegionInfo,
}


#[derive(Debug)]
pub struct CoarseLocationUpdate_Location {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}

#[derive(Debug)]
pub struct CoarseLocationUpdate_Index {
    pub you: i16,
    pub prey: i16,
}

#[derive(Debug)]
pub struct CoarseLocationUpdate_AgentData {
    pub agent_id: Uuid,
}

/// The CoarseLocationUpdate message is sent to notify the viewer of
/// the location of mappable objects in the region. 1 meter resolution is
/// sufficient for this. The index block is used to show where you are,
/// and where someone you are tracking is located. They are -1 if not
/// applicable.
#[derive(Debug)]
pub struct CoarseLocationUpdate {
    pub location: Vec<CoarseLocationUpdate_Location>,
    pub index: CoarseLocationUpdate_Index,
    pub agent_data: Vec<CoarseLocationUpdate_AgentData>,
}


#[derive(Debug)]
pub struct ImageData_ImageID {
    pub id: Uuid,
    pub codec: u8,
    pub size: u32,
    pub packets: u16,
}

#[derive(Debug)]
pub struct ImageData_ImageData {
    pub data: Vec<u8>,
}

/// ImageData - sent to viewer to transmit information about an image
#[derive(Debug)]
pub struct ImageData {
    pub image_id: ImageData_ImageID,
    pub image_data: ImageData_ImageData,
}


#[derive(Debug)]
pub struct ImagePacket_ImageID {
    pub id: Uuid,
    pub packet: u16,
}

#[derive(Debug)]
pub struct ImagePacket_ImageData {
    pub data: Vec<u8>,
}

/// ImagePacket - follow on image data for images having > 1 packet of data
#[derive(Debug)]
pub struct ImagePacket {
    pub image_id: ImagePacket_ImageID,
    pub image_data: ImagePacket_ImageData,
}


#[derive(Debug)]
pub struct LayerData_LayerID {
    pub type_: u8,
}

#[derive(Debug)]
pub struct LayerData_LayerData {
    pub data: Vec<u8>,
}


#[derive(Debug)]
pub struct LayerData {
    pub layer_id: LayerData_LayerID,
    pub layer_data: LayerData_LayerData,
}


#[derive(Debug)]
pub struct ObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdate_ObjectData {
    pub id: u32,
    pub state: u8,
    pub full_id: Uuid,
    pub crc: u32,
    pub p_code: u8,
    pub material: u8,
    pub click_action: u8,
    pub scale: Vector3<f32>,
    pub object_data: Vec<u8>,
    pub parent_id: u32,
    pub update_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub texture_entry: Vec<u8>,
    pub texture_anim: Vec<u8>,
    pub name_value: Vec<u8>,
    pub data: Vec<u8>,
    pub text: Vec<u8>,
    pub text_color: [u8; 4],
    pub media_url: Vec<u8>,
    pub ps_block: Vec<u8>,
    pub extra_params: Vec<u8>,
    pub sound: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
    pub radius: f32,
    pub joint_type: u8,
    pub joint_pivot: Vector3<f32>,
    pub joint_axis_or_anchor: Vector3<f32>,
}

/// joint info -- is sent in the update of each joint-child-root
#[derive(Debug)]
pub struct ObjectUpdate {
    pub region_data: ObjectUpdate_RegionData,
    pub object_data: Vec<ObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectUpdateCompressed_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdateCompressed_ObjectData {
    pub update_flags: u32,
    pub data: Vec<u8>,
}

/// ObjectUpdateCompressed
#[derive(Debug)]
pub struct ObjectUpdateCompressed {
    pub region_data: ObjectUpdateCompressed_RegionData,
    pub object_data: Vec<ObjectUpdateCompressed_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectUpdateCached_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdateCached_ObjectData {
    pub id: u32,
    pub crc: u32,
    pub update_flags: u32,
}

/// ObjectUpdateCached
/// reliable
#[derive(Debug)]
pub struct ObjectUpdateCached {
    pub region_data: ObjectUpdateCached_RegionData,
    pub object_data: Vec<ObjectUpdateCached_ObjectData>,
}


#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate_ObjectData {
    pub data: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

/// packed terse object update format
#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate {
    pub region_data: ImprovedTerseObjectUpdate_RegionData,
    pub object_data: Vec<ImprovedTerseObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct KillObject_ObjectData {
    pub id: u32,
}


#[derive(Debug)]
pub struct KillObject {
    pub object_data: Vec<KillObject_ObjectData>,
}


#[derive(Debug)]
pub struct CrossedRegion_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CrossedRegion_RegionData {
    pub sim_ip: Ip4Addr,
    pub sim_port: IpPort,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
}

#[derive(Debug)]
pub struct CrossedRegion_Info {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

/// CrossedRegion - new way to tell a viewer it has gone across a region
/// boundary
#[derive(Debug)]
pub struct CrossedRegion {
    pub agent_data: CrossedRegion_AgentData,
    pub region_data: CrossedRegion_RegionData,
    pub info: CrossedRegion_Info,
}


#[derive(Debug)]
pub struct SimulatorViewerTimeMessage_TimeInfo {
    pub usec_since_start: u64,
    pub sec_per_day: u32,
    pub sec_per_year: u32,
    pub sun_direction: Vector3<f32>,
    pub sun_phase: f32,
    pub sun_ang_velocity: Vector3<f32>,
}


#[derive(Debug)]
pub struct SimulatorViewerTimeMessage {
    pub time_info: SimulatorViewerTimeMessage_TimeInfo,
}


#[derive(Debug)]
pub struct EnableSimulator_SimulatorInfo {
    pub handle: u64,
    pub ip: Ip4Addr,
    pub port: IpPort,
}


#[derive(Debug)]
pub struct EnableSimulator {
    pub simulator_info: EnableSimulator_SimulatorInfo,
}



#[derive(Debug)]
pub struct DisableSimulator {}


#[derive(Debug)]
pub struct ConfirmEnableSimulator_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}


#[derive(Debug)]
pub struct ConfirmEnableSimulator {
    pub agent_data: ConfirmEnableSimulator_AgentData,
}


#[derive(Debug)]
pub struct TransferRequest_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub source_type: i32,
    pub priority: f32,
    pub params: Vec<u8>,
}

/// Request a new transfer (target->source)
#[derive(Debug)]
pub struct TransferRequest {
    pub transfer_info: TransferRequest_TransferInfo,
}


#[derive(Debug)]
pub struct TransferInfo_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub target_type: i32,
    pub status: i32,
    pub size: i32,
    pub params: Vec<u8>,
}

/// Return info about a transfer/initiate transfer (source->target)
/// Possibly should have a Params field like above
#[derive(Debug)]
pub struct TransferInfo {
    pub transfer_info: TransferInfo_TransferInfo,
}


#[derive(Debug)]
pub struct TransferPacket_TransferData {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub packet: i32,
    pub status: i32,
    pub data: Vec<u8>,
}


#[derive(Debug)]
pub struct TransferPacket {
    pub transfer_data: TransferPacket_TransferData,
}


#[derive(Debug)]
pub struct TransferAbort_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
}

/// Abort a transfer in progress (either from target->source or source->target)
#[derive(Debug)]
pub struct TransferAbort {
    pub transfer_info: TransferAbort_TransferInfo,
}


#[derive(Debug)]
pub struct RequestXfer_XferID {
    pub id: u64,
    pub filename: Vec<u8>,
    pub file_path: u8,
    pub delete_on_completion: bool,
    pub use_big_packets: bool,
    pub v_file_id: Uuid,
    pub v_file_type: i16,
}

/// RequestXfer - request an arbitrary xfer
#[derive(Debug)]
pub struct RequestXfer {
    pub xfer_id: RequestXfer_XferID,
}


#[derive(Debug)]
pub struct SendXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

#[derive(Debug)]
pub struct SendXferPacket_DataPacket {
    pub data: Vec<u8>,
}

/// SendXferPacket - send an additional packet of an arbitrary xfer from sim -> viewer
#[derive(Debug)]
pub struct SendXferPacket {
    pub xfer_id: SendXferPacket_XferID,
    pub data_packet: SendXferPacket_DataPacket,
}


#[derive(Debug)]
pub struct ConfirmXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

/// ConfirmXferPacket
#[derive(Debug)]
pub struct ConfirmXferPacket {
    pub xfer_id: ConfirmXferPacket_XferID,
}


#[derive(Debug)]
pub struct AbortXfer_XferID {
    pub id: u64,
    pub result: i32,
}

/// AbortXfer
#[derive(Debug)]
pub struct AbortXfer {
    pub xfer_id: AbortXfer_XferID,
}


#[derive(Debug)]
pub struct AvatarAnimation_Sender {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct AvatarAnimation_AnimationList {
    pub anim_id: Uuid,
    pub anim_sequence_id: i32,
}

#[derive(Debug)]
pub struct AvatarAnimation_AnimationSourceList {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}


#[derive(Debug)]
pub struct AvatarAnimation {
    pub sender: AvatarAnimation_Sender,
    pub animation_list: Vec<AvatarAnimation_AnimationList>,
    pub animation_source_list: Vec<AvatarAnimation_AnimationSourceList>,
    pub physical_avatar_event_list: Vec<AvatarAnimation_PhysicalAvatarEventList>,
}


#[derive(Debug)]
pub struct AvatarAppearance_Sender {
    pub id: Uuid,
    pub is_trial: bool,
}

#[derive(Debug)]
pub struct AvatarAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarAppearance_VisualParam {
    pub param_value: u8,
}

/// AvatarAppearance - Update visual params
#[derive(Debug)]
pub struct AvatarAppearance {
    pub sender: AvatarAppearance_Sender,
    pub object_data: AvatarAppearance_ObjectData,
    pub visual_param: Vec<AvatarAppearance_VisualParam>,
}


#[derive(Debug)]
pub struct AvatarSitResponse_SitObject {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct AvatarSitResponse_SitTransform {
    pub auto_pilot: bool,
    pub sit_position: Vector3<f32>,
    pub sit_rotation: Quaternion<f32>,
    pub camera_eye_offset: Vector3<f32>,
    pub camera_at_offset: Vector3<f32>,
    pub force_mouselook: bool,
}

/// AvatarSitResponse - response to a request to sit on an object
#[derive(Debug)]
pub struct AvatarSitResponse {
    pub sit_object: AvatarSitResponse_SitObject,
    pub sit_transform: AvatarSitResponse_SitTransform,
}


#[derive(Debug)]
pub struct SetFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct SetFollowCamProperties_CameraProperty {
    pub type_: i32,
    pub value: f32,
}

/// SetFollowCamProperties
#[derive(Debug)]
pub struct SetFollowCamProperties {
    pub object_data: SetFollowCamProperties_ObjectData,
    pub camera_property: Vec<SetFollowCamProperties_CameraProperty>,
}


#[derive(Debug)]
pub struct ClearFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

/// ClearFollowCamProperties
#[derive(Debug)]
pub struct ClearFollowCamProperties {
    pub object_data: ClearFollowCamProperties_ObjectData,
}


#[derive(Debug)]
pub struct CameraConstraint_CameraCollidePlane {
    pub plane: Vector4<f32>,
}

/// CameraConstraint - new camera distance limit (based on collision with objects)
#[derive(Debug)]
pub struct CameraConstraint {
    pub camera_collide_plane: CameraConstraint_CameraCollidePlane,
}


#[derive(Debug)]
pub struct ObjectProperties_ObjectData {
    pub object_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub creation_date: u64,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub aggregate_perms: u8,
    pub aggregate_perm_textures: u8,
    pub aggregate_perm_textures_owner: u8,
    pub category: u32,
    pub inventory_serial: i16,
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub from_task_id: Uuid,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub touch_name: Vec<u8>,
    pub sit_name: Vec<u8>,
    pub texture_id: Vec<u8>,
}

/// ObjectProperties
/// Extended information such as creator, permissions, etc.
/// Medium because potentially driven by mouse hover events.
///		{	TaxRate			F32	}	// F32
#[derive(Debug)]
pub struct ObjectProperties {
    pub object_data: Vec<ObjectProperties_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub category: u32,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

/// ObjectPropertiesFamily
/// Medium because potentially driven by mouse hover events.
#[derive(Debug)]
pub struct ObjectPropertiesFamily {
    pub object_data: ObjectPropertiesFamily_ObjectData,
}


#[derive(Debug)]
pub struct RequestPayPrice_ObjectData {
    pub object_id: Uuid,
}

/// RequestPayPrice
/// viewer -> sim
#[derive(Debug)]
pub struct RequestPayPrice {
    pub object_data: RequestPayPrice_ObjectData,
}


#[derive(Debug)]
pub struct PayPriceReply_ObjectData {
    pub object_id: Uuid,
    pub default_pay_price: i32,
}

#[derive(Debug)]
pub struct PayPriceReply_ButtonData {
    pub pay_button: i32,
}


#[derive(Debug)]
pub struct PayPriceReply {
    pub object_data: PayPriceReply_ObjectData,
    pub button_data: Vec<PayPriceReply_ButtonData>,
}


#[derive(Debug)]
pub struct KickUser_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: IpPort,
}

#[derive(Debug)]
pub struct KickUser_UserInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub reason: Vec<u8>,
}

/// KickUser
/// *FIXME*
/// Kick off a logged-in user, such as when two people log in with the
/// same account name.
/// ROUTED dataserver -> userserver -> spaceserver -> simulator -> viewer
/// reliable, but that may not matter if a system component is quitting
#[derive(Debug)]
pub struct KickUser {
    pub target_block: KickUser_TargetBlock,
    pub user_info: KickUser_UserInfo,
}


#[derive(Debug)]
pub struct KickUserAck_UserInfo {
    pub session_id: Uuid,
    pub flags: u32,
}

/// ack sent from the simulator up to the main database so that login
/// can continue.
#[derive(Debug)]
pub struct KickUserAck {
    pub user_info: KickUserAck_UserInfo,
}


#[derive(Debug)]
pub struct GodKickUser_UserInfo {
    pub god_id: Uuid,
    pub god_session_id: Uuid,
    pub agent_id: Uuid,
    pub kick_flags: u32,
    pub reason: Vec<u8>,
}

/// GodKickUser
/// When a god wants someone kicked
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct GodKickUser {
    pub user_info: GodKickUser_UserInfo,
}


#[derive(Debug)]
pub struct SystemKickUser_AgentInfo {
    pub agent_id: Uuid,
}

/// SystemKickUser
/// user->space, reliable
#[derive(Debug)]
pub struct SystemKickUser {
    pub agent_info: Vec<SystemKickUser_AgentInfo>,
}


#[derive(Debug)]
pub struct EjectUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EjectUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

/// EjectUser
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct EjectUser {
    pub agent_data: EjectUser_AgentData,
    pub data: EjectUser_Data,
}


#[derive(Debug)]
pub struct FreezeUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FreezeUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

/// FreezeUser
/// Freeze someone who is on my land.
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct FreezeUser {
    pub agent_data: FreezeUser_AgentData,
    pub data: FreezeUser_Data,
}


#[derive(Debug)]
pub struct AvatarPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub avatar_id: Uuid,
}

/// AvatarPropertiesRequest
/// viewer -> simulator
/// reliable
#[derive(Debug)]
pub struct AvatarPropertiesRequest {
    pub agent_data: AvatarPropertiesRequest_AgentData,
}


#[derive(Debug)]
pub struct AvatarPropertiesRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
    pub god_level: u8,
    pub web_profiles_disabled: bool,
}

/// AvatarPropertiesRequestBackend
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct AvatarPropertiesRequestBackend {
    pub agent_data: AvatarPropertiesRequestBackend_AgentData,
}


#[derive(Debug)]
pub struct AvatarPropertiesReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPropertiesReply_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub partner_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub born_on: Vec<u8>,
    pub profile_url: Vec<u8>,
    pub charter_member: Vec<u8>,
    pub flags: u32,
}

/// AvatarPropertiesReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AvatarPropertiesReply {
    pub agent_data: AvatarPropertiesReply_AgentData,
    pub properties_data: AvatarPropertiesReply_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarInterestsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarInterestsReply_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}


#[derive(Debug)]
pub struct AvatarInterestsReply {
    pub agent_data: AvatarInterestsReply_AgentData,
    pub properties_data: AvatarInterestsReply_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarGroupsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarGroupsReply_GroupData {
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_title: Vec<u8>,
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub group_insignia_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarGroupsReply_NewGroupData {
    pub list_in_profile: bool,
}

/// AvatarGroupsReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AvatarGroupsReply {
    pub agent_data: AvatarGroupsReply_AgentData,
    pub group_data: Vec<AvatarGroupsReply_GroupData>,
    pub new_group_data: AvatarGroupsReply_NewGroupData,
}


#[derive(Debug)]
pub struct AvatarPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPropertiesUpdate_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub profile_url: Vec<u8>,
}

/// AvatarPropertiesUpdate
/// viewer -> simulator
/// reliable
#[derive(Debug)]
pub struct AvatarPropertiesUpdate {
    pub agent_data: AvatarPropertiesUpdate_AgentData,
    pub properties_data: AvatarPropertiesUpdate_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarInterestsUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarInterestsUpdate_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}

/// AvatarInterestsUpdate
/// viewer -> simulator
/// reliable
#[derive(Debug)]
pub struct AvatarInterestsUpdate {
    pub agent_data: AvatarInterestsUpdate_AgentData,
    pub properties_data: AvatarInterestsUpdate_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarNotesReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarNotesReply_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

/// AvatarNotesReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AvatarNotesReply {
    pub agent_data: AvatarNotesReply_AgentData,
    pub data: AvatarNotesReply_Data,
}


#[derive(Debug)]
pub struct AvatarNotesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarNotesUpdate_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

/// AvatarNotesUpdate
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct AvatarNotesUpdate {
    pub agent_data: AvatarNotesUpdate_AgentData,
    pub data: AvatarNotesUpdate_Data,
}


#[derive(Debug)]
pub struct AvatarPicksReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPicksReply_Data {
    pub pick_id: Uuid,
    pub pick_name: Vec<u8>,
}

/// AvatarPicksReply
/// dataserver -> simulator -> viewer
/// Send the header information for this avatar's picks
/// This fills in the tabs of the Picks panel.
/// reliable
#[derive(Debug)]
pub struct AvatarPicksReply {
    pub agent_data: AvatarPicksReply_AgentData,
    pub data: Vec<AvatarPicksReply_Data>,
}


#[derive(Debug)]
pub struct EventInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventInfoRequest_EventData {
    pub event_id: u32,
}

/// EventInfoRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct EventInfoRequest {
    pub agent_data: EventInfoRequest_AgentData,
    pub event_data: EventInfoRequest_EventData,
}


#[derive(Debug)]
pub struct EventInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct EventInfoReply_EventData {
    pub event_id: u32,
    pub creator: Vec<u8>,
    pub name: Vec<u8>,
    pub category: Vec<u8>,
    pub desc: Vec<u8>,
    pub date: Vec<u8>,
    pub date_utc: u32,
    pub duration: u32,
    pub cover: u32,
    pub amount: u32,
    pub sim_name: Vec<u8>,
    pub global_pos: Vector3<f64>,
    pub event_flags: u32,
}

/// EventInfoReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct EventInfoReply {
    pub agent_data: EventInfoReply_AgentData,
    pub event_data: EventInfoReply_EventData,
}


#[derive(Debug)]
pub struct EventNotificationAddRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventNotificationAddRequest_EventData {
    pub event_id: u32,
}

/// EventNotificationAddRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct EventNotificationAddRequest {
    pub agent_data: EventNotificationAddRequest_AgentData,
    pub event_data: EventNotificationAddRequest_EventData,
}


#[derive(Debug)]
pub struct EventNotificationRemoveRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventNotificationRemoveRequest_EventData {
    pub event_id: u32,
}

/// EventNotificationRemoveRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct EventNotificationRemoveRequest {
    pub agent_data: EventNotificationRemoveRequest_AgentData,
    pub event_data: EventNotificationRemoveRequest_EventData,
}


#[derive(Debug)]
pub struct EventGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventGodDelete_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventGodDelete_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

/// EventGodDelete
/// viewer -> simulator
/// simulator -> dataserver
/// QueryData is used to resend a search result after the deletion
/// reliable
#[derive(Debug)]
pub struct EventGodDelete {
    pub agent_data: EventGodDelete_AgentData,
    pub event_data: EventGodDelete_EventData,
    pub query_data: EventGodDelete_QueryData,
}


#[derive(Debug)]
pub struct PickInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct PickInfoReply_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub user: Vec<u8>,
    pub original_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

/// PickInfoReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct PickInfoReply {
    pub agent_data: PickInfoReply_AgentData,
    pub data: PickInfoReply_Data,
}


#[derive(Debug)]
pub struct PickInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickInfoUpdate_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

/// PickInfoUpdate
/// Update a pick.  ParcelID is set on the simulator as the message
/// passes through.
/// If TopPick is TRUE, the simulator will only pass on the message
/// if the agent_id is a god.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct PickInfoUpdate {
    pub agent_data: PickInfoUpdate_AgentData,
    pub data: PickInfoUpdate_Data,
}


#[derive(Debug)]
pub struct PickDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickDelete_Data {
    pub pick_id: Uuid,
}

/// PickDelete
/// Delete a non-top pick from the database.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct PickDelete {
    pub agent_data: PickDelete_AgentData,
    pub data: PickDelete_Data,
}


#[derive(Debug)]
pub struct PickGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickGodDelete_Data {
    pub pick_id: Uuid,
    pub query_id: Uuid,
}

/// PickGodDelete
/// Delete a pick from the database.
/// QueryID is needed so database can send a repeat list of
/// picks.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct PickGodDelete {
    pub agent_data: PickGodDelete_AgentData,
    pub data: PickGodDelete_Data,
}


#[derive(Debug)]
pub struct ScriptQuestion_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub object_name: Vec<u8>,
    pub object_owner: Vec<u8>,
    pub questions: i32,
}

/// ScriptQuestion
/// reliable
#[derive(Debug)]
pub struct ScriptQuestion {
    pub data: ScriptQuestion_Data,
}


#[derive(Debug)]
pub struct ScriptControlChange_Data {
    pub take_controls: bool,
    pub controls: u32,
    pub pass_to_agent: bool,
}

/// ScriptControlChange
/// reliable
#[derive(Debug)]
pub struct ScriptControlChange {
    pub data: Vec<ScriptControlChange_Data>,
}


#[derive(Debug)]
pub struct ScriptDialog_Data {
    pub object_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub object_name: Vec<u8>,
    pub message: Vec<u8>,
    pub chat_channel: i32,
    pub image_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptDialog_Buttons {
    pub button_label: Vec<u8>,
}

#[derive(Debug)]
pub struct ScriptDialog_OwnerData {
    pub owner_id: Uuid,
}

/// ScriptDialog
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct ScriptDialog {
    pub data: ScriptDialog_Data,
    pub buttons: Vec<ScriptDialog_Buttons>,
    pub owner_data: Vec<ScriptDialog_OwnerData>,
}


#[derive(Debug)]
pub struct ScriptDialogReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptDialogReply_Data {
    pub object_id: Uuid,
    pub chat_channel: i32,
    pub button_index: i32,
    pub button_label: Vec<u8>,
}

/// ScriptDialogReply
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ScriptDialogReply {
    pub agent_data: ScriptDialogReply_AgentData,
    pub data: ScriptDialogReply_Data,
}


#[derive(Debug)]
pub struct ForceScriptControlRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// ForceScriptControlRelease
/// reliable
#[derive(Debug)]
pub struct ForceScriptControlRelease {
    pub agent_data: ForceScriptControlRelease_AgentData,
}


#[derive(Debug)]
pub struct RevokePermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RevokePermissions_Data {
    pub object_id: Uuid,
    pub object_permissions: u32,
}

/// RevokePermissions
/// reliable
#[derive(Debug)]
pub struct RevokePermissions {
    pub agent_data: RevokePermissions_AgentData,
    pub data: RevokePermissions_Data,
}


#[derive(Debug)]
pub struct LoadURL_Data {
    pub object_name: Vec<u8>,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub owner_is_group: bool,
    pub message: Vec<u8>,
    pub url: Vec<u8>,
}

/// LoadURL
/// sim -> viewer
/// Ask the user if they would like to load a URL
/// reliable
#[derive(Debug)]
pub struct LoadURL {
    pub data: LoadURL_Data,
}


#[derive(Debug)]
pub struct ScriptTeleportRequest_Data {
    pub object_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub sim_position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

/// ScriptTeleportRequest
/// reliable
#[derive(Debug)]
pub struct ScriptTeleportRequest {
    pub data: ScriptTeleportRequest_Data,
}


#[derive(Debug)]
pub struct ParcelOverlay_ParcelData {
    pub sequence_id: i32,
    pub data: Vec<u8>,
}

/// ParcelOverlay
/// We send N packets per region to the viewer.
/// N = 4, currently.  At 256x256 meter regions, 4x4 meter parcel grid,
/// there are 4096 parcel units per region.  At N = 4, that's 1024 units
/// per packet, allowing 8 bit bytes.
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct ParcelOverlay {
    pub parcel_data: ParcelOverlay_ParcelData,
}


#[derive(Debug)]
pub struct ParcelPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequest_ParcelData {
    pub sequence_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
    pub snap_selection: bool,
}

/// ParcelPropertiesRequest
/// SequenceID should be -1 or -2, and is echoed back in the
/// parcel properties message.
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelPropertiesRequest {
    pub agent_data: ParcelPropertiesRequest_AgentData,
    pub parcel_data: ParcelPropertiesRequest_ParcelData,
}


#[derive(Debug)]
pub struct ParcelPropertiesRequestByID_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequestByID_ParcelData {
    pub sequence_id: i32,
    pub local_id: i32,
}

/// ParcelPropertiesRequestByID
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelPropertiesRequestByID {
    pub agent_data: ParcelPropertiesRequestByID_AgentData,
    pub parcel_data: ParcelPropertiesRequestByID_ParcelData,
}


#[derive(Debug)]
pub struct ParcelProperties_ParcelData {
    pub request_result: i32,
    pub sequence_id: i32,
    pub snap_selection: bool,
    pub self_count: i32,
    pub other_count: i32,
    pub public_count: i32,
    pub local_id: i32,
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub auction_id: u32,
    pub claim_date: i32,
    pub claim_price: i32,
    pub rent_price: i32,
    pub aabb_min: Vector3<f32>,
    pub aabb_max: Vector3<f32>,
    pub bitmap: Vec<u8>,
    pub area: i32,
    pub status: u8,
    pub sim_wide_max_prims: i32,
    pub sim_wide_total_prims: i32,
    pub max_prims: i32,
    pub total_prims: i32,
    pub owner_prims: i32,
    pub group_prims: i32,
    pub other_prims: i32,
    pub selected_prims: i32,
    pub parcel_prim_bonus: f32,
    pub other_clean_time: i32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
    pub region_push_override: bool,
    pub region_deny_anonymous: bool,
    pub region_deny_identified: bool,
    pub region_deny_transacted: bool,
}

#[derive(Debug)]
pub struct ParcelProperties_AgeVerificationBlock {
    pub region_deny_age_unverified: bool,
}


#[derive(Debug)]
pub struct ParcelProperties {
    pub parcel_data: ParcelProperties_ParcelData,
    pub age_verification_block: ParcelProperties_AgeVerificationBlock,
}


#[derive(Debug)]
pub struct ParcelPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesUpdate_ParcelData {
    pub local_id: i32,
    pub flags: u32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
}


#[derive(Debug)]
pub struct ParcelPropertiesUpdate {
    pub agent_data: ParcelPropertiesUpdate_AgentData,
    pub parcel_data: ParcelPropertiesUpdate_ParcelData,
}


#[derive(Debug)]
pub struct ParcelReturnObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_TaskIDs {
    pub task_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_OwnerIDs {
    pub owner_id: Uuid,
}

/// ParcelReturnObjects
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelReturnObjects {
    pub agent_data: ParcelReturnObjects_AgentData,
    pub parcel_data: ParcelReturnObjects_ParcelData,
    pub task_i_ds: Vec<ParcelReturnObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelReturnObjects_OwnerIDs>,
}


#[derive(Debug)]
pub struct ParcelSetOtherCleanTime_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSetOtherCleanTime_ParcelData {
    pub local_id: i32,
    pub other_clean_time: i32,
}

/// ParcelSetOtherCleanTime
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelSetOtherCleanTime {
    pub agent_data: ParcelSetOtherCleanTime_AgentData,
    pub parcel_data: ParcelSetOtherCleanTime_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDisableObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_TaskIDs {
    pub task_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_OwnerIDs {
    pub owner_id: Uuid,
}

/// Disable makes objects nonphysical and turns off their scripts.
/// ParcelDisableObjects
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelDisableObjects {
    pub agent_data: ParcelDisableObjects_AgentData,
    pub parcel_data: ParcelDisableObjects_ParcelData,
    pub task_i_ds: Vec<ParcelDisableObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelDisableObjects_OwnerIDs>,
}


#[derive(Debug)]
pub struct ParcelSelectObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSelectObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelSelectObjects_ReturnIDs {
    pub return_id: Uuid,
}

/// ParcelSelectObjects
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelSelectObjects {
    pub agent_data: ParcelSelectObjects_AgentData,
    pub parcel_data: ParcelSelectObjects_ParcelData,
    pub return_i_ds: Vec<ParcelSelectObjects_ReturnIDs>,
}


#[derive(Debug)]
pub struct EstateCovenantRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// EstateCovenantRequest
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct EstateCovenantRequest {
    pub agent_data: EstateCovenantRequest_AgentData,
}


#[derive(Debug)]
pub struct EstateCovenantReply_Data {
    pub covenant_id: Uuid,
    pub covenant_timestamp: u32,
    pub estate_name: Vec<u8>,
    pub estate_owner_id: Uuid,
}

/// EstateCovenantReply
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct EstateCovenantReply {
    pub data: EstateCovenantReply_Data,
}


#[derive(Debug)]
pub struct ForceObjectSelect_Header {
    pub reset_list: bool,
}

#[derive(Debug)]
pub struct ForceObjectSelect_Data {
    pub local_id: u32,
}

/// ForceObjectSelect
/// sim -> viewer
/// reliable
#[derive(Debug)]
pub struct ForceObjectSelect {
    pub header: ForceObjectSelect_Header,
    pub data: Vec<ForceObjectSelect_Data>,
}


#[derive(Debug)]
pub struct ParcelBuyPass_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelBuyPass_ParcelData {
    pub local_id: i32,
}

/// ParcelBuyPass - purchase a temporary access pass
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelBuyPass {
    pub agent_data: ParcelBuyPass_AgentData,
    pub parcel_data: ParcelBuyPass_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDeedToGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDeedToGroup_Data {
    pub group_id: Uuid,
    pub local_id: i32,
}

/// ParcelDeedToGroup - deed a patch of land to a group
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelDeedToGroup {
    pub agent_data: ParcelDeedToGroup_AgentData,
    pub data: ParcelDeedToGroup_Data,
}


#[derive(Debug)]
pub struct ParcelReclaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReclaim_Data {
    pub local_id: i32,
}

/// reserved for when island owners force re-claim parcel
#[derive(Debug)]
pub struct ParcelReclaim {
    pub agent_data: ParcelReclaim_AgentData,
    pub data: ParcelReclaim_Data,
}


#[derive(Debug)]
pub struct ParcelClaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelClaim_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub final_: bool,
}

#[derive(Debug)]
pub struct ParcelClaim_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

/// ParcelClaim - change the owner of a patch of land
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelClaim {
    pub agent_data: ParcelClaim_AgentData,
    pub data: ParcelClaim_Data,
    pub parcel_data: Vec<ParcelClaim_ParcelData>,
}


#[derive(Debug)]
pub struct ParcelJoin_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelJoin_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

/// ParcelJoin - Take all parcels which are owned by agent and inside
/// rectangle, and make them 1 parcel if they all are leased.
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelJoin {
    pub agent_data: ParcelJoin_AgentData,
    pub parcel_data: ParcelJoin_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDivide_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDivide_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

/// ParcelDivide
/// If the selection is a subsection of exactly one parcel,
/// chop out that section and make a new parcel of it.
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelDivide {
    pub agent_data: ParcelDivide_AgentData,
    pub parcel_data: ParcelDivide_ParcelData,
}


#[derive(Debug)]
pub struct ParcelRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelRelease_Data {
    pub local_id: i32,
}

/// ParcelRelease
/// Release a parcel to public
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelRelease {
    pub agent_data: ParcelRelease_AgentData,
    pub data: ParcelRelease_Data,
}


#[derive(Debug)]
pub struct ParcelBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelBuy_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub remove_contribution: bool,
    pub local_id: i32,
    pub final_: bool,
}

#[derive(Debug)]
pub struct ParcelBuy_ParcelData {
    pub price: i32,
    pub area: i32,
}

/// ParcelBuy - change the owner of a patch of land.
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct ParcelBuy {
    pub agent_data: ParcelBuy_AgentData,
    pub data: ParcelBuy_Data,
    pub parcel_data: ParcelBuy_ParcelData,
}


#[derive(Debug)]
pub struct ParcelGodForceOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelGodForceOwner_Data {
    pub owner_id: Uuid,
    pub local_id: i32,
}

/// ParcelGodForceOwner Unencoded
#[derive(Debug)]
pub struct ParcelGodForceOwner {
    pub agent_data: ParcelGodForceOwner_AgentData,
    pub data: ParcelGodForceOwner_Data,
}


#[derive(Debug)]
pub struct ParcelAccessListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelAccessListRequest_Data {
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

/// viewer -> sim
/// ParcelAccessListRequest
#[derive(Debug)]
pub struct ParcelAccessListRequest {
    pub agent_data: ParcelAccessListRequest_AgentData,
    pub data: ParcelAccessListRequest_Data,
}


#[derive(Debug)]
pub struct ParcelAccessListReply_Data {
    pub agent_id: Uuid,
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelAccessListReply_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

/// sim -> viewer
/// ParcelAccessListReply
#[derive(Debug)]
pub struct ParcelAccessListReply {
    pub data: ParcelAccessListReply_Data,
    pub list: Vec<ParcelAccessListReply_List>,
}


#[derive(Debug)]
pub struct ParcelAccessListUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelAccessListUpdate_Data {
    pub flags: u32,
    pub local_id: i32,
    pub transaction_id: Uuid,
    pub sequence_id: i32,
    pub sections: i32,
}

#[derive(Debug)]
pub struct ParcelAccessListUpdate_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

/// viewer -> sim
/// ParcelAccessListUpdate
#[derive(Debug)]
pub struct ParcelAccessListUpdate {
    pub agent_data: ParcelAccessListUpdate_AgentData,
    pub data: ParcelAccessListUpdate_Data,
    pub list: Vec<ParcelAccessListUpdate_List>,
}


#[derive(Debug)]
pub struct ParcelDwellRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDwellRequest_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
}

/// viewer -> sim -> dataserver
/// reliable
#[derive(Debug)]
pub struct ParcelDwellRequest {
    pub agent_data: ParcelDwellRequest_AgentData,
    pub data: ParcelDwellRequest_Data,
}


#[derive(Debug)]
pub struct ParcelDwellReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDwellReply_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
    pub dwell: f32,
}

/// dataserver -> sim -> viewer
/// reliable
#[derive(Debug)]
pub struct ParcelDwellReply {
    pub agent_data: ParcelDwellReply_AgentData,
    pub data: ParcelDwellReply_Data,
}


#[derive(Debug)]
pub struct RequestParcelTransfer_Data {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub owner_id: Uuid,
    pub flags: u8,
    pub transaction_type: i32,
    pub amount: i32,
    pub billable_area: i32,
    pub actual_area: i32,
    pub final_: bool,
}

#[derive(Debug)]
pub struct RequestParcelTransfer_RegionData {
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
}

/// sim -> dataserver
/// This message is used to check if a user can buy a parcel. If
/// successful, the transaction is approved through a money balance reply
/// with the same transaction id.
#[derive(Debug)]
pub struct RequestParcelTransfer {
    pub data: RequestParcelTransfer_Data,
    pub region_data: RequestParcelTransfer_RegionData,
}


#[derive(Debug)]
pub struct UpdateParcel_ParcelData {
    pub parcel_id: Uuid,
    pub region_handle: u64,
    pub owner_id: Uuid,
    pub group_owned: bool,
    pub status: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub music_url: Vec<u8>,
    pub region_x: f32,
    pub region_y: f32,
    pub actual_area: i32,
    pub billable_area: i32,
    pub show_dir: bool,
    pub is_for_sale: bool,
    pub category: u8,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub sale_price: i32,
    pub authorized_buyer_id: Uuid,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

/// sim ->dataserver
/// This message is used to send up complete parcel properties for
/// persistance in the database.
/// If you add something here, you should probably also change the
/// simulator's database update query on startup.
#[derive(Debug)]
pub struct UpdateParcel {
    pub parcel_data: UpdateParcel_ParcelData,
}


#[derive(Debug)]
pub struct RemoveParcel_ParcelData {
    pub parcel_id: Uuid,
}

/// sim -> dataserver or space ->sim
/// This message is used to tell the dataserver that a parcel has been
/// removed.
#[derive(Debug)]
pub struct RemoveParcel {
    pub parcel_data: Vec<RemoveParcel_ParcelData>,
}


#[derive(Debug)]
pub struct MergeParcel_MasterParcelData {
    pub master_id: Uuid,
}

#[derive(Debug)]
pub struct MergeParcel_SlaveParcelData {
    pub slave_id: Uuid,
}

/// sim -> dataserver
/// Merges some of the database information for parcels (dwell).
#[derive(Debug)]
pub struct MergeParcel {
    pub master_parcel_data: MergeParcel_MasterParcelData,
    pub slave_parcel_data: Vec<MergeParcel_SlaveParcelData>,
}


#[derive(Debug)]
pub struct LogParcelChanges_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct LogParcelChanges_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct LogParcelChanges_ParcelData {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub is_owner_group: bool,
    pub actual_area: i32,
    pub action: i8,
    pub transaction_id: Uuid,
}

/// sim -> dataserver
#[derive(Debug)]
pub struct LogParcelChanges {
    pub agent_data: LogParcelChanges_AgentData,
    pub region_data: LogParcelChanges_RegionData,
    pub parcel_data: Vec<LogParcelChanges_ParcelData>,
}


#[derive(Debug)]
pub struct CheckParcelSales_RegionData {
    pub region_handle: u64,
}

/// sim -> dataserver
#[derive(Debug)]
pub struct CheckParcelSales {
    pub region_data: Vec<CheckParcelSales_RegionData>,
}


#[derive(Debug)]
pub struct ParcelSales_ParcelData {
    pub parcel_id: Uuid,
    pub buyer_id: Uuid,
}

/// dataserver -> simulator
/// tell a particular simulator to finish parcel sale.
#[derive(Debug)]
pub struct ParcelSales {
    pub parcel_data: Vec<ParcelSales_ParcelData>,
}


#[derive(Debug)]
pub struct ParcelGodMarkAsContent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelGodMarkAsContent_ParcelData {
    pub local_id: i32,
}

/// viewer -> sim
/// mark parcel and double secret agent content on parcel as owned by
/// governor/maint and adjusts permissions approriately. Godlike request.
#[derive(Debug)]
pub struct ParcelGodMarkAsContent {
    pub agent_data: ParcelGodMarkAsContent_AgentData,
    pub parcel_data: ParcelGodMarkAsContent_ParcelData,
}


#[derive(Debug)]
pub struct ViewerStartAuction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ViewerStartAuction_ParcelData {
    pub local_id: i32,
    pub snapshot_id: Uuid,
}

/// viewer -> sim
/// start an auction. viewer fills in the appropriate date, simulator
/// validates and fills in the rest of the information to start an auction
/// on a parcel. Processing currently requires that AgentID is a god.
#[derive(Debug)]
pub struct ViewerStartAuction {
    pub agent_data: ViewerStartAuction_AgentData,
    pub parcel_data: ViewerStartAuction_ParcelData,
}


#[derive(Debug)]
pub struct StartAuction_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct StartAuction_ParcelData {
    pub parcel_id: Uuid,
    pub snapshot_id: Uuid,
    pub name: Vec<u8>,
}

/// sim -> dataserver
/// Once all of the data has been gathered,
#[derive(Debug)]
pub struct StartAuction {
    pub agent_data: StartAuction_AgentData,
    pub parcel_data: StartAuction_ParcelData,
}


#[derive(Debug)]
pub struct ConfirmAuctionStart_AuctionData {
    pub parcel_id: Uuid,
    pub auction_id: u32,
}

/// dataserver -> sim
#[derive(Debug)]
pub struct ConfirmAuctionStart {
    pub auction_data: ConfirmAuctionStart_AuctionData,
}


#[derive(Debug)]
pub struct CompleteAuction_ParcelData {
    pub parcel_id: Uuid,
}

/// sim -> dataserver
/// Tell the dataserver that an auction has completed.
#[derive(Debug)]
pub struct CompleteAuction {
    pub parcel_data: Vec<CompleteAuction_ParcelData>,
}


#[derive(Debug)]
pub struct CancelAuction_ParcelData {
    pub parcel_id: Uuid,
}

/// Tell the dataserver that an auction has been canceled.
#[derive(Debug)]
pub struct CancelAuction {
    pub parcel_data: Vec<CancelAuction_ParcelData>,
}


#[derive(Debug)]
pub struct CheckParcelAuctions_RegionData {
    pub region_handle: u64,
}

/// sim -> dataserver
#[derive(Debug)]
pub struct CheckParcelAuctions {
    pub region_data: Vec<CheckParcelAuctions_RegionData>,
}


#[derive(Debug)]
pub struct ParcelAuctions_ParcelData {
    pub parcel_id: Uuid,
    pub winner_id: Uuid,
}

/// dataserver -> sim
/// tell a particular simulator to finish parcel sale.
#[derive(Debug)]
pub struct ParcelAuctions {
    pub parcel_data: Vec<ParcelAuctions_ParcelData>,
}


#[derive(Debug)]
pub struct UUIDNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

/// UUIDNameRequest
/// Translate a UUID into first and last names
#[derive(Debug)]
pub struct UUIDNameRequest {
    pub uuid_name_block: Vec<UUIDNameRequest_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

/// UUIDNameReply
/// Translate a UUID into first and last names
#[derive(Debug)]
pub struct UUIDNameReply {
    pub uuid_name_block: Vec<UUIDNameReply_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDGroupNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

/// UUIDGroupNameRequest
/// Translate a UUID into a group name
#[derive(Debug)]
pub struct UUIDGroupNameRequest {
    pub uuid_name_block: Vec<UUIDGroupNameRequest_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDGroupNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub group_name: Vec<u8>,
}

/// UUIDGroupNameReply
/// Translate a UUID into a group name
#[derive(Debug)]
pub struct UUIDGroupNameReply {
    pub uuid_name_block: Vec<UUIDGroupNameReply_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct ChatPass_ChatData {
    pub channel: i32,
    pub position: Vector3<f32>,
    pub id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub source_type: u8,
    pub type_: u8,
    pub radius: f32,
    pub sim_access: u8,
    pub message: Vec<u8>,
}

/// ChatPass
/// Chat message transmission to neighbors
/// Chat is region local to receiving simulator.
/// Type is one of CHAT_TYPE_NORMAL, _WHISPER, _SHOUT
#[derive(Debug)]
pub struct ChatPass {
    pub chat_data: ChatPass_ChatData,
}


#[derive(Debug)]
pub struct EdgeDataPacket_EdgeData {
    pub layer_type: u8,
    pub direction: u8,
    pub layer_data: Vec<u8>,
}


#[derive(Debug)]
pub struct EdgeDataPacket {
    pub edge_data: EdgeDataPacket_EdgeData,
}


#[derive(Debug)]
pub struct SimStatus_SimStatus {
    pub can_accept_agents: bool,
    pub can_accept_tasks: bool,
}

/// Sim status, condition of this sim
/// sent reliably, when dirty
#[derive(Debug)]
pub struct SimStatus {
    pub sim_status: SimStatus_SimStatus,
}


#[derive(Debug)]
pub struct ChildAgentUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
    pub far: f32,
    pub aspect: f32,
    pub throttles: Vec<u8>,
    pub locomotion_state: u32,
    pub head_rotation: Quaternion<f32>,
    pub body_rotation: Quaternion<f32>,
    pub control_flags: u32,
    pub energy_level: f32,
    pub god_level: u8,
    pub always_run: bool,
    pub prey_agent: Uuid,
    pub agent_access: u8,
    pub agent_textures: Vec<u8>,
    pub active_group_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AnimationData {
    pub animation: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_GranterBlock {
    pub granter_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_NVPairData {
    pub nv_pairs: Vec<u8>,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_VisualParam {
    pub param_value: u8,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AgentAccess {
    pub agent_legacy_access: u8,
    pub agent_max_access: u8,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AgentInfo {
    pub flags: u32,
}


#[derive(Debug)]
pub struct ChildAgentUpdate {
    pub agent_data: ChildAgentUpdate_AgentData,
    pub group_data: Vec<ChildAgentUpdate_GroupData>,
    pub animation_data: Vec<ChildAgentUpdate_AnimationData>,
    pub granter_block: Vec<ChildAgentUpdate_GranterBlock>,
    pub nv_pair_data: Vec<ChildAgentUpdate_NVPairData>,
    pub visual_param: Vec<ChildAgentUpdate_VisualParam>,
    pub agent_access: Vec<ChildAgentUpdate_AgentAccess>,
    pub agent_info: Vec<ChildAgentUpdate_AgentInfo>,
}


#[derive(Debug)]
pub struct ChildAgentAlive_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// ChildAgentAlive
/// sent to child agents just to keep them alive
#[derive(Debug)]
pub struct ChildAgentAlive {
    pub agent_data: ChildAgentAlive_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentPositionUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
}


#[derive(Debug)]
pub struct ChildAgentPositionUpdate {
    pub agent_data: ChildAgentPositionUpdate_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentDying_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// Obituary for child agents - make sure the parent know the child is dead
/// This way, children can be reliably restarted
#[derive(Debug)]
pub struct ChildAgentDying {
    pub agent_data: ChildAgentDying_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentUnknown_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// This is sent if a full child agent hasn't been accepted yet
#[derive(Debug)]
pub struct ChildAgentUnknown {
    pub agent_data: ChildAgentUnknown_AgentData,
}


#[derive(Debug)]
pub struct AtomicPassObject_TaskData {
    pub task_id: Uuid,
    pub attachment_needs_save: bool,
}

/// This message is sent how objects get passed between regions.
#[derive(Debug)]
pub struct AtomicPassObject {
    pub task_data: AtomicPassObject_TaskData,
}


#[derive(Debug)]
pub struct KillChildAgents_IDBlock {
    pub agent_id: Uuid,
}

/// KillChildAgents - A new agent has connected to the simulator . . . make sure that any old child cameras are blitzed
#[derive(Debug)]
pub struct KillChildAgents {
    pub id_block: KillChildAgents_IDBlock,
}


#[derive(Debug)]
pub struct GetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

/// GetScriptRunning - asks if a script is running or not. the simulator
/// responds with ScriptRunningReply
#[derive(Debug)]
pub struct GetScriptRunning {
    pub script: GetScriptRunning_Script,
}


#[derive(Debug)]
pub struct ScriptRunningReply_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

/// ScriptRunningReply - response from simulator to message above
///		{	Mono			BOOL	} Added to LLSD message
#[derive(Debug)]
pub struct ScriptRunningReply {
    pub script: ScriptRunningReply_Script,
}


#[derive(Debug)]
pub struct SetScriptRunning_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

/// SetScriptRunning - makes a script active or inactive (Enable may be
/// true or false)
#[derive(Debug)]
pub struct SetScriptRunning {
    pub agent_data: SetScriptRunning_AgentData,
    pub script: SetScriptRunning_Script,
}


#[derive(Debug)]
pub struct ScriptReset_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptReset_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

/// ScriptReset - causes a script to reset
#[derive(Debug)]
pub struct ScriptReset {
    pub agent_data: ScriptReset_AgentData,
    pub script: ScriptReset_Script,
}


#[derive(Debug)]
pub struct ScriptSensorRequest_Requester {
    pub source_id: Uuid,
    pub request_id: Uuid,
    pub search_id: Uuid,
    pub search_pos: Vector3<f32>,
    pub search_dir: Quaternion<f32>,
    pub search_name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
    pub arc: f32,
    pub region_handle: u64,
    pub search_regions: u8,
}

/// ScriptSensorRequest - causes the receiving sim to run a script sensor and return the results
#[derive(Debug)]
pub struct ScriptSensorRequest {
    pub requester: ScriptSensorRequest_Requester,
}


#[derive(Debug)]
pub struct ScriptSensorReply_Requester {
    pub source_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptSensorReply_SensedData {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub position: Vector3<f32>,
    pub velocity: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
}

/// ScriptSensorReply - returns the request script search information back to the requester
#[derive(Debug)]
pub struct ScriptSensorReply {
    pub requester: ScriptSensorReply_Requester,
    pub sensed_data: Vec<ScriptSensorReply_SensedData>,
}


#[derive(Debug)]
pub struct CompleteAgentMovement_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

/// viewer -> sim
/// agent is coming into the region. The region should be expecting the
/// agent.
#[derive(Debug)]
pub struct CompleteAgentMovement {
    pub agent_data: CompleteAgentMovement_AgentData,
}


#[derive(Debug)]
pub struct AgentMovementComplete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentMovementComplete_Data {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub region_handle: u64,
    pub timestamp: u32,
}

#[derive(Debug)]
pub struct AgentMovementComplete_SimData {
    pub channel_version: Vec<u8>,
}

/// sim -> viewer
#[derive(Debug)]
pub struct AgentMovementComplete {
    pub agent_data: AgentMovementComplete_AgentData,
    pub data: AgentMovementComplete_Data,
    pub sim_data: AgentMovementComplete_SimData,
}


#[derive(Debug)]
pub struct DataServerLogout_UserData {
    pub agent_id: Uuid,
    pub viewer_ip: Ip4Addr,
    pub disconnect: bool,
    pub session_id: Uuid,
}

/// userserver -> dataserver
#[derive(Debug)]
pub struct DataServerLogout {
    pub user_data: DataServerLogout_UserData,
}


#[derive(Debug)]
pub struct LogoutRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// LogoutRequest
/// viewer -> sim
/// reliable
#[derive(Debug)]
pub struct LogoutRequest {
    pub agent_data: LogoutRequest_AgentData,
}


#[derive(Debug)]
pub struct LogoutReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LogoutReply_InventoryData {
    pub item_id: Uuid,
}

/// LogoutReply
/// it's ok for the viewer to quit.
/// sim -> viewer
/// reliable
/// Includes inventory items to update with new asset ids
#[derive(Debug)]
pub struct LogoutReply {
    pub agent_data: LogoutReply_AgentData,
    pub inventory_data: Vec<LogoutReply_InventoryData>,
}


#[derive(Debug)]
pub struct ImprovedInstantMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ImprovedInstantMessage_MessageBlock {
    pub from_group: bool,
    pub to_agent_id: Uuid,
    pub parent_estate_id: u32,
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub offline: u8,
    pub dialog: u8,
    pub id: Uuid,
    pub timestamp: u32,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

/// ImprovedInstantMessage
/// This message can potentially route all over the place
/// ParentEstateID: parent estate id of the source estate
/// RegionID: region id of the source of the IM.
/// Position: position of the sender in region local coordinates
/// Dialog	see llinstantmessage.h for values
/// ID		May be used by dialog. Interpretation depends on context.
/// BinaryBucket May be used by some dialog types
/// reliable
#[derive(Debug)]
pub struct ImprovedInstantMessage {
    pub agent_data: ImprovedInstantMessage_AgentData,
    pub message_block: ImprovedInstantMessage_MessageBlock,
}


#[derive(Debug)]
pub struct RetrieveInstantMessages_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// RetrieveInstantMessages - used to get instant messages that
/// were persisted out to the database while the user was offline
#[derive(Debug)]
pub struct RetrieveInstantMessages {
    pub agent_data: RetrieveInstantMessages_AgentData,
}


#[derive(Debug)]
pub struct FindAgent_AgentBlock {
    pub hunter: Uuid,
    pub prey: Uuid,
    pub space_ip: Ip4Addr,
}

#[derive(Debug)]
pub struct FindAgent_LocationBlock {
    pub global_x: f64,
    pub global_y: f64,
}

/// FindAgent - used to find an agent's global position. I used a
/// variable sized LocationBlock so that the message can be recycled with
/// minimum new messages and handlers.
#[derive(Debug)]
pub struct FindAgent {
    pub agent_block: FindAgent_AgentBlock,
    pub location_block: Vec<FindAgent_LocationBlock>,
}


#[derive(Debug)]
pub struct RequestGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestGodlikePowers_RequestBlock {
    pub godlike: bool,
    pub token: Uuid,
}

/// Set godlike to 1 if you want to become godlike.
/// Set godlike to 0 if you want to relinquish god powers.
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct RequestGodlikePowers {
    pub agent_data: RequestGodlikePowers_AgentData,
    pub request_block: RequestGodlikePowers_RequestBlock,
}


#[derive(Debug)]
pub struct GrantGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GrantGodlikePowers_GrantData {
    pub god_level: u8,
    pub token: Uuid,
}

/// At the simulator, turn the godlike bit on.
/// At the viewer, show the god menu.
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct GrantGodlikePowers {
    pub agent_data: GrantGodlikePowers_AgentData,
    pub grant_data: GrantGodlikePowers_GrantData,
}


#[derive(Debug)]
pub struct GodlikeMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GodlikeMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct GodlikeMessage_ParamList {
    pub parameter: Vec<u8>,
}

/// GodlikeMessage - generalized construct for Gods to send messages
/// around the system. Each Request has it's own internal protocol.
#[derive(Debug)]
pub struct GodlikeMessage {
    pub agent_data: GodlikeMessage_AgentData,
    pub method_data: GodlikeMessage_MethodData,
    pub param_list: Vec<GodlikeMessage_ParamList>,
}


#[derive(Debug)]
pub struct EstateOwnerMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct EstateOwnerMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct EstateOwnerMessage_ParamList {
    pub parameter: Vec<u8>,
}

/// EstateOwnerMessage
/// format must be identical to above
#[derive(Debug)]
pub struct EstateOwnerMessage {
    pub agent_data: EstateOwnerMessage_AgentData,
    pub method_data: EstateOwnerMessage_MethodData,
    pub param_list: Vec<EstateOwnerMessage_ParamList>,
}


#[derive(Debug)]
pub struct GenericMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GenericMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct GenericMessage_ParamList {
    pub parameter: Vec<u8>,
}

/// GenericMessage
/// format must be identical to above
/// As above, but don't have to be god or estate owner to send.
#[derive(Debug)]
pub struct GenericMessage {
    pub agent_data: GenericMessage_AgentData,
    pub method_data: GenericMessage_MethodData,
    pub param_list: Vec<GenericMessage_ParamList>,
}


#[derive(Debug)]
pub struct MuteListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MuteListRequest_MuteData {
    pub mute_crc: u32,
}

/// request for mute list
#[derive(Debug)]
pub struct MuteListRequest {
    pub agent_data: MuteListRequest_AgentData,
    pub mute_data: MuteListRequest_MuteData,
}


#[derive(Debug)]
pub struct UpdateMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
    pub mute_type: i32,
    pub mute_flags: u32,
}

/// update/add someone in the mute list
#[derive(Debug)]
pub struct UpdateMuteListEntry {
    pub agent_data: UpdateMuteListEntry_AgentData,
    pub mute_data: UpdateMuteListEntry_MuteData,
}


#[derive(Debug)]
pub struct RemoveMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
}

/// Remove a mute list entry.
#[derive(Debug)]
pub struct RemoveMuteListEntry {
    pub agent_data: RemoveMuteListEntry_AgentData,
    pub mute_data: RemoveMuteListEntry_MuteData,
}


#[derive(Debug)]
pub struct CopyInventoryFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryFromNotecard_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
}


#[derive(Debug)]
pub struct CopyInventoryFromNotecard {
    pub agent_data: CopyInventoryFromNotecard_AgentData,
    pub notecard_data: CopyInventoryFromNotecard_NotecardData,
    pub inventory_data: Vec<CopyInventoryFromNotecard_InventoryData>,
}


#[derive(Debug)]
pub struct UpdateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}


#[derive(Debug)]
pub struct UpdateInventoryItem {
    pub agent_data: UpdateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct UpdateCreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub sim_approved: bool,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateCreateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}


#[derive(Debug)]
pub struct UpdateCreateInventoryItem {
    pub agent_data: UpdateCreateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateCreateInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct MoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

#[derive(Debug)]
pub struct MoveInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub new_name: Vec<u8>,
}


#[derive(Debug)]
pub struct MoveInventoryItem {
    pub agent_data: MoveInventoryItem_AgentData,
    pub inventory_data: Vec<MoveInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct CopyInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryItem_InventoryData {
    pub callback_id: u32,
    pub old_agent_id: Uuid,
    pub old_item_id: Uuid,
    pub new_folder_id: Uuid,
    pub new_name: Vec<u8>,
}

/// copy inventory item by item id to specified destination folder,
/// send out bulk inventory update when done.
///
/// Inventory items are only unique for {agent, inv_id} pairs;
/// the OldItemID needs to be paired with the OldAgentID to
/// produce a unique inventory item.
#[derive(Debug)]
pub struct CopyInventoryItem {
    pub agent_data: CopyInventoryItem_AgentData,
    pub inventory_data: Vec<CopyInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct RemoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryItem_InventoryData {
    pub item_id: Uuid,
}


#[derive(Debug)]
pub struct RemoveInventoryItem {
    pub agent_data: RemoveInventoryItem_AgentData,
    pub inventory_data: Vec<RemoveInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct ChangeInventoryItemFlags_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChangeInventoryItemFlags_InventoryData {
    pub item_id: Uuid,
    pub flags: u32,
}


#[derive(Debug)]
pub struct ChangeInventoryItemFlags {
    pub agent_data: ChangeInventoryItemFlags_AgentData,
    pub inventory_data: Vec<ChangeInventoryItemFlags_InventoryData>,
}


#[derive(Debug)]
pub struct SaveAssetIntoInventory_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct SaveAssetIntoInventory_InventoryData {
    pub item_id: Uuid,
    pub new_asset_id: Uuid,
}

///
/// Sim outgoing only (to dataserver, to viewer)
/// NOT viewer to sim, sim should not have handler, ever
/// This message is currently only uses objects, so the viewer ignores
/// the asset id.
#[derive(Debug)]
pub struct SaveAssetIntoInventory {
    pub agent_data: SaveAssetIntoInventory_AgentData,
    pub inventory_data: SaveAssetIntoInventory_InventoryData,
}


#[derive(Debug)]
pub struct CreateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}


#[derive(Debug)]
pub struct CreateInventoryFolder {
    pub agent_data: CreateInventoryFolder_AgentData,
    pub folder_data: CreateInventoryFolder_FolderData,
}


#[derive(Debug)]
pub struct UpdateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}


#[derive(Debug)]
pub struct UpdateInventoryFolder {
    pub agent_data: UpdateInventoryFolder_AgentData,
    pub folder_data: Vec<UpdateInventoryFolder_FolderData>,
}


#[derive(Debug)]
pub struct MoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

#[derive(Debug)]
pub struct MoveInventoryFolder_InventoryData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
}


#[derive(Debug)]
pub struct MoveInventoryFolder {
    pub agent_data: MoveInventoryFolder_AgentData,
    pub inventory_data: Vec<MoveInventoryFolder_InventoryData>,
}


#[derive(Debug)]
pub struct RemoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryFolder_FolderData {
    pub folder_id: Uuid,
}


#[derive(Debug)]
pub struct RemoveInventoryFolder {
    pub agent_data: RemoveInventoryFolder_AgentData,
    pub folder_data: Vec<RemoveInventoryFolder_FolderData>,
}


#[derive(Debug)]
pub struct FetchInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub sort_order: i32,
    pub fetch_folders: bool,
    pub fetch_items: bool,
}

/// Get inventory segment.
#[derive(Debug)]
pub struct FetchInventoryDescendents {
    pub agent_data: FetchInventoryDescendents_AgentData,
    pub inventory_data: FetchInventoryDescendents_InventoryData,
}


#[derive(Debug)]
pub struct InventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub version: i32,
    pub descendents: i32,
}

#[derive(Debug)]
pub struct InventoryDescendents_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct InventoryDescendents_ItemData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// return inventory segment.
/// *NOTE: This could be compressed more since we already know the
/// parent_id for folders and the folder_id for items, but this is
/// reasonable until we heve server side inventory.
#[derive(Debug)]
pub struct InventoryDescendents {
    pub agent_data: InventoryDescendents_AgentData,
    pub folder_data: Vec<InventoryDescendents_FolderData>,
    pub item_data: Vec<InventoryDescendents_ItemData>,
}


#[derive(Debug)]
pub struct FetchInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventory_InventoryData {
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

/// Get inventory item(s) - response comes through FetchInventoryReply
#[derive(Debug)]
pub struct FetchInventory {
    pub agent_data: FetchInventory_AgentData,
    pub inventory_data: Vec<FetchInventory_InventoryData>,
}


#[derive(Debug)]
pub struct FetchInventoryReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventoryReply_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}


#[derive(Debug)]
pub struct FetchInventoryReply {
    pub agent_data: FetchInventoryReply_AgentData,
    pub inventory_data: Vec<FetchInventoryReply_InventoryData>,
}


#[derive(Debug)]
pub struct BulkUpdateInventory_AgentData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct BulkUpdateInventory_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct BulkUpdateInventory_ItemData {
    pub item_id: Uuid,
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// Can only fit around 7 items per packet - that's the way it goes. At
/// least many bulk updates can be packed.
/// Only from dataserver->sim->viewer
#[derive(Debug)]
pub struct BulkUpdateInventory {
    pub agent_data: BulkUpdateInventory_AgentData,
    pub folder_data: Vec<BulkUpdateInventory_FolderData>,
    pub item_data: Vec<BulkUpdateInventory_ItemData>,
}


#[derive(Debug)]
pub struct RequestInventoryAsset_QueryData {
    pub query_id: Uuid,
    pub agent_id: Uuid,
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

/// request permissions for agent id to get the asset for owner_id's
/// item_id.
#[derive(Debug)]
pub struct RequestInventoryAsset {
    pub query_data: RequestInventoryAsset_QueryData,
}


#[derive(Debug)]
pub struct InventoryAssetResponse_QueryData {
    pub query_id: Uuid,
    pub asset_id: Uuid,
    pub is_readable: bool,
}

/// response to RequestInventoryAsset
/// lluuid will be null if agentid in the request above cannot read asset
#[derive(Debug)]
pub struct InventoryAssetResponse {
    pub query_data: InventoryAssetResponse_QueryData,
}


#[derive(Debug)]
pub struct RemoveInventoryObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryObjects_FolderData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryObjects_ItemData {
    pub item_id: Uuid,
}

/// This is the new improved way to remove inventory items.  It is
/// currently only supported in viewer->userserver->dataserver
/// messages typically initiated by an empty trash method.
#[derive(Debug)]
pub struct RemoveInventoryObjects {
    pub agent_data: RemoveInventoryObjects_AgentData,
    pub folder_data: Vec<RemoveInventoryObjects_FolderData>,
    pub item_data: Vec<RemoveInventoryObjects_ItemData>,
}


#[derive(Debug)]
pub struct PurgeInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PurgeInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
}

/// This is how you remove inventory when you're not even sure what it
/// is - only it's parenting.
#[derive(Debug)]
pub struct PurgeInventoryDescendents {
    pub agent_data: PurgeInventoryDescendents_AgentData,
    pub inventory_data: PurgeInventoryDescendents_InventoryData,
}


#[derive(Debug)]
pub struct UpdateTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateTaskInventory_UpdateData {
    pub local_id: u32,
    pub key: u8,
}

#[derive(Debug)]
pub struct UpdateTaskInventory_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// These messages are viewer->simulator requests to update a task's
/// inventory.
/// if Key == 0, itemid is the key. if Key == 1, assetid is the key.
#[derive(Debug)]
pub struct UpdateTaskInventory {
    pub agent_data: UpdateTaskInventory_AgentData,
    pub update_data: UpdateTaskInventory_UpdateData,
    pub inventory_data: UpdateTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct RemoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}


#[derive(Debug)]
pub struct RemoveTaskInventory {
    pub agent_data: RemoveTaskInventory_AgentData,
    pub inventory_data: RemoveTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct MoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct MoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}


#[derive(Debug)]
pub struct MoveTaskInventory {
    pub agent_data: MoveTaskInventory_AgentData,
    pub inventory_data: MoveTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct RequestTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestTaskInventory_InventoryData {
    pub local_id: u32,
}


#[derive(Debug)]
pub struct RequestTaskInventory {
    pub agent_data: RequestTaskInventory_AgentData,
    pub inventory_data: RequestTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct ReplyTaskInventory_InventoryData {
    pub task_id: Uuid,
    pub serial: i16,
    pub filename: Vec<u8>,
}


#[derive(Debug)]
pub struct ReplyTaskInventory {
    pub inventory_data: ReplyTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct DeRezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeRezObject_AgentBlock {
    pub group_id: Uuid,
    pub destination: u8,
    pub destination_id: Uuid,
    pub transaction_id: Uuid,
    pub packet_count: u8,
    pub packet_number: u8,
}

#[derive(Debug)]
pub struct DeRezObject_ObjectData {
    pub object_local_id: u32,
}

/// These messages are viewer->simulator requests regarding objects
/// which are currently being simulated. The viewer will get an
/// UpdateInventoryItem response if a DeRez succeeds, and the object
/// will appear if a RezObject succeeds.
/// The Destination field tells where the derez should wind up, and the
/// meaning of DestinationID depends on it. For example, if the
/// destination is a category, then the destination is the category id. If
/// the destination is a task inventory, then the destination id is the
/// task id.
/// The transaction id is generated by the viewer on derez, and then
/// the packets are counted and numbered. The rest of the information is
/// just duplicated (it's not that much, and derezzes that span multiple
/// packets will be rare.)
#[derive(Debug)]
pub struct DeRezObject {
    pub agent_data: DeRezObject_AgentData,
    pub agent_block: DeRezObject_AgentBlock,
    pub object_data: Vec<DeRezObject_ObjectData>,
}


#[derive(Debug)]
pub struct DeRezAck_TransactionData {
    pub transaction_id: Uuid,
    pub success: bool,
}

/// This message is sent when a derez succeeds, but there's no way to
/// know, since no inventory is created on the viewer. For example, when
/// saving into task inventory.
#[derive(Debug)]
pub struct DeRezAck {
    pub transaction_data: DeRezAck_TransactionData,
}


#[derive(Debug)]
pub struct RezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezObject_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

#[derive(Debug)]
pub struct RezObject_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// This message is sent from viewer -> simulator when the viewer wants
/// to rez an object out of inventory.
#[derive(Debug)]
pub struct RezObject {
    pub agent_data: RezObject_AgentData,
    pub rez_data: RezObject_RezData,
    pub inventory_data: RezObject_InventoryData,
}


#[derive(Debug)]
pub struct RezObjectFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_InventoryData {
    pub item_id: Uuid,
}

/// This message is sent from viewer -> simulator when the viewer wants
/// to rez an object from a notecard.
#[derive(Debug)]
pub struct RezObjectFromNotecard {
    pub agent_data: RezObjectFromNotecard_AgentData,
    pub rez_data: RezObjectFromNotecard_RezData,
    pub notecard_data: RezObjectFromNotecard_NotecardData,
    pub inventory_data: Vec<RezObjectFromNotecard_InventoryData>,
}


#[derive(Debug)]
pub struct TransferInventory_InfoBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct TransferInventory_InventoryBlock {
    pub inventory_id: Uuid,
    pub type_: i8,
}

/// sim -> dataserver
/// sent during agent to agent inventory transfers
#[derive(Debug)]
pub struct TransferInventory {
    pub info_block: TransferInventory_InfoBlock,
    pub inventory_block: Vec<TransferInventory_InventoryBlock>,
}


#[derive(Debug)]
pub struct TransferInventoryAck_InfoBlock {
    pub transaction_id: Uuid,
    pub inventory_id: Uuid,
}

/// dataserver -> sim
/// InventoryID is the id of the inventory object that the end user
/// should discard if they deny the transfer.
#[derive(Debug)]
pub struct TransferInventoryAck {
    pub info_block: TransferInventoryAck_InfoBlock,
}


#[derive(Debug)]
pub struct AcceptFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptFriendship_FolderData {
    pub folder_id: Uuid,
}


#[derive(Debug)]
pub struct AcceptFriendship {
    pub agent_data: AcceptFriendship_AgentData,
    pub transaction_block: AcceptFriendship_TransactionBlock,
    pub folder_data: Vec<AcceptFriendship_FolderData>,
}


#[derive(Debug)]
pub struct DeclineFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}


#[derive(Debug)]
pub struct DeclineFriendship {
    pub agent_data: DeclineFriendship_AgentData,
    pub transaction_block: DeclineFriendship_TransactionBlock,
}


#[derive(Debug)]
pub struct FormFriendship_AgentBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
}


#[derive(Debug)]
pub struct FormFriendship {
    pub agent_block: FormFriendship_AgentBlock,
}


#[derive(Debug)]
pub struct TerminateFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TerminateFriendship_ExBlock {
    pub other_id: Uuid,
}

/// Cancels user relationship
/// Updates inventory for both users.
/// Stops agent tracking in userserver.
/// viewer -> userserver -> dataserver
/// reliable
#[derive(Debug)]
pub struct TerminateFriendship {
    pub agent_data: TerminateFriendship_AgentData,
    pub ex_block: TerminateFriendship_ExBlock,
}


#[derive(Debug)]
pub struct OfferCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct OfferCallingCard_AgentBlock {
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

/// used to give someone a calling card.
#[derive(Debug)]
pub struct OfferCallingCard {
    pub agent_data: OfferCallingCard_AgentData,
    pub agent_block: OfferCallingCard_AgentBlock,
}


#[derive(Debug)]
pub struct AcceptCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptCallingCard_FolderData {
    pub folder_id: Uuid,
}


#[derive(Debug)]
pub struct AcceptCallingCard {
    pub agent_data: AcceptCallingCard_AgentData,
    pub transaction_block: AcceptCallingCard_TransactionBlock,
    pub folder_data: Vec<AcceptCallingCard_FolderData>,
}


#[derive(Debug)]
pub struct DeclineCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}


#[derive(Debug)]
pub struct DeclineCallingCard {
    pub agent_data: DeclineCallingCard_AgentData,
    pub transaction_block: DeclineCallingCard_TransactionBlock,
}


#[derive(Debug)]
pub struct RezScript_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezScript_UpdateBlock {
    pub object_local_id: u32,
    pub enabled: bool,
}

#[derive(Debug)]
pub struct RezScript_InventoryBlock {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// Rez a script onto an object
#[derive(Debug)]
pub struct RezScript {
    pub agent_data: RezScript_AgentData,
    pub update_block: RezScript_UpdateBlock,
    pub inventory_block: RezScript_InventoryBlock,
}


#[derive(Debug)]
pub struct CreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub next_owner_mask: u32,
    pub type_: i8,
    pub inv_type: i8,
    pub wearable_type: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

/// Create inventory
#[derive(Debug)]
pub struct CreateInventoryItem {
    pub agent_data: CreateInventoryItem_AgentData,
    pub inventory_block: CreateInventoryItem_InventoryBlock,
}


#[derive(Debug)]
pub struct CreateLandmarkForEvent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateLandmarkForEvent_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct CreateLandmarkForEvent_InventoryBlock {
    pub folder_id: Uuid,
    pub name: Vec<u8>,
}

/// give agent a landmark for an event.
#[derive(Debug)]
pub struct CreateLandmarkForEvent {
    pub agent_data: CreateLandmarkForEvent_AgentData,
    pub event_data: CreateLandmarkForEvent_EventData,
    pub inventory_block: CreateLandmarkForEvent_InventoryBlock,
}


#[derive(Debug)]
pub struct EventLocationRequest_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct EventLocationRequest_EventData {
    pub event_id: u32,
}


#[derive(Debug)]
pub struct EventLocationRequest {
    pub query_data: EventLocationRequest_QueryData,
    pub event_data: EventLocationRequest_EventData,
}


#[derive(Debug)]
pub struct EventLocationReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct EventLocationReply_EventData {
    pub success: bool,
    pub region_id: Uuid,
    pub region_pos: Vector3<f32>,
}


#[derive(Debug)]
pub struct EventLocationReply {
    pub query_data: EventLocationReply_QueryData,
    pub event_data: EventLocationReply_EventData,
}


#[derive(Debug)]
pub struct RegionHandleRequest_RequestBlock {
    pub region_id: Uuid,
}

/// get information about landmarks. Used by viewers for determining
/// the location of a landmark, and by simulators for teleport
#[derive(Debug)]
pub struct RegionHandleRequest {
    pub request_block: RegionHandleRequest_RequestBlock,
}


#[derive(Debug)]
pub struct RegionIDAndHandleReply_ReplyBlock {
    pub region_id: Uuid,
    pub region_handle: u64,
}


#[derive(Debug)]
pub struct RegionIDAndHandleReply {
    pub reply_block: RegionIDAndHandleReply_ReplyBlock,
}


#[derive(Debug)]
pub struct MoneyTransferRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MoneyTransferRequest_MoneyData {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub description: Vec<u8>,
}

/// Move money from one agent to another. Validation will happen at the
/// simulator, the dataserver will actually do the work. Dataserver
/// generates a MoneyBalance message in reply.  The simulator
/// will generate a MoneyTransferBackend in response to this.
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct MoneyTransferRequest {
    pub agent_data: MoneyTransferRequest_AgentData,
    pub money_data: MoneyTransferRequest_MoneyData,
}


#[derive(Debug)]
pub struct MoneyTransferBackend_MoneyData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
    pub description: Vec<u8>,
}

/// And, the money transfer
/// *NOTE: Unused as of 2010-04-06, because all back-end money transactions
/// are done with web services via L$ API.  JC
#[derive(Debug)]
pub struct MoneyTransferBackend {
    pub money_data: MoneyTransferBackend_MoneyData,
}


#[derive(Debug)]
pub struct MoneyBalanceRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MoneyBalanceRequest_MoneyData {
    pub transaction_id: Uuid,
}

/// viewer -> userserver -> dataserver
/// Reliable
#[derive(Debug)]
pub struct MoneyBalanceRequest {
    pub agent_data: MoneyBalanceRequest_AgentData,
    pub money_data: MoneyBalanceRequest_MoneyData,
}


#[derive(Debug)]
pub struct MoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct MoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

/// dataserver -> simulator -> viewer
/// For replies that are part of a transaction (buying something) provide
/// metadata for localization.  If TransactionType is 0, the message is
/// purely a balance update.  Added for server 1.40 and viewer 2.1.  JC
#[derive(Debug)]
pub struct MoneyBalanceReply {
    pub money_data: MoneyBalanceReply_MoneyData,
    pub transaction_info: MoneyBalanceReply_TransactionInfo,
}


#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: IpPort,
}

#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

/// RoutedMoneyBalanceReply
/// This message is used when a dataserver needs to send updated
/// money balance information to a simulator other than the one it
/// is connected to.  It uses the standard TransferBlock format.
/// dataserver -> simulator -> spaceserver -> simulator -> viewer
/// reliable
/// See MoneyBalanceReply above.
#[derive(Debug)]
pub struct RoutedMoneyBalanceReply {
    pub target_block: RoutedMoneyBalanceReply_TargetBlock,
    pub money_data: RoutedMoneyBalanceReply_MoneyData,
    pub transaction_info: RoutedMoneyBalanceReply_TransactionInfo,
}


#[derive(Debug)]
pub struct ActivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ActivateGestures_Data {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub gesture_flags: u32,
}

/// Tell the database that some gestures are now active
/// viewer -> sim -> data
#[derive(Debug)]
pub struct ActivateGestures {
    pub agent_data: ActivateGestures_AgentData,
    pub data: Vec<ActivateGestures_Data>,
}


#[derive(Debug)]
pub struct DeactivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct DeactivateGestures_Data {
    pub item_id: Uuid,
    pub gesture_flags: u32,
}

/// Tell the database some gestures are no longer active
/// viewer -> sim -> data
#[derive(Debug)]
pub struct DeactivateGestures {
    pub agent_data: DeactivateGestures_AgentData,
    pub data: Vec<DeactivateGestures_Data>,
}


#[derive(Debug)]
pub struct MuteListUpdate_MuteData {
    pub agent_id: Uuid,
    pub filename: Vec<u8>,
}

/// dataserver-> userserver -> viewer to move around the mute list
#[derive(Debug)]
pub struct MuteListUpdate {
    pub mute_data: MuteListUpdate_MuteData,
}


#[derive(Debug)]
pub struct UseCachedMuteList_AgentData {
    pub agent_id: Uuid,
}

/// tell viewer to use the local mute cache
#[derive(Debug)]
pub struct UseCachedMuteList {
    pub agent_data: UseCachedMuteList_AgentData,
}


#[derive(Debug)]
pub struct GrantUserRights_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GrantUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

/// Sent from viewer to simulator to set user rights. This message will be
/// relayed up to the dataserver through a PUT. If that
/// succeeds, an UpdateUserRights will be relayed to the originating
/// viewer, and a presence lookup will be performed to find
/// agent-related and the same PUT will be issued to the sim host if
/// they are online.
#[derive(Debug)]
pub struct GrantUserRights {
    pub agent_data: GrantUserRights_AgentData,
    pub rights: Vec<GrantUserRights_Rights>,
}


#[derive(Debug)]
pub struct ChangeUserRights_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ChangeUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

/// This message is sent from the simulator to the viewer to indicate a
/// targets granted rights. This is only sent to the originator of the
/// request and the target agent if it is a modify or map
/// right. Adding/removing online status rights will show up as an
/// online/offline notification.
#[derive(Debug)]
pub struct ChangeUserRights {
    pub agent_data: ChangeUserRights_AgentData,
    pub rights: Vec<ChangeUserRights_Rights>,
}


#[derive(Debug)]
pub struct OnlineNotification_AgentBlock {
    pub agent_id: Uuid,
}

/// notification for login and logout.
/// source_sim -> dest_viewer
#[derive(Debug)]
pub struct OnlineNotification {
    pub agent_block: Vec<OnlineNotification_AgentBlock>,
}


#[derive(Debug)]
pub struct OfflineNotification_AgentBlock {
    pub agent_id: Uuid,
}


#[derive(Debug)]
pub struct OfflineNotification {
    pub agent_block: Vec<OfflineNotification_AgentBlock>,
}


#[derive(Debug)]
pub struct SetStartLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetStartLocationRequest_StartLocationData {
    pub sim_name: Vec<u8>,
    pub location_id: u32,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

/// SetStartLocationRequest
/// viewer -> sim
/// failure checked at sim and triggers ImprovedInstantMessage
/// success triggers SetStartLocation
#[derive(Debug)]
pub struct SetStartLocationRequest {
    pub agent_data: SetStartLocationRequest_AgentData,
    pub start_location_data: SetStartLocationRequest_StartLocationData,
}


#[derive(Debug)]
pub struct SetStartLocation_StartLocationData {
    pub agent_id: Uuid,
    pub region_id: Uuid,
    pub location_id: u32,
    pub region_handle: u64,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

/// SetStartLocation
/// sim -> dataserver
#[derive(Debug)]
pub struct SetStartLocation {
    pub start_location_data: SetStartLocation_StartLocationData,
}


#[derive(Debug)]
pub struct NetTest_NetBlock {
    pub port: IpPort,
}

/// NetTest - This goes back and forth to the space server because of
/// problems determining the port
#[derive(Debug)]
pub struct NetTest {
    pub net_block: NetTest_NetBlock,
}


#[derive(Debug)]
pub struct SetCPURatio_Data {
    pub ratio: u8,
}

/// SetChildCount - Sent to launcher to adjust nominal child count
/// Simulator sends this increase the sim/cpu ratio on startup
#[derive(Debug)]
pub struct SetCPURatio {
    pub data: SetCPURatio_Data,
}


#[derive(Debug)]
pub struct SimCrashed_Data {
    pub region_x: u32,
    pub region_y: u32,
}

#[derive(Debug)]
pub struct SimCrashed_Users {
    pub agent_id: Uuid,
}

/// SimCrashed - Sent to dataserver when the sim goes down.
/// Maybe we should notify the spaceserver as well?
#[derive(Debug)]
pub struct SimCrashed {
    pub data: SimCrashed_Data,
    pub users: Vec<SimCrashed_Users>,
}


#[derive(Debug)]
pub struct NameValuePair_TaskData {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct NameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

/// NameValuePair - if the specific task exists on simulator, add or replace this name value pair
#[derive(Debug)]
pub struct NameValuePair {
    pub task_data: NameValuePair_TaskData,
    pub name_value_data: Vec<NameValuePair_NameValueData>,
}


#[derive(Debug)]
pub struct RemoveNameValuePair_TaskData {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct RemoveNameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

/// NameValuePair - if the specific task exists on simulator or dataserver, remove the name value pair (value is ignored)
#[derive(Debug)]
pub struct RemoveNameValuePair {
    pub task_data: RemoveNameValuePair_TaskData,
    pub name_value_data: Vec<RemoveNameValuePair_NameValueData>,
}


#[derive(Debug)]
pub struct UpdateAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateAttachment_AttachmentBlock {
    pub attachment_point: u8,
}

#[derive(Debug)]
pub struct UpdateAttachment_OperationData {
    pub add_item: bool,
    pub use_existing_asset: bool,
}

#[derive(Debug)]
pub struct UpdateAttachment_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}


#[derive(Debug)]
pub struct UpdateAttachment {
    pub agent_data: UpdateAttachment_AgentData,
    pub attachment_block: UpdateAttachment_AttachmentBlock,
    pub operation_data: UpdateAttachment_OperationData,
    pub inventory_data: UpdateAttachment_InventoryData,
}


#[derive(Debug)]
pub struct RemoveAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveAttachment_AttachmentBlock {
    pub attachment_point: u8,
    pub item_id: Uuid,
}

/// Simulator informs Dataserver that attachment has been taken off
#[derive(Debug)]
pub struct RemoveAttachment {
    pub agent_data: RemoveAttachment_AgentData,
    pub attachment_block: RemoveAttachment_AttachmentBlock,
}


#[derive(Debug)]
pub struct SoundTrigger_SoundData {
    pub sound_id: Uuid,
    pub owner_id: Uuid,
    pub object_id: Uuid,
    pub parent_id: Uuid,
    pub handle: u64,
    pub position: Vector3<f32>,
    pub gain: f32,
}

/// SoundTrigger - Sent by simulator to viewer to trigger sound outside current region
#[derive(Debug)]
pub struct SoundTrigger {
    pub sound_data: SoundTrigger_SoundData,
}


#[derive(Debug)]
pub struct AttachedSound_DataBlock {
    pub sound_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
}

/// AttachedSound - Sent by simulator to viewer to play sound attached with an object
#[derive(Debug)]
pub struct AttachedSound {
    pub data_block: AttachedSound_DataBlock,
}


#[derive(Debug)]
pub struct AttachedSoundGainChange_DataBlock {
    pub object_id: Uuid,
    pub gain: f32,
}


#[derive(Debug)]
pub struct AttachedSoundGainChange {
    pub data_block: AttachedSoundGainChange_DataBlock,
}


#[derive(Debug)]
pub struct PreloadSound_DataBlock {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub sound_id: Uuid,
}


#[derive(Debug)]
pub struct PreloadSound {
    pub data_block: Vec<PreloadSound_DataBlock>,
}


#[derive(Debug)]
pub struct AssetUploadRequest_AssetBlock {
    pub transaction_id: Uuid,
    pub type_: i8,
    pub tempfile: bool,
    pub store_local: bool,
    pub asset_data: Vec<u8>,
}

/// current assumes an existing UUID, need to enhance for new assets
#[derive(Debug)]
pub struct AssetUploadRequest {
    pub asset_block: AssetUploadRequest_AssetBlock,
}


#[derive(Debug)]
pub struct AssetUploadComplete_AssetBlock {
    pub uuid: Uuid,
    pub type_: i8,
    pub success: bool,
}


#[derive(Debug)]
pub struct AssetUploadComplete {
    pub asset_block: AssetUploadComplete_AssetBlock,
}


#[derive(Debug)]
pub struct EmailMessageRequest_DataBlock {
    pub object_id: Uuid,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
}

/// Script on simulator asks dataserver if there are any email messages
/// waiting.
#[derive(Debug)]
pub struct EmailMessageRequest {
    pub data_block: EmailMessageRequest_DataBlock,
}


#[derive(Debug)]
pub struct EmailMessageReply_DataBlock {
    pub object_id: Uuid,
    pub more: u32,
    pub time: u32,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
    pub data: Vec<u8>,
    pub mail_filter: Vec<u8>,
}

/// Dataserver gives simulator the oldest email message in the queue, along with
/// how many messages are left in the queue.  And passes back the filter used to request emails.
#[derive(Debug)]
pub struct EmailMessageReply {
    pub data_block: EmailMessageReply_DataBlock,
}


#[derive(Debug)]
pub struct InternalScriptMail_DataBlock {
    pub from: Vec<u8>,
    pub to: Uuid,
    pub subject: Vec<u8>,
    pub body: Vec<u8>,
}

/// Script on simulator sends mail to another script
#[derive(Debug)]
pub struct InternalScriptMail {
    pub data_block: InternalScriptMail_DataBlock,
}


#[derive(Debug)]
pub struct ScriptDataRequest_DataBlock {
    pub hash: u64,
    pub request_type: i8,
    pub request: Vec<u8>,
}

/// Script on simulator asks dataserver for information
#[derive(Debug)]
pub struct ScriptDataRequest {
    pub data_block: Vec<ScriptDataRequest_DataBlock>,
}


#[derive(Debug)]
pub struct ScriptDataReply_DataBlock {
    pub hash: u64,
    pub reply: Vec<u8>,
}

/// Data server responds with data
#[derive(Debug)]
pub struct ScriptDataReply {
    pub data_block: Vec<ScriptDataReply_DataBlock>,
}


#[derive(Debug)]
pub struct CreateGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateGroupRequest_GroupData {
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

/// CreateGroupRequest
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct CreateGroupRequest {
    pub agent_data: CreateGroupRequest_AgentData,
    pub group_data: CreateGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct CreateGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct CreateGroupReply_ReplyData {
    pub group_id: Uuid,
    pub success: bool,
    pub message: Vec<u8>,
}

/// CreateGroupReply
/// dataserver -> simulator
/// simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct CreateGroupReply {
    pub agent_data: CreateGroupReply_AgentData,
    pub reply_data: CreateGroupReply_ReplyData,
}


#[derive(Debug)]
pub struct UpdateGroupInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateGroupInfo_GroupData {
    pub group_id: Uuid,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

/// UpdateGroupInfo
/// viewer -> simulator
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct UpdateGroupInfo {
    pub agent_data: UpdateGroupInfo_AgentData,
    pub group_data: UpdateGroupInfo_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleChanges_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleChanges_RoleChange {
    pub role_id: Uuid,
    pub member_id: Uuid,
    pub change: u32,
}

/// GroupRoleChanges
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupRoleChanges {
    pub agent_data: GroupRoleChanges_AgentData,
    pub role_change: Vec<GroupRoleChanges_RoleChange>,
}


#[derive(Debug)]
pub struct JoinGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct JoinGroupRequest_GroupData {
    pub group_id: Uuid,
}

/// JoinGroupRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct JoinGroupRequest {
    pub agent_data: JoinGroupRequest_AgentData,
    pub group_data: JoinGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct JoinGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct JoinGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

/// JoinGroupReply
/// dataserver -> simulator -> viewer
#[derive(Debug)]
pub struct JoinGroupReply {
    pub agent_data: JoinGroupReply_AgentData,
    pub group_data: JoinGroupReply_GroupData,
}


#[derive(Debug)]
pub struct EjectGroupMemberRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberRequest_EjectData {
    pub ejectee_id: Uuid,
}

/// EjectGroupMemberRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct EjectGroupMemberRequest {
    pub agent_data: EjectGroupMemberRequest_AgentData,
    pub group_data: EjectGroupMemberRequest_GroupData,
    pub eject_data: Vec<EjectGroupMemberRequest_EjectData>,
}


#[derive(Debug)]
pub struct EjectGroupMemberReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberReply_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberReply_EjectData {
    pub success: bool,
}

/// EjectGroupMemberReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct EjectGroupMemberReply {
    pub agent_data: EjectGroupMemberReply_AgentData,
    pub group_data: EjectGroupMemberReply_GroupData,
    pub eject_data: EjectGroupMemberReply_EjectData,
}


#[derive(Debug)]
pub struct LeaveGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LeaveGroupRequest_GroupData {
    pub group_id: Uuid,
}

/// LeaveGroupRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct LeaveGroupRequest {
    pub agent_data: LeaveGroupRequest_AgentData,
    pub group_data: LeaveGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct LeaveGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct LeaveGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

/// LeaveGroupReply
/// dataserver -> simulator -> viewer
#[derive(Debug)]
pub struct LeaveGroupReply {
    pub agent_data: LeaveGroupReply_AgentData,
    pub group_data: LeaveGroupReply_GroupData,
}


#[derive(Debug)]
pub struct InviteGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct InviteGroupRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct InviteGroupRequest_InviteData {
    pub invitee_id: Uuid,
    pub role_id: Uuid,
}

/// InviteGroupRequest
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct InviteGroupRequest {
    pub agent_data: InviteGroupRequest_AgentData,
    pub group_data: InviteGroupRequest_GroupData,
    pub invite_data: Vec<InviteGroupRequest_InviteData>,
}


#[derive(Debug)]
pub struct InviteGroupResponse_InviteData {
    pub agent_id: Uuid,
    pub invitee_id: Uuid,
    pub group_id: Uuid,
    pub role_id: Uuid,
    pub membership_fee: i32,
}

/// InviteGroupResponse
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct InviteGroupResponse {
    pub invite_data: InviteGroupResponse_InviteData,
}


#[derive(Debug)]
pub struct GroupProfileRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileRequest_GroupData {
    pub group_id: Uuid,
}

/// GroupProfileRequest
/// viewer-> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupProfileRequest {
    pub agent_data: GroupProfileRequest_AgentData,
    pub group_data: GroupProfileRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupProfileReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileReply_GroupData {
    pub group_id: Uuid,
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub member_title: Vec<u8>,
    pub powers_mask: u64,
    pub insignia_id: Uuid,
    pub founder_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub money: i32,
    pub group_membership_count: i32,
    pub group_roles_count: i32,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub owner_role: Uuid,
}

/// GroupProfileReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct GroupProfileReply {
    pub agent_data: GroupProfileReply_AgentData,
    pub group_data: GroupProfileReply_GroupData,
}


#[derive(Debug)]
pub struct GroupAccountSummaryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountSummaryRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

/// CurrentInterval = 0  =>  this period (week, day, etc.)
/// CurrentInterval = 1  =>  last period
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupAccountSummaryRequest {
    pub agent_data: GroupAccountSummaryRequest_AgentData,
    pub money_data: GroupAccountSummaryRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountSummaryReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountSummaryReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
    pub balance: i32,
    pub total_credits: i32,
    pub total_debits: i32,
    pub object_tax_current: i32,
    pub light_tax_current: i32,
    pub land_tax_current: i32,
    pub group_tax_current: i32,
    pub parcel_dir_fee_current: i32,
    pub object_tax_estimate: i32,
    pub light_tax_estimate: i32,
    pub land_tax_estimate: i32,
    pub group_tax_estimate: i32,
    pub parcel_dir_fee_estimate: i32,
    pub non_exempt_members: i32,
    pub last_tax_date: Vec<u8>,
    pub tax_date: Vec<u8>,
}

/// dataserver -> simulator -> viewer
/// Reliable
#[derive(Debug)]
pub struct GroupAccountSummaryReply {
    pub agent_data: GroupAccountSummaryReply_AgentData,
    pub money_data: GroupAccountSummaryReply_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountDetailsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountDetailsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

/// Reliable
#[derive(Debug)]
pub struct GroupAccountDetailsRequest {
    pub agent_data: GroupAccountDetailsRequest_AgentData,
    pub money_data: GroupAccountDetailsRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountDetailsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountDetailsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupAccountDetailsReply_HistoryData {
    pub description: Vec<u8>,
    pub amount: i32,
}

/// Reliable
#[derive(Debug)]
pub struct GroupAccountDetailsReply {
    pub agent_data: GroupAccountDetailsReply_AgentData,
    pub money_data: GroupAccountDetailsReply_MoneyData,
    pub history_data: Vec<GroupAccountDetailsReply_HistoryData>,
}


#[derive(Debug)]
pub struct GroupAccountTransactionsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

/// Reliable
#[derive(Debug)]
pub struct GroupAccountTransactionsRequest {
    pub agent_data: GroupAccountTransactionsRequest_AgentData,
    pub money_data: GroupAccountTransactionsRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountTransactionsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsReply_HistoryData {
    pub time: Vec<u8>,
    pub user: Vec<u8>,
    pub type_: i32,
    pub item: Vec<u8>,
    pub amount: i32,
}

/// Reliable
#[derive(Debug)]
pub struct GroupAccountTransactionsReply {
    pub agent_data: GroupAccountTransactionsReply_AgentData,
    pub money_data: GroupAccountTransactionsReply_MoneyData,
    pub history_data: Vec<GroupAccountTransactionsReply_HistoryData>,
}


#[derive(Debug)]
pub struct GroupActiveProposalsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalsRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalsRequest_TransactionData {
    pub transaction_id: Uuid,
}

/// GroupActiveProposalsRequest
/// viewer -> simulator -> dataserver
///reliable
#[derive(Debug)]
pub struct GroupActiveProposalsRequest {
    pub agent_data: GroupActiveProposalsRequest_AgentData,
    pub group_data: GroupActiveProposalsRequest_GroupData,
    pub transaction_data: GroupActiveProposalsRequest_TransactionData,
}


#[derive(Debug)]
pub struct GroupActiveProposalItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

#[derive(Debug)]
pub struct GroupActiveProposalItemReply_ProposalData {
    pub vote_id: Uuid,
    pub vote_initiator: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub already_voted: bool,
    pub vote_cast: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

/// GroupActiveProposalItemReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct GroupActiveProposalItemReply {
    pub agent_data: GroupActiveProposalItemReply_AgentData,
    pub transaction_data: GroupActiveProposalItemReply_TransactionData,
    pub proposal_data: Vec<GroupActiveProposalItemReply_ProposalData>,
}


#[derive(Debug)]
pub struct GroupVoteHistoryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryRequest_TransactionData {
    pub transaction_id: Uuid,
}

/// GroupVoteHistoryRequest
/// viewer -> simulator -> dataserver
///reliable
#[derive(Debug)]
pub struct GroupVoteHistoryRequest {
    pub agent_data: GroupVoteHistoryRequest_AgentData,
    pub group_data: GroupVoteHistoryRequest_GroupData,
    pub transaction_data: GroupVoteHistoryRequest_TransactionData,
}


#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_HistoryItemData {
    pub vote_id: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub vote_initiator: Uuid,
    pub vote_type: Vec<u8>,
    pub vote_result: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_VoteItem {
    pub candidate_id: Uuid,
    pub vote_cast: Vec<u8>,
    pub num_votes: i32,
}

/// GroupVoteHistoryItemReply
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct GroupVoteHistoryItemReply {
    pub agent_data: GroupVoteHistoryItemReply_AgentData,
    pub transaction_data: GroupVoteHistoryItemReply_TransactionData,
    pub history_item_data: GroupVoteHistoryItemReply_HistoryItemData,
    pub vote_item: Vec<GroupVoteHistoryItemReply_VoteItem>,
}


#[derive(Debug)]
pub struct StartGroupProposal_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StartGroupProposal_ProposalData {
    pub group_id: Uuid,
    pub quorum: i32,
    pub majority: f32,
    pub duration: i32,
    pub proposal_text: Vec<u8>,
}

/// StartGroupProposal
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct StartGroupProposal {
    pub agent_data: StartGroupProposal_AgentData,
    pub proposal_data: StartGroupProposal_ProposalData,
}


#[derive(Debug)]
pub struct GroupProposalBallot_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProposalBallot_ProposalData {
    pub proposal_id: Uuid,
    pub group_id: Uuid,
    pub vote_cast: Vec<u8>,
}

/// GroupProposalBallot
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupProposalBallot {
    pub agent_data: GroupProposalBallot_AgentData,
    pub proposal_data: GroupProposalBallot_ProposalData,
}


/// TallyVotes userserver -> dataserver
/// reliable
#[derive(Debug)]
pub struct TallyVotes {}


#[derive(Debug)]
pub struct GroupMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

/// GroupMembersRequest
/// get the group members
/// simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct GroupMembersRequest {
    pub agent_data: GroupMembersRequest_AgentData,
    pub group_data: GroupMembersRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupMembersReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupMembersReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub member_count: i32,
}

#[derive(Debug)]
pub struct GroupMembersReply_MemberData {
    pub agent_id: Uuid,
    pub contribution: i32,
    pub online_status: Vec<u8>,
    pub agent_powers: u64,
    pub title: Vec<u8>,
    pub is_owner: bool,
}

/// GroupMembersReply
/// list of uuids for the group members
/// dataserver -> simulator
/// reliable
#[derive(Debug)]
pub struct GroupMembersReply {
    pub agent_data: GroupMembersReply_AgentData,
    pub group_data: GroupMembersReply_GroupData,
    pub member_data: Vec<GroupMembersReply_MemberData>,
}


#[derive(Debug)]
pub struct ActivateGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

/// used to switch an agent's currently active group.
/// viewer -> simulator -> dataserver -> AgentDataUpdate...
#[derive(Debug)]
pub struct ActivateGroup {
    pub agent_data: ActivateGroup_AgentData,
}


#[derive(Debug)]
pub struct SetGroupContribution_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetGroupContribution_Data {
    pub group_id: Uuid,
    pub contribution: i32,
}

/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct SetGroupContribution {
    pub agent_data: SetGroupContribution_AgentData,
    pub data: SetGroupContribution_Data,
}


#[derive(Debug)]
pub struct SetGroupAcceptNotices_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetGroupAcceptNotices_Data {
    pub group_id: Uuid,
    pub accept_notices: bool,
}

#[derive(Debug)]
pub struct SetGroupAcceptNotices_NewData {
    pub list_in_profile: bool,
}

/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct SetGroupAcceptNotices {
    pub agent_data: SetGroupAcceptNotices_AgentData,
    pub data: SetGroupAcceptNotices_Data,
    pub new_data: SetGroupAcceptNotices_NewData,
}


#[derive(Debug)]
pub struct GroupRoleDataRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleDataRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

/// GroupRoleDataRequest
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct GroupRoleDataRequest {
    pub agent_data: GroupRoleDataRequest_AgentData,
    pub group_data: GroupRoleDataRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleDataReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleDataReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub role_count: i32,
}

#[derive(Debug)]
pub struct GroupRoleDataReply_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub title: Vec<u8>,
    pub description: Vec<u8>,
    pub powers: u64,
    pub members: u32,
}

/// GroupRoleDataReply
/// All role data for this group
/// dataserver -> simulator -> agent
#[derive(Debug)]
pub struct GroupRoleDataReply {
    pub agent_data: GroupRoleDataReply_AgentData,
    pub group_data: GroupRoleDataReply_GroupData,
    pub role_data: Vec<GroupRoleDataReply_RoleData>,
}


#[derive(Debug)]
pub struct GroupRoleMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

/// GroupRoleMembersRequest
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct GroupRoleMembersRequest {
    pub agent_data: GroupRoleMembersRequest_AgentData,
    pub group_data: GroupRoleMembersRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleMembersReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub total_pairs: u32,
}

#[derive(Debug)]
pub struct GroupRoleMembersReply_MemberData {
    pub role_id: Uuid,
    pub member_id: Uuid,
}

/// GroupRoleMembersReply
/// All role::member pairs for this group.
/// dataserver -> simulator -> agent
#[derive(Debug)]
pub struct GroupRoleMembersReply {
    pub agent_data: GroupRoleMembersReply_AgentData,
    pub member_data: Vec<GroupRoleMembersReply_MemberData>,
}


#[derive(Debug)]
pub struct GroupTitlesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

/// GroupTitlesRequest
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct GroupTitlesRequest {
    pub agent_data: GroupTitlesRequest_AgentData,
}


#[derive(Debug)]
pub struct GroupTitlesReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupTitlesReply_GroupData {
    pub title: Vec<u8>,
    pub role_id: Uuid,
    pub selected: bool,
}

/// GroupTitlesReply
/// dataserver -> simulator -> viewer
#[derive(Debug)]
pub struct GroupTitlesReply {
    pub agent_data: GroupTitlesReply_AgentData,
    pub group_data: Vec<GroupTitlesReply_GroupData>,
}


#[derive(Debug)]
pub struct GroupTitleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub title_role_id: Uuid,
}

/// GroupTitleUpdate
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct GroupTitleUpdate {
    pub agent_data: GroupTitleUpdate_AgentData,
}


#[derive(Debug)]
pub struct GroupRoleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleUpdate_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub title: Vec<u8>,
    pub powers: u64,
    pub update_type: u8,
}

/// GroupRoleUpdate
/// viewer -> simulator -> dataserver
#[derive(Debug)]
pub struct GroupRoleUpdate {
    pub agent_data: GroupRoleUpdate_AgentData,
    pub role_data: Vec<GroupRoleUpdate_RoleData>,
}


#[derive(Debug)]
pub struct LiveHelpGroupRequest_RequestData {
    pub request_id: Uuid,
    pub agent_id: Uuid,
}

/// Request the members of the live help group needed for requesting agent.
/// userserver -> dataserver
#[derive(Debug)]
pub struct LiveHelpGroupRequest {
    pub request_data: LiveHelpGroupRequest_RequestData,
}


#[derive(Debug)]
pub struct LiveHelpGroupReply_ReplyData {
    pub request_id: Uuid,
    pub group_id: Uuid,
    pub selection: Vec<u8>,
}

/// Send down the group
/// dataserver -> userserver
#[derive(Debug)]
pub struct LiveHelpGroupReply {
    pub reply_data: LiveHelpGroupReply_ReplyData,
}


#[derive(Debug)]
pub struct AgentWearablesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// AgentWearablesRequest
/// (a.k.a. "Tell me what the avatar is wearing.")
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct AgentWearablesRequest {
    pub agent_data: AgentWearablesRequest_AgentData,
}


#[derive(Debug)]
pub struct AgentWearablesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

#[derive(Debug)]
pub struct AgentWearablesUpdate_WearableData {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub wearable_type: u8,
}

/// AgentWearablesUpdate
/// (a.k.a. "Here's what your avatar should be wearing now.")
/// dataserver -> userserver -> viewer
/// reliable
/// NEVER from viewer to sim
#[derive(Debug)]
pub struct AgentWearablesUpdate {
    pub agent_data: AgentWearablesUpdate_AgentData,
    pub wearable_data: Vec<AgentWearablesUpdate_WearableData>,
}


#[derive(Debug)]
pub struct AgentIsNowWearing_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentIsNowWearing_WearableData {
    pub item_id: Uuid,
    pub wearable_type: u8,
}

///
/// AgentIsNowWearing
/// (a.k.a. "Here's what I'm wearing now.")
/// viewer->sim->dataserver
/// reliable
#[derive(Debug)]
pub struct AgentIsNowWearing {
    pub agent_data: AgentIsNowWearing_AgentData,
    pub wearable_data: Vec<AgentIsNowWearing_WearableData>,
}


#[derive(Debug)]
pub struct AgentCachedTexture_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

#[derive(Debug)]
pub struct AgentCachedTexture_WearableData {
    pub id: Uuid,
    pub texture_index: u8,
}

/// AgentCachedTexture
/// viewer queries for cached textures on dataserver (via simulator)
/// viewer -> simulator -> dataserver
/// reliable
#[derive(Debug)]
pub struct AgentCachedTexture {
    pub agent_data: AgentCachedTexture_AgentData,
    pub wearable_data: Vec<AgentCachedTexture_WearableData>,
}


#[derive(Debug)]
pub struct AgentCachedTextureResponse_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

#[derive(Debug)]
pub struct AgentCachedTextureResponse_WearableData {
    pub texture_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

/// AgentCachedTextureResponse
/// response to viewer queries for cached textures on dataserver (via simulator)
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AgentCachedTextureResponse {
    pub agent_data: AgentCachedTextureResponse_AgentData,
    pub wearable_data: Vec<AgentCachedTextureResponse_WearableData>,
}


#[derive(Debug)]
pub struct AgentDataUpdateRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

/// Request an AgentDataUpdate without changing any agent data.
#[derive(Debug)]
pub struct AgentDataUpdateRequest {
    pub agent_data: AgentDataUpdateRequest_AgentData,
}


#[derive(Debug)]
pub struct AgentDataUpdate_AgentData {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group_title: Vec<u8>,
    pub active_group_id: Uuid,
    pub group_powers: u64,
    pub group_name: Vec<u8>,
}

/// AgentDataUpdate
/// Updates a viewer or simulator's impression of agent-specific information.
/// Used, for example, when an agent's group changes.
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AgentDataUpdate {
    pub agent_data: AgentDataUpdate_AgentData,
}


#[derive(Debug)]
pub struct GroupDataUpdate_AgentGroupData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub agent_powers: u64,
    pub group_title: Vec<u8>,
}

/// GroupDataUpdate
/// This is a bunch of group data that needs to be appropriatly routed based on presence info.
/// dataserver -> simulator
#[derive(Debug)]
pub struct GroupDataUpdate {
    pub agent_group_data: Vec<GroupDataUpdate_AgentGroupData>,
}


#[derive(Debug)]
pub struct AgentGroupDataUpdate_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AgentGroupDataUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_insignia_id: Uuid,
    pub contribution: i32,
    pub group_name: Vec<u8>,
}

/// AgentGroupDataUpdate
/// Updates a viewer or simulator's impression of the groups an agent is in.
/// dataserver -> simulator -> viewer
/// reliable
#[derive(Debug)]
pub struct AgentGroupDataUpdate {
    pub agent_data: AgentGroupDataUpdate_AgentData,
    pub group_data: Vec<AgentGroupDataUpdate_GroupData>,
}


#[derive(Debug)]
pub struct AgentDropGroup_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

/// AgentDropGroup
/// Updates the viewer / simulator that an agent is no longer part of a group
/// dataserver -> simulator -> viewer
/// dataserver -> userserver
/// reliable
#[derive(Debug)]
pub struct AgentDropGroup {
    pub agent_data: AgentDropGroup_AgentData,
}


#[derive(Debug)]
pub struct LogTextMessage_DataBlock {
    pub from_agent_id: Uuid,
    pub to_agent_id: Uuid,
    pub global_x: f64,
    pub global_y: f64,
    pub time: u32,
    pub message: Vec<u8>,
}

/// LogTextMessage
/// Asks the dataserver to log the contents of this message in the
/// chat and IM log table.
/// Sent from userserver (IM logging) and simulator (chat logging).
#[derive(Debug)]
pub struct LogTextMessage {
    pub data_block: Vec<LogTextMessage_DataBlock>,
}


#[derive(Debug)]
pub struct ViewerEffect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ViewerEffect_Effect {
    pub id: Uuid,
    pub agent_id: Uuid,
    pub type_: u8,
    pub duration: f32,
    pub color: [u8; 4],
    pub type_data: Vec<u8>,
}

/// ViewerEffect
/// Viewer side effect that's sent from one viewer, and broadcast to other agents nearby
/// viewer-->sim (single effect created by viewer)
/// sim-->viewer (multiple effects that can be seen by viewer)
/// the AgentData block used for authentication for viewer-->sim messages
#[derive(Debug)]
pub struct ViewerEffect {
    pub agent_data: ViewerEffect_AgentData,
    pub effect: Vec<ViewerEffect_Effect>,
}


#[derive(Debug)]
pub struct CreateTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
    pub digest: [u8; 32],
}

/// CreateTrustedCircuit
/// Sent to establish a trust relationship between two components.
/// Only sent in response to a DenyTrustedCircuit message.
#[derive(Debug)]
pub struct CreateTrustedCircuit {
    pub data_block: CreateTrustedCircuit_DataBlock,
}


#[derive(Debug)]
pub struct DenyTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
}

/// DenyTrustedCircuit
/// Sent :
/// - in response to failed CreateTrustedCircuit
/// - to force the remote end-point to try to establish a trusted circuit
/// - the reception of a trusted message on a non-trusted circuit
/// This allows us to re-auth a circuit if it gets closed due to timeouts or network failures.
#[derive(Debug)]
pub struct DenyTrustedCircuit {
    pub data_block: DenyTrustedCircuit_DataBlock,
}


/// RequestTrustedCircuit
/// If the destination does not trust the sender, a Deny is sent back.
#[derive(Debug)]
pub struct RequestTrustedCircuit {}


#[derive(Debug)]
pub struct RezSingleAttachmentFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezSingleAttachmentFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}


#[derive(Debug)]
pub struct RezSingleAttachmentFromInv {
    pub agent_data: RezSingleAttachmentFromInv_AgentData,
    pub object_data: RezSingleAttachmentFromInv_ObjectData,
}


#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_HeaderData {
    pub compound_msg_id: Uuid,
    pub total_objects: u8,
    pub first_detach_all: bool,
}

#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}


#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv {
    pub agent_data: RezMultipleAttachmentsFromInv_AgentData,
    pub header_data: RezMultipleAttachmentsFromInv_HeaderData,
    pub object_data: Vec<RezMultipleAttachmentsFromInv_ObjectData>,
}


#[derive(Debug)]
pub struct DetachAttachmentIntoInv_ObjectData {
    pub agent_id: Uuid,
    pub item_id: Uuid,
}


#[derive(Debug)]
pub struct DetachAttachmentIntoInv {
    pub object_data: DetachAttachmentIntoInv_ObjectData,
}


#[derive(Debug)]
pub struct CreateNewOutfitAttachments_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateNewOutfitAttachments_HeaderData {
    pub new_folder_id: Uuid,
}

#[derive(Debug)]
pub struct CreateNewOutfitAttachments_ObjectData {
    pub old_item_id: Uuid,
    pub old_folder_id: Uuid,
}

/// Viewer -> Sim
/// Used in "Make New Outfit"
#[derive(Debug)]
pub struct CreateNewOutfitAttachments {
    pub agent_data: CreateNewOutfitAttachments_AgentData,
    pub header_data: CreateNewOutfitAttachments_HeaderData,
    pub object_data: Vec<CreateNewOutfitAttachments_ObjectData>,
}


#[derive(Debug)]
pub struct UserInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}


#[derive(Debug)]
pub struct UserInfoRequest {
    pub agent_data: UserInfoRequest_AgentData,
}


#[derive(Debug)]
pub struct UserInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct UserInfoReply_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
    pub e_mail: Vec<u8>,
}


#[derive(Debug)]
pub struct UserInfoReply {
    pub agent_data: UserInfoReply_AgentData,
    pub user_data: UserInfoReply_UserData,
}


#[derive(Debug)]
pub struct UpdateUserInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateUserInfo_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
}


#[derive(Debug)]
pub struct UpdateUserInfo {
    pub agent_data: UpdateUserInfo_AgentData,
    pub user_data: UpdateUserInfo_UserData,
}


#[derive(Debug)]
pub struct ParcelRename_ParcelData {
    pub parcel_id: Uuid,
    pub new_name: Vec<u8>,
}

/// spaceserver -> sim
/// tell a particular simulator to rename a parcel
#[derive(Debug)]
pub struct ParcelRename {
    pub parcel_data: Vec<ParcelRename_ParcelData>,
}


#[derive(Debug)]
pub struct InitiateDownload_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct InitiateDownload_FileData {
    pub sim_filename: Vec<u8>,
    pub viewer_filename: Vec<u8>,
}

/// sim -> viewer
/// initiate upload. primarily used for uploading raw files.
#[derive(Debug)]
pub struct InitiateDownload {
    pub agent_data: InitiateDownload_AgentData,
    pub file_data: InitiateDownload_FileData,
}


#[derive(Debug)]
pub struct SystemMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
    pub digest: [u8; 32],
}

#[derive(Debug)]
pub struct SystemMessage_ParamList {
    pub parameter: Vec<u8>,
}

/// Generalized system message. Each Requst has its own protocol for
/// the StringData block format and contents.
#[derive(Debug)]
pub struct SystemMessage {
    pub method_data: SystemMessage_MethodData,
    pub param_list: Vec<SystemMessage_ParamList>,
}


#[derive(Debug)]
pub struct MapLayerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

/// viewer -> sim
/// reliable
/// This message is sent up from the viewer to (eventually) get a list
/// of all map layers and NULL-layer sims.
/// Returns: MapLayerReply and MapBlockReply
#[derive(Debug)]
pub struct MapLayerRequest {
    pub agent_data: MapLayerRequest_AgentData,
}


#[derive(Debug)]
pub struct MapLayerReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapLayerReply_LayerData {
    pub left: u32,
    pub right: u32,
    pub top: u32,
    pub bottom: u32,
    pub image_id: Uuid,
}

/// sim -> viewer
#[derive(Debug)]
pub struct MapLayerReply {
    pub agent_data: MapLayerReply_AgentData,
    pub layer_data: Vec<MapLayerReply_LayerData>,
}


#[derive(Debug)]
pub struct MapBlockRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapBlockRequest_PositionData {
    pub min_x: u16,
    pub max_x: u16,
    pub min_y: u16,
    pub max_y: u16,
}

/// viewer -> sim
/// This message is sent up from the viewer to get a list
/// of the sims in a specified region.
/// Returns: MapBlockReply
#[derive(Debug)]
pub struct MapBlockRequest {
    pub agent_data: MapBlockRequest_AgentData,
    pub position_data: MapBlockRequest_PositionData,
}


#[derive(Debug)]
pub struct MapNameRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapNameRequest_NameData {
    pub name: Vec<u8>,
}

/// viewer -> sim
/// This message is sent up from the viewer to get a list
/// of the sims with a given name.
/// Returns: MapBlockReply
#[derive(Debug)]
pub struct MapNameRequest {
    pub agent_data: MapNameRequest_AgentData,
    pub name_data: MapNameRequest_NameData,
}


#[derive(Debug)]
pub struct MapBlockReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapBlockReply_Data {
    pub x: u16,
    pub y: u16,
    pub name: Vec<u8>,
    pub access: u8,
    pub region_flags: u32,
    pub water_height: u8,
    pub agents: u8,
    pub map_image_id: Uuid,
}

/// sim -> viewer
#[derive(Debug)]
pub struct MapBlockReply {
    pub agent_data: MapBlockReply_AgentData,
    pub data: Vec<MapBlockReply_Data>,
}


#[derive(Debug)]
pub struct MapItemRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapItemRequest_RequestData {
    pub item_type: u32,
    pub region_handle: u64,
}

/// viewer -> sim
/// This message is sent up from the viewer to get a list
/// of the items of a particular type on the map.
/// Used for Telehubs, Agents, Events, Popular Places, etc.
/// Returns: MapBlockReply
#[derive(Debug)]
pub struct MapItemRequest {
    pub agent_data: MapItemRequest_AgentData,
    pub request_data: MapItemRequest_RequestData,
}


#[derive(Debug)]
pub struct MapItemReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapItemReply_RequestData {
    pub item_type: u32,
}

#[derive(Debug)]
pub struct MapItemReply_Data {
    pub x: u32,
    pub y: u32,
    pub id: Uuid,
    pub extra: i32,
    pub extra2: i32,
    pub name: Vec<u8>,
}

/// sim -> viewer
#[derive(Debug)]
pub struct MapItemReply {
    pub agent_data: MapItemReply_AgentData,
    pub request_data: MapItemReply_RequestData,
    pub data: Vec<MapItemReply_Data>,
}


#[derive(Debug)]
pub struct SendPostcard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub asset_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub to: Vec<u8>,
    pub from: Vec<u8>,
    pub name: Vec<u8>,
    pub subject: Vec<u8>,
    pub msg: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

///-----------------------------------------------------------------------------
/// Postcard messages
///-----------------------------------------------------------------------------
/// reliable
#[derive(Debug)]
pub struct SendPostcard {
    pub agent_data: SendPostcard_AgentData,
}


#[derive(Debug)]
pub struct RpcChannelRequest_DataBlock {
    pub grid_x: u32,
    pub grid_y: u32,
    pub task_id: Uuid,
    pub item_id: Uuid,
}

/// RPC messages
/// Script on simulator requests rpc channel from rpcserver
/// simulator -> dataserver -> MySQL
#[derive(Debug)]
pub struct RpcChannelRequest {
    pub data_block: RpcChannelRequest_DataBlock,
}


#[derive(Debug)]
pub struct RpcChannelReply_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
}

/// RpcServer allocated a session for the script
/// ChannelID will be the NULL UUID if unable to register
/// dataserver -> simulator
#[derive(Debug)]
pub struct RpcChannelReply {
    pub data_block: RpcChannelReply_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptRequestInbound_TargetBlock {
    pub grid_x: u32,
    pub grid_y: u32,
}

#[derive(Debug)]
pub struct RpcScriptRequestInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

/// Inbound RPC requests follow this path:
/// RpcScriptRequestInbound: rpcserver -> spaceserver
/// RpcScriptRequestInboundForward: spaceserver -> simulator
/// reply: simulator -> rpcserver
#[derive(Debug)]
pub struct RpcScriptRequestInbound {
    pub target_block: RpcScriptRequestInbound_TargetBlock,
    pub data_block: RpcScriptRequestInbound_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptRequestInboundForward_DataBlock {
    pub rpc_server_ip: Ip4Addr,
    pub rpc_server_port: IpPort,
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

/// spaceserver -> simulator
#[derive(Debug)]
pub struct RpcScriptRequestInboundForward {
    pub data_block: RpcScriptRequestInboundForward_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptReplyInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

/// simulator -> rpcserver
/// Not trusted because trust establishment doesn't work here.
#[derive(Debug)]
pub struct RpcScriptReplyInbound {
    pub data_block: RpcScriptReplyInbound_DataBlock,
}


#[derive(Debug)]
pub struct ScriptMailRegistration_DataBlock {
    pub target_ip: Vec<u8>,
    pub target_port: IpPort,
    pub task_id: Uuid,
    pub flags: u32,
}

/// ScriptMailRegistration
/// Simulator -> dataserver
#[derive(Debug)]
pub struct ScriptMailRegistration {
    pub data_block: ScriptMailRegistration_DataBlock,
}


#[derive(Debug)]
pub struct ParcelMediaCommandMessage_CommandBlock {
    pub flags: u32,
    pub command: u32,
    pub time: f32,
}

/// ParcelMediaCommandMessage
/// Sends a parcel media command
#[derive(Debug)]
pub struct ParcelMediaCommandMessage {
    pub command_block: ParcelMediaCommandMessage_CommandBlock,
}


#[derive(Debug)]
pub struct ParcelMediaUpdate_DataBlock {
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
}

#[derive(Debug)]
pub struct ParcelMediaUpdate_DataBlockExtended {
    pub media_type: Vec<u8>,
    pub media_desc: Vec<u8>,
    pub media_width: i32,
    pub media_height: i32,
    pub media_loop: u8,
}

/// ParcelMediaUpdate
/// Sends a parcel media update to a single user
/// For global updates use the parcel manager.
#[derive(Debug)]
pub struct ParcelMediaUpdate {
    pub data_block: ParcelMediaUpdate_DataBlock,
    pub data_block_extended: ParcelMediaUpdate_DataBlockExtended,
}


#[derive(Debug)]
pub struct LandStatRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LandStatRequest_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub filter: Vec<u8>,
    pub parcel_local_id: i32,
}

/// LandStatRequest
/// Sent by the viewer to request collider/script information for a parcel
#[derive(Debug)]
pub struct LandStatRequest {
    pub agent_data: LandStatRequest_AgentData,
    pub request_data: LandStatRequest_RequestData,
}


#[derive(Debug)]
pub struct LandStatReply_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub total_object_count: u32,
}

#[derive(Debug)]
pub struct LandStatReply_ReportData {
    pub task_local_id: u32,
    pub task_id: Uuid,
    pub location_x: f32,
    pub location_y: f32,
    pub location_z: f32,
    pub score: f32,
    pub task_name: Vec<u8>,
    pub owner_name: Vec<u8>,
}

/// LandStatReply
/// Sent by the simulator in response to LandStatRequest
#[derive(Debug)]
pub struct LandStatReply {
    pub request_data: LandStatReply_RequestData,
    pub report_data: Vec<LandStatReply_ReportData>,
}


#[derive(Debug)]
pub struct Error_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct Error_Data {
    pub code: i32,
    pub token: Vec<u8>,
    pub id: Uuid,
    pub system: Vec<u8>,
    pub message: Vec<u8>,
    pub data: Vec<u8>,
}

/// Generic Error -- this is used for sending an error message
/// to a UDP recipient. The lowest common denominator is to at least
/// log the message. More sophisticated receivers can do something
/// smarter, for example, a money transaction failure can put up a
/// more user visible UI widget.
#[derive(Debug)]
pub struct Error {
    pub agent_data: Error_AgentData,
    pub data: Error_Data,
}


#[derive(Debug)]
pub struct ObjectIncludeInSearch_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectIncludeInSearch_ObjectData {
    pub object_local_id: u32,
    pub include_in_search: bool,
}

/// ObjectIncludeInSearch
/// viewer -> simulator
#[derive(Debug)]
pub struct ObjectIncludeInSearch {
    pub agent_data: ObjectIncludeInSearch_AgentData,
    pub object_data: Vec<ObjectIncludeInSearch_ObjectData>,
}


#[derive(Debug)]
pub struct RezRestoreToWorld_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezRestoreToWorld_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

/// This message is sent from viewer -> simulator when the viewer wants
/// to rez an object out of inventory back to its position before it
/// last moved into the inventory
#[derive(Debug)]
pub struct RezRestoreToWorld {
    pub agent_data: RezRestoreToWorld_AgentData,
    pub inventory_data: RezRestoreToWorld_InventoryData,
}


#[derive(Debug)]
pub struct LinkInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LinkInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub old_item_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}


#[derive(Debug)]
pub struct LinkInventoryItem {
    pub agent_data: LinkInventoryItem_AgentData,
    pub inventory_block: LinkInventoryItem_InventoryBlock,
}


#[derive(Debug)]
pub enum MessageInstance {
    TestMessage(TestMessage),
    PacketAck(PacketAck),
    OpenCircuit(OpenCircuit),
    CloseCircuit(CloseCircuit),
    StartPingCheck(StartPingCheck),
    CompletePingCheck(CompletePingCheck),
    AddCircuitCode(AddCircuitCode),
    UseCircuitCode(UseCircuitCode),
    NeighborList(NeighborList),
    AvatarTextureUpdate(AvatarTextureUpdate),
    SimulatorMapUpdate(SimulatorMapUpdate),
    SimulatorSetMap(SimulatorSetMap),
    SubscribeLoad(SubscribeLoad),
    UnsubscribeLoad(UnsubscribeLoad),
    SimulatorReady(SimulatorReady),
    TelehubInfo(TelehubInfo),
    SimulatorPresentAtLocation(SimulatorPresentAtLocation),
    SimulatorLoad(SimulatorLoad),
    SimulatorShutdownRequest(SimulatorShutdownRequest),
    RegionPresenceRequestByRegionID(RegionPresenceRequestByRegionID),
    RegionPresenceRequestByHandle(RegionPresenceRequestByHandle),
    RegionPresenceResponse(RegionPresenceResponse),
    UpdateSimulator(UpdateSimulator),
    LogDwellTime(LogDwellTime),
    FeatureDisabled(FeatureDisabled),
    LogFailedMoneyTransaction(LogFailedMoneyTransaction),
    UserReportInternal(UserReportInternal),
    SetSimStatusInDatabase(SetSimStatusInDatabase),
    SetSimPresenceInDatabase(SetSimPresenceInDatabase),
    EconomyDataRequest(EconomyDataRequest),
    EconomyData(EconomyData),
    AvatarPickerRequest(AvatarPickerRequest),
    AvatarPickerRequestBackend(AvatarPickerRequestBackend),
    AvatarPickerReply(AvatarPickerReply),
    PlacesQuery(PlacesQuery),
    PlacesReply(PlacesReply),
    DirFindQuery(DirFindQuery),
    DirFindQueryBackend(DirFindQueryBackend),
    DirPlacesQuery(DirPlacesQuery),
    DirPlacesQueryBackend(DirPlacesQueryBackend),
    DirPlacesReply(DirPlacesReply),
    DirPeopleReply(DirPeopleReply),
    DirEventsReply(DirEventsReply),
    DirGroupsReply(DirGroupsReply),
    DirClassifiedQuery(DirClassifiedQuery),
    DirClassifiedQueryBackend(DirClassifiedQueryBackend),
    DirClassifiedReply(DirClassifiedReply),
    AvatarClassifiedReply(AvatarClassifiedReply),
    ClassifiedInfoRequest(ClassifiedInfoRequest),
    ClassifiedInfoReply(ClassifiedInfoReply),
    ClassifiedInfoUpdate(ClassifiedInfoUpdate),
    ClassifiedDelete(ClassifiedDelete),
    ClassifiedGodDelete(ClassifiedGodDelete),
    DirLandQuery(DirLandQuery),
    DirLandQueryBackend(DirLandQueryBackend),
    DirLandReply(DirLandReply),
    DirPopularQuery(DirPopularQuery),
    DirPopularQueryBackend(DirPopularQueryBackend),
    DirPopularReply(DirPopularReply),
    ParcelInfoRequest(ParcelInfoRequest),
    ParcelInfoReply(ParcelInfoReply),
    ParcelObjectOwnersRequest(ParcelObjectOwnersRequest),
    ParcelObjectOwnersReply(ParcelObjectOwnersReply),
    GroupNoticesListRequest(GroupNoticesListRequest),
    GroupNoticesListReply(GroupNoticesListReply),
    GroupNoticeRequest(GroupNoticeRequest),
    GroupNoticeAdd(GroupNoticeAdd),
    TeleportRequest(TeleportRequest),
    TeleportLocationRequest(TeleportLocationRequest),
    TeleportLocal(TeleportLocal),
    TeleportLandmarkRequest(TeleportLandmarkRequest),
    TeleportProgress(TeleportProgress),
    DataHomeLocationRequest(DataHomeLocationRequest),
    DataHomeLocationReply(DataHomeLocationReply),
    TeleportFinish(TeleportFinish),
    StartLure(StartLure),
    TeleportLureRequest(TeleportLureRequest),
    TeleportCancel(TeleportCancel),
    TeleportStart(TeleportStart),
    TeleportFailed(TeleportFailed),
    Undo(Undo),
    Redo(Redo),
    UndoLand(UndoLand),
    AgentPause(AgentPause),
    AgentResume(AgentResume),
    AgentUpdate(AgentUpdate),
    ChatFromViewer(ChatFromViewer),
    AgentThrottle(AgentThrottle),
    AgentFOV(AgentFOV),
    AgentHeightWidth(AgentHeightWidth),
    AgentSetAppearance(AgentSetAppearance),
    AgentAnimation(AgentAnimation),
    AgentRequestSit(AgentRequestSit),
    AgentSit(AgentSit),
    AgentQuitCopy(AgentQuitCopy),
    RequestImage(RequestImage),
    ImageNotInDatabase(ImageNotInDatabase),
    RebakeAvatarTextures(RebakeAvatarTextures),
    SetAlwaysRun(SetAlwaysRun),
    ObjectAdd(ObjectAdd),
    ObjectDelete(ObjectDelete),
    ObjectDuplicate(ObjectDuplicate),
    ObjectDuplicateOnRay(ObjectDuplicateOnRay),
    MultipleObjectUpdate(MultipleObjectUpdate),
    RequestMultipleObjects(RequestMultipleObjects),
    ObjectPosition(ObjectPosition),
    ObjectScale(ObjectScale),
    ObjectRotation(ObjectRotation),
    ObjectFlagUpdate(ObjectFlagUpdate),
    ObjectClickAction(ObjectClickAction),
    ObjectImage(ObjectImage),
    ObjectMaterial(ObjectMaterial),
    ObjectShape(ObjectShape),
    ObjectExtraParams(ObjectExtraParams),
    ObjectOwner(ObjectOwner),
    ObjectGroup(ObjectGroup),
    ObjectBuy(ObjectBuy),
    BuyObjectInventory(BuyObjectInventory),
    DerezContainer(DerezContainer),
    ObjectPermissions(ObjectPermissions),
    ObjectSaleInfo(ObjectSaleInfo),
    ObjectName(ObjectName),
    ObjectDescription(ObjectDescription),
    ObjectCategory(ObjectCategory),
    ObjectSelect(ObjectSelect),
    ObjectDeselect(ObjectDeselect),
    ObjectAttach(ObjectAttach),
    ObjectDetach(ObjectDetach),
    ObjectDrop(ObjectDrop),
    ObjectLink(ObjectLink),
    ObjectDelink(ObjectDelink),
    ObjectGrab(ObjectGrab),
    ObjectGrabUpdate(ObjectGrabUpdate),
    ObjectDeGrab(ObjectDeGrab),
    ObjectSpinStart(ObjectSpinStart),
    ObjectSpinUpdate(ObjectSpinUpdate),
    ObjectSpinStop(ObjectSpinStop),
    ObjectExportSelected(ObjectExportSelected),
    ModifyLand(ModifyLand),
    VelocityInterpolateOn(VelocityInterpolateOn),
    VelocityInterpolateOff(VelocityInterpolateOff),
    StateSave(StateSave),
    ReportAutosaveCrash(ReportAutosaveCrash),
    SimWideDeletes(SimWideDeletes),
    RequestObjectPropertiesFamily(RequestObjectPropertiesFamily),
    TrackAgent(TrackAgent),
    ViewerStats(ViewerStats),
    ScriptAnswerYes(ScriptAnswerYes),
    UserReport(UserReport),
    AlertMessage(AlertMessage),
    AgentAlertMessage(AgentAlertMessage),
    MeanCollisionAlert(MeanCollisionAlert),
    ViewerFrozenMessage(ViewerFrozenMessage),
    HealthMessage(HealthMessage),
    ChatFromSimulator(ChatFromSimulator),
    SimStats(SimStats),
    RequestRegionInfo(RequestRegionInfo),
    RegionInfo(RegionInfo),
    GodUpdateRegionInfo(GodUpdateRegionInfo),
    NearestLandingRegionRequest(NearestLandingRegionRequest),
    NearestLandingRegionReply(NearestLandingRegionReply),
    NearestLandingRegionUpdated(NearestLandingRegionUpdated),
    TeleportLandingStatusChanged(TeleportLandingStatusChanged),
    RegionHandshake(RegionHandshake),
    RegionHandshakeReply(RegionHandshakeReply),
    CoarseLocationUpdate(CoarseLocationUpdate),
    ImageData(ImageData),
    ImagePacket(ImagePacket),
    LayerData(LayerData),
    ObjectUpdate(ObjectUpdate),
    ObjectUpdateCompressed(ObjectUpdateCompressed),
    ObjectUpdateCached(ObjectUpdateCached),
    ImprovedTerseObjectUpdate(ImprovedTerseObjectUpdate),
    KillObject(KillObject),
    CrossedRegion(CrossedRegion),
    SimulatorViewerTimeMessage(SimulatorViewerTimeMessage),
    EnableSimulator(EnableSimulator),
    DisableSimulator(DisableSimulator),
    ConfirmEnableSimulator(ConfirmEnableSimulator),
    TransferRequest(TransferRequest),
    TransferInfo(TransferInfo),
    TransferPacket(TransferPacket),
    TransferAbort(TransferAbort),
    RequestXfer(RequestXfer),
    SendXferPacket(SendXferPacket),
    ConfirmXferPacket(ConfirmXferPacket),
    AbortXfer(AbortXfer),
    AvatarAnimation(AvatarAnimation),
    AvatarAppearance(AvatarAppearance),
    AvatarSitResponse(AvatarSitResponse),
    SetFollowCamProperties(SetFollowCamProperties),
    ClearFollowCamProperties(ClearFollowCamProperties),
    CameraConstraint(CameraConstraint),
    ObjectProperties(ObjectProperties),
    ObjectPropertiesFamily(ObjectPropertiesFamily),
    RequestPayPrice(RequestPayPrice),
    PayPriceReply(PayPriceReply),
    KickUser(KickUser),
    KickUserAck(KickUserAck),
    GodKickUser(GodKickUser),
    SystemKickUser(SystemKickUser),
    EjectUser(EjectUser),
    FreezeUser(FreezeUser),
    AvatarPropertiesRequest(AvatarPropertiesRequest),
    AvatarPropertiesRequestBackend(AvatarPropertiesRequestBackend),
    AvatarPropertiesReply(AvatarPropertiesReply),
    AvatarInterestsReply(AvatarInterestsReply),
    AvatarGroupsReply(AvatarGroupsReply),
    AvatarPropertiesUpdate(AvatarPropertiesUpdate),
    AvatarInterestsUpdate(AvatarInterestsUpdate),
    AvatarNotesReply(AvatarNotesReply),
    AvatarNotesUpdate(AvatarNotesUpdate),
    AvatarPicksReply(AvatarPicksReply),
    EventInfoRequest(EventInfoRequest),
    EventInfoReply(EventInfoReply),
    EventNotificationAddRequest(EventNotificationAddRequest),
    EventNotificationRemoveRequest(EventNotificationRemoveRequest),
    EventGodDelete(EventGodDelete),
    PickInfoReply(PickInfoReply),
    PickInfoUpdate(PickInfoUpdate),
    PickDelete(PickDelete),
    PickGodDelete(PickGodDelete),
    ScriptQuestion(ScriptQuestion),
    ScriptControlChange(ScriptControlChange),
    ScriptDialog(ScriptDialog),
    ScriptDialogReply(ScriptDialogReply),
    ForceScriptControlRelease(ForceScriptControlRelease),
    RevokePermissions(RevokePermissions),
    LoadURL(LoadURL),
    ScriptTeleportRequest(ScriptTeleportRequest),
    ParcelOverlay(ParcelOverlay),
    ParcelPropertiesRequest(ParcelPropertiesRequest),
    ParcelPropertiesRequestByID(ParcelPropertiesRequestByID),
    ParcelProperties(ParcelProperties),
    ParcelPropertiesUpdate(ParcelPropertiesUpdate),
    ParcelReturnObjects(ParcelReturnObjects),
    ParcelSetOtherCleanTime(ParcelSetOtherCleanTime),
    ParcelDisableObjects(ParcelDisableObjects),
    ParcelSelectObjects(ParcelSelectObjects),
    EstateCovenantRequest(EstateCovenantRequest),
    EstateCovenantReply(EstateCovenantReply),
    ForceObjectSelect(ForceObjectSelect),
    ParcelBuyPass(ParcelBuyPass),
    ParcelDeedToGroup(ParcelDeedToGroup),
    ParcelReclaim(ParcelReclaim),
    ParcelClaim(ParcelClaim),
    ParcelJoin(ParcelJoin),
    ParcelDivide(ParcelDivide),
    ParcelRelease(ParcelRelease),
    ParcelBuy(ParcelBuy),
    ParcelGodForceOwner(ParcelGodForceOwner),
    ParcelAccessListRequest(ParcelAccessListRequest),
    ParcelAccessListReply(ParcelAccessListReply),
    ParcelAccessListUpdate(ParcelAccessListUpdate),
    ParcelDwellRequest(ParcelDwellRequest),
    ParcelDwellReply(ParcelDwellReply),
    RequestParcelTransfer(RequestParcelTransfer),
    UpdateParcel(UpdateParcel),
    RemoveParcel(RemoveParcel),
    MergeParcel(MergeParcel),
    LogParcelChanges(LogParcelChanges),
    CheckParcelSales(CheckParcelSales),
    ParcelSales(ParcelSales),
    ParcelGodMarkAsContent(ParcelGodMarkAsContent),
    ViewerStartAuction(ViewerStartAuction),
    StartAuction(StartAuction),
    ConfirmAuctionStart(ConfirmAuctionStart),
    CompleteAuction(CompleteAuction),
    CancelAuction(CancelAuction),
    CheckParcelAuctions(CheckParcelAuctions),
    ParcelAuctions(ParcelAuctions),
    UUIDNameRequest(UUIDNameRequest),
    UUIDNameReply(UUIDNameReply),
    UUIDGroupNameRequest(UUIDGroupNameRequest),
    UUIDGroupNameReply(UUIDGroupNameReply),
    ChatPass(ChatPass),
    EdgeDataPacket(EdgeDataPacket),
    SimStatus(SimStatus),
    ChildAgentUpdate(ChildAgentUpdate),
    ChildAgentAlive(ChildAgentAlive),
    ChildAgentPositionUpdate(ChildAgentPositionUpdate),
    ChildAgentDying(ChildAgentDying),
    ChildAgentUnknown(ChildAgentUnknown),
    AtomicPassObject(AtomicPassObject),
    KillChildAgents(KillChildAgents),
    GetScriptRunning(GetScriptRunning),
    ScriptRunningReply(ScriptRunningReply),
    SetScriptRunning(SetScriptRunning),
    ScriptReset(ScriptReset),
    ScriptSensorRequest(ScriptSensorRequest),
    ScriptSensorReply(ScriptSensorReply),
    CompleteAgentMovement(CompleteAgentMovement),
    AgentMovementComplete(AgentMovementComplete),
    DataServerLogout(DataServerLogout),
    LogoutRequest(LogoutRequest),
    LogoutReply(LogoutReply),
    ImprovedInstantMessage(ImprovedInstantMessage),
    RetrieveInstantMessages(RetrieveInstantMessages),
    FindAgent(FindAgent),
    RequestGodlikePowers(RequestGodlikePowers),
    GrantGodlikePowers(GrantGodlikePowers),
    GodlikeMessage(GodlikeMessage),
    EstateOwnerMessage(EstateOwnerMessage),
    GenericMessage(GenericMessage),
    MuteListRequest(MuteListRequest),
    UpdateMuteListEntry(UpdateMuteListEntry),
    RemoveMuteListEntry(RemoveMuteListEntry),
    CopyInventoryFromNotecard(CopyInventoryFromNotecard),
    UpdateInventoryItem(UpdateInventoryItem),
    UpdateCreateInventoryItem(UpdateCreateInventoryItem),
    MoveInventoryItem(MoveInventoryItem),
    CopyInventoryItem(CopyInventoryItem),
    RemoveInventoryItem(RemoveInventoryItem),
    ChangeInventoryItemFlags(ChangeInventoryItemFlags),
    SaveAssetIntoInventory(SaveAssetIntoInventory),
    CreateInventoryFolder(CreateInventoryFolder),
    UpdateInventoryFolder(UpdateInventoryFolder),
    MoveInventoryFolder(MoveInventoryFolder),
    RemoveInventoryFolder(RemoveInventoryFolder),
    FetchInventoryDescendents(FetchInventoryDescendents),
    InventoryDescendents(InventoryDescendents),
    FetchInventory(FetchInventory),
    FetchInventoryReply(FetchInventoryReply),
    BulkUpdateInventory(BulkUpdateInventory),
    RequestInventoryAsset(RequestInventoryAsset),
    InventoryAssetResponse(InventoryAssetResponse),
    RemoveInventoryObjects(RemoveInventoryObjects),
    PurgeInventoryDescendents(PurgeInventoryDescendents),
    UpdateTaskInventory(UpdateTaskInventory),
    RemoveTaskInventory(RemoveTaskInventory),
    MoveTaskInventory(MoveTaskInventory),
    RequestTaskInventory(RequestTaskInventory),
    ReplyTaskInventory(ReplyTaskInventory),
    DeRezObject(DeRezObject),
    DeRezAck(DeRezAck),
    RezObject(RezObject),
    RezObjectFromNotecard(RezObjectFromNotecard),
    TransferInventory(TransferInventory),
    TransferInventoryAck(TransferInventoryAck),
    AcceptFriendship(AcceptFriendship),
    DeclineFriendship(DeclineFriendship),
    FormFriendship(FormFriendship),
    TerminateFriendship(TerminateFriendship),
    OfferCallingCard(OfferCallingCard),
    AcceptCallingCard(AcceptCallingCard),
    DeclineCallingCard(DeclineCallingCard),
    RezScript(RezScript),
    CreateInventoryItem(CreateInventoryItem),
    CreateLandmarkForEvent(CreateLandmarkForEvent),
    EventLocationRequest(EventLocationRequest),
    EventLocationReply(EventLocationReply),
    RegionHandleRequest(RegionHandleRequest),
    RegionIDAndHandleReply(RegionIDAndHandleReply),
    MoneyTransferRequest(MoneyTransferRequest),
    MoneyTransferBackend(MoneyTransferBackend),
    MoneyBalanceRequest(MoneyBalanceRequest),
    MoneyBalanceReply(MoneyBalanceReply),
    RoutedMoneyBalanceReply(RoutedMoneyBalanceReply),
    ActivateGestures(ActivateGestures),
    DeactivateGestures(DeactivateGestures),
    MuteListUpdate(MuteListUpdate),
    UseCachedMuteList(UseCachedMuteList),
    GrantUserRights(GrantUserRights),
    ChangeUserRights(ChangeUserRights),
    OnlineNotification(OnlineNotification),
    OfflineNotification(OfflineNotification),
    SetStartLocationRequest(SetStartLocationRequest),
    SetStartLocation(SetStartLocation),
    NetTest(NetTest),
    SetCPURatio(SetCPURatio),
    SimCrashed(SimCrashed),
    NameValuePair(NameValuePair),
    RemoveNameValuePair(RemoveNameValuePair),
    UpdateAttachment(UpdateAttachment),
    RemoveAttachment(RemoveAttachment),
    SoundTrigger(SoundTrigger),
    AttachedSound(AttachedSound),
    AttachedSoundGainChange(AttachedSoundGainChange),
    PreloadSound(PreloadSound),
    AssetUploadRequest(AssetUploadRequest),
    AssetUploadComplete(AssetUploadComplete),
    EmailMessageRequest(EmailMessageRequest),
    EmailMessageReply(EmailMessageReply),
    InternalScriptMail(InternalScriptMail),
    ScriptDataRequest(ScriptDataRequest),
    ScriptDataReply(ScriptDataReply),
    CreateGroupRequest(CreateGroupRequest),
    CreateGroupReply(CreateGroupReply),
    UpdateGroupInfo(UpdateGroupInfo),
    GroupRoleChanges(GroupRoleChanges),
    JoinGroupRequest(JoinGroupRequest),
    JoinGroupReply(JoinGroupReply),
    EjectGroupMemberRequest(EjectGroupMemberRequest),
    EjectGroupMemberReply(EjectGroupMemberReply),
    LeaveGroupRequest(LeaveGroupRequest),
    LeaveGroupReply(LeaveGroupReply),
    InviteGroupRequest(InviteGroupRequest),
    InviteGroupResponse(InviteGroupResponse),
    GroupProfileRequest(GroupProfileRequest),
    GroupProfileReply(GroupProfileReply),
    GroupAccountSummaryRequest(GroupAccountSummaryRequest),
    GroupAccountSummaryReply(GroupAccountSummaryReply),
    GroupAccountDetailsRequest(GroupAccountDetailsRequest),
    GroupAccountDetailsReply(GroupAccountDetailsReply),
    GroupAccountTransactionsRequest(GroupAccountTransactionsRequest),
    GroupAccountTransactionsReply(GroupAccountTransactionsReply),
    GroupActiveProposalsRequest(GroupActiveProposalsRequest),
    GroupActiveProposalItemReply(GroupActiveProposalItemReply),
    GroupVoteHistoryRequest(GroupVoteHistoryRequest),
    GroupVoteHistoryItemReply(GroupVoteHistoryItemReply),
    StartGroupProposal(StartGroupProposal),
    GroupProposalBallot(GroupProposalBallot),
    TallyVotes(TallyVotes),
    GroupMembersRequest(GroupMembersRequest),
    GroupMembersReply(GroupMembersReply),
    ActivateGroup(ActivateGroup),
    SetGroupContribution(SetGroupContribution),
    SetGroupAcceptNotices(SetGroupAcceptNotices),
    GroupRoleDataRequest(GroupRoleDataRequest),
    GroupRoleDataReply(GroupRoleDataReply),
    GroupRoleMembersRequest(GroupRoleMembersRequest),
    GroupRoleMembersReply(GroupRoleMembersReply),
    GroupTitlesRequest(GroupTitlesRequest),
    GroupTitlesReply(GroupTitlesReply),
    GroupTitleUpdate(GroupTitleUpdate),
    GroupRoleUpdate(GroupRoleUpdate),
    LiveHelpGroupRequest(LiveHelpGroupRequest),
    LiveHelpGroupReply(LiveHelpGroupReply),
    AgentWearablesRequest(AgentWearablesRequest),
    AgentWearablesUpdate(AgentWearablesUpdate),
    AgentIsNowWearing(AgentIsNowWearing),
    AgentCachedTexture(AgentCachedTexture),
    AgentCachedTextureResponse(AgentCachedTextureResponse),
    AgentDataUpdateRequest(AgentDataUpdateRequest),
    AgentDataUpdate(AgentDataUpdate),
    GroupDataUpdate(GroupDataUpdate),
    AgentGroupDataUpdate(AgentGroupDataUpdate),
    AgentDropGroup(AgentDropGroup),
    LogTextMessage(LogTextMessage),
    ViewerEffect(ViewerEffect),
    CreateTrustedCircuit(CreateTrustedCircuit),
    DenyTrustedCircuit(DenyTrustedCircuit),
    RequestTrustedCircuit(RequestTrustedCircuit),
    RezSingleAttachmentFromInv(RezSingleAttachmentFromInv),
    RezMultipleAttachmentsFromInv(RezMultipleAttachmentsFromInv),
    DetachAttachmentIntoInv(DetachAttachmentIntoInv),
    CreateNewOutfitAttachments(CreateNewOutfitAttachments),
    UserInfoRequest(UserInfoRequest),
    UserInfoReply(UserInfoReply),
    UpdateUserInfo(UpdateUserInfo),
    ParcelRename(ParcelRename),
    InitiateDownload(InitiateDownload),
    SystemMessage(SystemMessage),
    MapLayerRequest(MapLayerRequest),
    MapLayerReply(MapLayerReply),
    MapBlockRequest(MapBlockRequest),
    MapNameRequest(MapNameRequest),
    MapBlockReply(MapBlockReply),
    MapItemRequest(MapItemRequest),
    MapItemReply(MapItemReply),
    SendPostcard(SendPostcard),
    RpcChannelRequest(RpcChannelRequest),
    RpcChannelReply(RpcChannelReply),
    RpcScriptRequestInbound(RpcScriptRequestInbound),
    RpcScriptRequestInboundForward(RpcScriptRequestInboundForward),
    RpcScriptReplyInbound(RpcScriptReplyInbound),
    ScriptMailRegistration(ScriptMailRegistration),
    ParcelMediaCommandMessage(ParcelMediaCommandMessage),
    ParcelMediaUpdate(ParcelMediaUpdate),
    LandStatRequest(LandStatRequest),
    LandStatReply(LandStatReply),
    Error(Error),
    ObjectIncludeInSearch(ObjectIncludeInSearch),
    RezRestoreToWorld(RezRestoreToWorld),
    LinkInventoryItem(LinkInventoryItem),
}

impl MessageInstance {
    pub fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        match *self {
            MessageInstance::TestMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::PacketAck(ref msg) => msg.write_to(buffer),
            MessageInstance::OpenCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::CloseCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::StartPingCheck(ref msg) => msg.write_to(buffer),
            MessageInstance::CompletePingCheck(ref msg) => msg.write_to(buffer),
            MessageInstance::AddCircuitCode(ref msg) => msg.write_to(buffer),
            MessageInstance::UseCircuitCode(ref msg) => msg.write_to(buffer),
            MessageInstance::NeighborList(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarTextureUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorMapUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorSetMap(ref msg) => msg.write_to(buffer),
            MessageInstance::SubscribeLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::UnsubscribeLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorReady(ref msg) => msg.write_to(buffer),
            MessageInstance::TelehubInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorPresentAtLocation(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorLoad(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorShutdownRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceRequestByRegionID(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceRequestByHandle(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionPresenceResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::LogDwellTime(ref msg) => msg.write_to(buffer),
            MessageInstance::FeatureDisabled(ref msg) => msg.write_to(buffer),
            MessageInstance::LogFailedMoneyTransaction(ref msg) => msg.write_to(buffer),
            MessageInstance::UserReportInternal(ref msg) => msg.write_to(buffer),
            MessageInstance::SetSimStatusInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::SetSimPresenceInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::EconomyDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EconomyData(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerRequestBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPickerReply(ref msg) => msg.write_to(buffer),
            MessageInstance::PlacesQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::PlacesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirFindQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirFindQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPlacesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPeopleReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirEventsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirGroupsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirClassifiedReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarClassifiedReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedInfoUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ClassifiedGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirLandReply(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularQuery(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularQueryBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::DirPopularReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelObjectOwnersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelObjectOwnersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticesListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticesListReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticeRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupNoticeAdd(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLocal(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLandmarkRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportProgress(ref msg) => msg.write_to(buffer),
            MessageInstance::DataHomeLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::DataHomeLocationReply(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportFinish(ref msg) => msg.write_to(buffer),
            MessageInstance::StartLure(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLureRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportCancel(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportStart(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportFailed(ref msg) => msg.write_to(buffer),
            MessageInstance::Undo(ref msg) => msg.write_to(buffer),
            MessageInstance::Redo(ref msg) => msg.write_to(buffer),
            MessageInstance::UndoLand(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentPause(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentResume(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatFromViewer(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentThrottle(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentFOV(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentHeightWidth(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentSetAppearance(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentAnimation(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentRequestSit(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentSit(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentQuitCopy(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestImage(ref msg) => msg.write_to(buffer),
            MessageInstance::ImageNotInDatabase(ref msg) => msg.write_to(buffer),
            MessageInstance::RebakeAvatarTextures(ref msg) => msg.write_to(buffer),
            MessageInstance::SetAlwaysRun(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectAdd(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDuplicate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDuplicateOnRay(ref msg) => msg.write_to(buffer),
            MessageInstance::MultipleObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestMultipleObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPosition(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectScale(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectRotation(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectFlagUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectClickAction(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectImage(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectMaterial(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectShape(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectExtraParams(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectOwner(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectBuy(ref msg) => msg.write_to(buffer),
            MessageInstance::BuyObjectInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::DerezContainer(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPermissions(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSaleInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectName(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDescription(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectCategory(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSelect(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDeselect(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectAttach(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDetach(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDrop(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectLink(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDelink(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGrab(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectGrabUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectDeGrab(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinStart(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectSpinStop(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectExportSelected(ref msg) => msg.write_to(buffer),
            MessageInstance::ModifyLand(ref msg) => msg.write_to(buffer),
            MessageInstance::VelocityInterpolateOn(ref msg) => msg.write_to(buffer),
            MessageInstance::VelocityInterpolateOff(ref msg) => msg.write_to(buffer),
            MessageInstance::StateSave(ref msg) => msg.write_to(buffer),
            MessageInstance::ReportAutosaveCrash(ref msg) => msg.write_to(buffer),
            MessageInstance::SimWideDeletes(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestObjectPropertiesFamily(ref msg) => msg.write_to(buffer),
            MessageInstance::TrackAgent(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerStats(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptAnswerYes(ref msg) => msg.write_to(buffer),
            MessageInstance::UserReport(ref msg) => msg.write_to(buffer),
            MessageInstance::AlertMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentAlertMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::MeanCollisionAlert(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerFrozenMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::HealthMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatFromSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::SimStats(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestRegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::GodUpdateRegionInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionReply(ref msg) => msg.write_to(buffer),
            MessageInstance::NearestLandingRegionUpdated(ref msg) => msg.write_to(buffer),
            MessageInstance::TeleportLandingStatusChanged(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandshake(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandshakeReply(ref msg) => msg.write_to(buffer),
            MessageInstance::CoarseLocationUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ImageData(ref msg) => msg.write_to(buffer),
            MessageInstance::ImagePacket(ref msg) => msg.write_to(buffer),
            MessageInstance::LayerData(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdateCompressed(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectUpdateCached(ref msg) => msg.write_to(buffer),
            MessageInstance::ImprovedTerseObjectUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::KillObject(ref msg) => msg.write_to(buffer),
            MessageInstance::CrossedRegion(ref msg) => msg.write_to(buffer),
            MessageInstance::SimulatorViewerTimeMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::EnableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::DisableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmEnableSimulator(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferAbort(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestXfer(ref msg) => msg.write_to(buffer),
            MessageInstance::SendXferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmXferPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::AbortXfer(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarAnimation(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarAppearance(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarSitResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::SetFollowCamProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::ClearFollowCamProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::CameraConstraint(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectPropertiesFamily(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestPayPrice(ref msg) => msg.write_to(buffer),
            MessageInstance::PayPriceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::KickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::KickUserAck(ref msg) => msg.write_to(buffer),
            MessageInstance::GodKickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::SystemKickUser(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectUser(ref msg) => msg.write_to(buffer),
            MessageInstance::FreezeUser(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesRequestBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarInterestsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarGroupsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPropertiesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarInterestsUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarNotesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarNotesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AvatarPicksReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EventInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EventNotificationAddRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventNotificationRemoveRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::PickInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::PickInfoUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::PickDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::PickGodDelete(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptQuestion(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptControlChange(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDialog(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDialogReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ForceScriptControlRelease(ref msg) => msg.write_to(buffer),
            MessageInstance::RevokePermissions(ref msg) => msg.write_to(buffer),
            MessageInstance::LoadURL(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptTeleportRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelOverlay(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesRequestByID(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelProperties(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelPropertiesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelReturnObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSetOtherCleanTime(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDisableObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSelectObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateCovenantRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateCovenantReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ForceObjectSelect(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelBuyPass(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDeedToGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelReclaim(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelClaim(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelJoin(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDivide(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelRelease(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelBuy(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelGodForceOwner(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAccessListUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDwellRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelDwellReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestParcelTransfer(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::MergeParcel(ref msg) => msg.write_to(buffer),
            MessageInstance::LogParcelChanges(ref msg) => msg.write_to(buffer),
            MessageInstance::CheckParcelSales(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelSales(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelGodMarkAsContent(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerStartAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::StartAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::ConfirmAuctionStart(ref msg) => msg.write_to(buffer),
            MessageInstance::CompleteAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::CancelAuction(ref msg) => msg.write_to(buffer),
            MessageInstance::CheckParcelAuctions(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelAuctions(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDNameReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDGroupNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UUIDGroupNameReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ChatPass(ref msg) => msg.write_to(buffer),
            MessageInstance::EdgeDataPacket(ref msg) => msg.write_to(buffer),
            MessageInstance::SimStatus(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentAlive(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentPositionUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentDying(ref msg) => msg.write_to(buffer),
            MessageInstance::ChildAgentUnknown(ref msg) => msg.write_to(buffer),
            MessageInstance::AtomicPassObject(ref msg) => msg.write_to(buffer),
            MessageInstance::KillChildAgents(ref msg) => msg.write_to(buffer),
            MessageInstance::GetScriptRunning(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptRunningReply(ref msg) => msg.write_to(buffer),
            MessageInstance::SetScriptRunning(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptReset(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptSensorRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptSensorReply(ref msg) => msg.write_to(buffer),
            MessageInstance::CompleteAgentMovement(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentMovementComplete(ref msg) => msg.write_to(buffer),
            MessageInstance::DataServerLogout(ref msg) => msg.write_to(buffer),
            MessageInstance::LogoutRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LogoutReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ImprovedInstantMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::RetrieveInstantMessages(ref msg) => msg.write_to(buffer),
            MessageInstance::FindAgent(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestGodlikePowers(ref msg) => msg.write_to(buffer),
            MessageInstance::GrantGodlikePowers(ref msg) => msg.write_to(buffer),
            MessageInstance::GodlikeMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::EstateOwnerMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::GenericMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::MuteListRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateMuteListEntry(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveMuteListEntry(ref msg) => msg.write_to(buffer),
            MessageInstance::CopyInventoryFromNotecard(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateCreateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::CopyInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::ChangeInventoryItemFlags(ref msg) => msg.write_to(buffer),
            MessageInstance::SaveAssetIntoInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryFolder(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::InventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::FetchInventoryReply(ref msg) => msg.write_to(buffer),
            MessageInstance::BulkUpdateInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestInventoryAsset(ref msg) => msg.write_to(buffer),
            MessageInstance::InventoryAssetResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveInventoryObjects(ref msg) => msg.write_to(buffer),
            MessageInstance::PurgeInventoryDescendents(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::MoveTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::ReplyTaskInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::DeRezObject(ref msg) => msg.write_to(buffer),
            MessageInstance::DeRezAck(ref msg) => msg.write_to(buffer),
            MessageInstance::RezObject(ref msg) => msg.write_to(buffer),
            MessageInstance::RezObjectFromNotecard(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInventory(ref msg) => msg.write_to(buffer),
            MessageInstance::TransferInventoryAck(ref msg) => msg.write_to(buffer),
            MessageInstance::AcceptFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::DeclineFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::FormFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::TerminateFriendship(ref msg) => msg.write_to(buffer),
            MessageInstance::OfferCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::AcceptCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::DeclineCallingCard(ref msg) => msg.write_to(buffer),
            MessageInstance::RezScript(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateInventoryItem(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateLandmarkForEvent(ref msg) => msg.write_to(buffer),
            MessageInstance::EventLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EventLocationReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionHandleRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::RegionIDAndHandleReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyTransferRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyTransferBackend(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyBalanceRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MoneyBalanceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RoutedMoneyBalanceReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ActivateGestures(ref msg) => msg.write_to(buffer),
            MessageInstance::DeactivateGestures(ref msg) => msg.write_to(buffer),
            MessageInstance::MuteListUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::UseCachedMuteList(ref msg) => msg.write_to(buffer),
            MessageInstance::GrantUserRights(ref msg) => msg.write_to(buffer),
            MessageInstance::ChangeUserRights(ref msg) => msg.write_to(buffer),
            MessageInstance::OnlineNotification(ref msg) => msg.write_to(buffer),
            MessageInstance::OfflineNotification(ref msg) => msg.write_to(buffer),
            MessageInstance::SetStartLocationRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::SetStartLocation(ref msg) => msg.write_to(buffer),
            MessageInstance::NetTest(ref msg) => msg.write_to(buffer),
            MessageInstance::SetCPURatio(ref msg) => msg.write_to(buffer),
            MessageInstance::SimCrashed(ref msg) => msg.write_to(buffer),
            MessageInstance::NameValuePair(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveNameValuePair(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateAttachment(ref msg) => msg.write_to(buffer),
            MessageInstance::RemoveAttachment(ref msg) => msg.write_to(buffer),
            MessageInstance::SoundTrigger(ref msg) => msg.write_to(buffer),
            MessageInstance::AttachedSound(ref msg) => msg.write_to(buffer),
            MessageInstance::AttachedSoundGainChange(ref msg) => msg.write_to(buffer),
            MessageInstance::PreloadSound(ref msg) => msg.write_to(buffer),
            MessageInstance::AssetUploadRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AssetUploadComplete(ref msg) => msg.write_to(buffer),
            MessageInstance::EmailMessageRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EmailMessageReply(ref msg) => msg.write_to(buffer),
            MessageInstance::InternalScriptMail(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptDataReply(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateGroupInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleChanges(ref msg) => msg.write_to(buffer),
            MessageInstance::JoinGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::JoinGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectGroupMemberRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::EjectGroupMemberReply(ref msg) => msg.write_to(buffer),
            MessageInstance::LeaveGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LeaveGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::InviteGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::InviteGroupResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProfileRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProfileReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountSummaryRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountSummaryReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountDetailsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountDetailsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountTransactionsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupAccountTransactionsReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupActiveProposalsRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupActiveProposalItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupVoteHistoryRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupVoteHistoryItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::StartGroupProposal(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupProposalBallot(ref msg) => msg.write_to(buffer),
            MessageInstance::TallyVotes(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupMembersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupMembersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::ActivateGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::SetGroupContribution(ref msg) => msg.write_to(buffer),
            MessageInstance::SetGroupAcceptNotices(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleDataRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleDataReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleMembersRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleMembersReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitlesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitlesReply(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupTitleUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupRoleUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::LiveHelpGroupRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LiveHelpGroupReply(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentWearablesRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentWearablesUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentIsNowWearing(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentCachedTexture(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentCachedTextureResponse(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDataUpdateRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::GroupDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentGroupDataUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::AgentDropGroup(ref msg) => msg.write_to(buffer),
            MessageInstance::LogTextMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ViewerEffect(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::DenyTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::RequestTrustedCircuit(ref msg) => msg.write_to(buffer),
            MessageInstance::RezSingleAttachmentFromInv(ref msg) => msg.write_to(buffer),
            MessageInstance::RezMultipleAttachmentsFromInv(ref msg) => msg.write_to(buffer),
            MessageInstance::DetachAttachmentIntoInv(ref msg) => msg.write_to(buffer),
            MessageInstance::CreateNewOutfitAttachments(ref msg) => msg.write_to(buffer),
            MessageInstance::UserInfoRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::UserInfoReply(ref msg) => msg.write_to(buffer),
            MessageInstance::UpdateUserInfo(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelRename(ref msg) => msg.write_to(buffer),
            MessageInstance::InitiateDownload(ref msg) => msg.write_to(buffer),
            MessageInstance::SystemMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::MapLayerRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapLayerReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MapBlockRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapNameRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapBlockReply(ref msg) => msg.write_to(buffer),
            MessageInstance::MapItemRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::MapItemReply(ref msg) => msg.write_to(buffer),
            MessageInstance::SendPostcard(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcChannelRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcChannelReply(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptRequestInbound(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptRequestInboundForward(ref msg) => msg.write_to(buffer),
            MessageInstance::RpcScriptReplyInbound(ref msg) => msg.write_to(buffer),
            MessageInstance::ScriptMailRegistration(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelMediaCommandMessage(ref msg) => msg.write_to(buffer),
            MessageInstance::ParcelMediaUpdate(ref msg) => msg.write_to(buffer),
            MessageInstance::LandStatRequest(ref msg) => msg.write_to(buffer),
            MessageInstance::LandStatReply(ref msg) => msg.write_to(buffer),
            MessageInstance::Error(ref msg) => msg.write_to(buffer),
            MessageInstance::ObjectIncludeInSearch(ref msg) => msg.write_to(buffer),
            MessageInstance::RezRestoreToWorld(ref msg) => msg.write_to(buffer),
            MessageInstance::LinkInventoryItem(ref msg) => msg.write_to(buffer),
        }
    }
}

impl From<TestMessage> for MessageInstance {
    fn from(msg: TestMessage) -> Self {
        MessageInstance::TestMessage(msg)
    }
}

impl From<PacketAck> for MessageInstance {
    fn from(msg: PacketAck) -> Self {
        MessageInstance::PacketAck(msg)
    }
}

impl From<OpenCircuit> for MessageInstance {
    fn from(msg: OpenCircuit) -> Self {
        MessageInstance::OpenCircuit(msg)
    }
}

impl From<CloseCircuit> for MessageInstance {
    fn from(msg: CloseCircuit) -> Self {
        MessageInstance::CloseCircuit(msg)
    }
}

impl From<StartPingCheck> for MessageInstance {
    fn from(msg: StartPingCheck) -> Self {
        MessageInstance::StartPingCheck(msg)
    }
}

impl From<CompletePingCheck> for MessageInstance {
    fn from(msg: CompletePingCheck) -> Self {
        MessageInstance::CompletePingCheck(msg)
    }
}

impl From<AddCircuitCode> for MessageInstance {
    fn from(msg: AddCircuitCode) -> Self {
        MessageInstance::AddCircuitCode(msg)
    }
}

impl From<UseCircuitCode> for MessageInstance {
    fn from(msg: UseCircuitCode) -> Self {
        MessageInstance::UseCircuitCode(msg)
    }
}

impl From<NeighborList> for MessageInstance {
    fn from(msg: NeighborList) -> Self {
        MessageInstance::NeighborList(msg)
    }
}

impl From<AvatarTextureUpdate> for MessageInstance {
    fn from(msg: AvatarTextureUpdate) -> Self {
        MessageInstance::AvatarTextureUpdate(msg)
    }
}

impl From<SimulatorMapUpdate> for MessageInstance {
    fn from(msg: SimulatorMapUpdate) -> Self {
        MessageInstance::SimulatorMapUpdate(msg)
    }
}

impl From<SimulatorSetMap> for MessageInstance {
    fn from(msg: SimulatorSetMap) -> Self {
        MessageInstance::SimulatorSetMap(msg)
    }
}

impl From<SubscribeLoad> for MessageInstance {
    fn from(msg: SubscribeLoad) -> Self {
        MessageInstance::SubscribeLoad(msg)
    }
}

impl From<UnsubscribeLoad> for MessageInstance {
    fn from(msg: UnsubscribeLoad) -> Self {
        MessageInstance::UnsubscribeLoad(msg)
    }
}

impl From<SimulatorReady> for MessageInstance {
    fn from(msg: SimulatorReady) -> Self {
        MessageInstance::SimulatorReady(msg)
    }
}

impl From<TelehubInfo> for MessageInstance {
    fn from(msg: TelehubInfo) -> Self {
        MessageInstance::TelehubInfo(msg)
    }
}

impl From<SimulatorPresentAtLocation> for MessageInstance {
    fn from(msg: SimulatorPresentAtLocation) -> Self {
        MessageInstance::SimulatorPresentAtLocation(msg)
    }
}

impl From<SimulatorLoad> for MessageInstance {
    fn from(msg: SimulatorLoad) -> Self {
        MessageInstance::SimulatorLoad(msg)
    }
}

impl From<SimulatorShutdownRequest> for MessageInstance {
    fn from(msg: SimulatorShutdownRequest) -> Self {
        MessageInstance::SimulatorShutdownRequest(msg)
    }
}

impl From<RegionPresenceRequestByRegionID> for MessageInstance {
    fn from(msg: RegionPresenceRequestByRegionID) -> Self {
        MessageInstance::RegionPresenceRequestByRegionID(msg)
    }
}

impl From<RegionPresenceRequestByHandle> for MessageInstance {
    fn from(msg: RegionPresenceRequestByHandle) -> Self {
        MessageInstance::RegionPresenceRequestByHandle(msg)
    }
}

impl From<RegionPresenceResponse> for MessageInstance {
    fn from(msg: RegionPresenceResponse) -> Self {
        MessageInstance::RegionPresenceResponse(msg)
    }
}

impl From<UpdateSimulator> for MessageInstance {
    fn from(msg: UpdateSimulator) -> Self {
        MessageInstance::UpdateSimulator(msg)
    }
}

impl From<LogDwellTime> for MessageInstance {
    fn from(msg: LogDwellTime) -> Self {
        MessageInstance::LogDwellTime(msg)
    }
}

impl From<FeatureDisabled> for MessageInstance {
    fn from(msg: FeatureDisabled) -> Self {
        MessageInstance::FeatureDisabled(msg)
    }
}

impl From<LogFailedMoneyTransaction> for MessageInstance {
    fn from(msg: LogFailedMoneyTransaction) -> Self {
        MessageInstance::LogFailedMoneyTransaction(msg)
    }
}

impl From<UserReportInternal> for MessageInstance {
    fn from(msg: UserReportInternal) -> Self {
        MessageInstance::UserReportInternal(msg)
    }
}

impl From<SetSimStatusInDatabase> for MessageInstance {
    fn from(msg: SetSimStatusInDatabase) -> Self {
        MessageInstance::SetSimStatusInDatabase(msg)
    }
}

impl From<SetSimPresenceInDatabase> for MessageInstance {
    fn from(msg: SetSimPresenceInDatabase) -> Self {
        MessageInstance::SetSimPresenceInDatabase(msg)
    }
}

impl From<EconomyDataRequest> for MessageInstance {
    fn from(msg: EconomyDataRequest) -> Self {
        MessageInstance::EconomyDataRequest(msg)
    }
}

impl From<EconomyData> for MessageInstance {
    fn from(msg: EconomyData) -> Self {
        MessageInstance::EconomyData(msg)
    }
}

impl From<AvatarPickerRequest> for MessageInstance {
    fn from(msg: AvatarPickerRequest) -> Self {
        MessageInstance::AvatarPickerRequest(msg)
    }
}

impl From<AvatarPickerRequestBackend> for MessageInstance {
    fn from(msg: AvatarPickerRequestBackend) -> Self {
        MessageInstance::AvatarPickerRequestBackend(msg)
    }
}

impl From<AvatarPickerReply> for MessageInstance {
    fn from(msg: AvatarPickerReply) -> Self {
        MessageInstance::AvatarPickerReply(msg)
    }
}

impl From<PlacesQuery> for MessageInstance {
    fn from(msg: PlacesQuery) -> Self {
        MessageInstance::PlacesQuery(msg)
    }
}

impl From<PlacesReply> for MessageInstance {
    fn from(msg: PlacesReply) -> Self {
        MessageInstance::PlacesReply(msg)
    }
}

impl From<DirFindQuery> for MessageInstance {
    fn from(msg: DirFindQuery) -> Self {
        MessageInstance::DirFindQuery(msg)
    }
}

impl From<DirFindQueryBackend> for MessageInstance {
    fn from(msg: DirFindQueryBackend) -> Self {
        MessageInstance::DirFindQueryBackend(msg)
    }
}

impl From<DirPlacesQuery> for MessageInstance {
    fn from(msg: DirPlacesQuery) -> Self {
        MessageInstance::DirPlacesQuery(msg)
    }
}

impl From<DirPlacesQueryBackend> for MessageInstance {
    fn from(msg: DirPlacesQueryBackend) -> Self {
        MessageInstance::DirPlacesQueryBackend(msg)
    }
}

impl From<DirPlacesReply> for MessageInstance {
    fn from(msg: DirPlacesReply) -> Self {
        MessageInstance::DirPlacesReply(msg)
    }
}

impl From<DirPeopleReply> for MessageInstance {
    fn from(msg: DirPeopleReply) -> Self {
        MessageInstance::DirPeopleReply(msg)
    }
}

impl From<DirEventsReply> for MessageInstance {
    fn from(msg: DirEventsReply) -> Self {
        MessageInstance::DirEventsReply(msg)
    }
}

impl From<DirGroupsReply> for MessageInstance {
    fn from(msg: DirGroupsReply) -> Self {
        MessageInstance::DirGroupsReply(msg)
    }
}

impl From<DirClassifiedQuery> for MessageInstance {
    fn from(msg: DirClassifiedQuery) -> Self {
        MessageInstance::DirClassifiedQuery(msg)
    }
}

impl From<DirClassifiedQueryBackend> for MessageInstance {
    fn from(msg: DirClassifiedQueryBackend) -> Self {
        MessageInstance::DirClassifiedQueryBackend(msg)
    }
}

impl From<DirClassifiedReply> for MessageInstance {
    fn from(msg: DirClassifiedReply) -> Self {
        MessageInstance::DirClassifiedReply(msg)
    }
}

impl From<AvatarClassifiedReply> for MessageInstance {
    fn from(msg: AvatarClassifiedReply) -> Self {
        MessageInstance::AvatarClassifiedReply(msg)
    }
}

impl From<ClassifiedInfoRequest> for MessageInstance {
    fn from(msg: ClassifiedInfoRequest) -> Self {
        MessageInstance::ClassifiedInfoRequest(msg)
    }
}

impl From<ClassifiedInfoReply> for MessageInstance {
    fn from(msg: ClassifiedInfoReply) -> Self {
        MessageInstance::ClassifiedInfoReply(msg)
    }
}

impl From<ClassifiedInfoUpdate> for MessageInstance {
    fn from(msg: ClassifiedInfoUpdate) -> Self {
        MessageInstance::ClassifiedInfoUpdate(msg)
    }
}

impl From<ClassifiedDelete> for MessageInstance {
    fn from(msg: ClassifiedDelete) -> Self {
        MessageInstance::ClassifiedDelete(msg)
    }
}

impl From<ClassifiedGodDelete> for MessageInstance {
    fn from(msg: ClassifiedGodDelete) -> Self {
        MessageInstance::ClassifiedGodDelete(msg)
    }
}

impl From<DirLandQuery> for MessageInstance {
    fn from(msg: DirLandQuery) -> Self {
        MessageInstance::DirLandQuery(msg)
    }
}

impl From<DirLandQueryBackend> for MessageInstance {
    fn from(msg: DirLandQueryBackend) -> Self {
        MessageInstance::DirLandQueryBackend(msg)
    }
}

impl From<DirLandReply> for MessageInstance {
    fn from(msg: DirLandReply) -> Self {
        MessageInstance::DirLandReply(msg)
    }
}

impl From<DirPopularQuery> for MessageInstance {
    fn from(msg: DirPopularQuery) -> Self {
        MessageInstance::DirPopularQuery(msg)
    }
}

impl From<DirPopularQueryBackend> for MessageInstance {
    fn from(msg: DirPopularQueryBackend) -> Self {
        MessageInstance::DirPopularQueryBackend(msg)
    }
}

impl From<DirPopularReply> for MessageInstance {
    fn from(msg: DirPopularReply) -> Self {
        MessageInstance::DirPopularReply(msg)
    }
}

impl From<ParcelInfoRequest> for MessageInstance {
    fn from(msg: ParcelInfoRequest) -> Self {
        MessageInstance::ParcelInfoRequest(msg)
    }
}

impl From<ParcelInfoReply> for MessageInstance {
    fn from(msg: ParcelInfoReply) -> Self {
        MessageInstance::ParcelInfoReply(msg)
    }
}

impl From<ParcelObjectOwnersRequest> for MessageInstance {
    fn from(msg: ParcelObjectOwnersRequest) -> Self {
        MessageInstance::ParcelObjectOwnersRequest(msg)
    }
}

impl From<ParcelObjectOwnersReply> for MessageInstance {
    fn from(msg: ParcelObjectOwnersReply) -> Self {
        MessageInstance::ParcelObjectOwnersReply(msg)
    }
}

impl From<GroupNoticesListRequest> for MessageInstance {
    fn from(msg: GroupNoticesListRequest) -> Self {
        MessageInstance::GroupNoticesListRequest(msg)
    }
}

impl From<GroupNoticesListReply> for MessageInstance {
    fn from(msg: GroupNoticesListReply) -> Self {
        MessageInstance::GroupNoticesListReply(msg)
    }
}

impl From<GroupNoticeRequest> for MessageInstance {
    fn from(msg: GroupNoticeRequest) -> Self {
        MessageInstance::GroupNoticeRequest(msg)
    }
}

impl From<GroupNoticeAdd> for MessageInstance {
    fn from(msg: GroupNoticeAdd) -> Self {
        MessageInstance::GroupNoticeAdd(msg)
    }
}

impl From<TeleportRequest> for MessageInstance {
    fn from(msg: TeleportRequest) -> Self {
        MessageInstance::TeleportRequest(msg)
    }
}

impl From<TeleportLocationRequest> for MessageInstance {
    fn from(msg: TeleportLocationRequest) -> Self {
        MessageInstance::TeleportLocationRequest(msg)
    }
}

impl From<TeleportLocal> for MessageInstance {
    fn from(msg: TeleportLocal) -> Self {
        MessageInstance::TeleportLocal(msg)
    }
}

impl From<TeleportLandmarkRequest> for MessageInstance {
    fn from(msg: TeleportLandmarkRequest) -> Self {
        MessageInstance::TeleportLandmarkRequest(msg)
    }
}

impl From<TeleportProgress> for MessageInstance {
    fn from(msg: TeleportProgress) -> Self {
        MessageInstance::TeleportProgress(msg)
    }
}

impl From<DataHomeLocationRequest> for MessageInstance {
    fn from(msg: DataHomeLocationRequest) -> Self {
        MessageInstance::DataHomeLocationRequest(msg)
    }
}

impl From<DataHomeLocationReply> for MessageInstance {
    fn from(msg: DataHomeLocationReply) -> Self {
        MessageInstance::DataHomeLocationReply(msg)
    }
}

impl From<TeleportFinish> for MessageInstance {
    fn from(msg: TeleportFinish) -> Self {
        MessageInstance::TeleportFinish(msg)
    }
}

impl From<StartLure> for MessageInstance {
    fn from(msg: StartLure) -> Self {
        MessageInstance::StartLure(msg)
    }
}

impl From<TeleportLureRequest> for MessageInstance {
    fn from(msg: TeleportLureRequest) -> Self {
        MessageInstance::TeleportLureRequest(msg)
    }
}

impl From<TeleportCancel> for MessageInstance {
    fn from(msg: TeleportCancel) -> Self {
        MessageInstance::TeleportCancel(msg)
    }
}

impl From<TeleportStart> for MessageInstance {
    fn from(msg: TeleportStart) -> Self {
        MessageInstance::TeleportStart(msg)
    }
}

impl From<TeleportFailed> for MessageInstance {
    fn from(msg: TeleportFailed) -> Self {
        MessageInstance::TeleportFailed(msg)
    }
}

impl From<Undo> for MessageInstance {
    fn from(msg: Undo) -> Self {
        MessageInstance::Undo(msg)
    }
}

impl From<Redo> for MessageInstance {
    fn from(msg: Redo) -> Self {
        MessageInstance::Redo(msg)
    }
}

impl From<UndoLand> for MessageInstance {
    fn from(msg: UndoLand) -> Self {
        MessageInstance::UndoLand(msg)
    }
}

impl From<AgentPause> for MessageInstance {
    fn from(msg: AgentPause) -> Self {
        MessageInstance::AgentPause(msg)
    }
}

impl From<AgentResume> for MessageInstance {
    fn from(msg: AgentResume) -> Self {
        MessageInstance::AgentResume(msg)
    }
}

impl From<AgentUpdate> for MessageInstance {
    fn from(msg: AgentUpdate) -> Self {
        MessageInstance::AgentUpdate(msg)
    }
}

impl From<ChatFromViewer> for MessageInstance {
    fn from(msg: ChatFromViewer) -> Self {
        MessageInstance::ChatFromViewer(msg)
    }
}

impl From<AgentThrottle> for MessageInstance {
    fn from(msg: AgentThrottle) -> Self {
        MessageInstance::AgentThrottle(msg)
    }
}

impl From<AgentFOV> for MessageInstance {
    fn from(msg: AgentFOV) -> Self {
        MessageInstance::AgentFOV(msg)
    }
}

impl From<AgentHeightWidth> for MessageInstance {
    fn from(msg: AgentHeightWidth) -> Self {
        MessageInstance::AgentHeightWidth(msg)
    }
}

impl From<AgentSetAppearance> for MessageInstance {
    fn from(msg: AgentSetAppearance) -> Self {
        MessageInstance::AgentSetAppearance(msg)
    }
}

impl From<AgentAnimation> for MessageInstance {
    fn from(msg: AgentAnimation) -> Self {
        MessageInstance::AgentAnimation(msg)
    }
}

impl From<AgentRequestSit> for MessageInstance {
    fn from(msg: AgentRequestSit) -> Self {
        MessageInstance::AgentRequestSit(msg)
    }
}

impl From<AgentSit> for MessageInstance {
    fn from(msg: AgentSit) -> Self {
        MessageInstance::AgentSit(msg)
    }
}

impl From<AgentQuitCopy> for MessageInstance {
    fn from(msg: AgentQuitCopy) -> Self {
        MessageInstance::AgentQuitCopy(msg)
    }
}

impl From<RequestImage> for MessageInstance {
    fn from(msg: RequestImage) -> Self {
        MessageInstance::RequestImage(msg)
    }
}

impl From<ImageNotInDatabase> for MessageInstance {
    fn from(msg: ImageNotInDatabase) -> Self {
        MessageInstance::ImageNotInDatabase(msg)
    }
}

impl From<RebakeAvatarTextures> for MessageInstance {
    fn from(msg: RebakeAvatarTextures) -> Self {
        MessageInstance::RebakeAvatarTextures(msg)
    }
}

impl From<SetAlwaysRun> for MessageInstance {
    fn from(msg: SetAlwaysRun) -> Self {
        MessageInstance::SetAlwaysRun(msg)
    }
}

impl From<ObjectAdd> for MessageInstance {
    fn from(msg: ObjectAdd) -> Self {
        MessageInstance::ObjectAdd(msg)
    }
}

impl From<ObjectDelete> for MessageInstance {
    fn from(msg: ObjectDelete) -> Self {
        MessageInstance::ObjectDelete(msg)
    }
}

impl From<ObjectDuplicate> for MessageInstance {
    fn from(msg: ObjectDuplicate) -> Self {
        MessageInstance::ObjectDuplicate(msg)
    }
}

impl From<ObjectDuplicateOnRay> for MessageInstance {
    fn from(msg: ObjectDuplicateOnRay) -> Self {
        MessageInstance::ObjectDuplicateOnRay(msg)
    }
}

impl From<MultipleObjectUpdate> for MessageInstance {
    fn from(msg: MultipleObjectUpdate) -> Self {
        MessageInstance::MultipleObjectUpdate(msg)
    }
}

impl From<RequestMultipleObjects> for MessageInstance {
    fn from(msg: RequestMultipleObjects) -> Self {
        MessageInstance::RequestMultipleObjects(msg)
    }
}

impl From<ObjectPosition> for MessageInstance {
    fn from(msg: ObjectPosition) -> Self {
        MessageInstance::ObjectPosition(msg)
    }
}

impl From<ObjectScale> for MessageInstance {
    fn from(msg: ObjectScale) -> Self {
        MessageInstance::ObjectScale(msg)
    }
}

impl From<ObjectRotation> for MessageInstance {
    fn from(msg: ObjectRotation) -> Self {
        MessageInstance::ObjectRotation(msg)
    }
}

impl From<ObjectFlagUpdate> for MessageInstance {
    fn from(msg: ObjectFlagUpdate) -> Self {
        MessageInstance::ObjectFlagUpdate(msg)
    }
}

impl From<ObjectClickAction> for MessageInstance {
    fn from(msg: ObjectClickAction) -> Self {
        MessageInstance::ObjectClickAction(msg)
    }
}

impl From<ObjectImage> for MessageInstance {
    fn from(msg: ObjectImage) -> Self {
        MessageInstance::ObjectImage(msg)
    }
}

impl From<ObjectMaterial> for MessageInstance {
    fn from(msg: ObjectMaterial) -> Self {
        MessageInstance::ObjectMaterial(msg)
    }
}

impl From<ObjectShape> for MessageInstance {
    fn from(msg: ObjectShape) -> Self {
        MessageInstance::ObjectShape(msg)
    }
}

impl From<ObjectExtraParams> for MessageInstance {
    fn from(msg: ObjectExtraParams) -> Self {
        MessageInstance::ObjectExtraParams(msg)
    }
}

impl From<ObjectOwner> for MessageInstance {
    fn from(msg: ObjectOwner) -> Self {
        MessageInstance::ObjectOwner(msg)
    }
}

impl From<ObjectGroup> for MessageInstance {
    fn from(msg: ObjectGroup) -> Self {
        MessageInstance::ObjectGroup(msg)
    }
}

impl From<ObjectBuy> for MessageInstance {
    fn from(msg: ObjectBuy) -> Self {
        MessageInstance::ObjectBuy(msg)
    }
}

impl From<BuyObjectInventory> for MessageInstance {
    fn from(msg: BuyObjectInventory) -> Self {
        MessageInstance::BuyObjectInventory(msg)
    }
}

impl From<DerezContainer> for MessageInstance {
    fn from(msg: DerezContainer) -> Self {
        MessageInstance::DerezContainer(msg)
    }
}

impl From<ObjectPermissions> for MessageInstance {
    fn from(msg: ObjectPermissions) -> Self {
        MessageInstance::ObjectPermissions(msg)
    }
}

impl From<ObjectSaleInfo> for MessageInstance {
    fn from(msg: ObjectSaleInfo) -> Self {
        MessageInstance::ObjectSaleInfo(msg)
    }
}

impl From<ObjectName> for MessageInstance {
    fn from(msg: ObjectName) -> Self {
        MessageInstance::ObjectName(msg)
    }
}

impl From<ObjectDescription> for MessageInstance {
    fn from(msg: ObjectDescription) -> Self {
        MessageInstance::ObjectDescription(msg)
    }
}

impl From<ObjectCategory> for MessageInstance {
    fn from(msg: ObjectCategory) -> Self {
        MessageInstance::ObjectCategory(msg)
    }
}

impl From<ObjectSelect> for MessageInstance {
    fn from(msg: ObjectSelect) -> Self {
        MessageInstance::ObjectSelect(msg)
    }
}

impl From<ObjectDeselect> for MessageInstance {
    fn from(msg: ObjectDeselect) -> Self {
        MessageInstance::ObjectDeselect(msg)
    }
}

impl From<ObjectAttach> for MessageInstance {
    fn from(msg: ObjectAttach) -> Self {
        MessageInstance::ObjectAttach(msg)
    }
}

impl From<ObjectDetach> for MessageInstance {
    fn from(msg: ObjectDetach) -> Self {
        MessageInstance::ObjectDetach(msg)
    }
}

impl From<ObjectDrop> for MessageInstance {
    fn from(msg: ObjectDrop) -> Self {
        MessageInstance::ObjectDrop(msg)
    }
}

impl From<ObjectLink> for MessageInstance {
    fn from(msg: ObjectLink) -> Self {
        MessageInstance::ObjectLink(msg)
    }
}

impl From<ObjectDelink> for MessageInstance {
    fn from(msg: ObjectDelink) -> Self {
        MessageInstance::ObjectDelink(msg)
    }
}

impl From<ObjectGrab> for MessageInstance {
    fn from(msg: ObjectGrab) -> Self {
        MessageInstance::ObjectGrab(msg)
    }
}

impl From<ObjectGrabUpdate> for MessageInstance {
    fn from(msg: ObjectGrabUpdate) -> Self {
        MessageInstance::ObjectGrabUpdate(msg)
    }
}

impl From<ObjectDeGrab> for MessageInstance {
    fn from(msg: ObjectDeGrab) -> Self {
        MessageInstance::ObjectDeGrab(msg)
    }
}

impl From<ObjectSpinStart> for MessageInstance {
    fn from(msg: ObjectSpinStart) -> Self {
        MessageInstance::ObjectSpinStart(msg)
    }
}

impl From<ObjectSpinUpdate> for MessageInstance {
    fn from(msg: ObjectSpinUpdate) -> Self {
        MessageInstance::ObjectSpinUpdate(msg)
    }
}

impl From<ObjectSpinStop> for MessageInstance {
    fn from(msg: ObjectSpinStop) -> Self {
        MessageInstance::ObjectSpinStop(msg)
    }
}

impl From<ObjectExportSelected> for MessageInstance {
    fn from(msg: ObjectExportSelected) -> Self {
        MessageInstance::ObjectExportSelected(msg)
    }
}

impl From<ModifyLand> for MessageInstance {
    fn from(msg: ModifyLand) -> Self {
        MessageInstance::ModifyLand(msg)
    }
}

impl From<VelocityInterpolateOn> for MessageInstance {
    fn from(msg: VelocityInterpolateOn) -> Self {
        MessageInstance::VelocityInterpolateOn(msg)
    }
}

impl From<VelocityInterpolateOff> for MessageInstance {
    fn from(msg: VelocityInterpolateOff) -> Self {
        MessageInstance::VelocityInterpolateOff(msg)
    }
}

impl From<StateSave> for MessageInstance {
    fn from(msg: StateSave) -> Self {
        MessageInstance::StateSave(msg)
    }
}

impl From<ReportAutosaveCrash> for MessageInstance {
    fn from(msg: ReportAutosaveCrash) -> Self {
        MessageInstance::ReportAutosaveCrash(msg)
    }
}

impl From<SimWideDeletes> for MessageInstance {
    fn from(msg: SimWideDeletes) -> Self {
        MessageInstance::SimWideDeletes(msg)
    }
}

impl From<RequestObjectPropertiesFamily> for MessageInstance {
    fn from(msg: RequestObjectPropertiesFamily) -> Self {
        MessageInstance::RequestObjectPropertiesFamily(msg)
    }
}

impl From<TrackAgent> for MessageInstance {
    fn from(msg: TrackAgent) -> Self {
        MessageInstance::TrackAgent(msg)
    }
}

impl From<ViewerStats> for MessageInstance {
    fn from(msg: ViewerStats) -> Self {
        MessageInstance::ViewerStats(msg)
    }
}

impl From<ScriptAnswerYes> for MessageInstance {
    fn from(msg: ScriptAnswerYes) -> Self {
        MessageInstance::ScriptAnswerYes(msg)
    }
}

impl From<UserReport> for MessageInstance {
    fn from(msg: UserReport) -> Self {
        MessageInstance::UserReport(msg)
    }
}

impl From<AlertMessage> for MessageInstance {
    fn from(msg: AlertMessage) -> Self {
        MessageInstance::AlertMessage(msg)
    }
}

impl From<AgentAlertMessage> for MessageInstance {
    fn from(msg: AgentAlertMessage) -> Self {
        MessageInstance::AgentAlertMessage(msg)
    }
}

impl From<MeanCollisionAlert> for MessageInstance {
    fn from(msg: MeanCollisionAlert) -> Self {
        MessageInstance::MeanCollisionAlert(msg)
    }
}

impl From<ViewerFrozenMessage> for MessageInstance {
    fn from(msg: ViewerFrozenMessage) -> Self {
        MessageInstance::ViewerFrozenMessage(msg)
    }
}

impl From<HealthMessage> for MessageInstance {
    fn from(msg: HealthMessage) -> Self {
        MessageInstance::HealthMessage(msg)
    }
}

impl From<ChatFromSimulator> for MessageInstance {
    fn from(msg: ChatFromSimulator) -> Self {
        MessageInstance::ChatFromSimulator(msg)
    }
}

impl From<SimStats> for MessageInstance {
    fn from(msg: SimStats) -> Self {
        MessageInstance::SimStats(msg)
    }
}

impl From<RequestRegionInfo> for MessageInstance {
    fn from(msg: RequestRegionInfo) -> Self {
        MessageInstance::RequestRegionInfo(msg)
    }
}

impl From<RegionInfo> for MessageInstance {
    fn from(msg: RegionInfo) -> Self {
        MessageInstance::RegionInfo(msg)
    }
}

impl From<GodUpdateRegionInfo> for MessageInstance {
    fn from(msg: GodUpdateRegionInfo) -> Self {
        MessageInstance::GodUpdateRegionInfo(msg)
    }
}

impl From<NearestLandingRegionRequest> for MessageInstance {
    fn from(msg: NearestLandingRegionRequest) -> Self {
        MessageInstance::NearestLandingRegionRequest(msg)
    }
}

impl From<NearestLandingRegionReply> for MessageInstance {
    fn from(msg: NearestLandingRegionReply) -> Self {
        MessageInstance::NearestLandingRegionReply(msg)
    }
}

impl From<NearestLandingRegionUpdated> for MessageInstance {
    fn from(msg: NearestLandingRegionUpdated) -> Self {
        MessageInstance::NearestLandingRegionUpdated(msg)
    }
}

impl From<TeleportLandingStatusChanged> for MessageInstance {
    fn from(msg: TeleportLandingStatusChanged) -> Self {
        MessageInstance::TeleportLandingStatusChanged(msg)
    }
}

impl From<RegionHandshake> for MessageInstance {
    fn from(msg: RegionHandshake) -> Self {
        MessageInstance::RegionHandshake(msg)
    }
}

impl From<RegionHandshakeReply> for MessageInstance {
    fn from(msg: RegionHandshakeReply) -> Self {
        MessageInstance::RegionHandshakeReply(msg)
    }
}

impl From<CoarseLocationUpdate> for MessageInstance {
    fn from(msg: CoarseLocationUpdate) -> Self {
        MessageInstance::CoarseLocationUpdate(msg)
    }
}

impl From<ImageData> for MessageInstance {
    fn from(msg: ImageData) -> Self {
        MessageInstance::ImageData(msg)
    }
}

impl From<ImagePacket> for MessageInstance {
    fn from(msg: ImagePacket) -> Self {
        MessageInstance::ImagePacket(msg)
    }
}

impl From<LayerData> for MessageInstance {
    fn from(msg: LayerData) -> Self {
        MessageInstance::LayerData(msg)
    }
}

impl From<ObjectUpdate> for MessageInstance {
    fn from(msg: ObjectUpdate) -> Self {
        MessageInstance::ObjectUpdate(msg)
    }
}

impl From<ObjectUpdateCompressed> for MessageInstance {
    fn from(msg: ObjectUpdateCompressed) -> Self {
        MessageInstance::ObjectUpdateCompressed(msg)
    }
}

impl From<ObjectUpdateCached> for MessageInstance {
    fn from(msg: ObjectUpdateCached) -> Self {
        MessageInstance::ObjectUpdateCached(msg)
    }
}

impl From<ImprovedTerseObjectUpdate> for MessageInstance {
    fn from(msg: ImprovedTerseObjectUpdate) -> Self {
        MessageInstance::ImprovedTerseObjectUpdate(msg)
    }
}

impl From<KillObject> for MessageInstance {
    fn from(msg: KillObject) -> Self {
        MessageInstance::KillObject(msg)
    }
}

impl From<CrossedRegion> for MessageInstance {
    fn from(msg: CrossedRegion) -> Self {
        MessageInstance::CrossedRegion(msg)
    }
}

impl From<SimulatorViewerTimeMessage> for MessageInstance {
    fn from(msg: SimulatorViewerTimeMessage) -> Self {
        MessageInstance::SimulatorViewerTimeMessage(msg)
    }
}

impl From<EnableSimulator> for MessageInstance {
    fn from(msg: EnableSimulator) -> Self {
        MessageInstance::EnableSimulator(msg)
    }
}

impl From<DisableSimulator> for MessageInstance {
    fn from(msg: DisableSimulator) -> Self {
        MessageInstance::DisableSimulator(msg)
    }
}

impl From<ConfirmEnableSimulator> for MessageInstance {
    fn from(msg: ConfirmEnableSimulator) -> Self {
        MessageInstance::ConfirmEnableSimulator(msg)
    }
}

impl From<TransferRequest> for MessageInstance {
    fn from(msg: TransferRequest) -> Self {
        MessageInstance::TransferRequest(msg)
    }
}

impl From<TransferInfo> for MessageInstance {
    fn from(msg: TransferInfo) -> Self {
        MessageInstance::TransferInfo(msg)
    }
}

impl From<TransferPacket> for MessageInstance {
    fn from(msg: TransferPacket) -> Self {
        MessageInstance::TransferPacket(msg)
    }
}

impl From<TransferAbort> for MessageInstance {
    fn from(msg: TransferAbort) -> Self {
        MessageInstance::TransferAbort(msg)
    }
}

impl From<RequestXfer> for MessageInstance {
    fn from(msg: RequestXfer) -> Self {
        MessageInstance::RequestXfer(msg)
    }
}

impl From<SendXferPacket> for MessageInstance {
    fn from(msg: SendXferPacket) -> Self {
        MessageInstance::SendXferPacket(msg)
    }
}

impl From<ConfirmXferPacket> for MessageInstance {
    fn from(msg: ConfirmXferPacket) -> Self {
        MessageInstance::ConfirmXferPacket(msg)
    }
}

impl From<AbortXfer> for MessageInstance {
    fn from(msg: AbortXfer) -> Self {
        MessageInstance::AbortXfer(msg)
    }
}

impl From<AvatarAnimation> for MessageInstance {
    fn from(msg: AvatarAnimation) -> Self {
        MessageInstance::AvatarAnimation(msg)
    }
}

impl From<AvatarAppearance> for MessageInstance {
    fn from(msg: AvatarAppearance) -> Self {
        MessageInstance::AvatarAppearance(msg)
    }
}

impl From<AvatarSitResponse> for MessageInstance {
    fn from(msg: AvatarSitResponse) -> Self {
        MessageInstance::AvatarSitResponse(msg)
    }
}

impl From<SetFollowCamProperties> for MessageInstance {
    fn from(msg: SetFollowCamProperties) -> Self {
        MessageInstance::SetFollowCamProperties(msg)
    }
}

impl From<ClearFollowCamProperties> for MessageInstance {
    fn from(msg: ClearFollowCamProperties) -> Self {
        MessageInstance::ClearFollowCamProperties(msg)
    }
}

impl From<CameraConstraint> for MessageInstance {
    fn from(msg: CameraConstraint) -> Self {
        MessageInstance::CameraConstraint(msg)
    }
}

impl From<ObjectProperties> for MessageInstance {
    fn from(msg: ObjectProperties) -> Self {
        MessageInstance::ObjectProperties(msg)
    }
}

impl From<ObjectPropertiesFamily> for MessageInstance {
    fn from(msg: ObjectPropertiesFamily) -> Self {
        MessageInstance::ObjectPropertiesFamily(msg)
    }
}

impl From<RequestPayPrice> for MessageInstance {
    fn from(msg: RequestPayPrice) -> Self {
        MessageInstance::RequestPayPrice(msg)
    }
}

impl From<PayPriceReply> for MessageInstance {
    fn from(msg: PayPriceReply) -> Self {
        MessageInstance::PayPriceReply(msg)
    }
}

impl From<KickUser> for MessageInstance {
    fn from(msg: KickUser) -> Self {
        MessageInstance::KickUser(msg)
    }
}

impl From<KickUserAck> for MessageInstance {
    fn from(msg: KickUserAck) -> Self {
        MessageInstance::KickUserAck(msg)
    }
}

impl From<GodKickUser> for MessageInstance {
    fn from(msg: GodKickUser) -> Self {
        MessageInstance::GodKickUser(msg)
    }
}

impl From<SystemKickUser> for MessageInstance {
    fn from(msg: SystemKickUser) -> Self {
        MessageInstance::SystemKickUser(msg)
    }
}

impl From<EjectUser> for MessageInstance {
    fn from(msg: EjectUser) -> Self {
        MessageInstance::EjectUser(msg)
    }
}

impl From<FreezeUser> for MessageInstance {
    fn from(msg: FreezeUser) -> Self {
        MessageInstance::FreezeUser(msg)
    }
}

impl From<AvatarPropertiesRequest> for MessageInstance {
    fn from(msg: AvatarPropertiesRequest) -> Self {
        MessageInstance::AvatarPropertiesRequest(msg)
    }
}

impl From<AvatarPropertiesRequestBackend> for MessageInstance {
    fn from(msg: AvatarPropertiesRequestBackend) -> Self {
        MessageInstance::AvatarPropertiesRequestBackend(msg)
    }
}

impl From<AvatarPropertiesReply> for MessageInstance {
    fn from(msg: AvatarPropertiesReply) -> Self {
        MessageInstance::AvatarPropertiesReply(msg)
    }
}

impl From<AvatarInterestsReply> for MessageInstance {
    fn from(msg: AvatarInterestsReply) -> Self {
        MessageInstance::AvatarInterestsReply(msg)
    }
}

impl From<AvatarGroupsReply> for MessageInstance {
    fn from(msg: AvatarGroupsReply) -> Self {
        MessageInstance::AvatarGroupsReply(msg)
    }
}

impl From<AvatarPropertiesUpdate> for MessageInstance {
    fn from(msg: AvatarPropertiesUpdate) -> Self {
        MessageInstance::AvatarPropertiesUpdate(msg)
    }
}

impl From<AvatarInterestsUpdate> for MessageInstance {
    fn from(msg: AvatarInterestsUpdate) -> Self {
        MessageInstance::AvatarInterestsUpdate(msg)
    }
}

impl From<AvatarNotesReply> for MessageInstance {
    fn from(msg: AvatarNotesReply) -> Self {
        MessageInstance::AvatarNotesReply(msg)
    }
}

impl From<AvatarNotesUpdate> for MessageInstance {
    fn from(msg: AvatarNotesUpdate) -> Self {
        MessageInstance::AvatarNotesUpdate(msg)
    }
}

impl From<AvatarPicksReply> for MessageInstance {
    fn from(msg: AvatarPicksReply) -> Self {
        MessageInstance::AvatarPicksReply(msg)
    }
}

impl From<EventInfoRequest> for MessageInstance {
    fn from(msg: EventInfoRequest) -> Self {
        MessageInstance::EventInfoRequest(msg)
    }
}

impl From<EventInfoReply> for MessageInstance {
    fn from(msg: EventInfoReply) -> Self {
        MessageInstance::EventInfoReply(msg)
    }
}

impl From<EventNotificationAddRequest> for MessageInstance {
    fn from(msg: EventNotificationAddRequest) -> Self {
        MessageInstance::EventNotificationAddRequest(msg)
    }
}

impl From<EventNotificationRemoveRequest> for MessageInstance {
    fn from(msg: EventNotificationRemoveRequest) -> Self {
        MessageInstance::EventNotificationRemoveRequest(msg)
    }
}

impl From<EventGodDelete> for MessageInstance {
    fn from(msg: EventGodDelete) -> Self {
        MessageInstance::EventGodDelete(msg)
    }
}

impl From<PickInfoReply> for MessageInstance {
    fn from(msg: PickInfoReply) -> Self {
        MessageInstance::PickInfoReply(msg)
    }
}

impl From<PickInfoUpdate> for MessageInstance {
    fn from(msg: PickInfoUpdate) -> Self {
        MessageInstance::PickInfoUpdate(msg)
    }
}

impl From<PickDelete> for MessageInstance {
    fn from(msg: PickDelete) -> Self {
        MessageInstance::PickDelete(msg)
    }
}

impl From<PickGodDelete> for MessageInstance {
    fn from(msg: PickGodDelete) -> Self {
        MessageInstance::PickGodDelete(msg)
    }
}

impl From<ScriptQuestion> for MessageInstance {
    fn from(msg: ScriptQuestion) -> Self {
        MessageInstance::ScriptQuestion(msg)
    }
}

impl From<ScriptControlChange> for MessageInstance {
    fn from(msg: ScriptControlChange) -> Self {
        MessageInstance::ScriptControlChange(msg)
    }
}

impl From<ScriptDialog> for MessageInstance {
    fn from(msg: ScriptDialog) -> Self {
        MessageInstance::ScriptDialog(msg)
    }
}

impl From<ScriptDialogReply> for MessageInstance {
    fn from(msg: ScriptDialogReply) -> Self {
        MessageInstance::ScriptDialogReply(msg)
    }
}

impl From<ForceScriptControlRelease> for MessageInstance {
    fn from(msg: ForceScriptControlRelease) -> Self {
        MessageInstance::ForceScriptControlRelease(msg)
    }
}

impl From<RevokePermissions> for MessageInstance {
    fn from(msg: RevokePermissions) -> Self {
        MessageInstance::RevokePermissions(msg)
    }
}

impl From<LoadURL> for MessageInstance {
    fn from(msg: LoadURL) -> Self {
        MessageInstance::LoadURL(msg)
    }
}

impl From<ScriptTeleportRequest> for MessageInstance {
    fn from(msg: ScriptTeleportRequest) -> Self {
        MessageInstance::ScriptTeleportRequest(msg)
    }
}

impl From<ParcelOverlay> for MessageInstance {
    fn from(msg: ParcelOverlay) -> Self {
        MessageInstance::ParcelOverlay(msg)
    }
}

impl From<ParcelPropertiesRequest> for MessageInstance {
    fn from(msg: ParcelPropertiesRequest) -> Self {
        MessageInstance::ParcelPropertiesRequest(msg)
    }
}

impl From<ParcelPropertiesRequestByID> for MessageInstance {
    fn from(msg: ParcelPropertiesRequestByID) -> Self {
        MessageInstance::ParcelPropertiesRequestByID(msg)
    }
}

impl From<ParcelProperties> for MessageInstance {
    fn from(msg: ParcelProperties) -> Self {
        MessageInstance::ParcelProperties(msg)
    }
}

impl From<ParcelPropertiesUpdate> for MessageInstance {
    fn from(msg: ParcelPropertiesUpdate) -> Self {
        MessageInstance::ParcelPropertiesUpdate(msg)
    }
}

impl From<ParcelReturnObjects> for MessageInstance {
    fn from(msg: ParcelReturnObjects) -> Self {
        MessageInstance::ParcelReturnObjects(msg)
    }
}

impl From<ParcelSetOtherCleanTime> for MessageInstance {
    fn from(msg: ParcelSetOtherCleanTime) -> Self {
        MessageInstance::ParcelSetOtherCleanTime(msg)
    }
}

impl From<ParcelDisableObjects> for MessageInstance {
    fn from(msg: ParcelDisableObjects) -> Self {
        MessageInstance::ParcelDisableObjects(msg)
    }
}

impl From<ParcelSelectObjects> for MessageInstance {
    fn from(msg: ParcelSelectObjects) -> Self {
        MessageInstance::ParcelSelectObjects(msg)
    }
}

impl From<EstateCovenantRequest> for MessageInstance {
    fn from(msg: EstateCovenantRequest) -> Self {
        MessageInstance::EstateCovenantRequest(msg)
    }
}

impl From<EstateCovenantReply> for MessageInstance {
    fn from(msg: EstateCovenantReply) -> Self {
        MessageInstance::EstateCovenantReply(msg)
    }
}

impl From<ForceObjectSelect> for MessageInstance {
    fn from(msg: ForceObjectSelect) -> Self {
        MessageInstance::ForceObjectSelect(msg)
    }
}

impl From<ParcelBuyPass> for MessageInstance {
    fn from(msg: ParcelBuyPass) -> Self {
        MessageInstance::ParcelBuyPass(msg)
    }
}

impl From<ParcelDeedToGroup> for MessageInstance {
    fn from(msg: ParcelDeedToGroup) -> Self {
        MessageInstance::ParcelDeedToGroup(msg)
    }
}

impl From<ParcelReclaim> for MessageInstance {
    fn from(msg: ParcelReclaim) -> Self {
        MessageInstance::ParcelReclaim(msg)
    }
}

impl From<ParcelClaim> for MessageInstance {
    fn from(msg: ParcelClaim) -> Self {
        MessageInstance::ParcelClaim(msg)
    }
}

impl From<ParcelJoin> for MessageInstance {
    fn from(msg: ParcelJoin) -> Self {
        MessageInstance::ParcelJoin(msg)
    }
}

impl From<ParcelDivide> for MessageInstance {
    fn from(msg: ParcelDivide) -> Self {
        MessageInstance::ParcelDivide(msg)
    }
}

impl From<ParcelRelease> for MessageInstance {
    fn from(msg: ParcelRelease) -> Self {
        MessageInstance::ParcelRelease(msg)
    }
}

impl From<ParcelBuy> for MessageInstance {
    fn from(msg: ParcelBuy) -> Self {
        MessageInstance::ParcelBuy(msg)
    }
}

impl From<ParcelGodForceOwner> for MessageInstance {
    fn from(msg: ParcelGodForceOwner) -> Self {
        MessageInstance::ParcelGodForceOwner(msg)
    }
}

impl From<ParcelAccessListRequest> for MessageInstance {
    fn from(msg: ParcelAccessListRequest) -> Self {
        MessageInstance::ParcelAccessListRequest(msg)
    }
}

impl From<ParcelAccessListReply> for MessageInstance {
    fn from(msg: ParcelAccessListReply) -> Self {
        MessageInstance::ParcelAccessListReply(msg)
    }
}

impl From<ParcelAccessListUpdate> for MessageInstance {
    fn from(msg: ParcelAccessListUpdate) -> Self {
        MessageInstance::ParcelAccessListUpdate(msg)
    }
}

impl From<ParcelDwellRequest> for MessageInstance {
    fn from(msg: ParcelDwellRequest) -> Self {
        MessageInstance::ParcelDwellRequest(msg)
    }
}

impl From<ParcelDwellReply> for MessageInstance {
    fn from(msg: ParcelDwellReply) -> Self {
        MessageInstance::ParcelDwellReply(msg)
    }
}

impl From<RequestParcelTransfer> for MessageInstance {
    fn from(msg: RequestParcelTransfer) -> Self {
        MessageInstance::RequestParcelTransfer(msg)
    }
}

impl From<UpdateParcel> for MessageInstance {
    fn from(msg: UpdateParcel) -> Self {
        MessageInstance::UpdateParcel(msg)
    }
}

impl From<RemoveParcel> for MessageInstance {
    fn from(msg: RemoveParcel) -> Self {
        MessageInstance::RemoveParcel(msg)
    }
}

impl From<MergeParcel> for MessageInstance {
    fn from(msg: MergeParcel) -> Self {
        MessageInstance::MergeParcel(msg)
    }
}

impl From<LogParcelChanges> for MessageInstance {
    fn from(msg: LogParcelChanges) -> Self {
        MessageInstance::LogParcelChanges(msg)
    }
}

impl From<CheckParcelSales> for MessageInstance {
    fn from(msg: CheckParcelSales) -> Self {
        MessageInstance::CheckParcelSales(msg)
    }
}

impl From<ParcelSales> for MessageInstance {
    fn from(msg: ParcelSales) -> Self {
        MessageInstance::ParcelSales(msg)
    }
}

impl From<ParcelGodMarkAsContent> for MessageInstance {
    fn from(msg: ParcelGodMarkAsContent) -> Self {
        MessageInstance::ParcelGodMarkAsContent(msg)
    }
}

impl From<ViewerStartAuction> for MessageInstance {
    fn from(msg: ViewerStartAuction) -> Self {
        MessageInstance::ViewerStartAuction(msg)
    }
}

impl From<StartAuction> for MessageInstance {
    fn from(msg: StartAuction) -> Self {
        MessageInstance::StartAuction(msg)
    }
}

impl From<ConfirmAuctionStart> for MessageInstance {
    fn from(msg: ConfirmAuctionStart) -> Self {
        MessageInstance::ConfirmAuctionStart(msg)
    }
}

impl From<CompleteAuction> for MessageInstance {
    fn from(msg: CompleteAuction) -> Self {
        MessageInstance::CompleteAuction(msg)
    }
}

impl From<CancelAuction> for MessageInstance {
    fn from(msg: CancelAuction) -> Self {
        MessageInstance::CancelAuction(msg)
    }
}

impl From<CheckParcelAuctions> for MessageInstance {
    fn from(msg: CheckParcelAuctions) -> Self {
        MessageInstance::CheckParcelAuctions(msg)
    }
}

impl From<ParcelAuctions> for MessageInstance {
    fn from(msg: ParcelAuctions) -> Self {
        MessageInstance::ParcelAuctions(msg)
    }
}

impl From<UUIDNameRequest> for MessageInstance {
    fn from(msg: UUIDNameRequest) -> Self {
        MessageInstance::UUIDNameRequest(msg)
    }
}

impl From<UUIDNameReply> for MessageInstance {
    fn from(msg: UUIDNameReply) -> Self {
        MessageInstance::UUIDNameReply(msg)
    }
}

impl From<UUIDGroupNameRequest> for MessageInstance {
    fn from(msg: UUIDGroupNameRequest) -> Self {
        MessageInstance::UUIDGroupNameRequest(msg)
    }
}

impl From<UUIDGroupNameReply> for MessageInstance {
    fn from(msg: UUIDGroupNameReply) -> Self {
        MessageInstance::UUIDGroupNameReply(msg)
    }
}

impl From<ChatPass> for MessageInstance {
    fn from(msg: ChatPass) -> Self {
        MessageInstance::ChatPass(msg)
    }
}

impl From<EdgeDataPacket> for MessageInstance {
    fn from(msg: EdgeDataPacket) -> Self {
        MessageInstance::EdgeDataPacket(msg)
    }
}

impl From<SimStatus> for MessageInstance {
    fn from(msg: SimStatus) -> Self {
        MessageInstance::SimStatus(msg)
    }
}

impl From<ChildAgentUpdate> for MessageInstance {
    fn from(msg: ChildAgentUpdate) -> Self {
        MessageInstance::ChildAgentUpdate(msg)
    }
}

impl From<ChildAgentAlive> for MessageInstance {
    fn from(msg: ChildAgentAlive) -> Self {
        MessageInstance::ChildAgentAlive(msg)
    }
}

impl From<ChildAgentPositionUpdate> for MessageInstance {
    fn from(msg: ChildAgentPositionUpdate) -> Self {
        MessageInstance::ChildAgentPositionUpdate(msg)
    }
}

impl From<ChildAgentDying> for MessageInstance {
    fn from(msg: ChildAgentDying) -> Self {
        MessageInstance::ChildAgentDying(msg)
    }
}

impl From<ChildAgentUnknown> for MessageInstance {
    fn from(msg: ChildAgentUnknown) -> Self {
        MessageInstance::ChildAgentUnknown(msg)
    }
}

impl From<AtomicPassObject> for MessageInstance {
    fn from(msg: AtomicPassObject) -> Self {
        MessageInstance::AtomicPassObject(msg)
    }
}

impl From<KillChildAgents> for MessageInstance {
    fn from(msg: KillChildAgents) -> Self {
        MessageInstance::KillChildAgents(msg)
    }
}

impl From<GetScriptRunning> for MessageInstance {
    fn from(msg: GetScriptRunning) -> Self {
        MessageInstance::GetScriptRunning(msg)
    }
}

impl From<ScriptRunningReply> for MessageInstance {
    fn from(msg: ScriptRunningReply) -> Self {
        MessageInstance::ScriptRunningReply(msg)
    }
}

impl From<SetScriptRunning> for MessageInstance {
    fn from(msg: SetScriptRunning) -> Self {
        MessageInstance::SetScriptRunning(msg)
    }
}

impl From<ScriptReset> for MessageInstance {
    fn from(msg: ScriptReset) -> Self {
        MessageInstance::ScriptReset(msg)
    }
}

impl From<ScriptSensorRequest> for MessageInstance {
    fn from(msg: ScriptSensorRequest) -> Self {
        MessageInstance::ScriptSensorRequest(msg)
    }
}

impl From<ScriptSensorReply> for MessageInstance {
    fn from(msg: ScriptSensorReply) -> Self {
        MessageInstance::ScriptSensorReply(msg)
    }
}

impl From<CompleteAgentMovement> for MessageInstance {
    fn from(msg: CompleteAgentMovement) -> Self {
        MessageInstance::CompleteAgentMovement(msg)
    }
}

impl From<AgentMovementComplete> for MessageInstance {
    fn from(msg: AgentMovementComplete) -> Self {
        MessageInstance::AgentMovementComplete(msg)
    }
}

impl From<DataServerLogout> for MessageInstance {
    fn from(msg: DataServerLogout) -> Self {
        MessageInstance::DataServerLogout(msg)
    }
}

impl From<LogoutRequest> for MessageInstance {
    fn from(msg: LogoutRequest) -> Self {
        MessageInstance::LogoutRequest(msg)
    }
}

impl From<LogoutReply> for MessageInstance {
    fn from(msg: LogoutReply) -> Self {
        MessageInstance::LogoutReply(msg)
    }
}

impl From<ImprovedInstantMessage> for MessageInstance {
    fn from(msg: ImprovedInstantMessage) -> Self {
        MessageInstance::ImprovedInstantMessage(msg)
    }
}

impl From<RetrieveInstantMessages> for MessageInstance {
    fn from(msg: RetrieveInstantMessages) -> Self {
        MessageInstance::RetrieveInstantMessages(msg)
    }
}

impl From<FindAgent> for MessageInstance {
    fn from(msg: FindAgent) -> Self {
        MessageInstance::FindAgent(msg)
    }
}

impl From<RequestGodlikePowers> for MessageInstance {
    fn from(msg: RequestGodlikePowers) -> Self {
        MessageInstance::RequestGodlikePowers(msg)
    }
}

impl From<GrantGodlikePowers> for MessageInstance {
    fn from(msg: GrantGodlikePowers) -> Self {
        MessageInstance::GrantGodlikePowers(msg)
    }
}

impl From<GodlikeMessage> for MessageInstance {
    fn from(msg: GodlikeMessage) -> Self {
        MessageInstance::GodlikeMessage(msg)
    }
}

impl From<EstateOwnerMessage> for MessageInstance {
    fn from(msg: EstateOwnerMessage) -> Self {
        MessageInstance::EstateOwnerMessage(msg)
    }
}

impl From<GenericMessage> for MessageInstance {
    fn from(msg: GenericMessage) -> Self {
        MessageInstance::GenericMessage(msg)
    }
}

impl From<MuteListRequest> for MessageInstance {
    fn from(msg: MuteListRequest) -> Self {
        MessageInstance::MuteListRequest(msg)
    }
}

impl From<UpdateMuteListEntry> for MessageInstance {
    fn from(msg: UpdateMuteListEntry) -> Self {
        MessageInstance::UpdateMuteListEntry(msg)
    }
}

impl From<RemoveMuteListEntry> for MessageInstance {
    fn from(msg: RemoveMuteListEntry) -> Self {
        MessageInstance::RemoveMuteListEntry(msg)
    }
}

impl From<CopyInventoryFromNotecard> for MessageInstance {
    fn from(msg: CopyInventoryFromNotecard) -> Self {
        MessageInstance::CopyInventoryFromNotecard(msg)
    }
}

impl From<UpdateInventoryItem> for MessageInstance {
    fn from(msg: UpdateInventoryItem) -> Self {
        MessageInstance::UpdateInventoryItem(msg)
    }
}

impl From<UpdateCreateInventoryItem> for MessageInstance {
    fn from(msg: UpdateCreateInventoryItem) -> Self {
        MessageInstance::UpdateCreateInventoryItem(msg)
    }
}

impl From<MoveInventoryItem> for MessageInstance {
    fn from(msg: MoveInventoryItem) -> Self {
        MessageInstance::MoveInventoryItem(msg)
    }
}

impl From<CopyInventoryItem> for MessageInstance {
    fn from(msg: CopyInventoryItem) -> Self {
        MessageInstance::CopyInventoryItem(msg)
    }
}

impl From<RemoveInventoryItem> for MessageInstance {
    fn from(msg: RemoveInventoryItem) -> Self {
        MessageInstance::RemoveInventoryItem(msg)
    }
}

impl From<ChangeInventoryItemFlags> for MessageInstance {
    fn from(msg: ChangeInventoryItemFlags) -> Self {
        MessageInstance::ChangeInventoryItemFlags(msg)
    }
}

impl From<SaveAssetIntoInventory> for MessageInstance {
    fn from(msg: SaveAssetIntoInventory) -> Self {
        MessageInstance::SaveAssetIntoInventory(msg)
    }
}

impl From<CreateInventoryFolder> for MessageInstance {
    fn from(msg: CreateInventoryFolder) -> Self {
        MessageInstance::CreateInventoryFolder(msg)
    }
}

impl From<UpdateInventoryFolder> for MessageInstance {
    fn from(msg: UpdateInventoryFolder) -> Self {
        MessageInstance::UpdateInventoryFolder(msg)
    }
}

impl From<MoveInventoryFolder> for MessageInstance {
    fn from(msg: MoveInventoryFolder) -> Self {
        MessageInstance::MoveInventoryFolder(msg)
    }
}

impl From<RemoveInventoryFolder> for MessageInstance {
    fn from(msg: RemoveInventoryFolder) -> Self {
        MessageInstance::RemoveInventoryFolder(msg)
    }
}

impl From<FetchInventoryDescendents> for MessageInstance {
    fn from(msg: FetchInventoryDescendents) -> Self {
        MessageInstance::FetchInventoryDescendents(msg)
    }
}

impl From<InventoryDescendents> for MessageInstance {
    fn from(msg: InventoryDescendents) -> Self {
        MessageInstance::InventoryDescendents(msg)
    }
}

impl From<FetchInventory> for MessageInstance {
    fn from(msg: FetchInventory) -> Self {
        MessageInstance::FetchInventory(msg)
    }
}

impl From<FetchInventoryReply> for MessageInstance {
    fn from(msg: FetchInventoryReply) -> Self {
        MessageInstance::FetchInventoryReply(msg)
    }
}

impl From<BulkUpdateInventory> for MessageInstance {
    fn from(msg: BulkUpdateInventory) -> Self {
        MessageInstance::BulkUpdateInventory(msg)
    }
}

impl From<RequestInventoryAsset> for MessageInstance {
    fn from(msg: RequestInventoryAsset) -> Self {
        MessageInstance::RequestInventoryAsset(msg)
    }
}

impl From<InventoryAssetResponse> for MessageInstance {
    fn from(msg: InventoryAssetResponse) -> Self {
        MessageInstance::InventoryAssetResponse(msg)
    }
}

impl From<RemoveInventoryObjects> for MessageInstance {
    fn from(msg: RemoveInventoryObjects) -> Self {
        MessageInstance::RemoveInventoryObjects(msg)
    }
}

impl From<PurgeInventoryDescendents> for MessageInstance {
    fn from(msg: PurgeInventoryDescendents) -> Self {
        MessageInstance::PurgeInventoryDescendents(msg)
    }
}

impl From<UpdateTaskInventory> for MessageInstance {
    fn from(msg: UpdateTaskInventory) -> Self {
        MessageInstance::UpdateTaskInventory(msg)
    }
}

impl From<RemoveTaskInventory> for MessageInstance {
    fn from(msg: RemoveTaskInventory) -> Self {
        MessageInstance::RemoveTaskInventory(msg)
    }
}

impl From<MoveTaskInventory> for MessageInstance {
    fn from(msg: MoveTaskInventory) -> Self {
        MessageInstance::MoveTaskInventory(msg)
    }
}

impl From<RequestTaskInventory> for MessageInstance {
    fn from(msg: RequestTaskInventory) -> Self {
        MessageInstance::RequestTaskInventory(msg)
    }
}

impl From<ReplyTaskInventory> for MessageInstance {
    fn from(msg: ReplyTaskInventory) -> Self {
        MessageInstance::ReplyTaskInventory(msg)
    }
}

impl From<DeRezObject> for MessageInstance {
    fn from(msg: DeRezObject) -> Self {
        MessageInstance::DeRezObject(msg)
    }
}

impl From<DeRezAck> for MessageInstance {
    fn from(msg: DeRezAck) -> Self {
        MessageInstance::DeRezAck(msg)
    }
}

impl From<RezObject> for MessageInstance {
    fn from(msg: RezObject) -> Self {
        MessageInstance::RezObject(msg)
    }
}

impl From<RezObjectFromNotecard> for MessageInstance {
    fn from(msg: RezObjectFromNotecard) -> Self {
        MessageInstance::RezObjectFromNotecard(msg)
    }
}

impl From<TransferInventory> for MessageInstance {
    fn from(msg: TransferInventory) -> Self {
        MessageInstance::TransferInventory(msg)
    }
}

impl From<TransferInventoryAck> for MessageInstance {
    fn from(msg: TransferInventoryAck) -> Self {
        MessageInstance::TransferInventoryAck(msg)
    }
}

impl From<AcceptFriendship> for MessageInstance {
    fn from(msg: AcceptFriendship) -> Self {
        MessageInstance::AcceptFriendship(msg)
    }
}

impl From<DeclineFriendship> for MessageInstance {
    fn from(msg: DeclineFriendship) -> Self {
        MessageInstance::DeclineFriendship(msg)
    }
}

impl From<FormFriendship> for MessageInstance {
    fn from(msg: FormFriendship) -> Self {
        MessageInstance::FormFriendship(msg)
    }
}

impl From<TerminateFriendship> for MessageInstance {
    fn from(msg: TerminateFriendship) -> Self {
        MessageInstance::TerminateFriendship(msg)
    }
}

impl From<OfferCallingCard> for MessageInstance {
    fn from(msg: OfferCallingCard) -> Self {
        MessageInstance::OfferCallingCard(msg)
    }
}

impl From<AcceptCallingCard> for MessageInstance {
    fn from(msg: AcceptCallingCard) -> Self {
        MessageInstance::AcceptCallingCard(msg)
    }
}

impl From<DeclineCallingCard> for MessageInstance {
    fn from(msg: DeclineCallingCard) -> Self {
        MessageInstance::DeclineCallingCard(msg)
    }
}

impl From<RezScript> for MessageInstance {
    fn from(msg: RezScript) -> Self {
        MessageInstance::RezScript(msg)
    }
}

impl From<CreateInventoryItem> for MessageInstance {
    fn from(msg: CreateInventoryItem) -> Self {
        MessageInstance::CreateInventoryItem(msg)
    }
}

impl From<CreateLandmarkForEvent> for MessageInstance {
    fn from(msg: CreateLandmarkForEvent) -> Self {
        MessageInstance::CreateLandmarkForEvent(msg)
    }
}

impl From<EventLocationRequest> for MessageInstance {
    fn from(msg: EventLocationRequest) -> Self {
        MessageInstance::EventLocationRequest(msg)
    }
}

impl From<EventLocationReply> for MessageInstance {
    fn from(msg: EventLocationReply) -> Self {
        MessageInstance::EventLocationReply(msg)
    }
}

impl From<RegionHandleRequest> for MessageInstance {
    fn from(msg: RegionHandleRequest) -> Self {
        MessageInstance::RegionHandleRequest(msg)
    }
}

impl From<RegionIDAndHandleReply> for MessageInstance {
    fn from(msg: RegionIDAndHandleReply) -> Self {
        MessageInstance::RegionIDAndHandleReply(msg)
    }
}

impl From<MoneyTransferRequest> for MessageInstance {
    fn from(msg: MoneyTransferRequest) -> Self {
        MessageInstance::MoneyTransferRequest(msg)
    }
}

impl From<MoneyTransferBackend> for MessageInstance {
    fn from(msg: MoneyTransferBackend) -> Self {
        MessageInstance::MoneyTransferBackend(msg)
    }
}

impl From<MoneyBalanceRequest> for MessageInstance {
    fn from(msg: MoneyBalanceRequest) -> Self {
        MessageInstance::MoneyBalanceRequest(msg)
    }
}

impl From<MoneyBalanceReply> for MessageInstance {
    fn from(msg: MoneyBalanceReply) -> Self {
        MessageInstance::MoneyBalanceReply(msg)
    }
}

impl From<RoutedMoneyBalanceReply> for MessageInstance {
    fn from(msg: RoutedMoneyBalanceReply) -> Self {
        MessageInstance::RoutedMoneyBalanceReply(msg)
    }
}

impl From<ActivateGestures> for MessageInstance {
    fn from(msg: ActivateGestures) -> Self {
        MessageInstance::ActivateGestures(msg)
    }
}

impl From<DeactivateGestures> for MessageInstance {
    fn from(msg: DeactivateGestures) -> Self {
        MessageInstance::DeactivateGestures(msg)
    }
}

impl From<MuteListUpdate> for MessageInstance {
    fn from(msg: MuteListUpdate) -> Self {
        MessageInstance::MuteListUpdate(msg)
    }
}

impl From<UseCachedMuteList> for MessageInstance {
    fn from(msg: UseCachedMuteList) -> Self {
        MessageInstance::UseCachedMuteList(msg)
    }
}

impl From<GrantUserRights> for MessageInstance {
    fn from(msg: GrantUserRights) -> Self {
        MessageInstance::GrantUserRights(msg)
    }
}

impl From<ChangeUserRights> for MessageInstance {
    fn from(msg: ChangeUserRights) -> Self {
        MessageInstance::ChangeUserRights(msg)
    }
}

impl From<OnlineNotification> for MessageInstance {
    fn from(msg: OnlineNotification) -> Self {
        MessageInstance::OnlineNotification(msg)
    }
}

impl From<OfflineNotification> for MessageInstance {
    fn from(msg: OfflineNotification) -> Self {
        MessageInstance::OfflineNotification(msg)
    }
}

impl From<SetStartLocationRequest> for MessageInstance {
    fn from(msg: SetStartLocationRequest) -> Self {
        MessageInstance::SetStartLocationRequest(msg)
    }
}

impl From<SetStartLocation> for MessageInstance {
    fn from(msg: SetStartLocation) -> Self {
        MessageInstance::SetStartLocation(msg)
    }
}

impl From<NetTest> for MessageInstance {
    fn from(msg: NetTest) -> Self {
        MessageInstance::NetTest(msg)
    }
}

impl From<SetCPURatio> for MessageInstance {
    fn from(msg: SetCPURatio) -> Self {
        MessageInstance::SetCPURatio(msg)
    }
}

impl From<SimCrashed> for MessageInstance {
    fn from(msg: SimCrashed) -> Self {
        MessageInstance::SimCrashed(msg)
    }
}

impl From<NameValuePair> for MessageInstance {
    fn from(msg: NameValuePair) -> Self {
        MessageInstance::NameValuePair(msg)
    }
}

impl From<RemoveNameValuePair> for MessageInstance {
    fn from(msg: RemoveNameValuePair) -> Self {
        MessageInstance::RemoveNameValuePair(msg)
    }
}

impl From<UpdateAttachment> for MessageInstance {
    fn from(msg: UpdateAttachment) -> Self {
        MessageInstance::UpdateAttachment(msg)
    }
}

impl From<RemoveAttachment> for MessageInstance {
    fn from(msg: RemoveAttachment) -> Self {
        MessageInstance::RemoveAttachment(msg)
    }
}

impl From<SoundTrigger> for MessageInstance {
    fn from(msg: SoundTrigger) -> Self {
        MessageInstance::SoundTrigger(msg)
    }
}

impl From<AttachedSound> for MessageInstance {
    fn from(msg: AttachedSound) -> Self {
        MessageInstance::AttachedSound(msg)
    }
}

impl From<AttachedSoundGainChange> for MessageInstance {
    fn from(msg: AttachedSoundGainChange) -> Self {
        MessageInstance::AttachedSoundGainChange(msg)
    }
}

impl From<PreloadSound> for MessageInstance {
    fn from(msg: PreloadSound) -> Self {
        MessageInstance::PreloadSound(msg)
    }
}

impl From<AssetUploadRequest> for MessageInstance {
    fn from(msg: AssetUploadRequest) -> Self {
        MessageInstance::AssetUploadRequest(msg)
    }
}

impl From<AssetUploadComplete> for MessageInstance {
    fn from(msg: AssetUploadComplete) -> Self {
        MessageInstance::AssetUploadComplete(msg)
    }
}

impl From<EmailMessageRequest> for MessageInstance {
    fn from(msg: EmailMessageRequest) -> Self {
        MessageInstance::EmailMessageRequest(msg)
    }
}

impl From<EmailMessageReply> for MessageInstance {
    fn from(msg: EmailMessageReply) -> Self {
        MessageInstance::EmailMessageReply(msg)
    }
}

impl From<InternalScriptMail> for MessageInstance {
    fn from(msg: InternalScriptMail) -> Self {
        MessageInstance::InternalScriptMail(msg)
    }
}

impl From<ScriptDataRequest> for MessageInstance {
    fn from(msg: ScriptDataRequest) -> Self {
        MessageInstance::ScriptDataRequest(msg)
    }
}

impl From<ScriptDataReply> for MessageInstance {
    fn from(msg: ScriptDataReply) -> Self {
        MessageInstance::ScriptDataReply(msg)
    }
}

impl From<CreateGroupRequest> for MessageInstance {
    fn from(msg: CreateGroupRequest) -> Self {
        MessageInstance::CreateGroupRequest(msg)
    }
}

impl From<CreateGroupReply> for MessageInstance {
    fn from(msg: CreateGroupReply) -> Self {
        MessageInstance::CreateGroupReply(msg)
    }
}

impl From<UpdateGroupInfo> for MessageInstance {
    fn from(msg: UpdateGroupInfo) -> Self {
        MessageInstance::UpdateGroupInfo(msg)
    }
}

impl From<GroupRoleChanges> for MessageInstance {
    fn from(msg: GroupRoleChanges) -> Self {
        MessageInstance::GroupRoleChanges(msg)
    }
}

impl From<JoinGroupRequest> for MessageInstance {
    fn from(msg: JoinGroupRequest) -> Self {
        MessageInstance::JoinGroupRequest(msg)
    }
}

impl From<JoinGroupReply> for MessageInstance {
    fn from(msg: JoinGroupReply) -> Self {
        MessageInstance::JoinGroupReply(msg)
    }
}

impl From<EjectGroupMemberRequest> for MessageInstance {
    fn from(msg: EjectGroupMemberRequest) -> Self {
        MessageInstance::EjectGroupMemberRequest(msg)
    }
}

impl From<EjectGroupMemberReply> for MessageInstance {
    fn from(msg: EjectGroupMemberReply) -> Self {
        MessageInstance::EjectGroupMemberReply(msg)
    }
}

impl From<LeaveGroupRequest> for MessageInstance {
    fn from(msg: LeaveGroupRequest) -> Self {
        MessageInstance::LeaveGroupRequest(msg)
    }
}

impl From<LeaveGroupReply> for MessageInstance {
    fn from(msg: LeaveGroupReply) -> Self {
        MessageInstance::LeaveGroupReply(msg)
    }
}

impl From<InviteGroupRequest> for MessageInstance {
    fn from(msg: InviteGroupRequest) -> Self {
        MessageInstance::InviteGroupRequest(msg)
    }
}

impl From<InviteGroupResponse> for MessageInstance {
    fn from(msg: InviteGroupResponse) -> Self {
        MessageInstance::InviteGroupResponse(msg)
    }
}

impl From<GroupProfileRequest> for MessageInstance {
    fn from(msg: GroupProfileRequest) -> Self {
        MessageInstance::GroupProfileRequest(msg)
    }
}

impl From<GroupProfileReply> for MessageInstance {
    fn from(msg: GroupProfileReply) -> Self {
        MessageInstance::GroupProfileReply(msg)
    }
}

impl From<GroupAccountSummaryRequest> for MessageInstance {
    fn from(msg: GroupAccountSummaryRequest) -> Self {
        MessageInstance::GroupAccountSummaryRequest(msg)
    }
}

impl From<GroupAccountSummaryReply> for MessageInstance {
    fn from(msg: GroupAccountSummaryReply) -> Self {
        MessageInstance::GroupAccountSummaryReply(msg)
    }
}

impl From<GroupAccountDetailsRequest> for MessageInstance {
    fn from(msg: GroupAccountDetailsRequest) -> Self {
        MessageInstance::GroupAccountDetailsRequest(msg)
    }
}

impl From<GroupAccountDetailsReply> for MessageInstance {
    fn from(msg: GroupAccountDetailsReply) -> Self {
        MessageInstance::GroupAccountDetailsReply(msg)
    }
}

impl From<GroupAccountTransactionsRequest> for MessageInstance {
    fn from(msg: GroupAccountTransactionsRequest) -> Self {
        MessageInstance::GroupAccountTransactionsRequest(msg)
    }
}

impl From<GroupAccountTransactionsReply> for MessageInstance {
    fn from(msg: GroupAccountTransactionsReply) -> Self {
        MessageInstance::GroupAccountTransactionsReply(msg)
    }
}

impl From<GroupActiveProposalsRequest> for MessageInstance {
    fn from(msg: GroupActiveProposalsRequest) -> Self {
        MessageInstance::GroupActiveProposalsRequest(msg)
    }
}

impl From<GroupActiveProposalItemReply> for MessageInstance {
    fn from(msg: GroupActiveProposalItemReply) -> Self {
        MessageInstance::GroupActiveProposalItemReply(msg)
    }
}

impl From<GroupVoteHistoryRequest> for MessageInstance {
    fn from(msg: GroupVoteHistoryRequest) -> Self {
        MessageInstance::GroupVoteHistoryRequest(msg)
    }
}

impl From<GroupVoteHistoryItemReply> for MessageInstance {
    fn from(msg: GroupVoteHistoryItemReply) -> Self {
        MessageInstance::GroupVoteHistoryItemReply(msg)
    }
}

impl From<StartGroupProposal> for MessageInstance {
    fn from(msg: StartGroupProposal) -> Self {
        MessageInstance::StartGroupProposal(msg)
    }
}

impl From<GroupProposalBallot> for MessageInstance {
    fn from(msg: GroupProposalBallot) -> Self {
        MessageInstance::GroupProposalBallot(msg)
    }
}

impl From<TallyVotes> for MessageInstance {
    fn from(msg: TallyVotes) -> Self {
        MessageInstance::TallyVotes(msg)
    }
}

impl From<GroupMembersRequest> for MessageInstance {
    fn from(msg: GroupMembersRequest) -> Self {
        MessageInstance::GroupMembersRequest(msg)
    }
}

impl From<GroupMembersReply> for MessageInstance {
    fn from(msg: GroupMembersReply) -> Self {
        MessageInstance::GroupMembersReply(msg)
    }
}

impl From<ActivateGroup> for MessageInstance {
    fn from(msg: ActivateGroup) -> Self {
        MessageInstance::ActivateGroup(msg)
    }
}

impl From<SetGroupContribution> for MessageInstance {
    fn from(msg: SetGroupContribution) -> Self {
        MessageInstance::SetGroupContribution(msg)
    }
}

impl From<SetGroupAcceptNotices> for MessageInstance {
    fn from(msg: SetGroupAcceptNotices) -> Self {
        MessageInstance::SetGroupAcceptNotices(msg)
    }
}

impl From<GroupRoleDataRequest> for MessageInstance {
    fn from(msg: GroupRoleDataRequest) -> Self {
        MessageInstance::GroupRoleDataRequest(msg)
    }
}

impl From<GroupRoleDataReply> for MessageInstance {
    fn from(msg: GroupRoleDataReply) -> Self {
        MessageInstance::GroupRoleDataReply(msg)
    }
}

impl From<GroupRoleMembersRequest> for MessageInstance {
    fn from(msg: GroupRoleMembersRequest) -> Self {
        MessageInstance::GroupRoleMembersRequest(msg)
    }
}

impl From<GroupRoleMembersReply> for MessageInstance {
    fn from(msg: GroupRoleMembersReply) -> Self {
        MessageInstance::GroupRoleMembersReply(msg)
    }
}

impl From<GroupTitlesRequest> for MessageInstance {
    fn from(msg: GroupTitlesRequest) -> Self {
        MessageInstance::GroupTitlesRequest(msg)
    }
}

impl From<GroupTitlesReply> for MessageInstance {
    fn from(msg: GroupTitlesReply) -> Self {
        MessageInstance::GroupTitlesReply(msg)
    }
}

impl From<GroupTitleUpdate> for MessageInstance {
    fn from(msg: GroupTitleUpdate) -> Self {
        MessageInstance::GroupTitleUpdate(msg)
    }
}

impl From<GroupRoleUpdate> for MessageInstance {
    fn from(msg: GroupRoleUpdate) -> Self {
        MessageInstance::GroupRoleUpdate(msg)
    }
}

impl From<LiveHelpGroupRequest> for MessageInstance {
    fn from(msg: LiveHelpGroupRequest) -> Self {
        MessageInstance::LiveHelpGroupRequest(msg)
    }
}

impl From<LiveHelpGroupReply> for MessageInstance {
    fn from(msg: LiveHelpGroupReply) -> Self {
        MessageInstance::LiveHelpGroupReply(msg)
    }
}

impl From<AgentWearablesRequest> for MessageInstance {
    fn from(msg: AgentWearablesRequest) -> Self {
        MessageInstance::AgentWearablesRequest(msg)
    }
}

impl From<AgentWearablesUpdate> for MessageInstance {
    fn from(msg: AgentWearablesUpdate) -> Self {
        MessageInstance::AgentWearablesUpdate(msg)
    }
}

impl From<AgentIsNowWearing> for MessageInstance {
    fn from(msg: AgentIsNowWearing) -> Self {
        MessageInstance::AgentIsNowWearing(msg)
    }
}

impl From<AgentCachedTexture> for MessageInstance {
    fn from(msg: AgentCachedTexture) -> Self {
        MessageInstance::AgentCachedTexture(msg)
    }
}

impl From<AgentCachedTextureResponse> for MessageInstance {
    fn from(msg: AgentCachedTextureResponse) -> Self {
        MessageInstance::AgentCachedTextureResponse(msg)
    }
}

impl From<AgentDataUpdateRequest> for MessageInstance {
    fn from(msg: AgentDataUpdateRequest) -> Self {
        MessageInstance::AgentDataUpdateRequest(msg)
    }
}

impl From<AgentDataUpdate> for MessageInstance {
    fn from(msg: AgentDataUpdate) -> Self {
        MessageInstance::AgentDataUpdate(msg)
    }
}

impl From<GroupDataUpdate> for MessageInstance {
    fn from(msg: GroupDataUpdate) -> Self {
        MessageInstance::GroupDataUpdate(msg)
    }
}

impl From<AgentGroupDataUpdate> for MessageInstance {
    fn from(msg: AgentGroupDataUpdate) -> Self {
        MessageInstance::AgentGroupDataUpdate(msg)
    }
}

impl From<AgentDropGroup> for MessageInstance {
    fn from(msg: AgentDropGroup) -> Self {
        MessageInstance::AgentDropGroup(msg)
    }
}

impl From<LogTextMessage> for MessageInstance {
    fn from(msg: LogTextMessage) -> Self {
        MessageInstance::LogTextMessage(msg)
    }
}

impl From<ViewerEffect> for MessageInstance {
    fn from(msg: ViewerEffect) -> Self {
        MessageInstance::ViewerEffect(msg)
    }
}

impl From<CreateTrustedCircuit> for MessageInstance {
    fn from(msg: CreateTrustedCircuit) -> Self {
        MessageInstance::CreateTrustedCircuit(msg)
    }
}

impl From<DenyTrustedCircuit> for MessageInstance {
    fn from(msg: DenyTrustedCircuit) -> Self {
        MessageInstance::DenyTrustedCircuit(msg)
    }
}

impl From<RequestTrustedCircuit> for MessageInstance {
    fn from(msg: RequestTrustedCircuit) -> Self {
        MessageInstance::RequestTrustedCircuit(msg)
    }
}

impl From<RezSingleAttachmentFromInv> for MessageInstance {
    fn from(msg: RezSingleAttachmentFromInv) -> Self {
        MessageInstance::RezSingleAttachmentFromInv(msg)
    }
}

impl From<RezMultipleAttachmentsFromInv> for MessageInstance {
    fn from(msg: RezMultipleAttachmentsFromInv) -> Self {
        MessageInstance::RezMultipleAttachmentsFromInv(msg)
    }
}

impl From<DetachAttachmentIntoInv> for MessageInstance {
    fn from(msg: DetachAttachmentIntoInv) -> Self {
        MessageInstance::DetachAttachmentIntoInv(msg)
    }
}

impl From<CreateNewOutfitAttachments> for MessageInstance {
    fn from(msg: CreateNewOutfitAttachments) -> Self {
        MessageInstance::CreateNewOutfitAttachments(msg)
    }
}

impl From<UserInfoRequest> for MessageInstance {
    fn from(msg: UserInfoRequest) -> Self {
        MessageInstance::UserInfoRequest(msg)
    }
}

impl From<UserInfoReply> for MessageInstance {
    fn from(msg: UserInfoReply) -> Self {
        MessageInstance::UserInfoReply(msg)
    }
}

impl From<UpdateUserInfo> for MessageInstance {
    fn from(msg: UpdateUserInfo) -> Self {
        MessageInstance::UpdateUserInfo(msg)
    }
}

impl From<ParcelRename> for MessageInstance {
    fn from(msg: ParcelRename) -> Self {
        MessageInstance::ParcelRename(msg)
    }
}

impl From<InitiateDownload> for MessageInstance {
    fn from(msg: InitiateDownload) -> Self {
        MessageInstance::InitiateDownload(msg)
    }
}

impl From<SystemMessage> for MessageInstance {
    fn from(msg: SystemMessage) -> Self {
        MessageInstance::SystemMessage(msg)
    }
}

impl From<MapLayerRequest> for MessageInstance {
    fn from(msg: MapLayerRequest) -> Self {
        MessageInstance::MapLayerRequest(msg)
    }
}

impl From<MapLayerReply> for MessageInstance {
    fn from(msg: MapLayerReply) -> Self {
        MessageInstance::MapLayerReply(msg)
    }
}

impl From<MapBlockRequest> for MessageInstance {
    fn from(msg: MapBlockRequest) -> Self {
        MessageInstance::MapBlockRequest(msg)
    }
}

impl From<MapNameRequest> for MessageInstance {
    fn from(msg: MapNameRequest) -> Self {
        MessageInstance::MapNameRequest(msg)
    }
}

impl From<MapBlockReply> for MessageInstance {
    fn from(msg: MapBlockReply) -> Self {
        MessageInstance::MapBlockReply(msg)
    }
}

impl From<MapItemRequest> for MessageInstance {
    fn from(msg: MapItemRequest) -> Self {
        MessageInstance::MapItemRequest(msg)
    }
}

impl From<MapItemReply> for MessageInstance {
    fn from(msg: MapItemReply) -> Self {
        MessageInstance::MapItemReply(msg)
    }
}

impl From<SendPostcard> for MessageInstance {
    fn from(msg: SendPostcard) -> Self {
        MessageInstance::SendPostcard(msg)
    }
}

impl From<RpcChannelRequest> for MessageInstance {
    fn from(msg: RpcChannelRequest) -> Self {
        MessageInstance::RpcChannelRequest(msg)
    }
}

impl From<RpcChannelReply> for MessageInstance {
    fn from(msg: RpcChannelReply) -> Self {
        MessageInstance::RpcChannelReply(msg)
    }
}

impl From<RpcScriptRequestInbound> for MessageInstance {
    fn from(msg: RpcScriptRequestInbound) -> Self {
        MessageInstance::RpcScriptRequestInbound(msg)
    }
}

impl From<RpcScriptRequestInboundForward> for MessageInstance {
    fn from(msg: RpcScriptRequestInboundForward) -> Self {
        MessageInstance::RpcScriptRequestInboundForward(msg)
    }
}

impl From<RpcScriptReplyInbound> for MessageInstance {
    fn from(msg: RpcScriptReplyInbound) -> Self {
        MessageInstance::RpcScriptReplyInbound(msg)
    }
}

impl From<ScriptMailRegistration> for MessageInstance {
    fn from(msg: ScriptMailRegistration) -> Self {
        MessageInstance::ScriptMailRegistration(msg)
    }
}

impl From<ParcelMediaCommandMessage> for MessageInstance {
    fn from(msg: ParcelMediaCommandMessage) -> Self {
        MessageInstance::ParcelMediaCommandMessage(msg)
    }
}

impl From<ParcelMediaUpdate> for MessageInstance {
    fn from(msg: ParcelMediaUpdate) -> Self {
        MessageInstance::ParcelMediaUpdate(msg)
    }
}

impl From<LandStatRequest> for MessageInstance {
    fn from(msg: LandStatRequest) -> Self {
        MessageInstance::LandStatRequest(msg)
    }
}

impl From<LandStatReply> for MessageInstance {
    fn from(msg: LandStatReply) -> Self {
        MessageInstance::LandStatReply(msg)
    }
}

impl From<Error> for MessageInstance {
    fn from(msg: Error) -> Self {
        MessageInstance::Error(msg)
    }
}

impl From<ObjectIncludeInSearch> for MessageInstance {
    fn from(msg: ObjectIncludeInSearch) -> Self {
        MessageInstance::ObjectIncludeInSearch(msg)
    }
}

impl From<RezRestoreToWorld> for MessageInstance {
    fn from(msg: RezRestoreToWorld) -> Self {
        MessageInstance::RezRestoreToWorld(msg)
    }
}

impl From<LinkInventoryItem> for MessageInstance {
    fn from(msg: LinkInventoryItem) -> Self {
        MessageInstance::LinkInventoryItem(msg)
    }
}



// Block IMPLEMENTATIONS



impl TestMessage_TestBlock1 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TestMessage_TestBlock1 {
            test1: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TestMessage_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TestMessage_NeighborBlock {
            test0: buffer.read_u32::<LittleEndian>()?,
            test1: buffer.read_u32::<LittleEndian>()?,
            test2: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl PacketAck_Packets {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PacketAck_Packets { id: buffer.read_u32::<LittleEndian>()? })
    }
}

impl OpenCircuit_CircuitInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(OpenCircuit_CircuitInfo {
            ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl StartPingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartPingCheck_PingID {
            ping_id: buffer.read_u8()?,
            oldest_unacked: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CompletePingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CompletePingCheck_PingID { ping_id: buffer.read_u8()? })
    }
}

impl AddCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AddCircuitCode_CircuitCode {
            code: buffer.read_u32::<LittleEndian>()?,
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UseCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UseCircuitCode_CircuitCode {
            code: buffer.read_u32::<LittleEndian>()?,
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl NeighborList_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NeighborList_NeighborBlock {
            ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
            public_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            public_port: buffer.read_u16::<LittleEndian>()?,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
        })
    }
}

impl AvatarTextureUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarTextureUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            textures_changed: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarTextureUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarTextureUpdate_WearableData {
            cache_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarTextureUpdate_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarTextureUpdate_TextureData {
            texture_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimulatorMapUpdate_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorMapUpdate_MapData {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorSetMap_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorSetMap_MapData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            type_: buffer.read_i32::<LittleEndian>()?,
            map_image: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimulatorReady_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorReady_SimulatorBlock {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorReady_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorReady_TelehubBlock {
            has_telehub: buffer.read_u8()? == 1,
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TelehubInfo_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TelehubInfo_TelehubBlock {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            telehub_rot: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl TelehubInfo_SpawnPointBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TelehubInfo_SpawnPointBlock {
            spawn_point_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorPresentAtLocation_SimulatorPublicHostBlock {
            port: buffer.read_u16::<LittleEndian>()?,
            simulator_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorPresentAtLocation_NeighborBlock {
            ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorPresentAtLocation_SimulatorBlock {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimulatorPresentAtLocation_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorPresentAtLocation_TelehubBlock {
            has_telehub: buffer.read_u8()? == 1,
            telehub_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimulatorLoad_SimulatorLoad {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorLoad_SimulatorLoad {
            time_dilation: buffer.read_f32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            can_accept_agents: buffer.read_u8()? == 1,
        })
    }
}

impl SimulatorLoad_AgentList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorLoad_AgentList {
            circuit_code: buffer.read_u32::<LittleEndian>()?,
            x: buffer.read_u8()?,
            y: buffer.read_u8()?,
        })
    }
}

impl RegionPresenceRequestByRegionID_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionPresenceRequestByRegionID_RegionData {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionPresenceRequestByHandle_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionPresenceRequestByHandle_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl RegionPresenceResponse_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionPresenceResponse_RegionData {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            internal_region_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            external_region_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            region_port: buffer.read_u16::<LittleEndian>()?,
            valid_until: buffer.read_f64::<LittleEndian>()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateSimulator_SimulatorInfo {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
        })
    }
}

impl LogDwellTime_DwellInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogDwellTime_DwellInfo {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            duration: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
            avg_agents_in_view: buffer.read_u8()?,
            avg_viewer_fps: buffer.read_u8()?,
        })
    }
}

impl FeatureDisabled_FailureInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FeatureDisabled_FailureInfo {
            error_message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogFailedMoneyTransaction_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogFailedMoneyTransaction_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            simulator_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            failure_type: buffer.read_u8()?,
        })
    }
}

impl UserReportInternal_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserReportInternal_ReportData {
            report_type: buffer.read_u8()?,
            category: buffer.read_u8()?,
            reporter_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            viewer_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            screenshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            last_owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuser_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuse_region_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            abuse_region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            summary: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            details: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            version_string: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SetSimStatusInDatabase_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetSimStatusInDatabase_Data {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            x: buffer.read_i32::<LittleEndian>()?,
            y: buffer.read_i32::<LittleEndian>()?,
            pid: buffer.read_i32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            time_to_live: buffer.read_i32::<LittleEndian>()?,
            status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SetSimPresenceInDatabase_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetSimPresenceInDatabase_SimData {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            pid: buffer.read_i32::<LittleEndian>()?,
            agent_count: buffer.read_i32::<LittleEndian>()?,
            time_to_live: buffer.read_i32::<LittleEndian>()?,
            status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EconomyData_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EconomyData_Info {
            object_capacity: buffer.read_i32::<LittleEndian>()?,
            object_count: buffer.read_i32::<LittleEndian>()?,
            price_energy_unit: buffer.read_i32::<LittleEndian>()?,
            price_object_claim: buffer.read_i32::<LittleEndian>()?,
            price_public_object_decay: buffer.read_i32::<LittleEndian>()?,
            price_public_object_delete: buffer.read_i32::<LittleEndian>()?,
            price_parcel_claim: buffer.read_i32::<LittleEndian>()?,
            price_parcel_claim_factor: buffer.read_f32::<LittleEndian>()?,
            price_upload: buffer.read_i32::<LittleEndian>()?,
            price_rent_light: buffer.read_i32::<LittleEndian>()?,
            teleport_min_price: buffer.read_i32::<LittleEndian>()?,
            teleport_price_exponent: buffer.read_f32::<LittleEndian>()?,
            energy_efficiency: buffer.read_f32::<LittleEndian>()?,
            price_object_rent: buffer.read_f32::<LittleEndian>()?,
            price_object_scale_factor: buffer.read_f32::<LittleEndian>()?,
            price_parcel_rent: buffer.read_i32::<LittleEndian>()?,
            price_group_create: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AvatarPickerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPickerRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerRequest_Data {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPickerRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_level: buffer.read_u8()?,
        })
    }
}

impl AvatarPickerRequestBackend_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerRequestBackend_Data {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPickerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPickerReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPickerReply_Data {
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl PlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesQuery_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesQuery_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesQuery_QueryData {
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl PlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PlacesReply_QueryData {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            global_x: buffer.read_f32::<LittleEndian>()?,
            global_y: buffer.read_f32::<LittleEndian>()?,
            global_z: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirFindQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirFindQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirFindQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirFindQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirFindQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirFindQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirFindQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirFindQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirPlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_i8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPlacesReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            for_sale: buffer.read_u8()? == 1,
            auction: buffer.read_u8()? == 1,
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl DirPlacesReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPlacesReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirPeopleReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPeopleReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPeopleReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPeopleReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPeopleReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPeopleReply_QueryReplies {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            online: buffer.read_u8()? == 1,
            reputation: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirEventsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirEventsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirEventsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirEventsReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirEventsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirEventsReply_QueryReplies {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            event_id: buffer.read_u32::<LittleEndian>()?,
            date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            unix_time: buffer.read_u32::<LittleEndian>()?,
            event_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirEventsReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirEventsReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirGroupsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirGroupsReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirGroupsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirGroupsReply_QueryReplies {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            members: buffer.read_i32::<LittleEndian>()?,
            search_order: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirClassifiedReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedReply_QueryReplies {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            classified_flags: buffer.read_u8()?,
            creation_date: buffer.read_u32::<LittleEndian>()?,
            expiration_date: buffer.read_u32::<LittleEndian>()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirClassifiedReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirClassifiedReply_StatusData {
            status: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AvatarClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarClassifiedReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarClassifiedReply_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ClassifiedInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoRequest_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoReply_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creation_date: buffer.read_u32::<LittleEndian>()?,
            expiration_date: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate: buffer.read_u32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            parcel_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            classified_flags: buffer.read_u8()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ClassifiedInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedInfoUpdate_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            category: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate: buffer.read_u32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            classified_flags: buffer.read_u8()?,
            price_for_listing: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ClassifiedDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedDelete_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ClassifiedGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClassifiedGodDelete_Data {
            classified_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            search_type: buffer.read_u32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirLandQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            search_type: buffer.read_u32::<LittleEndian>()?,
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirLandReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirLandReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirLandReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            auction: buffer.read_u8()? == 1,
            for_sale: buffer.read_u8()? == 1,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl DirPopularQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DirPopularQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl DirPopularReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DirPopularReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DirPopularReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelInfoRequest_Data {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelInfoReply_Data {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            global_x: buffer.read_f32::<LittleEndian>()?,
            global_y: buffer.read_f32::<LittleEndian>()?,
            global_z: buffer.read_f32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            auction_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelObjectOwnersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelObjectOwnersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelObjectOwnersRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelObjectOwnersRequest_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelObjectOwnersReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelObjectOwnersReply_Data {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            count: buffer.read_i32::<LittleEndian>()?,
            online_status: buffer.read_u8()? == 1,
        })
    }
}

impl GroupNoticesListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticesListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticesListRequest_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticesListReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticesListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticesListReply_Data {
            notice_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            timestamp: buffer.read_u32::<LittleEndian>()?,
            from_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            has_attachment: buffer.read_u8()? == 1,
            asset_type: buffer.read_u8()?,
        })
    }
}

impl GroupNoticeRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticeRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticeRequest_Data {
            group_notice_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticeAdd_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupNoticeAdd_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupNoticeAdd_MessageBlock {
            to_group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dialog: buffer.read_u8()?,
            from_agent_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            binary_bucket: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TeleportRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportRequest_Info {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLocationRequest_Info {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportLocal_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLocal_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportLandmarkRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLandmarkRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            landmark_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportProgress_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportProgress_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportProgress_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportProgress_Info {
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl DataHomeLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DataHomeLocationRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            kicked_from_estate_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DataHomeLocationRequest_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DataHomeLocationRequest_AgentInfo {
            agent_effective_maturity: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DataHomeLocationReply_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DataHomeLocationReply_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl TeleportFinish_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportFinish_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            sim_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            sim_port: buffer.read_u16::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            seed_capability: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_access: buffer.read_u8()?,
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl StartLure_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartLure_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartLure_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartLure_Info {
            lure_type: buffer.read_u8()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl StartLure_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartLure_TargetData {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportLureRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLureRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            lure_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportCancel_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportCancel_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TeleportStart_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportStart_Info {
            teleport_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl TeleportFailed_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportFailed_Info {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            reason: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TeleportFailed_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportFailed_AlertInfo {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl Undo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Undo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Undo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Undo_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Redo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Redo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Redo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Redo_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UndoLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UndoLand_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentPause_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentPause_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentResume_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentResume_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            body_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            head_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            state: buffer.read_u8()?,
            camera_center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            far: buffer.read_f32::<LittleEndian>()?,
            control_flags: buffer.read_u32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
        })
    }
}

impl ChatFromViewer_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChatFromViewer_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChatFromViewer_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChatFromViewer_ChatData {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_u8()?,
            channel: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AgentThrottle_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentThrottle_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentThrottle_Throttle {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentThrottle_Throttle {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            throttles: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentFOV_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentFOV_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentFOV_FOVBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentFOV_FOVBlock {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            vertical_angle: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl AgentHeightWidth_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentHeightWidth_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentHeightWidth_HeightWidthBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentHeightWidth_HeightWidthBlock {
            gen_counter: buffer.read_u32::<LittleEndian>()?,
            height: buffer.read_u16::<LittleEndian>()?,
            width: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl AgentSetAppearance_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentSetAppearance_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl AgentSetAppearance_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentSetAppearance_WearableData {
            cache_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
        })
    }
}

impl AgentSetAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentSetAppearance_ObjectData {
            texture_entry: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentSetAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentSetAppearance_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl AgentAnimation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentAnimation_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentAnimation_AnimationList {
            anim_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            start_anim: buffer.read_u8()? == 1,
        })
    }
}

impl AgentAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentRequestSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentRequestSit_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentRequestSit_TargetObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentRequestSit_TargetObject {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl AgentSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentSit_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentQuitCopy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentQuitCopy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentQuitCopy_FuseBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentQuitCopy_FuseBlock {
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestImage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestImage_RequestImage {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestImage_RequestImage {
            image: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            discard_level: buffer.read_i8()?,
            download_priority: buffer.read_f32::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
        })
    }
}

impl ImageNotInDatabase_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImageNotInDatabase_ImageID {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RebakeAvatarTextures_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RebakeAvatarTextures_TextureData {
            texture_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetAlwaysRun_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetAlwaysRun_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            always_run: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectAdd_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectAdd_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectAdd_ObjectData {
            p_code: buffer.read_u8()?,
            material: buffer.read_u8()?,
            add_flags: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            state: buffer.read_u8()?,
        })
    }
}

impl ObjectDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            force: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectDelete_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDelete_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDuplicate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDuplicate_SharedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDuplicate_SharedData {
            offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            duplicate_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDuplicate_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicateOnRay_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDuplicateOnRay_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            bypass_raycast: buffer.read_u8()? == 1,
            ray_end_is_intersection: buffer.read_u8()? == 1,
            copy_centers: buffer.read_u8()? == 1,
            copy_rotates: buffer.read_u8()? == 1,
            ray_target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            duplicate_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDuplicateOnRay_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDuplicateOnRay_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MultipleObjectUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MultipleObjectUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MultipleObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MultipleObjectUpdate_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RequestMultipleObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestMultipleObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestMultipleObjects_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestMultipleObjects_ObjectData {
            cache_miss_type: buffer.read_u8()?,
            id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectPosition_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPosition_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectPosition_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPosition_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectScale_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectScale_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectScale_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectScale_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectRotation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectRotation_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectRotation_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectRotation_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectFlagUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectFlagUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            use_physics: buffer.read_u8()? == 1,
            is_temporary: buffer.read_u8()? == 1,
            is_phantom: buffer.read_u8()? == 1,
            casts_shadows: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectClickAction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectClickAction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectClickAction_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectClickAction_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            click_action: buffer.read_u8()?,
        })
    }
}

impl ObjectImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectImage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectImage_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectImage_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_entry: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectMaterial_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectMaterial_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectMaterial_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectMaterial_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            material: buffer.read_u8()?,
        })
    }
}

impl ObjectShape_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectShape_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectShape_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectShape_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectExtraParams_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectExtraParams_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectExtraParams_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectExtraParams_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            param_type: buffer.read_u16::<LittleEndian>()?,
            param_in_use: buffer.read_u8()? == 1,
            param_size: buffer.read_u32::<LittleEndian>()?,
            param_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectOwner_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectOwner_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectOwner_HeaderData {
            override_: buffer.read_u8()? == 1,
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectOwner_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectOwner_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGroup_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGroup_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectBuy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            category_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectBuy_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectBuy_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl BuyObjectInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(BuyObjectInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl BuyObjectInventory_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(BuyObjectInventory_Data {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DerezContainer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DerezContainer_Data {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            delete: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectPermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPermissions_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectPermissions_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPermissions_HeaderData {
            override_: buffer.read_u8()? == 1,
        })
    }
}

impl ObjectPermissions_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPermissions_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            field: buffer.read_u8()?,
            set: buffer.read_u8()?,
            mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectSaleInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSaleInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSaleInfo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSaleInfo_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ObjectName_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectName_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectName_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectName_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectDescription_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDescription_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDescription_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDescription_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectCategory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectCategory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectCategory_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectCategory_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectSelect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSelect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSelect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSelect_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDeselect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDeselect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDeselect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDeselect_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectAttach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectAttach_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_point: buffer.read_u8()?,
        })
    }
}

impl ObjectAttach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectAttach_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectDetach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDetach_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDetach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDetach_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDrop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDrop_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDrop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDrop_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectLink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectLink_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectLink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectLink_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDelink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDelink_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDelink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDelink_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrab_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrab_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            grab_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrab_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectGrabUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrabUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectGrabUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrabUpdate_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grab_offset_initial: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            grab_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            time_since_last: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectGrabUpdate_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectGrabUpdate_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectDeGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDeGrab_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectDeGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDeGrab_ObjectData {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ObjectDeGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectDeGrab_SurfaceInfo {
            uv_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            st_coord: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            face_index: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            normal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            binormal: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectSpinStart_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinStart_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinStart_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinStart_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinUpdate_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
        })
    }
}

impl ObjectSpinStop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinStop_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectSpinStop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectSpinStop_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectExportSelected_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectExportSelected_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            volume_detail: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl ObjectExportSelected_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectExportSelected_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ModifyLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ModifyLand_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ModifyLand_ModifyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ModifyLand_ModifyBlock {
            action: buffer.read_u8()?,
            brush_size: buffer.read_u8()?,
            seconds: buffer.read_f32::<LittleEndian>()?,
            height: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ModifyLand_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ModifyLand_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ModifyLand_ModifyBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ModifyLand_ModifyBlockExtended {
            brush_size: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl VelocityInterpolateOn_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(VelocityInterpolateOn_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl VelocityInterpolateOff_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(VelocityInterpolateOff_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StateSave_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StateSave_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StateSave_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StateSave_DataBlock {
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ReportAutosaveCrash_AutosaveData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ReportAutosaveCrash_AutosaveData {
            pid: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl SimWideDeletes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimWideDeletes_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SimWideDeletes_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimWideDeletes_DataBlock {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestObjectPropertiesFamily_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestObjectPropertiesFamily_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestObjectPropertiesFamily_ObjectData {
            request_flags: buffer.read_u32::<LittleEndian>()?,
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TrackAgent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TrackAgent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TrackAgent_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TrackAgent_TargetData {
            prey_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerStats_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStats_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            start_time: buffer.read_u32::<LittleEndian>()?,
            run_time: buffer.read_f32::<LittleEndian>()?,
            sim_fps: buffer.read_f32::<LittleEndian>()?,
            fps: buffer.read_f32::<LittleEndian>()?,
            agents_in_view: buffer.read_u8()?,
            ping: buffer.read_f32::<LittleEndian>()?,
            meters_traveled: buffer.read_f64::<LittleEndian>()?,
            regions_visited: buffer.read_i32::<LittleEndian>()?,
            sys_ram: buffer.read_u32::<LittleEndian>()?,
            sys_os: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sys_cpu: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sys_gpu: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ViewerStats_DownloadTotals {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStats_DownloadTotals {
            world: buffer.read_u32::<LittleEndian>()?,
            objects: buffer.read_u32::<LittleEndian>()?,
            textures: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_NetStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStats_NetStats {
            bytes: buffer.read_u32::<LittleEndian>()?,
            packets: buffer.read_u32::<LittleEndian>()?,
            compressed: buffer.read_u32::<LittleEndian>()?,
            savings: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_FailStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStats_FailStats {
            send_packet: buffer.read_u32::<LittleEndian>()?,
            dropped: buffer.read_u32::<LittleEndian>()?,
            resent: buffer.read_u32::<LittleEndian>()?,
            failed_resends: buffer.read_u32::<LittleEndian>()?,
            off_circuit: buffer.read_u32::<LittleEndian>()?,
            invalid: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ViewerStats_MiscStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStats_MiscStats {
            type_: buffer.read_u32::<LittleEndian>()?,
            value: buffer.read_f64::<LittleEndian>()?,
        })
    }
}

impl ScriptAnswerYes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptAnswerYes_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptAnswerYes_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptAnswerYes_Data {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            questions: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl UserReport_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserReport_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserReport_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserReport_ReportData {
            report_type: buffer.read_u8()?,
            category: buffer.read_u8()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            check_flags: buffer.read_u8()?,
            screenshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuser_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            abuse_region_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            abuse_region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            summary: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            details: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            version_string: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AlertMessage_AlertData {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AlertMessage_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AlertMessage_AlertInfo {
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentAlertMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentAlertMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentAlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentAlertMessage_AlertData {
            modal: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MeanCollisionAlert_MeanCollision {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MeanCollisionAlert_MeanCollision {
            victim: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            perp: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_u32::<LittleEndian>()?,
            mag: buffer.read_f32::<LittleEndian>()?,
            type_: buffer.read_u8()?,
        })
    }
}

impl ViewerFrozenMessage_FrozenData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerFrozenMessage_FrozenData {
            data: buffer.read_u8()? == 1,
        })
    }
}

impl HealthMessage_HealthData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(HealthMessage_HealthData {
            health: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ChatFromSimulator_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChatFromSimulator_ChatData {
            from_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            source_type: buffer.read_u8()?,
            chat_type: buffer.read_u8()?,
            audible: buffer.read_u8()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SimStats_Region {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimStats_Region {
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            object_capacity: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimStats_Stat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimStats_Stat {
            stat_id: buffer.read_u32::<LittleEndian>()?,
            stat_value: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl SimStats_PidStat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimStats_PidStat { pid: buffer.read_i32::<LittleEndian>()? })
    }
}

impl RequestRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionInfo_RegionInfo {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            max_agents: buffer.read_u8()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            object_bonus_factor: buffer.read_f32::<LittleEndian>()?,
            water_height: buffer.read_f32::<LittleEndian>()?,
            terrain_raise_limit: buffer.read_f32::<LittleEndian>()?,
            terrain_lower_limit: buffer.read_f32::<LittleEndian>()?,
            price_per_meter: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_x: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_y: buffer.read_i32::<LittleEndian>()?,
            use_estate_sun: buffer.read_u8()? == 1,
            sun_hour: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl RegionInfo_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionInfo_RegionInfo2 {
            product_sku: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            max_agents32: buffer.read_u32::<LittleEndian>()?,
            hard_max_agents: buffer.read_u32::<LittleEndian>()?,
            hard_max_objects: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GodUpdateRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodUpdateRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodUpdateRegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodUpdateRegionInfo_RegionInfo {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_id: buffer.read_u32::<LittleEndian>()?,
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            price_per_meter: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_x: buffer.read_i32::<LittleEndian>()?,
            redirect_grid_y: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl NearestLandingRegionRequest_RequestingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NearestLandingRegionRequest_RequestingRegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl NearestLandingRegionReply_LandingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NearestLandingRegionReply_LandingRegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl NearestLandingRegionUpdated_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NearestLandingRegionUpdated_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl TeleportLandingStatusChanged_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TeleportLandingStatusChanged_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl RegionHandshake_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandshake_RegionInfo {
            region_flags: buffer.read_u32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_owner: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_estate_manager: buffer.read_u8()? == 1,
            water_height: buffer.read_f32::<LittleEndian>()?,
            billable_factor: buffer.read_f32::<LittleEndian>()?,
            cache_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base0: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base1: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base2: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_base3: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail0: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail1: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail2: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_detail3: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terrain_start_height00: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height01: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height10: buffer.read_f32::<LittleEndian>()?,
            terrain_start_height11: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range00: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range01: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range10: buffer.read_f32::<LittleEndian>()?,
            terrain_height_range11: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl RegionHandshake_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandshake_RegionInfo2 {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandshake_RegionInfo3 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandshake_RegionInfo3 {
            cpu_class_id: buffer.read_i32::<LittleEndian>()?,
            cpu_ratio: buffer.read_i32::<LittleEndian>()?,
            colo_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_sku: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            product_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RegionHandshakeReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandshakeReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionHandshakeReply_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandshakeReply_RegionInfo {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CoarseLocationUpdate_Location {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CoarseLocationUpdate_Location {
            x: buffer.read_u8()?,
            y: buffer.read_u8()?,
            z: buffer.read_u8()?,
        })
    }
}

impl CoarseLocationUpdate_Index {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CoarseLocationUpdate_Index {
            you: buffer.read_i16::<LittleEndian>()?,
            prey: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl CoarseLocationUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CoarseLocationUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ImageData_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImageData_ImageID {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            codec: buffer.read_u8()?,
            size: buffer.read_u32::<LittleEndian>()?,
            packets: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImageData_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImageData_ImageData {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ImagePacket_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImagePacket_ImageID {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            packet: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImagePacket_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImagePacket_ImageData {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl LayerData_LayerID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LayerData_LayerID { type_: buffer.read_u8()? })
    }
}

impl LayerData_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LayerData_LayerData {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdate_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdate_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
            state: buffer.read_u8()?,
            full_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            crc: buffer.read_u32::<LittleEndian>()?,
            p_code: buffer.read_u8()?,
            material: buffer.read_u8()?,
            click_action: buffer.read_u8()?,
            scale: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            object_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parent_id: buffer.read_u32::<LittleEndian>()?,
            update_flags: buffer.read_u32::<LittleEndian>()?,
            path_curve: buffer.read_u8()?,
            profile_curve: buffer.read_u8()?,
            path_begin: buffer.read_u16::<LittleEndian>()?,
            path_end: buffer.read_u16::<LittleEndian>()?,
            path_scale_x: buffer.read_u8()?,
            path_scale_y: buffer.read_u8()?,
            path_shear_x: buffer.read_u8()?,
            path_shear_y: buffer.read_u8()?,
            path_twist: buffer.read_i8()?,
            path_twist_begin: buffer.read_i8()?,
            path_radius_offset: buffer.read_i8()?,
            path_taper_x: buffer.read_i8()?,
            path_taper_y: buffer.read_i8()?,
            path_revolutions: buffer.read_u8()?,
            path_skew: buffer.read_i8()?,
            profile_begin: buffer.read_u16::<LittleEndian>()?,
            profile_end: buffer.read_u16::<LittleEndian>()?,
            profile_hollow: buffer.read_u16::<LittleEndian>()?,
            texture_entry: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_anim: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name_value: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            text_color: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            ps_block: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            extra_params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sound: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
            radius: buffer.read_f32::<LittleEndian>()?,
            joint_type: buffer.read_u8()?,
            joint_pivot: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            joint_axis_or_anchor: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectUpdateCompressed_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdateCompressed_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdateCompressed_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdateCompressed_ObjectData {
            update_flags: buffer.read_u32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectUpdateCached_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdateCached_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ObjectUpdateCached_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectUpdateCached_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
            update_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ImprovedTerseObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImprovedTerseObjectUpdate_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            time_dilation: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ImprovedTerseObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImprovedTerseObjectUpdate_ObjectData {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_entry: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl KillObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(KillObject_ObjectData {
            id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CrossedRegion_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CrossedRegion_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CrossedRegion_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CrossedRegion_RegionData {
            sim_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            sim_port: buffer.read_u16::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            seed_capability: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CrossedRegion_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CrossedRegion_Info {
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SimulatorViewerTimeMessage_TimeInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimulatorViewerTimeMessage_TimeInfo {
            usec_since_start: buffer.read_u64::<LittleEndian>()?,
            sec_per_day: buffer.read_u32::<LittleEndian>()?,
            sec_per_year: buffer.read_u32::<LittleEndian>()?,
            sun_direction: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sun_phase: buffer.read_f32::<LittleEndian>()?,
            sun_ang_velocity: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl EnableSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EnableSimulator_SimulatorInfo {
            handle: buffer.read_u64::<LittleEndian>()?,
            ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl ConfirmEnableSimulator_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ConfirmEnableSimulator_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferRequest_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferRequest_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            source_type: buffer.read_i32::<LittleEndian>()?,
            priority: buffer.read_f32::<LittleEndian>()?,
            params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TransferInfo_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferInfo_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            target_type: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
            size: buffer.read_i32::<LittleEndian>()?,
            params: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TransferPacket_TransferData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferPacket_TransferData {
            transfer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
            packet: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_i32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl TransferAbort_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferAbort_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_type: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl RequestXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestXfer_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            file_path: buffer.read_u8()?,
            delete_on_completion: buffer.read_u8()? == 1,
            use_big_packets: buffer.read_u8()? == 1,
            v_file_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            v_file_type: buffer.read_i16::<LittleEndian>()?,
        })
    }
}

impl SendXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SendXferPacket_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SendXferPacket_DataPacket {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SendXferPacket_DataPacket {
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ConfirmXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ConfirmXferPacket_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            packet: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AbortXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AbortXfer_XferID {
            id: buffer.read_u64::<LittleEndian>()?,
            result: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AvatarAnimation_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAnimation_Sender {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAnimation_AnimationList {
            anim_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            anim_sequence_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AvatarAnimation_AnimationSourceList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAnimation_AnimationSourceList {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarAppearance_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAppearance_Sender {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_trial: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAppearance_ObjectData {
            texture_entry: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarAppearance_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl AvatarSitResponse_SitObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarSitResponse_SitObject {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarSitResponse_SitTransform {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarSitResponse_SitTransform {
            auto_pilot: buffer.read_u8()? == 1,
            sit_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sit_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            camera_eye_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            camera_at_offset: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            force_mouselook: buffer.read_u8()? == 1,
        })
    }
}

impl SetFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetFollowCamProperties_CameraProperty {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetFollowCamProperties_CameraProperty {
            type_: buffer.read_i32::<LittleEndian>()?,
            value: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ClearFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ClearFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CameraConstraint_CameraCollidePlane {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CameraConstraint_CameraCollidePlane {
            plane: Vector4::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ObjectProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creation_date: buffer.read_u64::<LittleEndian>()?,
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            ownership_cost: buffer.read_i32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            aggregate_perms: buffer.read_u8()?,
            aggregate_perm_textures: buffer.read_u8()?,
            aggregate_perm_textures_owner: buffer.read_u8()?,
            category: buffer.read_u32::<LittleEndian>()?,
            inventory_serial: buffer.read_i16::<LittleEndian>()?,
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            from_task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            last_owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            touch_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sit_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            texture_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectPropertiesFamily_ObjectData {
            request_flags: buffer.read_u32::<LittleEndian>()?,
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            ownership_cost: buffer.read_i32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            category: buffer.read_u32::<LittleEndian>()?,
            last_owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RequestPayPrice_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestPayPrice_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PayPriceReply_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PayPriceReply_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            default_pay_price: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PayPriceReply_ButtonData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PayPriceReply_ButtonData {
            pay_button: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl KickUser_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(KickUser_TargetBlock {
            target_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl KickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(KickUser_UserInfo {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            reason: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl KickUserAck_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(KickUserAck_UserInfo {
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GodKickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodKickUser_UserInfo {
            god_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            kick_flags: buffer.read_u32::<LittleEndian>()?,
            reason: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SystemKickUser_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SystemKickUser_AgentInfo {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectUser_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectUser_Data {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl FreezeUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FreezeUser_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FreezeUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FreezeUser_Data {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AvatarPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            god_level: buffer.read_u8()?,
            web_profiles_disabled: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarPropertiesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesReply_PropertiesData {
            image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            fl_image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            partner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            fl_about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            born_on: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            profile_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter_member: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AvatarInterestsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarInterestsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarInterestsReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarInterestsReply_PropertiesData {
            want_to_mask: buffer.read_u32::<LittleEndian>()?,
            want_to_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            skills_mask: buffer.read_u32::<LittleEndian>()?,
            skills_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            languages_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            avatar_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarGroupsReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarGroupsReply_GroupData {
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_insignia_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarGroupsReply_NewGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarGroupsReply_NewGroupData {
            list_in_profile: buffer.read_u8()? == 1,
        })
    }
}

impl AvatarPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPropertiesUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPropertiesUpdate_PropertiesData {
            image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            fl_image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            fl_about_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
            profile_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarInterestsUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarInterestsUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarInterestsUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarInterestsUpdate_PropertiesData {
            want_to_mask: buffer.read_u32::<LittleEndian>()?,
            want_to_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            skills_mask: buffer.read_u32::<LittleEndian>()?,
            skills_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            languages_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarNotesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarNotesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarNotesReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarNotesReply_Data {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            notes: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarNotesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarNotesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarNotesUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarNotesUpdate_Data {
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            notes: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AvatarPicksReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPicksReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AvatarPicksReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AvatarPicksReply_Data {
            pick_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pick_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EventInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventInfoRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventInfoRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventInfoReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventInfoReply_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
            creator: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            category: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            date_utc: buffer.read_u32::<LittleEndian>()?,
            duration: buffer.read_u32::<LittleEndian>()?,
            cover: buffer.read_u32::<LittleEndian>()?,
            amount: buffer.read_u32::<LittleEndian>()?,
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            global_pos: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            event_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventNotificationAddRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventNotificationAddRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventNotificationAddRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventNotificationAddRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventNotificationRemoveRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventNotificationRemoveRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventNotificationRemoveRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventNotificationRemoveRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventGodDelete_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventGodDelete_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventGodDelete_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventGodDelete_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            query_flags: buffer.read_u32::<LittleEndian>()?,
            query_start: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl PickInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickInfoReply_Data {
            pick_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            top_pick: buffer.read_u8()? == 1,
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            original_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            sort_order: buffer.read_i32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl PickInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickInfoUpdate_Data {
            pick_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            top_pick: buffer.read_u8()? == 1,
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            sort_order: buffer.read_i32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl PickDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickDelete_Data {
            pick_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PickGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PickGodDelete_Data {
            pick_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptQuestion_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptQuestion_Data {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_owner: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            questions: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ScriptControlChange_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptControlChange_Data {
            take_controls: buffer.read_u8()? == 1,
            controls: buffer.read_u32::<LittleEndian>()?,
            pass_to_agent: buffer.read_u8()? == 1,
        })
    }
}

impl ScriptDialog_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDialog_Data {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            chat_channel: buffer.read_i32::<LittleEndian>()?,
            image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialog_Buttons {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDialog_Buttons {
            button_label: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDialog_OwnerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDialog_OwnerData {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialogReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDialogReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptDialogReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDialogReply_Data {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            chat_channel: buffer.read_i32::<LittleEndian>()?,
            button_index: buffer.read_i32::<LittleEndian>()?,
            button_label: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ForceScriptControlRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ForceScriptControlRelease_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RevokePermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RevokePermissions_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RevokePermissions_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RevokePermissions_Data {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_permissions: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl LoadURL_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LoadURL_Data {
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_is_group: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptTeleportRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptTeleportRequest_Data {
            object_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            sim_position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl ParcelOverlay_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelOverlay_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ParcelPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesRequest_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
            snap_selection: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelPropertiesRequestByID_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesRequestByID_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesRequestByID_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesRequestByID_ParcelData {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelProperties_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelProperties_ParcelData {
            request_result: buffer.read_i32::<LittleEndian>()?,
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            snap_selection: buffer.read_u8()? == 1,
            self_count: buffer.read_i32::<LittleEndian>()?,
            other_count: buffer.read_i32::<LittleEndian>()?,
            public_count: buffer.read_i32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            auction_id: buffer.read_u32::<LittleEndian>()?,
            claim_date: buffer.read_i32::<LittleEndian>()?,
            claim_price: buffer.read_i32::<LittleEndian>()?,
            rent_price: buffer.read_i32::<LittleEndian>()?,
            aabb_min: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            aabb_max: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            bitmap: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            area: buffer.read_i32::<LittleEndian>()?,
            status: buffer.read_u8()?,
            sim_wide_max_prims: buffer.read_i32::<LittleEndian>()?,
            sim_wide_total_prims: buffer.read_i32::<LittleEndian>()?,
            max_prims: buffer.read_i32::<LittleEndian>()?,
            total_prims: buffer.read_i32::<LittleEndian>()?,
            owner_prims: buffer.read_i32::<LittleEndian>()?,
            group_prims: buffer.read_i32::<LittleEndian>()?,
            other_prims: buffer.read_i32::<LittleEndian>()?,
            selected_prims: buffer.read_i32::<LittleEndian>()?,
            parcel_prim_bonus: buffer.read_f32::<LittleEndian>()?,
            other_clean_time: buffer.read_i32::<LittleEndian>()?,
            parcel_flags: buffer.read_u32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pass_price: buffer.read_i32::<LittleEndian>()?,
            pass_hours: buffer.read_f32::<LittleEndian>()?,
            category: buffer.read_u8()?,
            auth_buyer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            user_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            landing_type: buffer.read_u8()?,
            region_push_override: buffer.read_u8()? == 1,
            region_deny_anonymous: buffer.read_u8()? == 1,
            region_deny_identified: buffer.read_u8()? == 1,
            region_deny_transacted: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelProperties_AgeVerificationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelProperties_AgeVerificationBlock {
            region_deny_age_unverified: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelPropertiesUpdate_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelPropertiesUpdate_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            parcel_flags: buffer.read_u32::<LittleEndian>()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pass_price: buffer.read_i32::<LittleEndian>()?,
            pass_hours: buffer.read_f32::<LittleEndian>()?,
            category: buffer.read_u8()?,
            auth_buyer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            user_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            landing_type: buffer.read_u8()?,
        })
    }
}

impl ParcelReturnObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReturnObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReturnObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReturnObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelReturnObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReturnObjects_TaskIDs {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReturnObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReturnObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSetOtherCleanTime_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSetOtherCleanTime_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSetOtherCleanTime_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSetOtherCleanTime_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            other_clean_time: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelDisableObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDisableObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDisableObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDisableObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelDisableObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDisableObjects_TaskIDs {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDisableObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDisableObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSelectObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSelectObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelSelectObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSelectObjects_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            return_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelSelectObjects_ReturnIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSelectObjects_ReturnIDs {
            return_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateCovenantRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EstateCovenantRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateCovenantReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EstateCovenantReply_Data {
            covenant_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            covenant_timestamp: buffer.read_u32::<LittleEndian>()?,
            estate_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            estate_owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ForceObjectSelect_Header {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ForceObjectSelect_Header {
            reset_list: buffer.read_u8()? == 1,
        })
    }
}

impl ForceObjectSelect_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ForceObjectSelect_Data {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelBuyPass_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelBuyPass_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelBuyPass_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelBuyPass_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelDeedToGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDeedToGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDeedToGroup_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDeedToGroup_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelReclaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReclaim_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelReclaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelReclaim_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelClaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelClaim_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelClaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelClaim_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelClaim_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelClaim_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelJoin_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelJoin_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelJoin_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelJoin_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelDivide_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDivide_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDivide_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDivide_ParcelData {
            west: buffer.read_f32::<LittleEndian>()?,
            south: buffer.read_f32::<LittleEndian>()?,
            east: buffer.read_f32::<LittleEndian>()?,
            north: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelRelease_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelRelease_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelRelease_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelBuy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelBuy_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelBuy_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_group_owned: buffer.read_u8()? == 1,
            remove_contribution: buffer.read_u8()? == 1,
            local_id: buffer.read_i32::<LittleEndian>()?,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl ParcelBuy_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelBuy_ParcelData {
            price: buffer.read_i32::<LittleEndian>()?,
            area: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelGodForceOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelGodForceOwner_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodForceOwner_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelGodForceOwner_Data {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelAccessListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListRequest_Data {
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListReply_Data {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListReply_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListReply_List {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelAccessListUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListUpdate_Data {
            flags: buffer.read_u32::<LittleEndian>()?,
            local_id: buffer.read_i32::<LittleEndian>()?,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sequence_id: buffer.read_i32::<LittleEndian>()?,
            sections: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ParcelAccessListUpdate_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAccessListUpdate_List {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            time: buffer.read_i32::<LittleEndian>()?,
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelDwellRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDwellRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDwellRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDwellRequest_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDwellReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDwellReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelDwellReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelDwellReply_Data {
            local_id: buffer.read_i32::<LittleEndian>()?,
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dwell: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl RequestParcelTransfer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestParcelTransfer_Data {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            final_: buffer.read_u8()? == 1,
        })
    }
}

impl RequestParcelTransfer_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestParcelTransfer_RegionData {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateParcel_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_owned: buffer.read_u8()? == 1,
            status: buffer.read_u8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            music_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            region_x: buffer.read_f32::<LittleEndian>()?,
            region_y: buffer.read_f32::<LittleEndian>()?,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            billable_area: buffer.read_i32::<LittleEndian>()?,
            show_dir: buffer.read_u8()? == 1,
            is_for_sale: buffer.read_u8()? == 1,
            category: buffer.read_u8()?,
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            user_location: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            sale_price: buffer.read_i32::<LittleEndian>()?,
            authorized_buyer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl RemoveParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveParcel_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MergeParcel_MasterParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MergeParcel_MasterParcelData {
            master_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MergeParcel_SlaveParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MergeParcel_SlaveParcelData {
            slave_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogParcelChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogParcelChanges_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogParcelChanges_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogParcelChanges_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl LogParcelChanges_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogParcelChanges_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_owner_group: buffer.read_u8()? == 1,
            actual_area: buffer.read_i32::<LittleEndian>()?,
            action: buffer.read_i8()?,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CheckParcelSales_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CheckParcelSales_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl ParcelSales_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelSales_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            buyer_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodMarkAsContent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelGodMarkAsContent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ParcelGodMarkAsContent_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelGodMarkAsContent_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ViewerStartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStartAuction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerStartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerStartAuction_ParcelData {
            local_id: buffer.read_i32::<LittleEndian>()?,
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartAuction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            snapshot_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ConfirmAuctionStart_AuctionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ConfirmAuctionStart_AuctionData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            auction_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CompleteAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CompleteAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CancelAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CancelAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CheckParcelAuctions_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CheckParcelAuctions_RegionData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl ParcelAuctions_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelAuctions_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            winner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UUIDNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UUIDNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UUIDNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UUIDNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UUIDGroupNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UUIDGroupNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UUIDGroupNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UUIDGroupNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ChatPass_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChatPass_ChatData {
            channel: buffer.read_i32::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            source_type: buffer.read_u8()?,
            type_: buffer.read_u8()?,
            radius: buffer.read_f32::<LittleEndian>()?,
            sim_access: buffer.read_u8()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EdgeDataPacket_EdgeData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EdgeDataPacket_EdgeData {
            layer_type: buffer.read_u8()?,
            direction: buffer.read_u8()?,
            layer_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SimStatus_SimStatus {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimStatus_SimStatus {
            can_accept_agents: buffer.read_u8()? == 1,
            can_accept_tasks: buffer.read_u8()? == 1,
        })
    }
}

impl ChildAgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_vel: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            changed_grid: buffer.read_u8()? == 1,
            far: buffer.read_f32::<LittleEndian>()?,
            aspect: buffer.read_f32::<LittleEndian>()?,
            throttles: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            locomotion_state: buffer.read_u32::<LittleEndian>()?,
            head_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            body_rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            control_flags: buffer.read_u32::<LittleEndian>()?,
            energy_level: buffer.read_f32::<LittleEndian>()?,
            god_level: buffer.read_u8()?,
            always_run: buffer.read_u8()? == 1,
            prey_agent: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_access: buffer.read_u8()?,
            agent_textures: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            active_group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
        })
    }
}

impl ChildAgentUpdate_AnimationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_AnimationData {
            animation: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_GranterBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_GranterBlock {
            granter_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUpdate_NVPairData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_NVPairData {
            nv_pairs: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ChildAgentUpdate_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_VisualParam {
            param_value: buffer.read_u8()?,
        })
    }
}

impl ChildAgentUpdate_AgentAccess {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_AgentAccess {
            agent_legacy_access: buffer.read_u8()?,
            agent_max_access: buffer.read_u8()?,
        })
    }
}

impl ChildAgentUpdate_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUpdate_AgentInfo {
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ChildAgentAlive_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentAlive_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentPositionUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentPositionUpdate_AgentData {
            region_handle: buffer.read_u64::<LittleEndian>()?,
            viewer_circuit_code: buffer.read_u32::<LittleEndian>()?,
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            agent_vel: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            center: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            size: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            at_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            left_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            up_axis: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            changed_grid: buffer.read_u8()? == 1,
        })
    }
}

impl ChildAgentDying_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentDying_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChildAgentUnknown_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChildAgentUnknown_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AtomicPassObject_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AtomicPassObject_TaskData {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_needs_save: buffer.read_u8()? == 1,
        })
    }
}

impl KillChildAgents_IDBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(KillChildAgents_IDBlock {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GetScriptRunning_Script {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptRunningReply_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptRunningReply_Script {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            running: buffer.read_u8()? == 1,
        })
    }
}

impl SetScriptRunning_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetScriptRunning_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetScriptRunning_Script {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            running: buffer.read_u8()? == 1,
        })
    }
}

impl ScriptReset_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptReset_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptReset_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptReset_Script {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptSensorRequest_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptSensorRequest_Requester {
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            search_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            search_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            search_dir: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            search_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            range: buffer.read_f32::<LittleEndian>()?,
            arc: buffer.read_f32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            search_regions: buffer.read_u8()?,
        })
    }
}

impl ScriptSensorReply_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptSensorReply_Requester {
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ScriptSensorReply_SensedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptSensorReply_SensedData {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            velocity: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            rotation: Quaternion::from_parts(
                1.,
                Vector3::new(
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                    buffer.read_f32::<LittleEndian>()?,
                ),
            ),
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            range: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl CompleteAgentMovement_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CompleteAgentMovement_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            circuit_code: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentMovementComplete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentMovementComplete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentMovementComplete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentMovementComplete_Data {
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            region_handle: buffer.read_u64::<LittleEndian>()?,
            timestamp: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentMovementComplete_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentMovementComplete_SimData {
            channel_version: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl DataServerLogout_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DataServerLogout_UserData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            viewer_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            disconnect: buffer.read_u8()? == 1,
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogoutRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogoutRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogoutReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogoutReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogoutReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogoutReply_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ImprovedInstantMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImprovedInstantMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ImprovedInstantMessage_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ImprovedInstantMessage_MessageBlock {
            from_group: buffer.read_u8()? == 1,
            to_agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_estate_id: buffer.read_u32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            offline: buffer.read_u8()?,
            dialog: buffer.read_u8()?,
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            timestamp: buffer.read_u32::<LittleEndian>()?,
            from_agent_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            binary_bucket: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RetrieveInstantMessages_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RetrieveInstantMessages_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FindAgent_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FindAgent_AgentBlock {
            hunter: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            prey: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            space_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
        })
    }
}

impl FindAgent_LocationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FindAgent_LocationBlock {
            global_x: buffer.read_f64::<LittleEndian>()?,
            global_y: buffer.read_f64::<LittleEndian>()?,
        })
    }
}

impl RequestGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestGodlikePowers_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestGodlikePowers_RequestBlock {
            godlike: buffer.read_u8()? == 1,
            token: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GrantGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantGodlikePowers_GrantData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GrantGodlikePowers_GrantData {
            god_level: buffer.read_u8()?,
            token: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodlikeMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodlikeMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodlikeMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodlikeMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GodlikeMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GodlikeMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EstateOwnerMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EstateOwnerMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateOwnerMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EstateOwnerMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EstateOwnerMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EstateOwnerMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GenericMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GenericMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GenericMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GenericMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GenericMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GenericMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MuteListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MuteListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MuteListRequest_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MuteListRequest_MuteData {
            mute_crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            mute_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            mute_type: buffer.read_i32::<LittleEndian>()?,
            mute_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RemoveMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            mute_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CopyInventoryFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CopyInventoryFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CopyInventoryFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CopyInventoryFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl UpdateCreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateCreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sim_approved: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateCreateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateCreateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            stamp: buffer.read_u8()? == 1,
        })
    }
}

impl MoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CopyInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CopyInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CopyInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CopyInventoryItem_InventoryData {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            old_agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RemoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeInventoryItemFlags_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChangeInventoryItemFlags_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeInventoryItemFlags_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChangeInventoryItemFlags_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SaveAssetIntoInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SaveAssetIntoInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SaveAssetIntoInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SaveAssetIntoInventory_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            stamp: buffer.read_u8()? == 1,
        })
    }
}

impl MoveInventoryFolder_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveInventoryFolder_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sort_order: buffer.read_i32::<LittleEndian>()?,
            fetch_folders: buffer.read_u8()? == 1,
            fetch_items: buffer.read_u8()? == 1,
        })
    }
}

impl InventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            version: buffer.read_i32::<LittleEndian>()?,
            descendents: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl InventoryDescendents_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InventoryDescendents_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InventoryDescendents_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InventoryDescendents_ItemData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl FetchInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventory_InventoryData {
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventoryReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FetchInventoryReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FetchInventoryReply_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl BulkUpdateInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(BulkUpdateInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl BulkUpdateInventory_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(BulkUpdateInventory_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl BulkUpdateInventory_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(BulkUpdateInventory_ItemData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RequestInventoryAsset_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestInventoryAsset_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InventoryAssetResponse_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InventoryAssetResponse_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_readable: buffer.read_u8()? == 1,
        })
    }
}

impl RemoveInventoryObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryObjects_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryObjects_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveInventoryObjects_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveInventoryObjects_ItemData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PurgeInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PurgeInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl PurgeInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PurgeInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateTaskInventory_UpdateData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateTaskInventory_UpdateData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            key: buffer.read_u8()?,
        })
    }
}

impl UpdateTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateTaskInventory_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RemoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoveTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RequestTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RequestTaskInventory_InventoryData {
            local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ReplyTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ReplyTaskInventory_InventoryData {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial: buffer.read_i16::<LittleEndian>()?,
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl DeRezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeRezObject_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeRezObject_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeRezObject_AgentBlock {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            destination: buffer.read_u8()?,
            destination_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            packet_count: buffer.read_u8()?,
            packet_number: buffer.read_u8()?,
        })
    }
}

impl DeRezObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeRezObject_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeRezAck_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeRezAck_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl RezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObject_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObject_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObject_RezData {
            from_task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()? == 1,
            rez_selected: buffer.read_u8()? == 1,
            remove_item: buffer.read_u8()? == 1,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObject_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObject_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObjectFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObjectFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObjectFromNotecard_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObjectFromNotecard_RezData {
            from_task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            bypass_raycast: buffer.read_u8()?,
            ray_start: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_end: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            ray_target_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            ray_end_is_intersection: buffer.read_u8()? == 1,
            rez_selected: buffer.read_u8()? == 1,
            remove_item: buffer.read_u8()? == 1,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RezObjectFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObjectFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezObjectFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezObjectFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferInventory_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferInventory_InfoBlock {
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TransferInventory_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferInventory_InventoryBlock {
            inventory_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
        })
    }
}

impl TransferInventoryAck_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TransferInventoryAck_InfoBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            inventory_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptFriendship_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptFriendship_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeclineFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeclineFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl FormFriendship_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(FormFriendship_AgentBlock {
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TerminateFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TerminateFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl TerminateFriendship_ExBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(TerminateFriendship_ExBlock {
            other_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OfferCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(OfferCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OfferCallingCard_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(OfferCallingCard_AgentBlock {
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AcceptCallingCard_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AcceptCallingCard_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeclineCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl DeclineCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeclineCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezScript_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezScript_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezScript_UpdateBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezScript_UpdateBlock {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            enabled: buffer.read_u8()? == 1,
        })
    }
}

impl RezScript_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezScript_InventoryBlock {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateInventoryItem_InventoryBlock {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            wearable_type: buffer.read_u8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateLandmarkForEvent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateLandmarkForEvent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateLandmarkForEvent_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateLandmarkForEvent_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl CreateLandmarkForEvent_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateLandmarkForEvent_InventoryBlock {
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EventLocationRequest_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventLocationRequest_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventLocationRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventLocationRequest_EventData {
            event_id: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl EventLocationReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventLocationReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EventLocationReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EventLocationReply_EventData {
            success: buffer.read_u8()? == 1,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl RegionHandleRequest_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionHandleRequest_RequestBlock {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RegionIDAndHandleReply_ReplyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RegionIDAndHandleReply_ReplyBlock {
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl MoneyTransferRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyTransferRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyTransferRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyTransferRequest_MoneyData {
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            aggregate_perm_next_owner: buffer.read_u8()?,
            aggregate_perm_inventory: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyTransferBackend_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyTransferBackend_MoneyData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_time: buffer.read_u32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u8()?,
            amount: buffer.read_i32::<LittleEndian>()?,
            aggregate_perm_next_owner: buffer.read_u8()?,
            aggregate_perm_inventory: buffer.read_u8()?,
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyBalanceRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyBalanceRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyBalanceRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyBalanceRequest_MoneyData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_success: buffer.read_u8()? == 1,
            money_balance: buffer.read_i32::<LittleEndian>()?,
            square_meters_credit: buffer.read_i32::<LittleEndian>()?,
            square_meters_committed: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MoneyBalanceReply_TransactionInfo {
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_source_group: buffer.read_u8()? == 1,
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_dest_group: buffer.read_u8()? == 1,
            amount: buffer.read_i32::<LittleEndian>()?,
            item_description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RoutedMoneyBalanceReply_TargetBlock {
            target_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl RoutedMoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RoutedMoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_success: buffer.read_u8()? == 1,
            money_balance: buffer.read_i32::<LittleEndian>()?,
            square_meters_credit: buffer.read_i32::<LittleEndian>()?,
            square_meters_committed: buffer.read_i32::<LittleEndian>()?,
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RoutedMoneyBalanceReply_TransactionInfo {
            transaction_type: buffer.read_i32::<LittleEndian>()?,
            source_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_source_group: buffer.read_u8()? == 1,
            dest_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            is_dest_group: buffer.read_u8()? == 1,
            amount: buffer.read_i32::<LittleEndian>()?,
            item_description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ActivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ActivateGestures_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ActivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ActivateGestures_Data {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gesture_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeactivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeactivateGestures_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl DeactivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DeactivateGestures_Data {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gesture_flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MuteListUpdate_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MuteListUpdate_MuteData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UseCachedMuteList_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UseCachedMuteList_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GrantUserRights_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GrantUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GrantUserRights_Rights {
            agent_related: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            related_rights: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl ChangeUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChangeUserRights_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ChangeUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ChangeUserRights_Rights {
            agent_related: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            related_rights: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl OnlineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(OnlineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl OfflineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(OfflineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetStartLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetStartLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetStartLocationRequest_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetStartLocationRequest_StartLocationData {
            sim_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            location_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            location_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl SetStartLocation_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetStartLocation_StartLocationData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            region_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_id: buffer.read_u32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
            location_pos: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            location_look_at: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
        })
    }
}

impl NetTest_NetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NetTest_NetBlock {
            port: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl SetCPURatio_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetCPURatio_Data { ratio: buffer.read_u8()? })
    }
}

impl SimCrashed_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimCrashed_Data {
            region_x: buffer.read_u32::<LittleEndian>()?,
            region_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl SimCrashed_Users {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SimCrashed_Users {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl NameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NameValuePair_TaskData {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl NameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(NameValuePair_NameValueData {
            nv_pair: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RemoveNameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveNameValuePair_TaskData {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveNameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveNameValuePair_NameValueData {
            nv_pair: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateAttachment_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateAttachment_AttachmentBlock {
            attachment_point: buffer.read_u8()?,
        })
    }
}

impl UpdateAttachment_OperationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateAttachment_OperationData {
            add_item: buffer.read_u8()? == 1,
            use_existing_asset: buffer.read_u8()? == 1,
        })
    }
}

impl UpdateAttachment_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateAttachment_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RemoveAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveAttachment_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RemoveAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RemoveAttachment_AttachmentBlock {
            attachment_point: buffer.read_u8()?,
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SoundTrigger_SoundData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SoundTrigger_SoundData {
            sound_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            parent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            handle: buffer.read_u64::<LittleEndian>()?,
            position: Vector3::new(
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
                buffer.read_f32::<LittleEndian>()?,
            ),
            gain: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl AttachedSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AttachedSound_DataBlock {
            sound_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
            flags: buffer.read_u8()?,
        })
    }
}

impl AttachedSoundGainChange_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AttachedSoundGainChange_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            gain: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl PreloadSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(PreloadSound_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            sound_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AssetUploadRequest_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AssetUploadRequest_AssetBlock {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            tempfile: buffer.read_u8()? == 1,
            store_local: buffer.read_u8()? == 1,
            asset_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AssetUploadComplete_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AssetUploadComplete_AssetBlock {
            uuid: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            success: buffer.read_u8()? == 1,
        })
    }
}

impl EmailMessageRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EmailMessageRequest_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            from_address: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl EmailMessageReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EmailMessageReply_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            more: buffer.read_u32::<LittleEndian>()?,
            time: buffer.read_u32::<LittleEndian>()?,
            from_address: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            mail_filter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InternalScriptMail_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InternalScriptMail_DataBlock {
            from: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            to: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            body: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDataRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDataRequest_DataBlock {
            hash: buffer.read_u64::<LittleEndian>()?,
            request_type: buffer.read_i8()?,
            request: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptDataReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptDataReply_DataBlock {
            hash: buffer.read_u64::<LittleEndian>()?,
            reply: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateGroupRequest_GroupData {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            insignia_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl CreateGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateGroupReply_ReplyData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateGroupInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateGroupInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateGroupInfo_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateGroupInfo_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            charter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            insignia_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl GroupRoleChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleChanges_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleChanges_RoleChange {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleChanges_RoleChange {
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            change: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl JoinGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(JoinGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl JoinGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(JoinGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl JoinGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(JoinGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl JoinGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(JoinGroupReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl EjectGroupMemberRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberRequest_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberRequest_EjectData {
            ejectee_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl EjectGroupMemberReply_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(EjectGroupMemberReply_EjectData {
            success: buffer.read_u8()? == 1,
        })
    }
}

impl LeaveGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LeaveGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LeaveGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LeaveGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LeaveGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LeaveGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LeaveGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LeaveGroupReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            success: buffer.read_u8()? == 1,
        })
    }
}

impl InviteGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InviteGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InviteGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupRequest_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InviteGroupRequest_InviteData {
            invitee_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InviteGroupResponse_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InviteGroupResponse_InviteData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            invitee_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupProfileRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProfileRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProfileRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProfileReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProfileReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProfileReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            charter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            show_in_list: buffer.read_u8()? == 1,
            member_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers_mask: buffer.read_u64::<LittleEndian>()?,
            insignia_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            founder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            membership_fee: buffer.read_i32::<LittleEndian>()?,
            open_enrollment: buffer.read_u8()? == 1,
            money: buffer.read_i32::<LittleEndian>()?,
            group_membership_count: buffer.read_i32::<LittleEndian>()?,
            group_roles_count: buffer.read_i32::<LittleEndian>()?,
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
            owner_role: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountSummaryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountSummaryRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountSummaryRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountSummaryRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountSummaryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountSummaryReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountSummaryReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountSummaryReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            balance: buffer.read_i32::<LittleEndian>()?,
            total_credits: buffer.read_i32::<LittleEndian>()?,
            total_debits: buffer.read_i32::<LittleEndian>()?,
            object_tax_current: buffer.read_i32::<LittleEndian>()?,
            light_tax_current: buffer.read_i32::<LittleEndian>()?,
            land_tax_current: buffer.read_i32::<LittleEndian>()?,
            group_tax_current: buffer.read_i32::<LittleEndian>()?,
            parcel_dir_fee_current: buffer.read_i32::<LittleEndian>()?,
            object_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            light_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            land_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            group_tax_estimate: buffer.read_i32::<LittleEndian>()?,
            parcel_dir_fee_estimate: buffer.read_i32::<LittleEndian>()?,
            non_exempt_members: buffer.read_i32::<LittleEndian>()?,
            last_tax_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            tax_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountDetailsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountDetailsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountDetailsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountDetailsRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountDetailsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountDetailsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountDetailsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountDetailsReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountDetailsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountDetailsReply_HistoryData {
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            amount: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountTransactionsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountTransactionsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountTransactionsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountTransactionsRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupAccountTransactionsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountTransactionsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupAccountTransactionsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountTransactionsReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            interval_days: buffer.read_i32::<LittleEndian>()?,
            current_interval: buffer.read_i32::<LittleEndian>()?,
            start_date: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupAccountTransactionsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupAccountTransactionsReply_HistoryData {
            time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            user: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_: buffer.read_i32::<LittleEndian>()?,
            item: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            amount: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupActiveProposalsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalsRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalsRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalsRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalsRequest_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupActiveProposalItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_num_items: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupActiveProposalItemReply_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupActiveProposalItemReply_ProposalData {
            vote_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_initiator: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terse_date_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            start_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            end_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            already_voted: buffer.read_u8()? == 1,
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            majority: buffer.read_f32::<LittleEndian>()?,
            quorum: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupVoteHistoryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryRequest_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupVoteHistoryItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_num_items: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupVoteHistoryItemReply_HistoryItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryItemReply_HistoryItemData {
            vote_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            terse_date_id: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            start_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            end_date_time: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            vote_initiator: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_type: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            vote_result: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            majority: buffer.read_f32::<LittleEndian>()?,
            quorum: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupVoteHistoryItemReply_VoteItem {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupVoteHistoryItemReply_VoteItem {
            candidate_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            num_votes: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl StartGroupProposal_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartGroupProposal_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl StartGroupProposal_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(StartGroupProposal_ProposalData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            quorum: buffer.read_i32::<LittleEndian>()?,
            majority: buffer.read_f32::<LittleEndian>()?,
            duration: buffer.read_i32::<LittleEndian>()?,
            proposal_text: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupProposalBallot_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProposalBallot_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupProposalBallot_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupProposalBallot_ProposalData {
            proposal_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            vote_cast: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupMembersRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupMembersReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupMembersReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupMembersReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_count: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupMembersReply_MemberData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
            online_status: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            agent_powers: buffer.read_u64::<LittleEndian>()?,
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            is_owner: buffer.read_u8()? == 1,
        })
    }
}

impl ActivateGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ActivateGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetGroupContribution_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetGroupContribution_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetGroupContribution_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetGroupContribution_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl SetGroupAcceptNotices_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetGroupAcceptNotices_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl SetGroupAcceptNotices_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetGroupAcceptNotices_Data {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            accept_notices: buffer.read_u8()? == 1,
        })
    }
}

impl SetGroupAcceptNotices_NewData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SetGroupAcceptNotices_NewData {
            list_in_profile: buffer.read_u8()? == 1,
        })
    }
}

impl GroupRoleDataRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleDataRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleDataRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleDataRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleDataReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleDataReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleDataReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleDataReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            role_count: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleDataReply_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleDataReply_RoleData {
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers: buffer.read_u64::<LittleEndian>()?,
            members: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleMembersRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleMembersReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_pairs: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl GroupRoleMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleMembersReply_MemberData {
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            member_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupTitlesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupTitlesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupTitlesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupTitlesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupTitlesReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupTitlesReply_GroupData {
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            selected: buffer.read_u8()? == 1,
        })
    }
}

impl GroupTitleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupTitleUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            title_role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl GroupRoleUpdate_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupRoleUpdate_RoleData {
            role_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            powers: buffer.read_u64::<LittleEndian>()?,
            update_type: buffer.read_u8()?,
        })
    }
}

impl LiveHelpGroupRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LiveHelpGroupRequest_RequestData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LiveHelpGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LiveHelpGroupReply_ReplyData {
            request_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            selection: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentWearablesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentWearablesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentWearablesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentWearablesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl AgentWearablesUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentWearablesUpdate_WearableData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            wearable_type: buffer.read_u8()?,
        })
    }
}

impl AgentIsNowWearing_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentIsNowWearing_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentIsNowWearing_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentIsNowWearing_WearableData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            wearable_type: buffer.read_u8()?,
        })
    }
}

impl AgentCachedTexture_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentCachedTexture_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AgentCachedTexture_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentCachedTexture_WearableData {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
        })
    }
}

impl AgentCachedTextureResponse_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentCachedTextureResponse_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            serial_num: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl AgentCachedTextureResponse_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentCachedTextureResponse_WearableData {
            texture_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            texture_index: buffer.read_u8()?,
            host_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentDataUpdateRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentDataUpdateRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            first_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            last_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            active_group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl GroupDataUpdate_AgentGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(GroupDataUpdate_AgentGroupData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_powers: buffer.read_u64::<LittleEndian>()?,
            group_title: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentGroupDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentGroupDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl AgentGroupDataUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentGroupDataUpdate_GroupData {
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_powers: buffer.read_u64::<LittleEndian>()?,
            accept_notices: buffer.read_u8()? == 1,
            group_insignia_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            contribution: buffer.read_i32::<LittleEndian>()?,
            group_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl AgentDropGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(AgentDropGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LogTextMessage_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LogTextMessage_DataBlock {
            from_agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            to_agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            global_x: buffer.read_f64::<LittleEndian>()?,
            global_y: buffer.read_f64::<LittleEndian>()?,
            time: buffer.read_u32::<LittleEndian>()?,
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ViewerEffect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerEffect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ViewerEffect_Effect {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ViewerEffect_Effect {
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_u8()?,
            duration: buffer.read_f32::<LittleEndian>()?,
            color: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                raw
            },
            type_data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl CreateTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            digest: {
                let mut raw = [0; 32];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl DenyTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DenyTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezSingleAttachmentFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezSingleAttachmentFromInv_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezSingleAttachmentFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezSingleAttachmentFromInv_ObjectData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_pt: buffer.read_u8()?,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RezMultipleAttachmentsFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezMultipleAttachmentsFromInv_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezMultipleAttachmentsFromInv_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezMultipleAttachmentsFromInv_HeaderData {
            compound_msg_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            total_objects: buffer.read_u8()?,
            first_detach_all: buffer.read_u8()? == 1,
        })
    }
}

impl RezMultipleAttachmentsFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezMultipleAttachmentsFromInv_ObjectData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            attachment_pt: buffer.read_u8()?,
            item_flags: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl DetachAttachmentIntoInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(DetachAttachmentIntoInv_ObjectData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateNewOutfitAttachments_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateNewOutfitAttachments_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateNewOutfitAttachments_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateNewOutfitAttachments_HeaderData {
            new_folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl CreateNewOutfitAttachments_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(CreateNewOutfitAttachments_ObjectData {
            old_item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UserInfoReply_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UserInfoReply_UserData {
            im_via_e_mail: buffer.read_u8()? == 1,
            directory_visibility: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            e_mail: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl UpdateUserInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateUserInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl UpdateUserInfo_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(UpdateUserInfo_UserData {
            im_via_e_mail: buffer.read_u8()? == 1,
            directory_visibility: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ParcelRename_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelRename_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            new_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl InitiateDownload_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InitiateDownload_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl InitiateDownload_FileData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(InitiateDownload_FileData {
            sim_filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            viewer_filename: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SystemMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SystemMessage_MethodData {
            method: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            digest: {
                let mut raw = [0; 32];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SystemMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SystemMessage_ParamList {
            parameter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MapLayerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapLayerRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapLayerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapLayerReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapLayerReply_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapLayerReply_LayerData {
            left: buffer.read_u32::<LittleEndian>()?,
            right: buffer.read_u32::<LittleEndian>()?,
            top: buffer.read_u32::<LittleEndian>()?,
            bottom: buffer.read_u32::<LittleEndian>()?,
            image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MapBlockRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapBlockRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapBlockRequest_PositionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapBlockRequest_PositionData {
            min_x: buffer.read_u16::<LittleEndian>()?,
            max_x: buffer.read_u16::<LittleEndian>()?,
            min_y: buffer.read_u16::<LittleEndian>()?,
            max_y: buffer.read_u16::<LittleEndian>()?,
        })
    }
}

impl MapNameRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapNameRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapNameRequest_NameData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapNameRequest_NameData {
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl MapBlockReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapBlockReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapBlockReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapBlockReply_Data {
            x: buffer.read_u16::<LittleEndian>()?,
            y: buffer.read_u16::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            access: buffer.read_u8()?,
            region_flags: buffer.read_u32::<LittleEndian>()?,
            water_height: buffer.read_u8()?,
            agents: buffer.read_u8()?,
            map_image_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl MapItemRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapItemRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
            estate_id: buffer.read_u32::<LittleEndian>()?,
            godlike: buffer.read_u8()? == 1,
        })
    }
}

impl MapItemRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapItemRequest_RequestData {
            item_type: buffer.read_u32::<LittleEndian>()?,
            region_handle: buffer.read_u64::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapItemReply_RequestData {
            item_type: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl MapItemReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(MapItemReply_Data {
            x: buffer.read_u32::<LittleEndian>()?,
            y: buffer.read_u32::<LittleEndian>()?,
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            extra: buffer.read_i32::<LittleEndian>()?,
            extra2: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl SendPostcard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(SendPostcard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            asset_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            pos_global: Vector3::new(
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
                buffer.read_f64::<LittleEndian>()?,
            ),
            to: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            from: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            subject: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            msg: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            allow_publish: buffer.read_u8()? == 1,
            mature_publish: buffer.read_u8()? == 1,
        })
    }
}

impl RpcChannelRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcChannelRequest_DataBlock {
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RpcChannelReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcChannelReply_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RpcScriptRequestInbound_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcScriptRequestInbound_TargetBlock {
            grid_x: buffer.read_u32::<LittleEndian>()?,
            grid_y: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl RpcScriptRequestInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcScriptRequestInbound_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RpcScriptRequestInboundForward_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcScriptRequestInboundForward_DataBlock {
            rpc_server_ip: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Ip4Addr::from(raw)
            },
            rpc_server_port: buffer.read_u16::<LittleEndian>()?,
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl RpcScriptReplyInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RpcScriptReplyInbound_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            channel_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            int_value: buffer.read_u32::<LittleEndian>()?,
            string_value: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ScriptMailRegistration_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ScriptMailRegistration_DataBlock {
            target_ip: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            target_port: buffer.read_u16::<LittleEndian>()?,
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            flags: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl ParcelMediaCommandMessage_CommandBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelMediaCommandMessage_CommandBlock {
            flags: buffer.read_u32::<LittleEndian>()?,
            command: buffer.read_u32::<LittleEndian>()?,
            time: buffer.read_f32::<LittleEndian>()?,
        })
    }
}

impl ParcelMediaUpdate_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelMediaUpdate_DataBlock {
            media_url: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            media_auto_scale: buffer.read_u8()?,
        })
    }
}

impl ParcelMediaUpdate_DataBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ParcelMediaUpdate_DataBlockExtended {
            media_type: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_desc: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            media_width: buffer.read_i32::<LittleEndian>()?,
            media_height: buffer.read_i32::<LittleEndian>()?,
            media_loop: buffer.read_u8()?,
        })
    }
}

impl LandStatRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LandStatRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LandStatRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LandStatRequest_RequestData {
            report_type: buffer.read_u32::<LittleEndian>()?,
            request_flags: buffer.read_u32::<LittleEndian>()?,
            filter: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            parcel_local_id: buffer.read_i32::<LittleEndian>()?,
        })
    }
}

impl LandStatReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LandStatReply_RequestData {
            report_type: buffer.read_u32::<LittleEndian>()?,
            request_flags: buffer.read_u32::<LittleEndian>()?,
            total_object_count: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl LandStatReply_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LandStatReply_ReportData {
            task_local_id: buffer.read_u32::<LittleEndian>()?,
            task_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            location_x: buffer.read_f32::<LittleEndian>()?,
            location_y: buffer.read_f32::<LittleEndian>()?,
            location_z: buffer.read_f32::<LittleEndian>()?,
            score: buffer.read_f32::<LittleEndian>()?,
            task_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            owner_name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl Error_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Error_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl Error_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(Error_Data {
            code: buffer.read_i32::<LittleEndian>()?,
            token: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            system: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            message: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            data: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}

impl ObjectIncludeInSearch_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectIncludeInSearch_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl ObjectIncludeInSearch_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(ObjectIncludeInSearch_ObjectData {
            object_local_id: buffer.read_u32::<LittleEndian>()?,
            include_in_search: buffer.read_u8()? == 1,
        })
    }
}

impl RezRestoreToWorld_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezRestoreToWorld_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl RezRestoreToWorld_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(RezRestoreToWorld_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            creator_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            owner_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            group_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            base_mask: buffer.read_u32::<LittleEndian>()?,
            owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_mask: buffer.read_u32::<LittleEndian>()?,
            everyone_mask: buffer.read_u32::<LittleEndian>()?,
            next_owner_mask: buffer.read_u32::<LittleEndian>()?,
            group_owned: buffer.read_u8()? == 1,
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            flags: buffer.read_u32::<LittleEndian>()?,
            sale_type: buffer.read_u8()?,
            sale_price: buffer.read_i32::<LittleEndian>()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            creation_date: buffer.read_i32::<LittleEndian>()?,
            crc: buffer.read_u32::<LittleEndian>()?,
        })
    }
}

impl LinkInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LinkInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            session_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
        })
    }
}

impl LinkInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
    where
        R: Read,
    {
        Ok(LinkInventoryItem_InventoryBlock {
            callback_id: buffer.read_u32::<LittleEndian>()?,
            folder_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            transaction_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            old_item_id: {
                let mut raw = [0; 4];
                buffer.read_exact(&mut raw)?;
                Uuid::from_bytes(&raw)?
            },
            type_: buffer.read_i8()?,
            inv_type: buffer.read_i8()?,
            name: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
            description: {
                let n = buffer.read_u8()? as usize;
                let mut raw = vec![0; n];
                buffer.read_exact(&mut raw)?;
                raw
            },
        })
    }
}



// Message IMPLEMENTATIONS



impl Message for TestMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x01])?;
        // Block TestBlock1
        buffer.write_u32::<LittleEndian>(self.test_block1.test1)?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write_u32::<LittleEndian>(
                self.neighbor_block[i].test0,
            )?;
            buffer.write_u32::<LittleEndian>(
                self.neighbor_block[i].test1,
            )?;
            buffer.write_u32::<LittleEndian>(
                self.neighbor_block[i].test2,
            )?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TestBlock1
        let test_block1 = TestMessage_TestBlock1::read_from(buffer)?;
        // Block NeighborBlock
        let neighbor_block = [
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
            TestMessage_NeighborBlock::read_from(buffer)?,
        ];
        Ok(MessageInstance::TestMessage(TestMessage {
            test_block1: test_block1,
            neighbor_block: neighbor_block,
        }))
    }
}

impl Message for PacketAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0xff, 0xFB])?;
        // Block Packets
        buffer.write_u8(self.packets.len() as u8)?;
        for item in &self.packets {
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Packets
        let mut packets = Vec::new();
        let _packets_count = buffer.read_u8()?;
        for _ in 0.._packets_count {
            packets.push(PacketAck_Packets::read_from(buffer)?);
        }
        Ok(MessageInstance::PacketAck(PacketAck { packets: packets }))
    }
}

impl Message for OpenCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0xff, 0xFC])?;
        // Block CircuitInfo
        buffer.write(&self.circuit_info.ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.circuit_info.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block CircuitInfo
        let circuit_info = OpenCircuit_CircuitInfo::read_from(buffer)?;
        Ok(MessageInstance::OpenCircuit(
            OpenCircuit { circuit_info: circuit_info },
        ))
    }
}

impl Message for CloseCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0xff, 0xFD])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::CloseCircuit(CloseCircuit {}))
    }
}

impl Message for StartPingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x01])?;
        // Block PingID
        buffer.write_u8(self.ping_id.ping_id)?;
        buffer.write_u32::<LittleEndian>(
            self.ping_id.oldest_unacked,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block PingID
        let ping_id = StartPingCheck_PingID::read_from(buffer)?;
        Ok(MessageInstance::StartPingCheck(
            StartPingCheck { ping_id: ping_id },
        ))
    }
}

impl Message for CompletePingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x02])?;
        // Block PingID
        buffer.write_u8(self.ping_id.ping_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block PingID
        let ping_id = CompletePingCheck_PingID::read_from(buffer)?;
        Ok(MessageInstance::CompletePingCheck(
            CompletePingCheck { ping_id: ping_id },
        ))
    }
}

impl Message for AddCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x02])?;
        // Block CircuitCode
        buffer.write_u32::<LittleEndian>(self.circuit_code.code)?;
        buffer.write(self.circuit_code.session_id.as_bytes())?;
        buffer.write(self.circuit_code.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block CircuitCode
        let circuit_code = AddCircuitCode_CircuitCode::read_from(buffer)?;
        Ok(MessageInstance::AddCircuitCode(
            AddCircuitCode { circuit_code: circuit_code },
        ))
    }
}

impl Message for UseCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x03])?;
        // Block CircuitCode
        buffer.write_u32::<LittleEndian>(self.circuit_code.code)?;
        buffer.write(self.circuit_code.session_id.as_bytes())?;
        buffer.write(self.circuit_code.id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block CircuitCode
        let circuit_code = UseCircuitCode_CircuitCode::read_from(buffer)?;
        Ok(MessageInstance::UseCircuitCode(
            UseCircuitCode { circuit_code: circuit_code },
        ))
    }
}

impl Message for NeighborList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x03])?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write(&self.neighbor_block[i].ip.octets())?;
            buffer.write_u16::<LittleEndian>(
                self.neighbor_block[i].port,
            )?;
            buffer.write(&self.neighbor_block[i].public_ip.octets())?;
            buffer.write_u16::<LittleEndian>(
                self.neighbor_block[i].public_port,
            )?;
            buffer.write(self.neighbor_block[i].region_id.as_bytes())?;
            buffer.write(&self.neighbor_block[i].name[..])?;
            buffer.write_u8(self.neighbor_block[i].sim_access)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block NeighborBlock
        let neighbor_block = [
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
            NeighborList_NeighborBlock::read_from(buffer)?,
        ];
        Ok(MessageInstance::NeighborList(
            NeighborList { neighbor_block: neighbor_block },
        ))
    }
}

impl Message for AvatarTextureUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u8(self.agent_data.textures_changed as u8)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.cache_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
            buffer.write(&item.host_name[..])?;
        }
        // Block TextureData
        buffer.write_u8(self.texture_data.len() as u8)?;
        for item in &self.texture_data {
            buffer.write(item.texture_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarTextureUpdate_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AvatarTextureUpdate_WearableData::read_from(buffer)?);
        }
        // Block TextureData
        let mut texture_data = Vec::new();
        let _texture_data_count = buffer.read_u8()?;
        for _ in 0.._texture_data_count {
            texture_data.push(AvatarTextureUpdate_TextureData::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarTextureUpdate(AvatarTextureUpdate {
            agent_data: agent_data,
            wearable_data: wearable_data,
            texture_data: texture_data,
        }))
    }
}

impl Message for SimulatorMapUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x05])?;
        // Block MapData
        buffer.write_u32::<LittleEndian>(self.map_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MapData
        let map_data = SimulatorMapUpdate_MapData::read_from(buffer)?;
        Ok(MessageInstance::SimulatorMapUpdate(
            SimulatorMapUpdate { map_data: map_data },
        ))
    }
}

impl Message for SimulatorSetMap {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x06])?;
        // Block MapData
        buffer.write_u64::<LittleEndian>(
            self.map_data.region_handle,
        )?;
        buffer.write_i32::<LittleEndian>(self.map_data.type_)?;
        buffer.write(self.map_data.map_image.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MapData
        let map_data = SimulatorSetMap_MapData::read_from(buffer)?;
        Ok(MessageInstance::SimulatorSetMap(
            SimulatorSetMap { map_data: map_data },
        ))
    }
}

impl Message for SubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x07])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::SubscribeLoad(SubscribeLoad {}))
    }
}

impl Message for UnsubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x08])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::UnsubscribeLoad(UnsubscribeLoad {}))
    }
}

impl Message for SimulatorReady {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x09])?;
        // Block SimulatorBlock
        buffer.write(&self.simulator_block.sim_name[..])?;
        buffer.write_u8(self.simulator_block.sim_access)?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.region_flags,
        )?;
        buffer.write(self.simulator_block.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.estate_id,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.parent_estate_id,
        )?;
        // Block TelehubBlock
        buffer.write_u8(self.telehub_block.has_telehub as u8)?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimulatorBlock
        let simulator_block = SimulatorReady_SimulatorBlock::read_from(buffer)?;
        // Block TelehubBlock
        let telehub_block = SimulatorReady_TelehubBlock::read_from(buffer)?;
        Ok(MessageInstance::SimulatorReady(SimulatorReady {
            simulator_block: simulator_block,
            telehub_block: telehub_block,
        }))
    }
}

impl Message for TelehubInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0a])?;
        // Block TelehubBlock
        buffer.write(self.telehub_block.object_id.as_bytes())?;
        buffer.write(&self.telehub_block.object_name[..])?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.telehub_block.telehub_pos.z,
        )?;
        let normed_telehub_rot = UnitQuaternion::new(&self.telehub_block.telehub_rot).unwrap();
        buffer.write_f32::<LittleEndian>(normed_telehub_rot.i)?;
        buffer.write_f32::<LittleEndian>(normed_telehub_rot.j)?;
        buffer.write_f32::<LittleEndian>(normed_telehub_rot.k)?;
        // Block SpawnPointBlock
        buffer.write_u8(self.spawn_point_block.len() as u8)?;
        for item in &self.spawn_point_block {
            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.x)?;
            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.y)?;
            buffer.write_f32::<LittleEndian>(item.spawn_point_pos.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TelehubBlock
        let telehub_block = TelehubInfo_TelehubBlock::read_from(buffer)?;
        // Block SpawnPointBlock
        let mut spawn_point_block = Vec::new();
        let _spawn_point_block_count = buffer.read_u8()?;
        for _ in 0.._spawn_point_block_count {
            spawn_point_block.push(TelehubInfo_SpawnPointBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::TelehubInfo(TelehubInfo {
            telehub_block: telehub_block,
            spawn_point_block: spawn_point_block,
        }))
    }
}

impl Message for SimulatorPresentAtLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0b])?;
        // Block SimulatorPublicHostBlock
        buffer.write_u16::<LittleEndian>(
            self.simulator_public_host_block.port,
        )?;
        buffer.write(&self.simulator_public_host_block
            .simulator_ip
            .octets())?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_public_host_block.grid_x,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_public_host_block.grid_y,
        )?;
        // Block NeighborBlock
        for i in 0..4 {
            buffer.write(&self.neighbor_block[i].ip.octets())?;
            buffer.write_u16::<LittleEndian>(
                self.neighbor_block[i].port,
            )?;
        }
        // Block SimulatorBlock
        buffer.write(&self.simulator_block.sim_name[..])?;
        buffer.write_u8(self.simulator_block.sim_access)?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.region_flags,
        )?;
        buffer.write(self.simulator_block.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.estate_id,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_block.parent_estate_id,
        )?;
        // Block TelehubBlock
        buffer.write_u8(self.telehub_block.len() as u8)?;
        for item in &self.telehub_block {
            buffer.write_u8(item.has_telehub as u8)?;
            buffer.write_f32::<LittleEndian>(item.telehub_pos.x)?;
            buffer.write_f32::<LittleEndian>(item.telehub_pos.y)?;
            buffer.write_f32::<LittleEndian>(item.telehub_pos.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimulatorPublicHostBlock
        let simulator_public_host_block =
            SimulatorPresentAtLocation_SimulatorPublicHostBlock::read_from(buffer)?;
        // Block NeighborBlock
        let neighbor_block = [
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
            SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)?,
        ];
        // Block SimulatorBlock
        let simulator_block = SimulatorPresentAtLocation_SimulatorBlock::read_from(buffer)?;
        // Block TelehubBlock
        let mut telehub_block = Vec::new();
        let _telehub_block_count = buffer.read_u8()?;
        for _ in 0.._telehub_block_count {
            telehub_block.push(SimulatorPresentAtLocation_TelehubBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::SimulatorPresentAtLocation(
            SimulatorPresentAtLocation {
                simulator_public_host_block: simulator_public_host_block,
                neighbor_block: neighbor_block,
                simulator_block: simulator_block,
                telehub_block: telehub_block,
            },
        ))
    }
}

impl Message for SimulatorLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0c])?;
        // Block SimulatorLoad
        buffer.write_f32::<LittleEndian>(
            self.simulator_load.time_dilation,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.simulator_load.agent_count,
        )?;
        buffer.write_u8(self.simulator_load.can_accept_agents as u8)?;
        // Block AgentList
        buffer.write_u8(self.agent_list.len() as u8)?;
        for item in &self.agent_list {
            buffer.write_u32::<LittleEndian>(item.circuit_code)?;
            buffer.write_u8(item.x)?;
            buffer.write_u8(item.y)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimulatorLoad
        let simulator_load = SimulatorLoad_SimulatorLoad::read_from(buffer)?;
        // Block AgentList
        let mut agent_list = Vec::new();
        let _agent_list_count = buffer.read_u8()?;
        for _ in 0.._agent_list_count {
            agent_list.push(SimulatorLoad_AgentList::read_from(buffer)?);
        }
        Ok(MessageInstance::SimulatorLoad(SimulatorLoad {
            simulator_load: simulator_load,
            agent_list: agent_list,
        }))
    }
}

impl Message for SimulatorShutdownRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0d])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::SimulatorShutdownRequest(
            SimulatorShutdownRequest {},
        ))
    }
}

impl Message for RegionPresenceRequestByRegionID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0e])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write(item.region_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceRequestByRegionID_RegionData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::RegionPresenceRequestByRegionID(
            RegionPresenceRequestByRegionID { region_data: region_data },
        ))
    }
}

impl Message for RegionPresenceRequestByHandle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x0f])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceRequestByHandle_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::RegionPresenceRequestByHandle(
            RegionPresenceRequestByHandle { region_data: region_data },
        ))
    }
}

impl Message for RegionPresenceResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x10])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write(item.region_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
            buffer.write(&item.internal_region_ip.octets())?;
            buffer.write(&item.external_region_ip.octets())?;
            buffer.write_u16::<LittleEndian>(item.region_port)?;
            buffer.write_f64::<LittleEndian>(item.valid_until)?;
            buffer.write(&item.message[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(RegionPresenceResponse_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::RegionPresenceResponse(
            RegionPresenceResponse { region_data: region_data },
        ))
    }
}

impl Message for UpdateSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x11])?;
        // Block SimulatorInfo
        buffer.write(self.simulator_info.region_id.as_bytes())?;
        buffer.write(&self.simulator_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(
            self.simulator_info.estate_id,
        )?;
        buffer.write_u8(self.simulator_info.sim_access)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimulatorInfo
        let simulator_info = UpdateSimulator_SimulatorInfo::read_from(buffer)?;
        Ok(MessageInstance::UpdateSimulator(
            UpdateSimulator { simulator_info: simulator_info },
        ))
    }
}

impl Message for LogDwellTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x12])?;
        // Block DwellInfo
        buffer.write(self.dwell_info.agent_id.as_bytes())?;
        buffer.write(self.dwell_info.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.dwell_info.duration)?;
        buffer.write(&self.dwell_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.dwell_info.region_x)?;
        buffer.write_u32::<LittleEndian>(self.dwell_info.region_y)?;
        buffer.write_u8(self.dwell_info.avg_agents_in_view)?;
        buffer.write_u8(self.dwell_info.avg_viewer_fps)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DwellInfo
        let dwell_info = LogDwellTime_DwellInfo::read_from(buffer)?;
        Ok(MessageInstance::LogDwellTime(
            LogDwellTime { dwell_info: dwell_info },
        ))
    }
}

impl Message for FeatureDisabled {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x13])?;
        // Block FailureInfo
        buffer.write(&self.failure_info.error_message[..])?;
        buffer.write(self.failure_info.agent_id.as_bytes())?;
        buffer.write(self.failure_info.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block FailureInfo
        let failure_info = FeatureDisabled_FailureInfo::read_from(buffer)?;
        Ok(MessageInstance::FeatureDisabled(
            FeatureDisabled { failure_info: failure_info },
        ))
    }
}

impl Message for LogFailedMoneyTransaction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x14])?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        buffer.write_u32::<LittleEndian>(
            self.transaction_data.transaction_time,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.transaction_data.transaction_type,
        )?;
        buffer.write(self.transaction_data.source_id.as_bytes())?;
        buffer.write(self.transaction_data.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_data.flags)?;
        buffer.write_i32::<LittleEndian>(
            self.transaction_data.amount,
        )?;
        buffer.write(&self.transaction_data.simulator_ip.octets())?;
        buffer.write_u32::<LittleEndian>(
            self.transaction_data.grid_x,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.transaction_data.grid_y,
        )?;
        buffer.write_u8(self.transaction_data.failure_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransactionData
        let transaction_data = LogFailedMoneyTransaction_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::LogFailedMoneyTransaction(
            LogFailedMoneyTransaction {
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for UserReportInternal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x15])?;
        // Block ReportData
        buffer.write_u8(self.report_data.report_type)?;
        buffer.write_u8(self.report_data.category)?;
        buffer.write(self.report_data.reporter_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.viewer_position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.viewer_position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.viewer_position.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.agent_position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.agent_position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.agent_position.z,
        )?;
        buffer.write(self.report_data.screenshot_id.as_bytes())?;
        buffer.write(self.report_data.object_id.as_bytes())?;
        buffer.write(self.report_data.owner_id.as_bytes())?;
        buffer.write(self.report_data.last_owner_id.as_bytes())?;
        buffer.write(self.report_data.creator_id.as_bytes())?;
        buffer.write(self.report_data.region_id.as_bytes())?;
        buffer.write(self.report_data.abuser_id.as_bytes())?;
        buffer.write(&self.report_data.abuse_region_name[..])?;
        buffer.write(self.report_data.abuse_region_id.as_bytes())?;
        buffer.write(&self.report_data.summary[..])?;
        buffer.write(&self.report_data.details[..])?;
        buffer.write(&self.report_data.version_string[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ReportData
        let report_data = UserReportInternal_ReportData::read_from(buffer)?;
        Ok(MessageInstance::UserReportInternal(
            UserReportInternal { report_data: report_data },
        ))
    }
}

impl Message for SetSimStatusInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x16])?;
        // Block Data
        buffer.write(self.data.region_id.as_bytes())?;
        buffer.write(&self.data.host_name[..])?;
        buffer.write_i32::<LittleEndian>(self.data.x)?;
        buffer.write_i32::<LittleEndian>(self.data.y)?;
        buffer.write_i32::<LittleEndian>(self.data.pid)?;
        buffer.write_i32::<LittleEndian>(self.data.agent_count)?;
        buffer.write_i32::<LittleEndian>(self.data.time_to_live)?;
        buffer.write(&self.data.status[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = SetSimStatusInDatabase_Data::read_from(buffer)?;
        Ok(MessageInstance::SetSimStatusInDatabase(
            SetSimStatusInDatabase { data: data },
        ))
    }
}

impl Message for SetSimPresenceInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x17])?;
        // Block SimData
        buffer.write(self.sim_data.region_id.as_bytes())?;
        buffer.write(&self.sim_data.host_name[..])?;
        buffer.write_u32::<LittleEndian>(self.sim_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.sim_data.grid_y)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.pid)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.agent_count)?;
        buffer.write_i32::<LittleEndian>(self.sim_data.time_to_live)?;
        buffer.write(&self.sim_data.status[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimData
        let sim_data = SetSimPresenceInDatabase_SimData::read_from(buffer)?;
        Ok(MessageInstance::SetSimPresenceInDatabase(
            SetSimPresenceInDatabase { sim_data: sim_data },
        ))
    }
}

impl Message for EconomyDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x18])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::EconomyDataRequest(EconomyDataRequest {}))
    }
}

impl Message for EconomyData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x19])?;
        // Block Info
        buffer.write_i32::<LittleEndian>(self.info.object_capacity)?;
        buffer.write_i32::<LittleEndian>(self.info.object_count)?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_energy_unit,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_object_claim,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_public_object_decay,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_public_object_delete,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_parcel_claim,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.info.price_parcel_claim_factor,
        )?;
        buffer.write_i32::<LittleEndian>(self.info.price_upload)?;
        buffer.write_i32::<LittleEndian>(self.info.price_rent_light)?;
        buffer.write_i32::<LittleEndian>(
            self.info.teleport_min_price,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.info.teleport_price_exponent,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.info.energy_efficiency,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.info.price_object_rent,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.info.price_object_scale_factor,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_parcel_rent,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.info.price_group_create,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = EconomyData_Info::read_from(buffer)?;
        Ok(MessageInstance::EconomyData(EconomyData { info: info }))
    }
}

impl Message for AvatarPickerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block Data
        buffer.write(&self.data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPickerRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarPickerRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarPickerRequest(AvatarPickerRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        buffer.write_u8(self.agent_data.god_level)?;
        // Block Data
        buffer.write(&self.data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPickerRequestBackend_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarPickerRequestBackend_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarPickerRequestBackend(
            AvatarPickerRequestBackend {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for AvatarPickerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.avatar_id.as_bytes())?;
            buffer.write(&item.first_name[..])?;
            buffer.write(&item.last_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPickerReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarPickerReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarPickerReply(AvatarPickerReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        // Block QueryData
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write(&self.query_data.sim_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PlacesQuery_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = PlacesQuery_TransactionData::read_from(buffer)?;
        // Block QueryData
        let query_data = PlacesQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::PlacesQuery(PlacesQuery {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for PlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.query_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        // Block QueryData
        buffer.write_u8(self.query_data.len() as u8)?;
        for item in &self.query_data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.desc[..])?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
            buffer.write_i32::<LittleEndian>(item.billable_area)?;
            buffer.write_u8(item.flags)?;
            buffer.write_f32::<LittleEndian>(item.global_x)?;
            buffer.write_f32::<LittleEndian>(item.global_y)?;
            buffer.write_f32::<LittleEndian>(item.global_z)?;
            buffer.write(&item.sim_name[..])?;
            buffer.write(item.snapshot_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
            buffer.write_i32::<LittleEndian>(item.price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PlacesReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = PlacesReply_TransactionData::read_from(buffer)?;
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = buffer.read_u8()?;
        for _ in 0.._query_data_count {
            query_data.push(PlacesReply_QueryData::read_from(buffer)?);
        }
        Ok(MessageInstance::PlacesReply(PlacesReply {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirFindQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x1f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirFindQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirFindQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirFindQuery(DirFindQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirFindQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x20])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirFindQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirFindQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirFindQueryBackend(DirFindQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x21])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write(&self.query_data.sim_name[..])?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPlacesQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPlacesQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPlacesQuery(DirPlacesQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x22])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i8(self.query_data.category)?;
        buffer.write(&self.query_data.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPlacesQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPlacesQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPlacesQueryBackend(
            DirPlacesQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirPlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x23])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write_u8(self.query_data.len() as u8)?;
        for item in &self.query_data {
            buffer.write(item.query_id.as_bytes())?;
        }
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.for_sale as u8)?;
            buffer.write_u8(item.auction as u8)?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPlacesReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = buffer.read_u8()?;
        for _ in 0.._query_data_count {
            query_data.push(DirPlacesReply_QueryData::read_from(buffer)?);
        }
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPlacesReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirPlacesReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPlacesReply(DirPlacesReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirPeopleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x24])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write(&item.first_name[..])?;
            buffer.write(&item.last_name[..])?;
            buffer.write(&item.group[..])?;
            buffer.write_u8(item.online as u8)?;
            buffer.write_i32::<LittleEndian>(item.reputation)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPeopleReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPeopleReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPeopleReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPeopleReply(DirPeopleReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirEventsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x25])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write_u32::<LittleEndian>(item.event_id)?;
            buffer.write(&item.date[..])?;
            buffer.write_u32::<LittleEndian>(item.unix_time)?;
            buffer.write_u32::<LittleEndian>(item.event_flags)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirEventsReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirEventsReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirEventsReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirEventsReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirEventsReply(DirEventsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x26])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write(&item.group_name[..])?;
            buffer.write_i32::<LittleEndian>(item.members)?;
            buffer.write_f32::<LittleEndian>(item.search_order)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirGroupsReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirGroupsReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirGroupsReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirGroupsReply(DirGroupsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirClassifiedQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x27])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_u32::<LittleEndian>(self.query_data.category)?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirClassifiedQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirClassifiedQuery(DirClassifiedQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirClassifiedQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x28])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_u32::<LittleEndian>(self.query_data.category)?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirClassifiedQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirClassifiedQueryBackend(
            DirClassifiedQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x29])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.classified_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.classified_flags)?;
            buffer.write_u32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.expiration_date)?;
            buffer.write_i32::<LittleEndian>(item.price_for_listing)?;
        }
        // Block StatusData
        buffer.write_u8(self.status_data.len() as u8)?;
        for item in &self.status_data {
            buffer.write_u32::<LittleEndian>(item.status)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirClassifiedReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirClassifiedReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirClassifiedReply_QueryReplies::read_from(buffer)?);
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = buffer.read_u8()?;
        for _ in 0.._status_data_count {
            status_data.push(DirClassifiedReply_StatusData::read_from(buffer)?);
        }
        Ok(MessageInstance::DirClassifiedReply(DirClassifiedReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for AvatarClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.target_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.classified_id.as_bytes())?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarClassifiedReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarClassifiedReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarClassifiedReply(
            AvatarClassifiedReply {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ClassifiedInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ClassifiedInfoRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoRequest(
            ClassifiedInfoRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ClassifiedInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.creation_date)?;
        buffer.write_u32::<LittleEndian>(self.data.expiration_date)?;
        buffer.write_u32::<LittleEndian>(self.data.category)?;
        buffer.write(&self.data.name[..])?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.parent_estate)?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write(&self.data.parcel_name[..])?;
        buffer.write_u8(self.data.classified_flags)?;
        buffer.write_i32::<LittleEndian>(
            self.data.price_for_listing,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ClassifiedInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoReply(ClassifiedInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.category)?;
        buffer.write(&self.data.name[..])?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.parent_estate)?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_u8(self.data.classified_flags)?;
        buffer.write_i32::<LittleEndian>(
            self.data.price_for_listing,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ClassifiedInfoUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedInfoUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedInfoUpdate(
            ClassifiedInfoUpdate {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ClassifiedDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ClassifiedDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedDelete(ClassifiedDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x2f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.classified_id.as_bytes())?;
        buffer.write(self.data.query_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ClassifiedGodDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = ClassifiedGodDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::ClassifiedGodDelete(ClassifiedGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DirLandQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x30])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.search_type,
        )?;
        buffer.write_i32::<LittleEndian>(self.query_data.price)?;
        buffer.write_i32::<LittleEndian>(self.query_data.area)?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirLandQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirLandQuery(DirLandQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x31])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.search_type,
        )?;
        buffer.write_i32::<LittleEndian>(self.query_data.price)?;
        buffer.write_i32::<LittleEndian>(self.query_data.area)?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirLandQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirLandQueryBackend(DirLandQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x32])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.auction as u8)?;
            buffer.write_u8(item.for_sale as u8)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirLandReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirLandReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirLandReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirLandReply(DirLandReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirPopularQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x33])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPopularQuery_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularQuery_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPopularQuery(DirPopularQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPopularQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x34])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_u32::<LittleEndian>(self.query_data.estate_id)?;
        buffer.write_u8(self.query_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPopularQueryBackend_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularQueryBackend_QueryData::read_from(buffer)?;
        Ok(MessageInstance::DirPopularQueryBackend(
            DirPopularQueryBackend {
                agent_data: agent_data,
                query_data: query_data,
            },
        ))
    }
}

impl Message for DirPopularReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x35])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block QueryReplies
        buffer.write_u8(self.query_replies.len() as u8)?;
        for item in &self.query_replies {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write_f32::<LittleEndian>(item.dwell)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DirPopularReply_AgentData::read_from(buffer)?;
        // Block QueryData
        let query_data = DirPopularReply_QueryData::read_from(buffer)?;
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = buffer.read_u8()?;
        for _ in 0.._query_replies_count {
            query_replies.push(DirPopularReply_QueryReplies::read_from(buffer)?);
        }
        Ok(MessageInstance::DirPopularReply(DirPopularReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for ParcelInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x36])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.parcel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelInfoRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelInfoRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelInfoRequest(ParcelInfoRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x37])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write(&self.data.name[..])?;
        buffer.write(&self.data.desc[..])?;
        buffer.write_i32::<LittleEndian>(self.data.actual_area)?;
        buffer.write_i32::<LittleEndian>(self.data.billable_area)?;
        buffer.write_u8(self.data.flags)?;
        buffer.write_f32::<LittleEndian>(self.data.global_x)?;
        buffer.write_f32::<LittleEndian>(self.data.global_y)?;
        buffer.write_f32::<LittleEndian>(self.data.global_z)?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data.dwell)?;
        buffer.write_i32::<LittleEndian>(self.data.sale_price)?;
        buffer.write_i32::<LittleEndian>(self.data.auction_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelInfoReply(ParcelInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelObjectOwnersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x38])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelObjectOwnersRequest_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelObjectOwnersRequest_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelObjectOwnersRequest(
            ParcelObjectOwnersRequest {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelObjectOwnersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x39])?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.is_group_owned as u8)?;
            buffer.write_i32::<LittleEndian>(item.count)?;
            buffer.write_u8(item.online_status as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ParcelObjectOwnersReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelObjectOwnersReply(
            ParcelObjectOwnersReply { data: data },
        ))
    }
}

impl Message for GroupNoticesListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupNoticesListRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = GroupNoticesListRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticesListRequest(
            GroupNoticesListRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for GroupNoticesListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.notice_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.timestamp)?;
            buffer.write(&item.from_name[..])?;
            buffer.write(&item.subject[..])?;
            buffer.write_u8(item.has_attachment as u8)?;
            buffer.write_u8(item.asset_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupNoticesListReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(GroupNoticesListReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupNoticesListReply(
            GroupNoticesListReply {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for GroupNoticeRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_notice_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupNoticeRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = GroupNoticeRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticeRequest(GroupNoticeRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GroupNoticeAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block MessageBlock
        buffer.write(self.message_block.to_group_id.as_bytes())?;
        buffer.write(self.message_block.id.as_bytes())?;
        buffer.write_u8(self.message_block.dialog)?;
        buffer.write(&self.message_block.from_agent_name[..])?;
        buffer.write(&self.message_block.message[..])?;
        buffer.write(&self.message_block.binary_bucket[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupNoticeAdd_AgentData::read_from(buffer)?;
        // Block MessageBlock
        let message_block = GroupNoticeAdd_MessageBlock::read_from(buffer)?;
        Ok(MessageInstance::GroupNoticeAdd(GroupNoticeAdd {
            agent_data: agent_data,
            message_block: message_block,
        }))
    }
}

impl Message for TeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write(self.info.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;
        buffer.write_f32::<LittleEndian>(self.info.position.y)?;
        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = TeleportRequest_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportRequest(TeleportRequest {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for TeleportLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x3f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;
        buffer.write_f32::<LittleEndian>(self.info.position.y)?;
        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = TeleportLocationRequest_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportLocationRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLocationRequest(
            TeleportLocationRequest {
                agent_data: agent_data,
                info: info,
            },
        ))
    }
}

impl Message for TeleportLocal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x40])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.location_id)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;
        buffer.write_f32::<LittleEndian>(self.info.position.y)?;
        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportLocal_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLocal(TeleportLocal { info: info }))
    }
}

impl Message for TeleportLandmarkRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x41])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        buffer.write(self.info.landmark_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportLandmarkRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLandmarkRequest(
            TeleportLandmarkRequest { info: info },
        ))
    }
}

impl Message for TeleportProgress {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x42])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Info
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        buffer.write(&self.info.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = TeleportProgress_AgentData::read_from(buffer)?;
        // Block Info
        let info = TeleportProgress_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportProgress(TeleportProgress {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for DataHomeLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x43])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.info.kicked_from_estate_id,
        )?;
        // Block AgentInfo
        buffer.write_u32::<LittleEndian>(
            self.agent_info.agent_effective_maturity,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = DataHomeLocationRequest_Info::read_from(buffer)?;
        // Block AgentInfo
        let agent_info = DataHomeLocationRequest_AgentInfo::read_from(buffer)?;
        Ok(MessageInstance::DataHomeLocationRequest(
            DataHomeLocationRequest {
                info: info,
                agent_info: agent_info,
            },
        ))
    }
}

impl Message for DataHomeLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x44])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;
        buffer.write_f32::<LittleEndian>(self.info.position.y)?;
        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = DataHomeLocationReply_Info::read_from(buffer)?;
        Ok(MessageInstance::DataHomeLocationReply(
            DataHomeLocationReply { info: info },
        ))
    }
}

impl Message for TeleportFinish {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x45])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.location_id)?;
        buffer.write(&self.info.sim_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.info.sim_port)?;
        buffer.write_u64::<LittleEndian>(self.info.region_handle)?;
        buffer.write(&self.info.seed_capability[..])?;
        buffer.write_u8(self.info.sim_access)?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportFinish_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportFinish(
            TeleportFinish { info: info },
        ))
    }
}

impl Message for StartLure {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x46])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Info
        buffer.write_u8(self.info.lure_type)?;
        buffer.write(&self.info.message[..])?;
        // Block TargetData
        buffer.write_u8(self.target_data.len() as u8)?;
        for item in &self.target_data {
            buffer.write(item.target_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = StartLure_AgentData::read_from(buffer)?;
        // Block Info
        let info = StartLure_Info::read_from(buffer)?;
        // Block TargetData
        let mut target_data = Vec::new();
        let _target_data_count = buffer.read_u8()?;
        for _ in 0.._target_data_count {
            target_data.push(StartLure_TargetData::read_from(buffer)?);
        }
        Ok(MessageInstance::StartLure(StartLure {
            agent_data: agent_data,
            info: info,
            target_data: target_data,
        }))
    }
}

impl Message for TeleportLureRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x47])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        buffer.write(self.info.lure_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportLureRequest_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportLureRequest(
            TeleportLureRequest { info: info },
        ))
    }
}

impl Message for TeleportCancel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x48])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(self.info.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportCancel_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportCancel(
            TeleportCancel { info: info },
        ))
    }
}

impl Message for TeleportStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x49])?;
        // Block Info
        buffer.write_u32::<LittleEndian>(self.info.teleport_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportStart_Info::read_from(buffer)?;
        Ok(MessageInstance::TeleportStart(TeleportStart { info: info }))
    }
}

impl Message for TeleportFailed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4a])?;
        // Block Info
        buffer.write(self.info.agent_id.as_bytes())?;
        buffer.write(&self.info.reason[..])?;
        // Block AlertInfo
        buffer.write_u8(self.alert_info.len() as u8)?;
        for item in &self.alert_info {
            buffer.write(&item.message[..])?;
            buffer.write(&item.extra_params[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Info
        let info = TeleportFailed_Info::read_from(buffer)?;
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = buffer.read_u8()?;
        for _ in 0.._alert_info_count {
            alert_info.push(TeleportFailed_AlertInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::TeleportFailed(TeleportFailed {
            info: info,
            alert_info: alert_info,
        }))
    }
}

impl Message for Undo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = Undo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(Undo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::Undo(Undo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for Redo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = Redo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(Redo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::Redo(Redo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for UndoLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UndoLand_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UndoLand(
            UndoLand { agent_data: agent_data },
        ))
    }
}

impl Message for AgentPause {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentPause_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentPause(
            AgentPause { agent_data: agent_data },
        ))
    }
}

impl Message for AgentResume {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x4f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentResume_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentResume(
            AgentResume { agent_data: agent_data },
        ))
    }
}

impl Message for AgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_body_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_body_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_body_rotation.k)?;
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_head_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_head_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_head_rotation.k)?;
        buffer.write_u8(self.agent_data.state)?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_center.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_center.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_center.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_at_axis.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_at_axis.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_at_axis.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_left_axis.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_left_axis.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_left_axis.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_up_axis.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_up_axis.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.camera_up_axis.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.far)?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.control_flags,
        )?;
        buffer.write_u8(self.agent_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentUpdate(
            AgentUpdate { agent_data: agent_data },
        ))
    }
}

impl Message for ChatFromViewer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x50])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ChatData
        buffer.write(&self.chat_data.message[..])?;
        buffer.write_u8(self.chat_data.type_)?;
        buffer.write_i32::<LittleEndian>(self.chat_data.channel)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChatFromViewer_AgentData::read_from(buffer)?;
        // Block ChatData
        let chat_data = ChatFromViewer_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatFromViewer(ChatFromViewer {
            agent_data: agent_data,
            chat_data: chat_data,
        }))
    }
}

impl Message for AgentThrottle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x51])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.circuit_code,
        )?;
        // Block Throttle
        buffer.write_u32::<LittleEndian>(self.throttle.gen_counter)?;
        buffer.write(&self.throttle.throttles[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentThrottle_AgentData::read_from(buffer)?;
        // Block Throttle
        let throttle = AgentThrottle_Throttle::read_from(buffer)?;
        Ok(MessageInstance::AgentThrottle(AgentThrottle {
            agent_data: agent_data,
            throttle: throttle,
        }))
    }
}

impl Message for AgentFOV {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x52])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.circuit_code,
        )?;
        // Block FOVBlock
        buffer.write_u32::<LittleEndian>(self.fov_block.gen_counter)?;
        buffer.write_f32::<LittleEndian>(
            self.fov_block.vertical_angle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentFOV_AgentData::read_from(buffer)?;
        // Block FOVBlock
        let fov_block = AgentFOV_FOVBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentFOV(AgentFOV {
            agent_data: agent_data,
            fov_block: fov_block,
        }))
    }
}

impl Message for AgentHeightWidth {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x53])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.circuit_code,
        )?;
        // Block HeightWidthBlock
        buffer.write_u32::<LittleEndian>(
            self.height_width_block.gen_counter,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.height_width_block.height,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.height_width_block.width,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentHeightWidth_AgentData::read_from(buffer)?;
        // Block HeightWidthBlock
        let height_width_block = AgentHeightWidth_HeightWidthBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentHeightWidth(AgentHeightWidth {
            agent_data: agent_data,
            height_width_block: height_width_block,
        }))
    }
}

impl Message for AgentSetAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x54])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.cache_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
        }
        // Block ObjectData
        buffer.write(&self.object_data.texture_entry[..])?;
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentSetAppearance_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentSetAppearance_WearableData::read_from(buffer)?);
        }
        // Block ObjectData
        let object_data = AgentSetAppearance_ObjectData::read_from(buffer)?;
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(AgentSetAppearance_VisualParam::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentSetAppearance(AgentSetAppearance {
            agent_data: agent_data,
            wearable_data: wearable_data,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AgentAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x05])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AnimationList
        buffer.write_u8(self.animation_list.len() as u8)?;
        for item in &self.animation_list {
            buffer.write(item.anim_id.as_bytes())?;
            buffer.write_u8(item.start_anim as u8)?;
        }
        // Block PhysicalAvatarEventList
        buffer.write_u8(self.physical_avatar_event_list.len() as u8)?;
        for item in &self.physical_avatar_event_list {
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentAnimation_AgentData::read_from(buffer)?;
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = buffer.read_u8()?;
        for _ in 0.._animation_list_count {
            animation_list.push(AgentAnimation_AnimationList::read_from(buffer)?);
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = buffer.read_u8()?;
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list.push(AgentAnimation_PhysicalAvatarEventList::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentAnimation(AgentAnimation {
            agent_data: agent_data,
            animation_list: animation_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AgentRequestSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x06])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TargetObject
        buffer.write(self.target_object.target_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.target_object.offset.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.target_object.offset.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.target_object.offset.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentRequestSit_AgentData::read_from(buffer)?;
        // Block TargetObject
        let target_object = AgentRequestSit_TargetObject::read_from(buffer)?;
        Ok(MessageInstance::AgentRequestSit(AgentRequestSit {
            agent_data: agent_data,
            target_object: target_object,
        }))
    }
}

impl Message for AgentSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x07])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentSit_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentSit(
            AgentSit { agent_data: agent_data },
        ))
    }
}

impl Message for AgentQuitCopy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x55])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FuseBlock
        buffer.write_u32::<LittleEndian>(
            self.fuse_block.viewer_circuit_code,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentQuitCopy_AgentData::read_from(buffer)?;
        // Block FuseBlock
        let fuse_block = AgentQuitCopy_FuseBlock::read_from(buffer)?;
        Ok(MessageInstance::AgentQuitCopy(AgentQuitCopy {
            agent_data: agent_data,
            fuse_block: fuse_block,
        }))
    }
}

impl Message for RequestImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x08])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestImage
        buffer.write_u8(self.request_image.len() as u8)?;
        for item in &self.request_image {
            buffer.write(item.image.as_bytes())?;
            buffer.write_i8(item.discard_level)?;
            buffer.write_f32::<LittleEndian>(item.download_priority)?;
            buffer.write_u32::<LittleEndian>(item.packet)?;
            buffer.write_u8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestImage_AgentData::read_from(buffer)?;
        // Block RequestImage
        let mut request_image = Vec::new();
        let _request_image_count = buffer.read_u8()?;
        for _ in 0.._request_image_count {
            request_image.push(RequestImage_RequestImage::read_from(buffer)?);
        }
        Ok(MessageInstance::RequestImage(RequestImage {
            agent_data: agent_data,
            request_image: request_image,
        }))
    }
}

impl Message for ImageNotInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x56])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ImageID
        let image_id = ImageNotInDatabase_ImageID::read_from(buffer)?;
        Ok(MessageInstance::ImageNotInDatabase(
            ImageNotInDatabase { image_id: image_id },
        ))
    }
}

impl Message for RebakeAvatarTextures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x57])?;
        // Block TextureData
        buffer.write(self.texture_data.texture_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TextureData
        let texture_data = RebakeAvatarTextures_TextureData::read_from(buffer)?;
        Ok(MessageInstance::RebakeAvatarTextures(
            RebakeAvatarTextures { texture_data: texture_data },
        ))
    }
}

impl Message for SetAlwaysRun {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x58])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.always_run as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SetAlwaysRun_AgentData::read_from(buffer)?;
        Ok(MessageInstance::SetAlwaysRun(
            SetAlwaysRun { agent_data: agent_data },
        ))
    }
}

impl Message for ObjectAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x01])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.p_code)?;
        buffer.write_u8(self.object_data.material)?;
        buffer.write_u32::<LittleEndian>(self.object_data.add_flags)?;
        buffer.write_u8(self.object_data.path_curve)?;
        buffer.write_u8(self.object_data.profile_curve)?;
        buffer.write_u16::<LittleEndian>(
            self.object_data.path_begin,
        )?;
        buffer.write_u16::<LittleEndian>(self.object_data.path_end)?;
        buffer.write_u8(self.object_data.path_scale_x)?;
        buffer.write_u8(self.object_data.path_scale_y)?;
        buffer.write_u8(self.object_data.path_shear_x)?;
        buffer.write_u8(self.object_data.path_shear_y)?;
        buffer.write_i8(self.object_data.path_twist)?;
        buffer.write_i8(self.object_data.path_twist_begin)?;
        buffer.write_i8(self.object_data.path_radius_offset)?;
        buffer.write_i8(self.object_data.path_taper_x)?;
        buffer.write_i8(self.object_data.path_taper_y)?;
        buffer.write_u8(self.object_data.path_revolutions)?;
        buffer.write_i8(self.object_data.path_skew)?;
        buffer.write_u16::<LittleEndian>(
            self.object_data.profile_begin,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.object_data.profile_end,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.object_data.profile_hollow,
        )?;
        buffer.write_u8(self.object_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.ray_start.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.ray_start.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.ray_start.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.x)?;
        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.y)?;
        buffer.write_f32::<LittleEndian>(self.object_data.ray_end.z)?;
        buffer.write(self.object_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.object_data.ray_end_is_intersection)?;
        buffer.write_f32::<LittleEndian>(self.object_data.scale.x)?;
        buffer.write_f32::<LittleEndian>(self.object_data.scale.y)?;
        buffer.write_f32::<LittleEndian>(self.object_data.scale.z)?;
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_rotation.k)?;
        buffer.write_u8(self.object_data.state)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectAdd_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectAdd_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectAdd(ObjectAdd {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x59])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.force as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDelete_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDelete_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDelete(ObjectDelete {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block SharedData
        buffer.write_f32::<LittleEndian>(self.shared_data.offset.x)?;
        buffer.write_f32::<LittleEndian>(self.shared_data.offset.y)?;
        buffer.write_f32::<LittleEndian>(self.shared_data.offset.z)?;
        buffer.write_u32::<LittleEndian>(
            self.shared_data.duplicate_flags,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDuplicate_AgentData::read_from(buffer)?;
        // Block SharedData
        let shared_data = ObjectDuplicate_SharedData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDuplicate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDuplicate(ObjectDuplicate {
            agent_data: agent_data,
            shared_data: shared_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicateOnRay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.ray_start.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.ray_start.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.ray_start.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.z)?;
        buffer.write_u8(self.agent_data.bypass_raycast as u8)?;
        buffer.write_u8(
            self.agent_data.ray_end_is_intersection as u8,
        )?;
        buffer.write_u8(self.agent_data.copy_centers as u8)?;
        buffer.write_u8(self.agent_data.copy_rotates as u8)?;
        buffer.write(self.agent_data.ray_target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.duplicate_flags,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDuplicateOnRay_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDuplicateOnRay_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDuplicateOnRay(
            ObjectDuplicateOnRay {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for MultipleObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x02])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.type_)?;
            buffer.write(&item.data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MultipleObjectUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(MultipleObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::MultipleObjectUpdate(
            MultipleObjectUpdate {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RequestMultipleObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x03])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u8(item.cache_miss_type)?;
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestMultipleObjects_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(RequestMultipleObjects_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::RequestMultipleObjects(
            RequestMultipleObjects {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectPosition {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;
            buffer.write_f32::<LittleEndian>(item.position.y)?;
            buffer.write_f32::<LittleEndian>(item.position.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectPosition_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectPosition_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectPosition(ObjectPosition {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectScale {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_f32::<LittleEndian>(item.scale.x)?;
            buffer.write_f32::<LittleEndian>(item.scale.y)?;
            buffer.write_f32::<LittleEndian>(item.scale.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectScale_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectScale_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectScale(ObjectScale {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectRotation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            buffer.write_f32::<LittleEndian>(normed_rotation.i)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.j)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.k)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectRotation_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectRotation_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectRotation(ObjectRotation {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectFlagUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.object_local_id,
        )?;
        buffer.write_u8(self.agent_data.use_physics as u8)?;
        buffer.write_u8(self.agent_data.is_temporary as u8)?;
        buffer.write_u8(self.agent_data.is_phantom as u8)?;
        buffer.write_u8(self.agent_data.casts_shadows as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectFlagUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ObjectFlagUpdate(
            ObjectFlagUpdate { agent_data: agent_data },
        ))
    }
}

impl Message for ObjectClickAction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x5f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.click_action)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectClickAction_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectClickAction_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectClickAction(ObjectClickAction {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x60])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write(&item.media_url[..])?;
            buffer.write(&item.texture_entry[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectImage_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectImage_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectImage(ObjectImage {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectMaterial {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x61])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.material)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectMaterial_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectMaterial_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectMaterial(ObjectMaterial {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectShape {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x62])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.path_curve)?;
            buffer.write_u8(item.profile_curve)?;
            buffer.write_u16::<LittleEndian>(item.path_begin)?;
            buffer.write_u16::<LittleEndian>(item.path_end)?;
            buffer.write_u8(item.path_scale_x)?;
            buffer.write_u8(item.path_scale_y)?;
            buffer.write_u8(item.path_shear_x)?;
            buffer.write_u8(item.path_shear_y)?;
            buffer.write_i8(item.path_twist)?;
            buffer.write_i8(item.path_twist_begin)?;
            buffer.write_i8(item.path_radius_offset)?;
            buffer.write_i8(item.path_taper_x)?;
            buffer.write_i8(item.path_taper_y)?;
            buffer.write_u8(item.path_revolutions)?;
            buffer.write_i8(item.path_skew)?;
            buffer.write_u16::<LittleEndian>(item.profile_begin)?;
            buffer.write_u16::<LittleEndian>(item.profile_end)?;
            buffer.write_u16::<LittleEndian>(item.profile_hollow)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectShape_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectShape_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectShape(ObjectShape {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectExtraParams {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x63])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u16::<LittleEndian>(item.param_type)?;
            buffer.write_u8(item.param_in_use as u8)?;
            buffer.write_u32::<LittleEndian>(item.param_size)?;
            buffer.write(&item.param_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectExtraParams_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectExtraParams_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectExtraParams(ObjectExtraParams {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x64])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write_u8(self.header_data.override_ as u8)?;
        buffer.write(self.header_data.owner_id.as_bytes())?;
        buffer.write(self.header_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectOwner_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = ObjectOwner_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectOwner_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectOwner(ObjectOwner {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x65])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectGroup_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectGroup_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGroup(ObjectGroup {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x66])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.category_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectBuy_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectBuy_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectBuy(ObjectBuy {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for BuyObjectInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x67])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write(self.data.folder_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = BuyObjectInventory_AgentData::read_from(buffer)?;
        // Block Data
        let data = BuyObjectInventory_Data::read_from(buffer)?;
        Ok(MessageInstance::BuyObjectInventory(BuyObjectInventory {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DerezContainer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x68])?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_u8(self.data.delete as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = DerezContainer_Data::read_from(buffer)?;
        Ok(MessageInstance::DerezContainer(
            DerezContainer { data: data },
        ))
    }
}

impl Message for ObjectPermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x69])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write_u8(self.header_data.override_ as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.field)?;
            buffer.write_u8(item.set)?;
            buffer.write_u32::<LittleEndian>(item.mask)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectPermissions_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = ObjectPermissions_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectPermissions_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectPermissions(ObjectPermissions {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSaleInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectSaleInfo_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectSaleInfo_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectSaleInfo(ObjectSaleInfo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectName {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectName_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectName_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectName(ObjectName {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDescription {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write(&item.description[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDescription_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDescription_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDescription(ObjectDescription {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectCategory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
            buffer.write_u32::<LittleEndian>(item.category)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectCategory_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectCategory_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectCategory(ObjectCategory {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectSelect_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectSelect_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectSelect(ObjectSelect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDeselect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x6f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDeselect_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDeselect_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDeselect(ObjectDeselect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectAttach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x70])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.attachment_point)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            buffer.write_f32::<LittleEndian>(normed_rotation.i)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.j)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.k)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectAttach_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectAttach_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectAttach(ObjectAttach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDetach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x71])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDetach_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDetach_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDetach(ObjectDetach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDrop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x72])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDrop_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDrop_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDrop(ObjectDrop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectLink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x73])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectLink_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectLink_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectLink(ObjectLink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDelink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x74])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDelink_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectDelink_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDelink(ObjectDelink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x75])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.local_id)?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset.z,
        )?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;
            buffer.write_f32::<LittleEndian>(item.position.y)?;
            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;
            buffer.write_f32::<LittleEndian>(item.normal.y)?;
            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;
            buffer.write_f32::<LittleEndian>(item.binormal.y)?;
            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectGrab_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectGrab_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectGrab_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGrab(ObjectGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectGrabUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x76])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset_initial.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset_initial.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_offset_initial.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.object_data.grab_position.z,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.time_since_last,
        )?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;
            buffer.write_f32::<LittleEndian>(item.position.y)?;
            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;
            buffer.write_f32::<LittleEndian>(item.normal.y)?;
            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;
            buffer.write_f32::<LittleEndian>(item.binormal.y)?;
            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectGrabUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectGrabUpdate_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectGrabUpdate_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectGrabUpdate(ObjectGrabUpdate {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectDeGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x77])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(self.object_data.local_id)?;
        // Block SurfaceInfo
        buffer.write_u8(self.surface_info.len() as u8)?;
        for item in &self.surface_info {
            buffer.write_f32::<LittleEndian>(item.uv_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.uv_coord.z)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.x)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.y)?;
            buffer.write_f32::<LittleEndian>(item.st_coord.z)?;
            buffer.write_i32::<LittleEndian>(item.face_index)?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;
            buffer.write_f32::<LittleEndian>(item.position.y)?;
            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.normal.x)?;
            buffer.write_f32::<LittleEndian>(item.normal.y)?;
            buffer.write_f32::<LittleEndian>(item.normal.z)?;
            buffer.write_f32::<LittleEndian>(item.binormal.x)?;
            buffer.write_f32::<LittleEndian>(item.binormal.y)?;
            buffer.write_f32::<LittleEndian>(item.binormal.z)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectDeGrab_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectDeGrab_ObjectData::read_from(buffer)?;
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = buffer.read_u8()?;
        for _ in 0.._surface_info_count {
            surface_info.push(ObjectDeGrab_SurfaceInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectDeGrab(ObjectDeGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectSpinStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x78])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectSpinStart_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinStart_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinStart(ObjectSpinStart {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x79])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_rotation.k)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectSpinUpdate_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinUpdate_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinUpdate(ObjectSpinUpdate {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinStop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectSpinStop_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = ObjectSpinStop_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectSpinStop(ObjectSpinStop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectExportSelected {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(
            self.agent_data.volume_detail,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectExportSelected_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectExportSelected_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectExportSelected(
            ObjectExportSelected {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ModifyLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ModifyBlock
        buffer.write_u8(self.modify_block.action)?;
        buffer.write_u8(self.modify_block.brush_size)?;
        buffer.write_f32::<LittleEndian>(self.modify_block.seconds)?;
        buffer.write_f32::<LittleEndian>(self.modify_block.height)?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write_i32::<LittleEndian>(item.local_id)?;
            buffer.write_f32::<LittleEndian>(item.west)?;
            buffer.write_f32::<LittleEndian>(item.south)?;
            buffer.write_f32::<LittleEndian>(item.east)?;
            buffer.write_f32::<LittleEndian>(item.north)?;
        }
        // Block ModifyBlockExtended
        buffer.write_u8(self.modify_block_extended.len() as u8)?;
        for item in &self.modify_block_extended {
            buffer.write_f32::<LittleEndian>(item.brush_size)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ModifyLand_AgentData::read_from(buffer)?;
        // Block ModifyBlock
        let modify_block = ModifyLand_ModifyBlock::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ModifyLand_ParcelData::read_from(buffer)?);
        }
        // Block ModifyBlockExtended
        let mut modify_block_extended = Vec::new();
        let _modify_block_extended_count = buffer.read_u8()?;
        for _ in 0.._modify_block_extended_count {
            modify_block_extended.push(ModifyLand_ModifyBlockExtended::read_from(buffer)?);
        }
        Ok(MessageInstance::ModifyLand(ModifyLand {
            agent_data: agent_data,
            modify_block: modify_block,
            parcel_data: parcel_data,
            modify_block_extended: modify_block_extended,
        }))
    }
}

impl Message for VelocityInterpolateOn {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = VelocityInterpolateOn_AgentData::read_from(buffer)?;
        Ok(MessageInstance::VelocityInterpolateOn(
            VelocityInterpolateOn { agent_data: agent_data },
        ))
    }
}

impl Message for VelocityInterpolateOff {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = VelocityInterpolateOff_AgentData::read_from(buffer)?;
        Ok(MessageInstance::VelocityInterpolateOff(
            VelocityInterpolateOff { agent_data: agent_data },
        ))
    }
}

impl Message for StateSave {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x7f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block DataBlock
        buffer.write(&self.data_block.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = StateSave_AgentData::read_from(buffer)?;
        // Block DataBlock
        let data_block = StateSave_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::StateSave(StateSave {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for ReportAutosaveCrash {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x80])?;
        // Block AutosaveData
        buffer.write_i32::<LittleEndian>(self.autosave_data.pid)?;
        buffer.write_i32::<LittleEndian>(self.autosave_data.status)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AutosaveData
        let autosave_data = ReportAutosaveCrash_AutosaveData::read_from(buffer)?;
        Ok(MessageInstance::ReportAutosaveCrash(
            ReportAutosaveCrash { autosave_data: autosave_data },
        ))
    }
}

impl Message for SimWideDeletes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x81])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block DataBlock
        buffer.write(self.data_block.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SimWideDeletes_AgentData::read_from(buffer)?;
        // Block DataBlock
        let data_block = SimWideDeletes_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::SimWideDeletes(SimWideDeletes {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for RequestObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x05])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(
            self.object_data.request_flags,
        )?;
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestObjectPropertiesFamily_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = RequestObjectPropertiesFamily_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RequestObjectPropertiesFamily(
            RequestObjectPropertiesFamily {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for TrackAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x82])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TargetData
        buffer.write(self.target_data.prey_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = TrackAgent_AgentData::read_from(buffer)?;
        // Block TargetData
        let target_data = TrackAgent_TargetData::read_from(buffer)?;
        Ok(MessageInstance::TrackAgent(TrackAgent {
            agent_data: agent_data,
            target_data: target_data,
        }))
    }
}

impl Message for ViewerStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x83])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(&self.agent_data.ip.octets())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.start_time)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.run_time)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.sim_fps)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.fps)?;
        buffer.write_u8(self.agent_data.agents_in_view)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.ping)?;
        buffer.write_f64::<LittleEndian>(
            self.agent_data.meters_traveled,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.agent_data.regions_visited,
        )?;
        buffer.write_u32::<LittleEndian>(self.agent_data.sys_ram)?;
        buffer.write(&self.agent_data.sys_os[..])?;
        buffer.write(&self.agent_data.sys_cpu[..])?;
        buffer.write(&self.agent_data.sys_gpu[..])?;
        // Block DownloadTotals
        buffer.write_u32::<LittleEndian>(self.download_totals.world)?;
        buffer.write_u32::<LittleEndian>(
            self.download_totals.objects,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.download_totals.textures,
        )?;
        // Block NetStats
        for i in 0..2 {
            buffer.write_u32::<LittleEndian>(self.net_stats[i].bytes)?;
            buffer.write_u32::<LittleEndian>(self.net_stats[i].packets)?;
            buffer.write_u32::<LittleEndian>(
                self.net_stats[i].compressed,
            )?;
            buffer.write_u32::<LittleEndian>(self.net_stats[i].savings)?;
        }
        // Block FailStats
        buffer.write_u32::<LittleEndian>(
            self.fail_stats.send_packet,
        )?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.dropped)?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.resent)?;
        buffer.write_u32::<LittleEndian>(
            self.fail_stats.failed_resends,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.fail_stats.off_circuit,
        )?;
        buffer.write_u32::<LittleEndian>(self.fail_stats.invalid)?;
        // Block MiscStats
        buffer.write_u8(self.misc_stats.len() as u8)?;
        for item in &self.misc_stats {
            buffer.write_u32::<LittleEndian>(item.type_)?;
            buffer.write_f64::<LittleEndian>(item.value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ViewerStats_AgentData::read_from(buffer)?;
        // Block DownloadTotals
        let download_totals = ViewerStats_DownloadTotals::read_from(buffer)?;
        // Block NetStats
        let net_stats = [
            ViewerStats_NetStats::read_from(buffer)?,
            ViewerStats_NetStats::read_from(buffer)?,
        ];
        // Block FailStats
        let fail_stats = ViewerStats_FailStats::read_from(buffer)?;
        // Block MiscStats
        let mut misc_stats = Vec::new();
        let _misc_stats_count = buffer.read_u8()?;
        for _ in 0.._misc_stats_count {
            misc_stats.push(ViewerStats_MiscStats::read_from(buffer)?);
        }
        Ok(MessageInstance::ViewerStats(ViewerStats {
            agent_data: agent_data,
            download_totals: download_totals,
            net_stats: net_stats,
            fail_stats: fail_stats,
            misc_stats: misc_stats,
        }))
    }
}

impl Message for ScriptAnswerYes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x84])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.task_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.questions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ScriptAnswerYes_AgentData::read_from(buffer)?;
        // Block Data
        let data = ScriptAnswerYes_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptAnswerYes(ScriptAnswerYes {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for UserReport {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x85])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ReportData
        buffer.write_u8(self.report_data.report_type)?;
        buffer.write_u8(self.report_data.category)?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.report_data.position.z,
        )?;
        buffer.write_u8(self.report_data.check_flags)?;
        buffer.write(self.report_data.screenshot_id.as_bytes())?;
        buffer.write(self.report_data.object_id.as_bytes())?;
        buffer.write(self.report_data.abuser_id.as_bytes())?;
        buffer.write(&self.report_data.abuse_region_name[..])?;
        buffer.write(self.report_data.abuse_region_id.as_bytes())?;
        buffer.write(&self.report_data.summary[..])?;
        buffer.write(&self.report_data.details[..])?;
        buffer.write(&self.report_data.version_string[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UserReport_AgentData::read_from(buffer)?;
        // Block ReportData
        let report_data = UserReport_ReportData::read_from(buffer)?;
        Ok(MessageInstance::UserReport(UserReport {
            agent_data: agent_data,
            report_data: report_data,
        }))
    }
}

impl Message for AlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x86])?;
        // Block AlertData
        buffer.write(&self.alert_data.message[..])?;
        // Block AlertInfo
        buffer.write_u8(self.alert_info.len() as u8)?;
        for item in &self.alert_info {
            buffer.write(&item.message[..])?;
            buffer.write(&item.extra_params[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AlertData
        let alert_data = AlertMessage_AlertData::read_from(buffer)?;
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = buffer.read_u8()?;
        for _ in 0.._alert_info_count {
            alert_info.push(AlertMessage_AlertInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::AlertMessage(AlertMessage {
            alert_data: alert_data,
            alert_info: alert_info,
        }))
    }
}

impl Message for AgentAlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x87])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block AlertData
        buffer.write_u8(self.alert_data.modal as u8)?;
        buffer.write(&self.alert_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentAlertMessage_AgentData::read_from(buffer)?;
        // Block AlertData
        let alert_data = AgentAlertMessage_AlertData::read_from(buffer)?;
        Ok(MessageInstance::AgentAlertMessage(AgentAlertMessage {
            agent_data: agent_data,
            alert_data: alert_data,
        }))
    }
}

impl Message for MeanCollisionAlert {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x88])?;
        // Block MeanCollision
        buffer.write_u8(self.mean_collision.len() as u8)?;
        for item in &self.mean_collision {
            buffer.write(item.victim.as_bytes())?;
            buffer.write(item.perp.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.time)?;
            buffer.write_f32::<LittleEndian>(item.mag)?;
            buffer.write_u8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MeanCollision
        let mut mean_collision = Vec::new();
        let _mean_collision_count = buffer.read_u8()?;
        for _ in 0.._mean_collision_count {
            mean_collision.push(MeanCollisionAlert_MeanCollision::read_from(buffer)?);
        }
        Ok(MessageInstance::MeanCollisionAlert(
            MeanCollisionAlert { mean_collision: mean_collision },
        ))
    }
}

impl Message for ViewerFrozenMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x89])?;
        // Block FrozenData
        buffer.write_u8(self.frozen_data.data as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block FrozenData
        let frozen_data = ViewerFrozenMessage_FrozenData::read_from(buffer)?;
        Ok(MessageInstance::ViewerFrozenMessage(
            ViewerFrozenMessage { frozen_data: frozen_data },
        ))
    }
}

impl Message for HealthMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8a])?;
        // Block HealthData
        buffer.write_f32::<LittleEndian>(self.health_data.health)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block HealthData
        let health_data = HealthMessage_HealthData::read_from(buffer)?;
        Ok(MessageInstance::HealthMessage(
            HealthMessage { health_data: health_data },
        ))
    }
}

impl Message for ChatFromSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8b])?;
        // Block ChatData
        buffer.write(&self.chat_data.from_name[..])?;
        buffer.write(self.chat_data.source_id.as_bytes())?;
        buffer.write(self.chat_data.owner_id.as_bytes())?;
        buffer.write_u8(self.chat_data.source_type)?;
        buffer.write_u8(self.chat_data.chat_type)?;
        buffer.write_u8(self.chat_data.audible)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.x)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.y)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.z)?;
        buffer.write(&self.chat_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ChatData
        let chat_data = ChatFromSimulator_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatFromSimulator(
            ChatFromSimulator { chat_data: chat_data },
        ))
    }
}

impl Message for SimStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8c])?;
        // Block Region
        buffer.write_u32::<LittleEndian>(self.region.region_x)?;
        buffer.write_u32::<LittleEndian>(self.region.region_y)?;
        buffer.write_u32::<LittleEndian>(self.region.region_flags)?;
        buffer.write_u32::<LittleEndian>(
            self.region.object_capacity,
        )?;
        // Block Stat
        buffer.write_u8(self.stat.len() as u8)?;
        for item in &self.stat {
            buffer.write_u32::<LittleEndian>(item.stat_id)?;
            buffer.write_f32::<LittleEndian>(item.stat_value)?;
        }
        // Block PidStat
        buffer.write_i32::<LittleEndian>(self.pid_stat.pid)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Region
        let region = SimStats_Region::read_from(buffer)?;
        // Block Stat
        let mut stat = Vec::new();
        let _stat_count = buffer.read_u8()?;
        for _ in 0.._stat_count {
            stat.push(SimStats_Stat::read_from(buffer)?);
        }
        // Block PidStat
        let pid_stat = SimStats_PidStat::read_from(buffer)?;
        Ok(MessageInstance::SimStats(SimStats {
            region: region,
            stat: stat,
            pid_stat: pid_stat,
        }))
    }
}

impl Message for RequestRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestRegionInfo_AgentData::read_from(buffer)?;
        Ok(MessageInstance::RequestRegionInfo(
            RequestRegionInfo { agent_data: agent_data },
        ))
    }
}

impl Message for RegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.region_info.estate_id)?;
        buffer.write_u32::<LittleEndian>(
            self.region_info.parent_estate_id,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.region_info.region_flags,
        )?;
        buffer.write_u8(self.region_info.sim_access)?;
        buffer.write_u8(self.region_info.max_agents)?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.billable_factor,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.object_bonus_factor,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.water_height,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_raise_limit,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_lower_limit,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.price_per_meter,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.redirect_grid_x,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.redirect_grid_y,
        )?;
        buffer.write_u8(self.region_info.use_estate_sun as u8)?;
        buffer.write_f32::<LittleEndian>(self.region_info.sun_hour)?;
        // Block RegionInfo2
        buffer.write(&self.region_info2.product_sku[..])?;
        buffer.write(&self.region_info2.product_name[..])?;
        buffer.write_u32::<LittleEndian>(
            self.region_info2.max_agents32,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.region_info2.hard_max_agents,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.region_info2.hard_max_objects,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RegionInfo_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = RegionInfo_RegionInfo::read_from(buffer)?;
        // Block RegionInfo2
        let region_info2 = RegionInfo_RegionInfo2::read_from(buffer)?;
        Ok(MessageInstance::RegionInfo(RegionInfo {
            agent_data: agent_data,
            region_info: region_info,
            region_info2: region_info2,
        }))
    }
}

impl Message for GodUpdateRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x8f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(self.region_info.estate_id)?;
        buffer.write_u32::<LittleEndian>(
            self.region_info.parent_estate_id,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.region_info.region_flags,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.billable_factor,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.price_per_meter,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.redirect_grid_x,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info.redirect_grid_y,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GodUpdateRegionInfo_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = GodUpdateRegionInfo_RegionInfo::read_from(buffer)?;
        Ok(MessageInstance::GodUpdateRegionInfo(GodUpdateRegionInfo {
            agent_data: agent_data,
            region_info: region_info,
        }))
    }
}

impl Message for NearestLandingRegionRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x90])?;
        // Block RequestingRegionData
        buffer.write_u64::<LittleEndian>(
            self.requesting_region_data.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RequestingRegionData
        let requesting_region_data = NearestLandingRegionRequest_RequestingRegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionRequest(
            NearestLandingRegionRequest {
                requesting_region_data: requesting_region_data,
            },
        ))
    }
}

impl Message for NearestLandingRegionReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x91])?;
        // Block LandingRegionData
        buffer.write_u64::<LittleEndian>(
            self.landing_region_data.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block LandingRegionData
        let landing_region_data = NearestLandingRegionReply_LandingRegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionReply(
            NearestLandingRegionReply {
                landing_region_data: landing_region_data,
            },
        ))
    }
}

impl Message for NearestLandingRegionUpdated {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x92])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = NearestLandingRegionUpdated_RegionData::read_from(buffer)?;
        Ok(MessageInstance::NearestLandingRegionUpdated(
            NearestLandingRegionUpdated { region_data: region_data },
        ))
    }
}

impl Message for TeleportLandingStatusChanged {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x93])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = TeleportLandingStatusChanged_RegionData::read_from(buffer)?;
        Ok(MessageInstance::TeleportLandingStatusChanged(
            TeleportLandingStatusChanged { region_data: region_data },
        ))
    }
}

impl Message for RegionHandshake {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x94])?;
        // Block RegionInfo
        buffer.write_u32::<LittleEndian>(
            self.region_info.region_flags,
        )?;
        buffer.write_u8(self.region_info.sim_access)?;
        buffer.write(&self.region_info.sim_name[..])?;
        buffer.write(self.region_info.sim_owner.as_bytes())?;
        buffer.write_u8(self.region_info.is_estate_manager as u8)?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.water_height,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.billable_factor,
        )?;
        buffer.write(self.region_info.cache_id.as_bytes())?;
        buffer.write(self.region_info.terrain_base0.as_bytes())?;
        buffer.write(self.region_info.terrain_base1.as_bytes())?;
        buffer.write(self.region_info.terrain_base2.as_bytes())?;
        buffer.write(self.region_info.terrain_base3.as_bytes())?;
        buffer.write(self.region_info.terrain_detail0.as_bytes())?;
        buffer.write(self.region_info.terrain_detail1.as_bytes())?;
        buffer.write(self.region_info.terrain_detail2.as_bytes())?;
        buffer.write(self.region_info.terrain_detail3.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_start_height00,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_start_height01,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_start_height10,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_start_height11,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_height_range00,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_height_range01,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_height_range10,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.region_info.terrain_height_range11,
        )?;
        // Block RegionInfo2
        buffer.write(self.region_info2.region_id.as_bytes())?;
        // Block RegionInfo3
        buffer.write_i32::<LittleEndian>(
            self.region_info3.cpu_class_id,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.region_info3.cpu_ratio,
        )?;
        buffer.write(&self.region_info3.colo_name[..])?;
        buffer.write(&self.region_info3.product_sku[..])?;
        buffer.write(&self.region_info3.product_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionInfo
        let region_info = RegionHandshake_RegionInfo::read_from(buffer)?;
        // Block RegionInfo2
        let region_info2 = RegionHandshake_RegionInfo2::read_from(buffer)?;
        // Block RegionInfo3
        let region_info3 = RegionHandshake_RegionInfo3::read_from(buffer)?;
        Ok(MessageInstance::RegionHandshake(RegionHandshake {
            region_info: region_info,
            region_info2: region_info2,
            region_info3: region_info3,
        }))
    }
}

impl Message for RegionHandshakeReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x95])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionInfo
        buffer.write_u32::<LittleEndian>(self.region_info.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RegionHandshakeReply_AgentData::read_from(buffer)?;
        // Block RegionInfo
        let region_info = RegionHandshakeReply_RegionInfo::read_from(buffer)?;
        Ok(MessageInstance::RegionHandshakeReply(
            RegionHandshakeReply {
                agent_data: agent_data,
                region_info: region_info,
            },
        ))
    }
}

impl Message for CoarseLocationUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x06])?;
        // Block Location
        buffer.write_u8(self.location.len() as u8)?;
        for item in &self.location {
            buffer.write_u8(item.x)?;
            buffer.write_u8(item.y)?;
            buffer.write_u8(item.z)?;
        }
        // Block Index
        buffer.write_i16::<LittleEndian>(self.index.you)?;
        buffer.write_i16::<LittleEndian>(self.index.prey)?;
        // Block AgentData
        buffer.write_u8(self.agent_data.len() as u8)?;
        for item in &self.agent_data {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Location
        let mut location = Vec::new();
        let _location_count = buffer.read_u8()?;
        for _ in 0.._location_count {
            location.push(CoarseLocationUpdate_Location::read_from(buffer)?);
        }
        // Block Index
        let index = CoarseLocationUpdate_Index::read_from(buffer)?;
        // Block AgentData
        let mut agent_data = Vec::new();
        let _agent_data_count = buffer.read_u8()?;
        for _ in 0.._agent_data_count {
            agent_data.push(CoarseLocationUpdate_AgentData::read_from(buffer)?);
        }
        Ok(MessageInstance::CoarseLocationUpdate(
            CoarseLocationUpdate {
                location: location,
                index: index,
                agent_data: agent_data,
            },
        ))
    }
}

impl Message for ImageData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x09])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        buffer.write_u8(self.image_id.codec)?;
        buffer.write_u32::<LittleEndian>(self.image_id.size)?;
        buffer.write_u16::<LittleEndian>(self.image_id.packets)?;
        // Block ImageData
        buffer.write(&self.image_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ImageID
        let image_id = ImageData_ImageID::read_from(buffer)?;
        // Block ImageData
        let image_data = ImageData_ImageData::read_from(buffer)?;
        Ok(MessageInstance::ImageData(ImageData {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for ImagePacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0a])?;
        // Block ImageID
        buffer.write(self.image_id.id.as_bytes())?;
        buffer.write_u16::<LittleEndian>(self.image_id.packet)?;
        // Block ImageData
        buffer.write(&self.image_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ImageID
        let image_id = ImagePacket_ImageID::read_from(buffer)?;
        // Block ImageData
        let image_data = ImagePacket_ImageData::read_from(buffer)?;
        Ok(MessageInstance::ImagePacket(ImagePacket {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for LayerData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0b])?;
        // Block LayerID
        buffer.write_u8(self.layer_id.type_)?;
        // Block LayerData
        buffer.write(&self.layer_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block LayerID
        let layer_id = LayerData_LayerID::read_from(buffer)?;
        // Block LayerData
        let layer_data = LayerData_LayerData::read_from(buffer)?;
        Ok(MessageInstance::LayerData(LayerData {
            layer_id: layer_id,
            layer_data: layer_data,
        }))
    }
}

impl Message for ObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0c])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.region_data.time_dilation,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
            buffer.write_u8(item.state)?;
            buffer.write(item.full_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
            buffer.write_u8(item.p_code)?;
            buffer.write_u8(item.material)?;
            buffer.write_u8(item.click_action)?;
            buffer.write_f32::<LittleEndian>(item.scale.x)?;
            buffer.write_f32::<LittleEndian>(item.scale.y)?;
            buffer.write_f32::<LittleEndian>(item.scale.z)?;
            buffer.write(&item.object_data[..])?;
            buffer.write_u32::<LittleEndian>(item.parent_id)?;
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
            buffer.write_u8(item.path_curve)?;
            buffer.write_u8(item.profile_curve)?;
            buffer.write_u16::<LittleEndian>(item.path_begin)?;
            buffer.write_u16::<LittleEndian>(item.path_end)?;
            buffer.write_u8(item.path_scale_x)?;
            buffer.write_u8(item.path_scale_y)?;
            buffer.write_u8(item.path_shear_x)?;
            buffer.write_u8(item.path_shear_y)?;
            buffer.write_i8(item.path_twist)?;
            buffer.write_i8(item.path_twist_begin)?;
            buffer.write_i8(item.path_radius_offset)?;
            buffer.write_i8(item.path_taper_x)?;
            buffer.write_i8(item.path_taper_y)?;
            buffer.write_u8(item.path_revolutions)?;
            buffer.write_i8(item.path_skew)?;
            buffer.write_u16::<LittleEndian>(item.profile_begin)?;
            buffer.write_u16::<LittleEndian>(item.profile_end)?;
            buffer.write_u16::<LittleEndian>(item.profile_hollow)?;
            buffer.write(&item.texture_entry[..])?;
            buffer.write(&item.texture_anim[..])?;
            buffer.write(&item.name_value[..])?;
            buffer.write(&item.data[..])?;
            buffer.write(&item.text[..])?;
            buffer.write(&item.text_color)?;
            buffer.write(&item.media_url[..])?;
            buffer.write(&item.ps_block[..])?;
            buffer.write(&item.extra_params[..])?;
            buffer.write(item.sound.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.gain)?;
            buffer.write_u8(item.flags)?;
            buffer.write_f32::<LittleEndian>(item.radius)?;
            buffer.write_u8(item.joint_type)?;
            buffer.write_f32::<LittleEndian>(item.joint_pivot.x)?;
            buffer.write_f32::<LittleEndian>(item.joint_pivot.y)?;
            buffer.write_f32::<LittleEndian>(item.joint_pivot.z)?;
            buffer.write_f32::<LittleEndian>(
                item.joint_axis_or_anchor.x,
            )?;
            buffer.write_f32::<LittleEndian>(
                item.joint_axis_or_anchor.y,
            )?;
            buffer.write_f32::<LittleEndian>(
                item.joint_axis_or_anchor.z,
            )?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = ObjectUpdate_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdate(ObjectUpdate {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdateCompressed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0d])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.region_data.time_dilation,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
            buffer.write(&item.data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = ObjectUpdateCompressed_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdateCompressed_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdateCompressed(
            ObjectUpdateCompressed {
                region_data: region_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for ObjectUpdateCached {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0e])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.region_data.time_dilation,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
            buffer.write_u32::<LittleEndian>(item.update_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = ObjectUpdateCached_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectUpdateCached_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectUpdateCached(ObjectUpdateCached {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ImprovedTerseObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x0f])?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        buffer.write_u16::<LittleEndian>(
            self.region_data.time_dilation,
        )?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(&item.data[..])?;
            buffer.write(&item.texture_entry[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let region_data = ImprovedTerseObjectUpdate_RegionData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ImprovedTerseObjectUpdate_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ImprovedTerseObjectUpdate(
            ImprovedTerseObjectUpdate {
                region_data: region_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for KillObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x10])?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(KillObject_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::KillObject(
            KillObject { object_data: object_data },
        ))
    }
}

impl Message for CrossedRegion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x07])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RegionData
        buffer.write(&self.region_data.sim_ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.region_data.sim_port)?;
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        buffer.write(&self.region_data.seed_capability[..])?;
        // Block Info
        buffer.write_f32::<LittleEndian>(self.info.position.x)?;
        buffer.write_f32::<LittleEndian>(self.info.position.y)?;
        buffer.write_f32::<LittleEndian>(self.info.position.z)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.info.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CrossedRegion_AgentData::read_from(buffer)?;
        // Block RegionData
        let region_data = CrossedRegion_RegionData::read_from(buffer)?;
        // Block Info
        let info = CrossedRegion_Info::read_from(buffer)?;
        Ok(MessageInstance::CrossedRegion(CrossedRegion {
            agent_data: agent_data,
            region_data: region_data,
            info: info,
        }))
    }
}

impl Message for SimulatorViewerTimeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x96])?;
        // Block TimeInfo
        buffer.write_u64::<LittleEndian>(
            self.time_info.usec_since_start,
        )?;
        buffer.write_u32::<LittleEndian>(self.time_info.sec_per_day)?;
        buffer.write_u32::<LittleEndian>(
            self.time_info.sec_per_year,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_direction.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_direction.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_direction.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.time_info.sun_phase)?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_ang_velocity.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_ang_velocity.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.time_info.sun_ang_velocity.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TimeInfo
        let time_info = SimulatorViewerTimeMessage_TimeInfo::read_from(buffer)?;
        Ok(MessageInstance::SimulatorViewerTimeMessage(
            SimulatorViewerTimeMessage { time_info: time_info },
        ))
    }
}

impl Message for EnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x97])?;
        // Block SimulatorInfo
        buffer.write_u64::<LittleEndian>(self.simulator_info.handle)?;
        buffer.write(&self.simulator_info.ip.octets())?;
        buffer.write_u16::<LittleEndian>(self.simulator_info.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimulatorInfo
        let simulator_info = EnableSimulator_SimulatorInfo::read_from(buffer)?;
        Ok(MessageInstance::EnableSimulator(
            EnableSimulator { simulator_info: simulator_info },
        ))
    }
}

impl Message for DisableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x98])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::DisableSimulator(DisableSimulator {}))
    }
}

impl Message for ConfirmEnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x08])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ConfirmEnableSimulator_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ConfirmEnableSimulator(
            ConfirmEnableSimulator { agent_data: agent_data },
        ))
    }
}

impl Message for TransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x99])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_info.channel_type,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_info.source_type,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.transfer_info.priority,
        )?;
        buffer.write(&self.transfer_info.params[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransferInfo
        let transfer_info = TransferRequest_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferRequest(
            TransferRequest { transfer_info: transfer_info },
        ))
    }
}

impl Message for TransferInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9a])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_info.channel_type,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_info.target_type,
        )?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.status)?;
        buffer.write_i32::<LittleEndian>(self.transfer_info.size)?;
        buffer.write(&self.transfer_info.params[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransferInfo
        let transfer_info = TransferInfo_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferInfo(
            TransferInfo { transfer_info: transfer_info },
        ))
    }
}

impl Message for TransferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x11])?;
        // Block TransferData
        buffer.write(self.transfer_data.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_data.channel_type,
        )?;
        buffer.write_i32::<LittleEndian>(self.transfer_data.packet)?;
        buffer.write_i32::<LittleEndian>(self.transfer_data.status)?;
        buffer.write(&self.transfer_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransferData
        let transfer_data = TransferPacket_TransferData::read_from(buffer)?;
        Ok(MessageInstance::TransferPacket(
            TransferPacket { transfer_data: transfer_data },
        ))
    }
}

impl Message for TransferAbort {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9b])?;
        // Block TransferInfo
        buffer.write(self.transfer_info.transfer_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.transfer_info.channel_type,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransferInfo
        let transfer_info = TransferAbort_TransferInfo::read_from(buffer)?;
        Ok(MessageInstance::TransferAbort(
            TransferAbort { transfer_info: transfer_info },
        ))
    }
}

impl Message for RequestXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9c])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write(&self.xfer_id.filename[..])?;
        buffer.write_u8(self.xfer_id.file_path)?;
        buffer.write_u8(self.xfer_id.delete_on_completion as u8)?;
        buffer.write_u8(self.xfer_id.use_big_packets as u8)?;
        buffer.write(self.xfer_id.v_file_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(self.xfer_id.v_file_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block XferID
        let xfer_id = RequestXfer_XferID::read_from(buffer)?;
        Ok(MessageInstance::RequestXfer(
            RequestXfer { xfer_id: xfer_id },
        ))
    }
}

impl Message for SendXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x12])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_u32::<LittleEndian>(self.xfer_id.packet)?;
        // Block DataPacket
        buffer.write(&self.data_packet.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block XferID
        let xfer_id = SendXferPacket_XferID::read_from(buffer)?;
        // Block DataPacket
        let data_packet = SendXferPacket_DataPacket::read_from(buffer)?;
        Ok(MessageInstance::SendXferPacket(SendXferPacket {
            xfer_id: xfer_id,
            data_packet: data_packet,
        }))
    }
}

impl Message for ConfirmXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x13])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_u32::<LittleEndian>(self.xfer_id.packet)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block XferID
        let xfer_id = ConfirmXferPacket_XferID::read_from(buffer)?;
        Ok(MessageInstance::ConfirmXferPacket(
            ConfirmXferPacket { xfer_id: xfer_id },
        ))
    }
}

impl Message for AbortXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9d])?;
        // Block XferID
        buffer.write_u64::<LittleEndian>(self.xfer_id.id)?;
        buffer.write_i32::<LittleEndian>(self.xfer_id.result)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block XferID
        let xfer_id = AbortXfer_XferID::read_from(buffer)?;
        Ok(MessageInstance::AbortXfer(AbortXfer { xfer_id: xfer_id }))
    }
}

impl Message for AvatarAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x14])?;
        // Block Sender
        buffer.write(self.sender.id.as_bytes())?;
        // Block AnimationList
        buffer.write_u8(self.animation_list.len() as u8)?;
        for item in &self.animation_list {
            buffer.write(item.anim_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.anim_sequence_id)?;
        }
        // Block AnimationSourceList
        buffer.write_u8(self.animation_source_list.len() as u8)?;
        for item in &self.animation_source_list {
            buffer.write(item.object_id.as_bytes())?;
        }
        // Block PhysicalAvatarEventList
        buffer.write_u8(self.physical_avatar_event_list.len() as u8)?;
        for item in &self.physical_avatar_event_list {
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Sender
        let sender = AvatarAnimation_Sender::read_from(buffer)?;
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = buffer.read_u8()?;
        for _ in 0.._animation_list_count {
            animation_list.push(AvatarAnimation_AnimationList::read_from(buffer)?);
        }
        // Block AnimationSourceList
        let mut animation_source_list = Vec::new();
        let _animation_source_list_count = buffer.read_u8()?;
        for _ in 0.._animation_source_list_count {
            animation_source_list.push(AvatarAnimation_AnimationSourceList::read_from(buffer)?);
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = buffer.read_u8()?;
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list.push(AvatarAnimation_PhysicalAvatarEventList::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarAnimation(AvatarAnimation {
            sender: sender,
            animation_list: animation_list,
            animation_source_list: animation_source_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AvatarAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9e])?;
        // Block Sender
        buffer.write(self.sender.id.as_bytes())?;
        buffer.write_u8(self.sender.is_trial as u8)?;
        // Block ObjectData
        buffer.write(&self.object_data.texture_entry[..])?;
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Sender
        let sender = AvatarAppearance_Sender::read_from(buffer)?;
        // Block ObjectData
        let object_data = AvatarAppearance_ObjectData::read_from(buffer)?;
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(AvatarAppearance_VisualParam::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarAppearance(AvatarAppearance {
            sender: sender,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AvatarSitResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x15])?;
        // Block SitObject
        buffer.write(self.sit_object.id.as_bytes())?;
        // Block SitTransform
        buffer.write_u8(self.sit_transform.auto_pilot as u8)?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.sit_position.z,
        )?;
        let normed_sit_rotation = UnitQuaternion::new(&self.sit_transform.sit_rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_sit_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_sit_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_sit_rotation.k)?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_eye_offset.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_eye_offset.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_eye_offset.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_at_offset.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_at_offset.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.sit_transform.camera_at_offset.z,
        )?;
        buffer.write_u8(self.sit_transform.force_mouselook as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SitObject
        let sit_object = AvatarSitResponse_SitObject::read_from(buffer)?;
        // Block SitTransform
        let sit_transform = AvatarSitResponse_SitTransform::read_from(buffer)?;
        Ok(MessageInstance::AvatarSitResponse(AvatarSitResponse {
            sit_object: sit_object,
            sit_transform: sit_transform,
        }))
    }
}

impl Message for SetFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0x9f])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        // Block CameraProperty
        buffer.write_u8(self.camera_property.len() as u8)?;
        for item in &self.camera_property {
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.value)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = SetFollowCamProperties_ObjectData::read_from(buffer)?;
        // Block CameraProperty
        let mut camera_property = Vec::new();
        let _camera_property_count = buffer.read_u8()?;
        for _ in 0.._camera_property_count {
            camera_property.push(SetFollowCamProperties_CameraProperty::read_from(buffer)?);
        }
        Ok(MessageInstance::SetFollowCamProperties(
            SetFollowCamProperties {
                object_data: object_data,
                camera_property: camera_property,
            },
        ))
    }
}

impl Message for ClearFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa0])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = ClearFollowCamProperties_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ClearFollowCamProperties(
            ClearFollowCamProperties { object_data: object_data },
        ))
    }
}

impl Message for CameraConstraint {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x16])?;
        // Block CameraCollidePlane
        buffer.write_f32::<LittleEndian>(
            self.camera_collide_plane.plane.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.camera_collide_plane.plane.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.camera_collide_plane.plane.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.camera_collide_plane.plane.w,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block CameraCollidePlane
        let camera_collide_plane = CameraConstraint_CameraCollidePlane::read_from(buffer)?;
        Ok(MessageInstance::CameraConstraint(CameraConstraint {
            camera_collide_plane: camera_collide_plane,
        }))
    }
}

impl Message for ObjectProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x09])?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_i32::<LittleEndian>(item.ownership_cost)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write_u8(item.aggregate_perms)?;
            buffer.write_u8(item.aggregate_perm_textures)?;
            buffer.write_u8(item.aggregate_perm_textures_owner)?;
            buffer.write_u32::<LittleEndian>(item.category)?;
            buffer.write_i16::<LittleEndian>(item.inventory_serial)?;
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.from_task_id.as_bytes())?;
            buffer.write(item.last_owner_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write(&item.touch_name[..])?;
            buffer.write(&item.sit_name[..])?;
            buffer.write(&item.texture_id[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectProperties_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectProperties(
            ObjectProperties { object_data: object_data },
        ))
    }
}

impl Message for ObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0a])?;
        // Block ObjectData
        buffer.write_u32::<LittleEndian>(
            self.object_data.request_flags,
        )?;
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write(self.object_data.owner_id.as_bytes())?;
        buffer.write(self.object_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.object_data.base_mask)?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.next_owner_mask,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.object_data.ownership_cost,
        )?;
        buffer.write_u8(self.object_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.object_data.sale_price,
        )?;
        buffer.write_u32::<LittleEndian>(self.object_data.category)?;
        buffer.write(self.object_data.last_owner_id.as_bytes())?;
        buffer.write(&self.object_data.name[..])?;
        buffer.write(&self.object_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = ObjectPropertiesFamily_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::ObjectPropertiesFamily(
            ObjectPropertiesFamily { object_data: object_data },
        ))
    }
}

impl Message for RequestPayPrice {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa1])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = RequestPayPrice_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RequestPayPrice(
            RequestPayPrice { object_data: object_data },
        ))
    }
}

impl Message for PayPriceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa2])?;
        // Block ObjectData
        buffer.write(self.object_data.object_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.object_data.default_pay_price,
        )?;
        // Block ButtonData
        buffer.write_u8(self.button_data.len() as u8)?;
        for item in &self.button_data {
            buffer.write_i32::<LittleEndian>(item.pay_button)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = PayPriceReply_ObjectData::read_from(buffer)?;
        // Block ButtonData
        let mut button_data = Vec::new();
        let _button_data_count = buffer.read_u8()?;
        for _ in 0.._button_data_count {
            button_data.push(PayPriceReply_ButtonData::read_from(buffer)?);
        }
        Ok(MessageInstance::PayPriceReply(PayPriceReply {
            object_data: object_data,
            button_data: button_data,
        }))
    }
}

impl Message for KickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa3])?;
        // Block TargetBlock
        buffer.write(&self.target_block.target_ip.octets())?;
        buffer.write_u16::<LittleEndian>(
            self.target_block.target_port,
        )?;
        // Block UserInfo
        buffer.write(self.user_info.agent_id.as_bytes())?;
        buffer.write(self.user_info.session_id.as_bytes())?;
        buffer.write(&self.user_info.reason[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TargetBlock
        let target_block = KickUser_TargetBlock::read_from(buffer)?;
        // Block UserInfo
        let user_info = KickUser_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::KickUser(KickUser {
            target_block: target_block,
            user_info: user_info,
        }))
    }
}

impl Message for KickUserAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa4])?;
        // Block UserInfo
        buffer.write(self.user_info.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.user_info.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UserInfo
        let user_info = KickUserAck_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::KickUserAck(
            KickUserAck { user_info: user_info },
        ))
    }
}

impl Message for GodKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa5])?;
        // Block UserInfo
        buffer.write(self.user_info.god_id.as_bytes())?;
        buffer.write(self.user_info.god_session_id.as_bytes())?;
        buffer.write(self.user_info.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.user_info.kick_flags)?;
        buffer.write(&self.user_info.reason[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UserInfo
        let user_info = GodKickUser_UserInfo::read_from(buffer)?;
        Ok(MessageInstance::GodKickUser(
            GodKickUser { user_info: user_info },
        ))
    }
}

impl Message for SystemKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa6])?;
        // Block AgentInfo
        buffer.write_u8(self.agent_info.len() as u8)?;
        for item in &self.agent_info {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = buffer.read_u8()?;
        for _ in 0.._agent_info_count {
            agent_info.push(SystemKickUser_AgentInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::SystemKickUser(
            SystemKickUser { agent_info: agent_info },
        ))
    }
}

impl Message for EjectUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa7])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EjectUser_AgentData::read_from(buffer)?;
        // Block Data
        let data = EjectUser_Data::read_from(buffer)?;
        Ok(MessageInstance::EjectUser(EjectUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for FreezeUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa8])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = FreezeUser_AgentData::read_from(buffer)?;
        // Block Data
        let data = FreezeUser_Data::read_from(buffer)?;
        Ok(MessageInstance::FreezeUser(FreezeUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xa9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPropertiesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesRequest(
            AvatarPropertiesRequest { agent_data: agent_data },
        ))
    }
}

impl Message for AvatarPropertiesRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xaa])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        buffer.write_u8(self.agent_data.god_level)?;
        buffer.write_u8(self.agent_data.web_profiles_disabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPropertiesRequestBackend_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesRequestBackend(
            AvatarPropertiesRequestBackend { agent_data: agent_data },
        ))
    }
}

impl Message for AvatarPropertiesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xab])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block PropertiesData
        buffer.write(self.properties_data.image_id.as_bytes())?;
        buffer.write(self.properties_data.fl_image_id.as_bytes())?;
        buffer.write(self.properties_data.partner_id.as_bytes())?;
        buffer.write(&self.properties_data.about_text[..])?;
        buffer.write(&self.properties_data.fl_about_text[..])?;
        buffer.write(&self.properties_data.born_on[..])?;
        buffer.write(&self.properties_data.profile_url[..])?;
        buffer.write(&self.properties_data.charter_member[..])?;
        buffer.write_u32::<LittleEndian>(self.properties_data.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPropertiesReply_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarPropertiesReply_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesReply(
            AvatarPropertiesReply {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarInterestsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xac])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block PropertiesData
        buffer.write_u32::<LittleEndian>(
            self.properties_data.want_to_mask,
        )?;
        buffer.write(&self.properties_data.want_to_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.properties_data.skills_mask,
        )?;
        buffer.write(&self.properties_data.skills_text[..])?;
        buffer.write(&self.properties_data.languages_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarInterestsReply_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarInterestsReply_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarInterestsReply(
            AvatarInterestsReply {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xad])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.avatar_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
            buffer.write(&item.group_title[..])?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write(&item.group_name[..])?;
            buffer.write(item.group_insignia_id.as_bytes())?;
        }
        // Block NewGroupData
        buffer.write_u8(self.new_group_data.list_in_profile as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarGroupsReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(AvatarGroupsReply_GroupData::read_from(buffer)?);
        }
        // Block NewGroupData
        let new_group_data = AvatarGroupsReply_NewGroupData::read_from(buffer)?;
        Ok(MessageInstance::AvatarGroupsReply(AvatarGroupsReply {
            agent_data: agent_data,
            group_data: group_data,
            new_group_data: new_group_data,
        }))
    }
}

impl Message for AvatarPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xae])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block PropertiesData
        buffer.write(self.properties_data.image_id.as_bytes())?;
        buffer.write(self.properties_data.fl_image_id.as_bytes())?;
        buffer.write(&self.properties_data.about_text[..])?;
        buffer.write(&self.properties_data.fl_about_text[..])?;
        buffer.write_u8(self.properties_data.allow_publish as u8)?;
        buffer.write_u8(self.properties_data.mature_publish as u8)?;
        buffer.write(&self.properties_data.profile_url[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPropertiesUpdate_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarPropertiesUpdate_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarPropertiesUpdate(
            AvatarPropertiesUpdate {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarInterestsUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xaf])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block PropertiesData
        buffer.write_u32::<LittleEndian>(
            self.properties_data.want_to_mask,
        )?;
        buffer.write(&self.properties_data.want_to_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.properties_data.skills_mask,
        )?;
        buffer.write(&self.properties_data.skills_text[..])?;
        buffer.write(&self.properties_data.languages_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarInterestsUpdate_AgentData::read_from(buffer)?;
        // Block PropertiesData
        let properties_data = AvatarInterestsUpdate_PropertiesData::read_from(buffer)?;
        Ok(MessageInstance::AvatarInterestsUpdate(
            AvatarInterestsUpdate {
                agent_data: agent_data,
                properties_data: properties_data,
            },
        ))
    }
}

impl Message for AvatarNotesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb0])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write(&self.data.notes[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarNotesReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarNotesReply_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarNotesReply(AvatarNotesReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarNotesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb1])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.target_id.as_bytes())?;
        buffer.write(&self.data.notes[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarNotesUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = AvatarNotesUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::AvatarNotesUpdate(AvatarNotesUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPicksReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb2])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.target_id.as_bytes())?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.pick_id.as_bytes())?;
            buffer.write(&item.pick_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AvatarPicksReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(AvatarPicksReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::AvatarPicksReply(AvatarPicksReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for EventInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb3])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EventInfoRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventInfoRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventInfoRequest(EventInfoRequest {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb4])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        buffer.write(&self.event_data.creator[..])?;
        buffer.write(&self.event_data.name[..])?;
        buffer.write(&self.event_data.category[..])?;
        buffer.write(&self.event_data.desc[..])?;
        buffer.write(&self.event_data.date[..])?;
        buffer.write_u32::<LittleEndian>(self.event_data.date_utc)?;
        buffer.write_u32::<LittleEndian>(self.event_data.duration)?;
        buffer.write_u32::<LittleEndian>(self.event_data.cover)?;
        buffer.write_u32::<LittleEndian>(self.event_data.amount)?;
        buffer.write(&self.event_data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(
            self.event_data.global_pos.x,
        )?;
        buffer.write_f64::<LittleEndian>(
            self.event_data.global_pos.y,
        )?;
        buffer.write_f64::<LittleEndian>(
            self.event_data.global_pos.z,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.event_data.event_flags,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EventInfoReply_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventInfoReply_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventInfoReply(EventInfoReply {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventNotificationAddRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EventNotificationAddRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventNotificationAddRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventNotificationAddRequest(
            EventNotificationAddRequest {
                agent_data: agent_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for EventNotificationRemoveRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb6])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EventNotificationRemoveRequest_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventNotificationRemoveRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventNotificationRemoveRequest(
            EventNotificationRemoveRequest {
                agent_data: agent_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for EventGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb7])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(&self.query_data.query_text[..])?;
        buffer.write_u32::<LittleEndian>(
            self.query_data.query_flags,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.query_data.query_start,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EventGodDelete_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = EventGodDelete_EventData::read_from(buffer)?;
        // Block QueryData
        let query_data = EventGodDelete_QueryData::read_from(buffer)?;
        Ok(MessageInstance::EventGodDelete(EventGodDelete {
            agent_data: agent_data,
            event_data: event_data,
            query_data: query_data,
        }))
    }
}

impl Message for PickInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb8])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u8(self.data.top_pick as u8)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write(&self.data.name[..])?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write(&self.data.user[..])?;
        buffer.write(&self.data.original_name[..])?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_i32::<LittleEndian>(self.data.sort_order)?;
        buffer.write_u8(self.data.enabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PickInfoReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickInfoReply_Data::read_from(buffer)?;
        Ok(MessageInstance::PickInfoReply(PickInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xb9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.creator_id.as_bytes())?;
        buffer.write_u8(self.data.top_pick as u8)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write(&self.data.name[..])?;
        buffer.write(&self.data.desc[..])?;
        buffer.write(self.data.snapshot_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.x)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.y)?;
        buffer.write_f64::<LittleEndian>(self.data.pos_global.z)?;
        buffer.write_i32::<LittleEndian>(self.data.sort_order)?;
        buffer.write_u8(self.data.enabled as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PickInfoUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickInfoUpdate_Data::read_from(buffer)?;
        Ok(MessageInstance::PickInfoUpdate(PickInfoUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xba])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PickDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::PickDelete(PickDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xbb])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.pick_id.as_bytes())?;
        buffer.write(self.data.query_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PickGodDelete_AgentData::read_from(buffer)?;
        // Block Data
        let data = PickGodDelete_Data::read_from(buffer)?;
        Ok(MessageInstance::PickGodDelete(PickGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ScriptQuestion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xbc])?;
        // Block Data
        buffer.write(self.data.task_id.as_bytes())?;
        buffer.write(self.data.item_id.as_bytes())?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write(&self.data.object_owner[..])?;
        buffer.write_i32::<LittleEndian>(self.data.questions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = ScriptQuestion_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptQuestion(
            ScriptQuestion { data: data },
        ))
    }
}

impl Message for ScriptControlChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xbd])?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u8(item.take_controls as u8)?;
            buffer.write_u32::<LittleEndian>(item.controls)?;
            buffer.write_u8(item.pass_to_agent as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ScriptControlChange_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptControlChange(
            ScriptControlChange { data: data },
        ))
    }
}

impl Message for ScriptDialog {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xbe])?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write(&self.data.first_name[..])?;
        buffer.write(&self.data.last_name[..])?;
        buffer.write(&self.data.object_name[..])?;
        buffer.write(&self.data.message[..])?;
        buffer.write_i32::<LittleEndian>(self.data.chat_channel)?;
        buffer.write(self.data.image_id.as_bytes())?;
        // Block Buttons
        buffer.write_u8(self.buttons.len() as u8)?;
        for item in &self.buttons {
            buffer.write(&item.button_label[..])?;
        }
        // Block OwnerData
        buffer.write_u8(self.owner_data.len() as u8)?;
        for item in &self.owner_data {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = ScriptDialog_Data::read_from(buffer)?;
        // Block Buttons
        let mut buttons = Vec::new();
        let _buttons_count = buffer.read_u8()?;
        for _ in 0.._buttons_count {
            buttons.push(ScriptDialog_Buttons::read_from(buffer)?);
        }
        // Block OwnerData
        let mut owner_data = Vec::new();
        let _owner_data_count = buffer.read_u8()?;
        for _ in 0.._owner_data_count {
            owner_data.push(ScriptDialog_OwnerData::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDialog(ScriptDialog {
            data: data,
            buttons: buttons,
            owner_data: owner_data,
        }))
    }
}

impl Message for ScriptDialogReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xbf])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.chat_channel)?;
        buffer.write_i32::<LittleEndian>(self.data.button_index)?;
        buffer.write(&self.data.button_label[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ScriptDialogReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ScriptDialogReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptDialogReply(ScriptDialogReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ForceScriptControlRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc0])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ForceScriptControlRelease_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ForceScriptControlRelease(
            ForceScriptControlRelease { agent_data: agent_data },
        ))
    }
}

impl Message for RevokePermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc1])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.data.object_permissions,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RevokePermissions_AgentData::read_from(buffer)?;
        // Block Data
        let data = RevokePermissions_Data::read_from(buffer)?;
        Ok(MessageInstance::RevokePermissions(RevokePermissions {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for LoadURL {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc2])?;
        // Block Data
        buffer.write(&self.data.object_name[..])?;
        buffer.write(self.data.object_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_u8(self.data.owner_is_group as u8)?;
        buffer.write(&self.data.message[..])?;
        buffer.write(&self.data.url[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = LoadURL_Data::read_from(buffer)?;
        Ok(MessageInstance::LoadURL(LoadURL { data: data }))
    }
}

impl Message for ScriptTeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc3])?;
        // Block Data
        buffer.write(&self.data.object_name[..])?;
        buffer.write(&self.data.sim_name[..])?;
        buffer.write_f32::<LittleEndian>(self.data.sim_position.x)?;
        buffer.write_f32::<LittleEndian>(self.data.sim_position.y)?;
        buffer.write_f32::<LittleEndian>(self.data.sim_position.z)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.z)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = ScriptTeleportRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ScriptTeleportRequest(
            ScriptTeleportRequest { data: data },
        ))
    }
}

impl Message for ParcelOverlay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc4])?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sequence_id,
        )?;
        buffer.write(&self.parcel_data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let parcel_data = ParcelOverlay_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelOverlay(
            ParcelOverlay { parcel_data: parcel_data },
        ))
    }
}

impl Message for ParcelPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sequence_id,
        )?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        buffer.write_u8(self.parcel_data.snap_selection as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelPropertiesRequest_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesRequest_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesRequest(
            ParcelPropertiesRequest {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelPropertiesRequestByID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sequence_id,
        )?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelPropertiesRequestByID_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesRequestByID_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesRequestByID(
            ParcelPropertiesRequestByID {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x17])?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.request_result,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sequence_id,
        )?;
        buffer.write_u8(self.parcel_data.snap_selection as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.self_count,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.other_count,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.public_count,
        )?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write(self.parcel_data.owner_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.is_group_owned as u8)?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.auction_id,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.claim_date,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.claim_price,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.rent_price,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_min.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_min.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_min.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_max.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_max.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.aabb_max.z,
        )?;
        buffer.write(&self.parcel_data.bitmap[..])?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.area)?;
        buffer.write_u8(self.parcel_data.status)?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sim_wide_max_prims,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sim_wide_total_prims,
        )?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.max_prims)?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.total_prims,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.owner_prims,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.group_prims,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.other_prims,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.selected_prims,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.parcel_prim_bonus,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.other_clean_time,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.parcel_flags,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sale_price,
        )?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write(&self.parcel_data.desc[..])?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write(&self.parcel_data.media_url[..])?;
        buffer.write(self.parcel_data.media_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.media_auto_scale)?;
        buffer.write(self.parcel_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.pass_price,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.pass_hours,
        )?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.auth_buyer_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.z,
        )?;
        buffer.write_u8(self.parcel_data.landing_type)?;
        buffer.write_u8(self.parcel_data.region_push_override as u8)?;
        buffer.write_u8(
            self.parcel_data.region_deny_anonymous as u8,
        )?;
        buffer.write_u8(
            self.parcel_data.region_deny_identified as u8,
        )?;
        buffer.write_u8(
            self.parcel_data.region_deny_transacted as u8,
        )?;
        // Block AgeVerificationBlock
        buffer.write_u8(
            self.age_verification_block
                .region_deny_age_unverified as u8,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let parcel_data = ParcelProperties_ParcelData::read_from(buffer)?;
        // Block AgeVerificationBlock
        let age_verification_block = ParcelProperties_AgeVerificationBlock::read_from(buffer)?;
        Ok(MessageInstance::ParcelProperties(ParcelProperties {
            parcel_data: parcel_data,
            age_verification_block: age_verification_block,
        }))
    }
}

impl Message for ParcelPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc6])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(self.parcel_data.flags)?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.parcel_flags,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sale_price,
        )?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write(&self.parcel_data.desc[..])?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write(&self.parcel_data.media_url[..])?;
        buffer.write(self.parcel_data.media_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.media_auto_scale)?;
        buffer.write(self.parcel_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.pass_price,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.pass_hours,
        )?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.auth_buyer_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_look_at.z,
        )?;
        buffer.write_u8(self.parcel_data.landing_type)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelPropertiesUpdate_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelPropertiesUpdate_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelPropertiesUpdate(
            ParcelPropertiesUpdate {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelReturnObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc7])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.return_type,
        )?;
        // Block TaskIDs
        buffer.write_u8(self.task_i_ds.len() as u8)?;
        for item in &self.task_i_ds {
            buffer.write(item.task_id.as_bytes())?;
        }
        // Block OwnerIDs
        buffer.write_u8(self.owner_i_ds.len() as u8)?;
        for item in &self.owner_i_ds {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelReturnObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelReturnObjects_ParcelData::read_from(buffer)?;
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = buffer.read_u8()?;
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(ParcelReturnObjects_TaskIDs::read_from(buffer)?);
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = buffer.read_u8()?;
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(ParcelReturnObjects_OwnerIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelReturnObjects(ParcelReturnObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            task_i_ds: task_i_ds,
            owner_i_ds: owner_i_ds,
        }))
    }
}

impl Message for ParcelSetOtherCleanTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc8])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.other_clean_time,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelSetOtherCleanTime_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelSetOtherCleanTime_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelSetOtherCleanTime(
            ParcelSetOtherCleanTime {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ParcelDisableObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xc9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.return_type,
        )?;
        // Block TaskIDs
        buffer.write_u8(self.task_i_ds.len() as u8)?;
        for item in &self.task_i_ds {
            buffer.write(item.task_id.as_bytes())?;
        }
        // Block OwnerIDs
        buffer.write_u8(self.owner_i_ds.len() as u8)?;
        for item in &self.owner_i_ds {
            buffer.write(item.owner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelDisableObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelDisableObjects_ParcelData::read_from(buffer)?;
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = buffer.read_u8()?;
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(ParcelDisableObjects_TaskIDs::read_from(buffer)?);
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = buffer.read_u8()?;
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(ParcelDisableObjects_OwnerIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelDisableObjects(
            ParcelDisableObjects {
                agent_data: agent_data,
                parcel_data: parcel_data,
                task_i_ds: task_i_ds,
                owner_i_ds: owner_i_ds,
            },
        ))
    }
}

impl Message for ParcelSelectObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xca])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write_u32::<LittleEndian>(
            self.parcel_data.return_type,
        )?;
        // Block ReturnIDs
        buffer.write_u8(self.return_i_ds.len() as u8)?;
        for item in &self.return_i_ds {
            buffer.write(item.return_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelSelectObjects_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelSelectObjects_ParcelData::read_from(buffer)?;
        // Block ReturnIDs
        let mut return_i_ds = Vec::new();
        let _return_i_ds_count = buffer.read_u8()?;
        for _ in 0.._return_i_ds_count {
            return_i_ds.push(ParcelSelectObjects_ReturnIDs::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelSelectObjects(ParcelSelectObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            return_i_ds: return_i_ds,
        }))
    }
}

impl Message for EstateCovenantRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xcb])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EstateCovenantRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::EstateCovenantRequest(
            EstateCovenantRequest { agent_data: agent_data },
        ))
    }
}

impl Message for EstateCovenantReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xcc])?;
        // Block Data
        buffer.write(self.data.covenant_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.data.covenant_timestamp,
        )?;
        buffer.write(&self.data.estate_name[..])?;
        buffer.write(self.data.estate_owner_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = EstateCovenantReply_Data::read_from(buffer)?;
        Ok(MessageInstance::EstateCovenantReply(
            EstateCovenantReply { data: data },
        ))
    }
}

impl Message for ForceObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xcd])?;
        // Block Header
        buffer.write_u8(self.header.reset_list as u8)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u32::<LittleEndian>(item.local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Header
        let header = ForceObjectSelect_Header::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ForceObjectSelect_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ForceObjectSelect(ForceObjectSelect {
            header: header,
            data: data,
        }))
    }
}

impl Message for ParcelBuyPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xce])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelBuyPass_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelBuyPass_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelBuyPass(ParcelBuyPass {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDeedToGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xcf])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelDeedToGroup_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDeedToGroup_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDeedToGroup(ParcelDeedToGroup {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelReclaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd0])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelReclaim_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelReclaim_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelReclaim(ParcelReclaim {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelClaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd1])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.is_group_owned as u8)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write_f32::<LittleEndian>(item.west)?;
            buffer.write_f32::<LittleEndian>(item.south)?;
            buffer.write_f32::<LittleEndian>(item.east)?;
            buffer.write_f32::<LittleEndian>(item.north)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelClaim_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelClaim_Data::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelClaim_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelClaim(ParcelClaim {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelJoin {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd2])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelJoin_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelJoin_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelJoin(ParcelJoin {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDivide {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd3])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_f32::<LittleEndian>(self.parcel_data.west)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.south)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.east)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.north)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelDivide_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelDivide_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelDivide(ParcelDivide {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd4])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelRelease_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelRelease_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelRelease(ParcelRelease {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.is_group_owned as u8)?;
        buffer.write_u8(self.data.remove_contribution as u8)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.price)?;
        buffer.write_i32::<LittleEndian>(self.parcel_data.area)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelBuy_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelBuy_Data::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelBuy_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelBuy(ParcelBuy {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelGodForceOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd6])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelGodForceOwner_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelGodForceOwner_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelGodForceOwner(ParcelGodForceOwner {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelAccessListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd7])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelAccessListRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelAccessListRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelAccessListRequest(
            ParcelAccessListRequest {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for ParcelAccessListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd8])?;
        // Block Data
        buffer.write(self.data.agent_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        // Block List
        buffer.write_u8(self.list.len() as u8)?;
        for item in &self.list {
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.time)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = ParcelAccessListReply_Data::read_from(buffer)?;
        // Block List
        let mut list = Vec::new();
        let _list_count = buffer.read_u8()?;
        for _ in 0.._list_count {
            list.push(ParcelAccessListReply_List::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAccessListReply(
            ParcelAccessListReply {
                data: data,
                list: list,
            },
        ))
    }
}

impl Message for ParcelAccessListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xd9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_u32::<LittleEndian>(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.transaction_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.sequence_id)?;
        buffer.write_i32::<LittleEndian>(self.data.sections)?;
        // Block List
        buffer.write_u8(self.list.len() as u8)?;
        for item in &self.list {
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.time)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelAccessListUpdate_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelAccessListUpdate_Data::read_from(buffer)?;
        // Block List
        let mut list = Vec::new();
        let _list_count = buffer.read_u8()?;
        for _ in 0.._list_count {
            list.push(ParcelAccessListUpdate_List::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAccessListUpdate(
            ParcelAccessListUpdate {
                agent_data: agent_data,
                data: data,
                list: list,
            },
        ))
    }
}

impl Message for ParcelDwellRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xda])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelDwellRequest_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDwellRequest_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDwellRequest(ParcelDwellRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelDwellReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xdb])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.local_id)?;
        buffer.write(self.data.parcel_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data.dwell)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelDwellReply_AgentData::read_from(buffer)?;
        // Block Data
        let data = ParcelDwellReply_Data::read_from(buffer)?;
        Ok(MessageInstance::ParcelDwellReply(ParcelDwellReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for RequestParcelTransfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xdc])?;
        // Block Data
        buffer.write(self.data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data.transaction_time)?;
        buffer.write(self.data.source_id.as_bytes())?;
        buffer.write(self.data.dest_id.as_bytes())?;
        buffer.write(self.data.owner_id.as_bytes())?;
        buffer.write_u8(self.data.flags)?;
        buffer.write_i32::<LittleEndian>(self.data.transaction_type)?;
        buffer.write_i32::<LittleEndian>(self.data.amount)?;
        buffer.write_i32::<LittleEndian>(self.data.billable_area)?;
        buffer.write_i32::<LittleEndian>(self.data.actual_area)?;
        buffer.write_u8(self.data.final_ as u8)?;
        // Block RegionData
        buffer.write(self.region_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.region_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.region_data.grid_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = RequestParcelTransfer_Data::read_from(buffer)?;
        // Block RegionData
        let region_data = RequestParcelTransfer_RegionData::read_from(buffer)?;
        Ok(MessageInstance::RequestParcelTransfer(
            RequestParcelTransfer {
                data: data,
                region_data: region_data,
            },
        ))
    }
}

impl Message for UpdateParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xdd])?;
        // Block ParcelData
        buffer.write(self.parcel_data.parcel_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(
            self.parcel_data.region_handle,
        )?;
        buffer.write(self.parcel_data.owner_id.as_bytes())?;
        buffer.write_u8(self.parcel_data.group_owned as u8)?;
        buffer.write_u8(self.parcel_data.status)?;
        buffer.write(&self.parcel_data.name[..])?;
        buffer.write(&self.parcel_data.description[..])?;
        buffer.write(&self.parcel_data.music_url[..])?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.region_x)?;
        buffer.write_f32::<LittleEndian>(self.parcel_data.region_y)?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.actual_area,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.billable_area,
        )?;
        buffer.write_u8(self.parcel_data.show_dir as u8)?;
        buffer.write_u8(self.parcel_data.is_for_sale as u8)?;
        buffer.write_u8(self.parcel_data.category)?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.parcel_data.user_location.z,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.parcel_data.sale_price,
        )?;
        buffer.write(
            self.parcel_data.authorized_buyer_id.as_bytes(),
        )?;
        buffer.write_u8(self.parcel_data.allow_publish as u8)?;
        buffer.write_u8(self.parcel_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let parcel_data = UpdateParcel_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::UpdateParcel(
            UpdateParcel { parcel_data: parcel_data },
        ))
    }
}

impl Message for RemoveParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xde])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(RemoveParcel_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveParcel(
            RemoveParcel { parcel_data: parcel_data },
        ))
    }
}

impl Message for MergeParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xdf])?;
        // Block MasterParcelData
        buffer.write(self.master_parcel_data.master_id.as_bytes())?;
        // Block SlaveParcelData
        buffer.write_u8(self.slave_parcel_data.len() as u8)?;
        for item in &self.slave_parcel_data {
            buffer.write(item.slave_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MasterParcelData
        let master_parcel_data = MergeParcel_MasterParcelData::read_from(buffer)?;
        // Block SlaveParcelData
        let mut slave_parcel_data = Vec::new();
        let _slave_parcel_data_count = buffer.read_u8()?;
        for _ in 0.._slave_parcel_data_count {
            slave_parcel_data.push(MergeParcel_SlaveParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::MergeParcel(MergeParcel {
            master_parcel_data: master_parcel_data,
            slave_parcel_data: slave_parcel_data,
        }))
    }
}

impl Message for LogParcelChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe0])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block RegionData
        buffer.write_u64::<LittleEndian>(
            self.region_data.region_handle,
        )?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.is_owner_group as u8)?;
            buffer.write_i32::<LittleEndian>(item.actual_area)?;
            buffer.write_i8(item.action)?;
            buffer.write(item.transaction_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LogParcelChanges_AgentData::read_from(buffer)?;
        // Block RegionData
        let region_data = LogParcelChanges_RegionData::read_from(buffer)?;
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(LogParcelChanges_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::LogParcelChanges(LogParcelChanges {
            agent_data: agent_data,
            region_data: region_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for CheckParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe1])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(CheckParcelSales_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::CheckParcelSales(
            CheckParcelSales { region_data: region_data },
        ))
    }
}

impl Message for ParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe2])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.buyer_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelSales_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelSales(
            ParcelSales { parcel_data: parcel_data },
        ))
    }
}

impl Message for ParcelGodMarkAsContent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe3])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ParcelGodMarkAsContent_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ParcelGodMarkAsContent_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ParcelGodMarkAsContent(
            ParcelGodMarkAsContent {
                agent_data: agent_data,
                parcel_data: parcel_data,
            },
        ))
    }
}

impl Message for ViewerStartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe4])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ParcelData
        buffer.write_i32::<LittleEndian>(self.parcel_data.local_id)?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ViewerStartAuction_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = ViewerStartAuction_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::ViewerStartAuction(ViewerStartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for StartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block ParcelData
        buffer.write(self.parcel_data.parcel_id.as_bytes())?;
        buffer.write(self.parcel_data.snapshot_id.as_bytes())?;
        buffer.write(&self.parcel_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = StartAuction_AgentData::read_from(buffer)?;
        // Block ParcelData
        let parcel_data = StartAuction_ParcelData::read_from(buffer)?;
        Ok(MessageInstance::StartAuction(StartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ConfirmAuctionStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe6])?;
        // Block AuctionData
        buffer.write(self.auction_data.parcel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.auction_data.auction_id,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AuctionData
        let auction_data = ConfirmAuctionStart_AuctionData::read_from(buffer)?;
        Ok(MessageInstance::ConfirmAuctionStart(
            ConfirmAuctionStart { auction_data: auction_data },
        ))
    }
}

impl Message for CompleteAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe7])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(CompleteAuction_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::CompleteAuction(
            CompleteAuction { parcel_data: parcel_data },
        ))
    }
}

impl Message for CancelAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe8])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(CancelAuction_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::CancelAuction(
            CancelAuction { parcel_data: parcel_data },
        ))
    }
}

impl Message for CheckParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xe9])?;
        // Block RegionData
        buffer.write_u8(self.region_data.len() as u8)?;
        for item in &self.region_data {
            buffer.write_u64::<LittleEndian>(item.region_handle)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = buffer.read_u8()?;
        for _ in 0.._region_data_count {
            region_data.push(CheckParcelAuctions_RegionData::read_from(buffer)?);
        }
        Ok(MessageInstance::CheckParcelAuctions(
            CheckParcelAuctions { region_data: region_data },
        ))
    }
}

impl Message for ParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xea])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(item.winner_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelAuctions_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelAuctions(
            ParcelAuctions { parcel_data: parcel_data },
        ))
    }
}

impl Message for UUIDNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xeb])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDNameRequest_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDNameRequest(
            UUIDNameRequest { uuid_name_block: uuid_name_block },
        ))
    }
}

impl Message for UUIDNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xec])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
            buffer.write(&item.first_name[..])?;
            buffer.write(&item.last_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDNameReply_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDNameReply(
            UUIDNameReply { uuid_name_block: uuid_name_block },
        ))
    }
}

impl Message for UUIDGroupNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xed])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDGroupNameRequest_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDGroupNameRequest(
            UUIDGroupNameRequest { uuid_name_block: uuid_name_block },
        ))
    }
}

impl Message for UUIDGroupNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xee])?;
        // Block UUIDNameBlock
        buffer.write_u8(self.uuid_name_block.len() as u8)?;
        for item in &self.uuid_name_block {
            buffer.write(item.id.as_bytes())?;
            buffer.write(&item.group_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = buffer.read_u8()?;
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(UUIDGroupNameReply_UUIDNameBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::UUIDGroupNameReply(
            UUIDGroupNameReply { uuid_name_block: uuid_name_block },
        ))
    }
}

impl Message for ChatPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xef])?;
        // Block ChatData
        buffer.write_i32::<LittleEndian>(self.chat_data.channel)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.x)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.y)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.position.z)?;
        buffer.write(self.chat_data.id.as_bytes())?;
        buffer.write(self.chat_data.owner_id.as_bytes())?;
        buffer.write(&self.chat_data.name[..])?;
        buffer.write_u8(self.chat_data.source_type)?;
        buffer.write_u8(self.chat_data.type_)?;
        buffer.write_f32::<LittleEndian>(self.chat_data.radius)?;
        buffer.write_u8(self.chat_data.sim_access)?;
        buffer.write(&self.chat_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ChatData
        let chat_data = ChatPass_ChatData::read_from(buffer)?;
        Ok(MessageInstance::ChatPass(ChatPass { chat_data: chat_data }))
    }
}

impl Message for EdgeDataPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x18])?;
        // Block EdgeData
        buffer.write_u8(self.edge_data.layer_type)?;
        buffer.write_u8(self.edge_data.direction)?;
        buffer.write(&self.edge_data.layer_data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block EdgeData
        let edge_data = EdgeDataPacket_EdgeData::read_from(buffer)?;
        Ok(MessageInstance::EdgeDataPacket(
            EdgeDataPacket { edge_data: edge_data },
        ))
    }
}

impl Message for SimStatus {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0c])?;
        // Block SimStatus
        buffer.write_u8(self.sim_status.can_accept_agents as u8)?;
        buffer.write_u8(self.sim_status.can_accept_tasks as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SimStatus
        let sim_status = SimStatus_SimStatus::read_from(buffer)?;
        Ok(MessageInstance::SimStatus(
            SimStatus { sim_status: sim_status },
        ))
    }
}

impl Message for ChildAgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x19])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(
            self.agent_data.region_handle,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.viewer_circuit_code,
        )?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z)?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z)?;
        buffer.write_u8(self.agent_data.changed_grid as u8)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.far)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.aspect)?;
        buffer.write(&self.agent_data.throttles[..])?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.locomotion_state,
        )?;
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_head_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_head_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_head_rotation.k)?;
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        buffer.write_f32::<LittleEndian>(normed_body_rotation.i)?;
        buffer.write_f32::<LittleEndian>(normed_body_rotation.j)?;
        buffer.write_f32::<LittleEndian>(normed_body_rotation.k)?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.control_flags,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.energy_level,
        )?;
        buffer.write_u8(self.agent_data.god_level)?;
        buffer.write_u8(self.agent_data.always_run as u8)?;
        buffer.write(self.agent_data.prey_agent.as_bytes())?;
        buffer.write_u8(self.agent_data.agent_access)?;
        buffer.write(&self.agent_data.agent_textures[..])?;
        buffer.write(self.agent_data.active_group_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
        }
        // Block AnimationData
        buffer.write_u8(self.animation_data.len() as u8)?;
        for item in &self.animation_data {
            buffer.write(item.animation.as_bytes())?;
            buffer.write(item.object_id.as_bytes())?;
        }
        // Block GranterBlock
        buffer.write_u8(self.granter_block.len() as u8)?;
        for item in &self.granter_block {
            buffer.write(item.granter_id.as_bytes())?;
        }
        // Block NVPairData
        buffer.write_u8(self.nv_pair_data.len() as u8)?;
        for item in &self.nv_pair_data {
            buffer.write(&item.nv_pairs[..])?;
        }
        // Block VisualParam
        buffer.write_u8(self.visual_param.len() as u8)?;
        for item in &self.visual_param {
            buffer.write_u8(item.param_value)?;
        }
        // Block AgentAccess
        buffer.write_u8(self.agent_access.len() as u8)?;
        for item in &self.agent_access {
            buffer.write_u8(item.agent_legacy_access)?;
            buffer.write_u8(item.agent_max_access)?;
        }
        // Block AgentInfo
        buffer.write_u8(self.agent_info.len() as u8)?;
        for item in &self.agent_info {
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChildAgentUpdate_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(ChildAgentUpdate_GroupData::read_from(buffer)?);
        }
        // Block AnimationData
        let mut animation_data = Vec::new();
        let _animation_data_count = buffer.read_u8()?;
        for _ in 0.._animation_data_count {
            animation_data.push(ChildAgentUpdate_AnimationData::read_from(buffer)?);
        }
        // Block GranterBlock
        let mut granter_block = Vec::new();
        let _granter_block_count = buffer.read_u8()?;
        for _ in 0.._granter_block_count {
            granter_block.push(ChildAgentUpdate_GranterBlock::read_from(buffer)?);
        }
        // Block NVPairData
        let mut nv_pair_data = Vec::new();
        let _nv_pair_data_count = buffer.read_u8()?;
        for _ in 0.._nv_pair_data_count {
            nv_pair_data.push(ChildAgentUpdate_NVPairData::read_from(buffer)?);
        }
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = buffer.read_u8()?;
        for _ in 0.._visual_param_count {
            visual_param.push(ChildAgentUpdate_VisualParam::read_from(buffer)?);
        }
        // Block AgentAccess
        let mut agent_access = Vec::new();
        let _agent_access_count = buffer.read_u8()?;
        for _ in 0.._agent_access_count {
            agent_access.push(ChildAgentUpdate_AgentAccess::read_from(buffer)?);
        }
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = buffer.read_u8()?;
        for _ in 0.._agent_info_count {
            agent_info.push(ChildAgentUpdate_AgentInfo::read_from(buffer)?);
        }
        Ok(MessageInstance::ChildAgentUpdate(ChildAgentUpdate {
            agent_data: agent_data,
            group_data: group_data,
            animation_data: animation_data,
            granter_block: granter_block,
            nv_pair_data: nv_pair_data,
            visual_param: visual_param,
            agent_access: agent_access,
            agent_info: agent_info,
        }))
    }
}

impl Message for ChildAgentAlive {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x1a])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(
            self.agent_data.region_handle,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.viewer_circuit_code,
        )?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChildAgentAlive_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentAlive(
            ChildAgentAlive { agent_data: agent_data },
        ))
    }
}

impl Message for ChildAgentPositionUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x1b])?;
        // Block AgentData
        buffer.write_u64::<LittleEndian>(
            self.agent_data.region_handle,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.viewer_circuit_code,
        )?;
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_pos.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.agent_vel.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.center.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.size.z)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z)?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.agent_data.left_axis.z,
        )?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y)?;
        buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z)?;
        buffer.write_u8(self.agent_data.changed_grid as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChildAgentPositionUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentPositionUpdate(
            ChildAgentPositionUpdate { agent_data: agent_data },
        ))
    }
}

impl Message for ChildAgentDying {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf0])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChildAgentDying_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentDying(
            ChildAgentDying { agent_data: agent_data },
        ))
    }
}

impl Message for ChildAgentUnknown {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf1])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChildAgentUnknown_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ChildAgentUnknown(
            ChildAgentUnknown { agent_data: agent_data },
        ))
    }
}

impl Message for AtomicPassObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x1c])?;
        // Block TaskData
        buffer.write(self.task_data.task_id.as_bytes())?;
        buffer.write_u8(self.task_data.attachment_needs_save as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TaskData
        let task_data = AtomicPassObject_TaskData::read_from(buffer)?;
        Ok(MessageInstance::AtomicPassObject(
            AtomicPassObject { task_data: task_data },
        ))
    }
}

impl Message for KillChildAgents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf2])?;
        // Block IDBlock
        buffer.write(self.id_block.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block IDBlock
        let id_block = KillChildAgents_IDBlock::read_from(buffer)?;
        Ok(MessageInstance::KillChildAgents(
            KillChildAgents { id_block: id_block },
        ))
    }
}

impl Message for GetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf3])?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Script
        let script = GetScriptRunning_Script::read_from(buffer)?;
        Ok(MessageInstance::GetScriptRunning(
            GetScriptRunning { script: script },
        ))
    }
}

impl Message for ScriptRunningReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf4])?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        buffer.write_u8(self.script.running as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Script
        let script = ScriptRunningReply_Script::read_from(buffer)?;
        Ok(MessageInstance::ScriptRunningReply(
            ScriptRunningReply { script: script },
        ))
    }
}

impl Message for SetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        buffer.write_u8(self.script.running as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SetScriptRunning_AgentData::read_from(buffer)?;
        // Block Script
        let script = SetScriptRunning_Script::read_from(buffer)?;
        Ok(MessageInstance::SetScriptRunning(SetScriptRunning {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for ScriptReset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf6])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Script
        buffer.write(self.script.object_id.as_bytes())?;
        buffer.write(self.script.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ScriptReset_AgentData::read_from(buffer)?;
        // Block Script
        let script = ScriptReset_Script::read_from(buffer)?;
        Ok(MessageInstance::ScriptReset(ScriptReset {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for ScriptSensorRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf7])?;
        // Block Requester
        buffer.write(self.requester.source_id.as_bytes())?;
        buffer.write(self.requester.request_id.as_bytes())?;
        buffer.write(self.requester.search_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.requester.search_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.requester.search_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.requester.search_pos.z,
        )?;
        let normed_search_dir = UnitQuaternion::new(&self.requester.search_dir).unwrap();
        buffer.write_f32::<LittleEndian>(normed_search_dir.i)?;
        buffer.write_f32::<LittleEndian>(normed_search_dir.j)?;
        buffer.write_f32::<LittleEndian>(normed_search_dir.k)?;
        buffer.write(&self.requester.search_name[..])?;
        buffer.write_i32::<LittleEndian>(self.requester.type_)?;
        buffer.write_f32::<LittleEndian>(self.requester.range)?;
        buffer.write_f32::<LittleEndian>(self.requester.arc)?;
        buffer.write_u64::<LittleEndian>(
            self.requester.region_handle,
        )?;
        buffer.write_u8(self.requester.search_regions)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Requester
        let requester = ScriptSensorRequest_Requester::read_from(buffer)?;
        Ok(MessageInstance::ScriptSensorRequest(
            ScriptSensorRequest { requester: requester },
        ))
    }
}

impl Message for ScriptSensorReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf8])?;
        // Block Requester
        buffer.write(self.requester.source_id.as_bytes())?;
        // Block SensedData
        buffer.write_u8(self.sensed_data.len() as u8)?;
        for item in &self.sensed_data {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.position.x)?;
            buffer.write_f32::<LittleEndian>(item.position.y)?;
            buffer.write_f32::<LittleEndian>(item.position.z)?;
            buffer.write_f32::<LittleEndian>(item.velocity.x)?;
            buffer.write_f32::<LittleEndian>(item.velocity.y)?;
            buffer.write_f32::<LittleEndian>(item.velocity.z)?;
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            buffer.write_f32::<LittleEndian>(normed_rotation.i)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.j)?;
            buffer.write_f32::<LittleEndian>(normed_rotation.k)?;
            buffer.write(&item.name[..])?;
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.range)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Requester
        let requester = ScriptSensorReply_Requester::read_from(buffer)?;
        // Block SensedData
        let mut sensed_data = Vec::new();
        let _sensed_data_count = buffer.read_u8()?;
        for _ in 0.._sensed_data_count {
            sensed_data.push(ScriptSensorReply_SensedData::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptSensorReply(ScriptSensorReply {
            requester: requester,
            sensed_data: sensed_data,
        }))
    }
}

impl Message for CompleteAgentMovement {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xf9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.circuit_code,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CompleteAgentMovement_AgentData::read_from(buffer)?;
        Ok(MessageInstance::CompleteAgentMovement(
            CompleteAgentMovement { agent_data: agent_data },
        ))
    }
}

impl Message for AgentMovementComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xfa])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write_f32::<LittleEndian>(self.data.position.x)?;
        buffer.write_f32::<LittleEndian>(self.data.position.y)?;
        buffer.write_f32::<LittleEndian>(self.data.position.z)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.x)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.y)?;
        buffer.write_f32::<LittleEndian>(self.data.look_at.z)?;
        buffer.write_u64::<LittleEndian>(self.data.region_handle)?;
        buffer.write_u32::<LittleEndian>(self.data.timestamp)?;
        // Block SimData
        buffer.write(&self.sim_data.channel_version[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentMovementComplete_AgentData::read_from(buffer)?;
        // Block Data
        let data = AgentMovementComplete_Data::read_from(buffer)?;
        // Block SimData
        let sim_data = AgentMovementComplete_SimData::read_from(buffer)?;
        Ok(MessageInstance::AgentMovementComplete(
            AgentMovementComplete {
                agent_data: agent_data,
                data: data,
                sim_data: sim_data,
            },
        ))
    }
}

impl Message for DataServerLogout {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xfb])?;
        // Block UserData
        buffer.write(self.user_data.agent_id.as_bytes())?;
        buffer.write(&self.user_data.viewer_ip.octets())?;
        buffer.write_u8(self.user_data.disconnect as u8)?;
        buffer.write(self.user_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block UserData
        let user_data = DataServerLogout_UserData::read_from(buffer)?;
        Ok(MessageInstance::DataServerLogout(
            DataServerLogout { user_data: user_data },
        ))
    }
}

impl Message for LogoutRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xfc])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LogoutRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::LogoutRequest(
            LogoutRequest { agent_data: agent_data },
        ))
    }
}

impl Message for LogoutReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xfd])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LogoutReply_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(LogoutReply_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::LogoutReply(LogoutReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ImprovedInstantMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xfe])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MessageBlock
        buffer.write_u8(self.message_block.from_group as u8)?;
        buffer.write(self.message_block.to_agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.message_block.parent_estate_id,
        )?;
        buffer.write(self.message_block.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.message_block.position.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.message_block.position.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.message_block.position.z,
        )?;
        buffer.write_u8(self.message_block.offline)?;
        buffer.write_u8(self.message_block.dialog)?;
        buffer.write(self.message_block.id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.message_block.timestamp,
        )?;
        buffer.write(&self.message_block.from_agent_name[..])?;
        buffer.write(&self.message_block.message[..])?;
        buffer.write(&self.message_block.binary_bucket[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ImprovedInstantMessage_AgentData::read_from(buffer)?;
        // Block MessageBlock
        let message_block = ImprovedInstantMessage_MessageBlock::read_from(buffer)?;
        Ok(MessageInstance::ImprovedInstantMessage(
            ImprovedInstantMessage {
                agent_data: agent_data,
                message_block: message_block,
            },
        ))
    }
}

impl Message for RetrieveInstantMessages {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x00, 0xff])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RetrieveInstantMessages_AgentData::read_from(buffer)?;
        Ok(MessageInstance::RetrieveInstantMessages(
            RetrieveInstantMessages { agent_data: agent_data },
        ))
    }
}

impl Message for FindAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x00])?;
        // Block AgentBlock
        buffer.write(self.agent_block.hunter.as_bytes())?;
        buffer.write(self.agent_block.prey.as_bytes())?;
        buffer.write(&self.agent_block.space_ip.octets())?;
        // Block LocationBlock
        buffer.write_u8(self.location_block.len() as u8)?;
        for item in &self.location_block {
            buffer.write_f64::<LittleEndian>(item.global_x)?;
            buffer.write_f64::<LittleEndian>(item.global_y)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentBlock
        let agent_block = FindAgent_AgentBlock::read_from(buffer)?;
        // Block LocationBlock
        let mut location_block = Vec::new();
        let _location_block_count = buffer.read_u8()?;
        for _ in 0.._location_block_count {
            location_block.push(FindAgent_LocationBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::FindAgent(FindAgent {
            agent_block: agent_block,
            location_block: location_block,
        }))
    }
}

impl Message for RequestGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x01])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestBlock
        buffer.write_u8(self.request_block.godlike as u8)?;
        buffer.write(self.request_block.token.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestGodlikePowers_AgentData::read_from(buffer)?;
        // Block RequestBlock
        let request_block = RequestGodlikePowers_RequestBlock::read_from(buffer)?;
        Ok(MessageInstance::RequestGodlikePowers(
            RequestGodlikePowers {
                agent_data: agent_data,
                request_block: request_block,
            },
        ))
    }
}

impl Message for GrantGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x02])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GrantData
        buffer.write_u8(self.grant_data.god_level)?;
        buffer.write(self.grant_data.token.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GrantGodlikePowers_AgentData::read_from(buffer)?;
        // Block GrantData
        let grant_data = GrantGodlikePowers_GrantData::read_from(buffer)?;
        Ok(MessageInstance::GrantGodlikePowers(GrantGodlikePowers {
            agent_data: agent_data,
            grant_data: grant_data,
        }))
    }
}

impl Message for GodlikeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x03])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GodlikeMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = GodlikeMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(GodlikeMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::GodlikeMessage(GodlikeMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for EstateOwnerMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x04])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EstateOwnerMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = EstateOwnerMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(EstateOwnerMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::EstateOwnerMessage(EstateOwnerMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for GenericMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x05])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block MethodData
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GenericMessage_AgentData::read_from(buffer)?;
        // Block MethodData
        let method_data = GenericMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(GenericMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::GenericMessage(GenericMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for MuteListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x06])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write_u32::<LittleEndian>(self.mute_data.mute_crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MuteListRequest_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = MuteListRequest_MuteData::read_from(buffer)?;
        Ok(MessageInstance::MuteListRequest(MuteListRequest {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for UpdateMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x07])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write(self.mute_data.mute_id.as_bytes())?;
        buffer.write(&self.mute_data.mute_name[..])?;
        buffer.write_i32::<LittleEndian>(self.mute_data.mute_type)?;
        buffer.write_u32::<LittleEndian>(self.mute_data.mute_flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateMuteListEntry_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = UpdateMuteListEntry_MuteData::read_from(buffer)?;
        Ok(MessageInstance::UpdateMuteListEntry(UpdateMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for RemoveMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x08])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MuteData
        buffer.write(self.mute_data.mute_id.as_bytes())?;
        buffer.write(&self.mute_data.mute_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveMuteListEntry_AgentData::read_from(buffer)?;
        // Block MuteData
        let mute_data = RemoveMuteListEntry_MuteData::read_from(buffer)?;
        Ok(MessageInstance::RemoveMuteListEntry(RemoveMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for CopyInventoryFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x09])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block NotecardData
        buffer.write(self.notecard_data.notecard_item_id.as_bytes())?;
        buffer.write(self.notecard_data.object_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CopyInventoryFromNotecard_AgentData::read_from(buffer)?;
        // Block NotecardData
        let notecard_data = CopyInventoryFromNotecard_NotecardData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(CopyInventoryFromNotecard_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::CopyInventoryFromNotecard(
            CopyInventoryFromNotecard {
                agent_data: agent_data,
                notecard_data: notecard_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for UpdateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.transaction_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(UpdateInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateInventoryItem(UpdateInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateCreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u8(self.agent_data.sim_approved as u8)?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateCreateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(UpdateCreateInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateCreateInventoryItem(
            UpdateCreateInventoryItem {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for MoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.stamp as u8)?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MoveInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(MoveInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::MoveInventoryItem(MoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for CopyInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.old_agent_id.as_bytes())?;
            buffer.write(item.old_item_id.as_bytes())?;
            buffer.write(item.new_folder_id.as_bytes())?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CopyInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(CopyInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::CopyInventoryItem(CopyInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(RemoveInventoryItem_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryItem(RemoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ChangeInventoryItemFlags {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x0f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChangeInventoryItemFlags_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(ChangeInventoryItemFlags_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::ChangeInventoryItemFlags(
            ChangeInventoryItemFlags {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for SaveAssetIntoInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x10])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.new_asset_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SaveAssetIntoInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = SaveAssetIntoInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::SaveAssetIntoInventory(
            SaveAssetIntoInventory {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for CreateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x11])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write(self.folder_data.folder_id.as_bytes())?;
        buffer.write(self.folder_data.parent_id.as_bytes())?;
        buffer.write_i8(self.folder_data.type_)?;
        buffer.write(&self.folder_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let folder_data = CreateInventoryFolder_FolderData::read_from(buffer)?;
        Ok(MessageInstance::CreateInventoryFolder(
            CreateInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for UpdateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x12])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(UpdateInventoryFolder_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::UpdateInventoryFolder(
            UpdateInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for MoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x13])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u8(self.agent_data.stamp as u8)?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MoveInventoryFolder_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(MoveInventoryFolder_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::MoveInventoryFolder(MoveInventoryFolder {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x14])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveInventoryFolder_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(RemoveInventoryFolder_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryFolder(
            RemoveInventoryFolder {
                agent_data: agent_data,
                folder_data: folder_data,
            },
        ))
    }
}

impl Message for FetchInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x15])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.sort_order,
        )?;
        buffer.write_u8(self.inventory_data.fetch_folders as u8)?;
        buffer.write_u8(self.inventory_data.fetch_items as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = FetchInventoryDescendents_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = FetchInventoryDescendents_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::FetchInventoryDescendents(
            FetchInventoryDescendents {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for InventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x16])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.folder_id.as_bytes())?;
        buffer.write(self.agent_data.owner_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.version)?;
        buffer.write_i32::<LittleEndian>(
            self.agent_data.descendents,
        )?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write(&item.name[..])?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = InventoryDescendents_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(InventoryDescendents_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(InventoryDescendents_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::InventoryDescendents(
            InventoryDescendents {
                agent_data: agent_data,
                folder_data: folder_data,
                item_data: item_data,
            },
        ))
    }
}

impl Message for FetchInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x17])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = FetchInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(FetchInventory_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::FetchInventory(FetchInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for FetchInventoryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x18])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = FetchInventoryReply_AgentData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(FetchInventoryReply_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::FetchInventoryReply(FetchInventoryReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for BulkUpdateInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x19])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.transaction_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.parent_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write(&item.name[..])?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.callback_id)?;
            buffer.write(item.folder_id.as_bytes())?;
            buffer.write(item.creator_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.base_mask)?;
            buffer.write_u32::<LittleEndian>(item.owner_mask)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write_u8(item.group_owned as u8)?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
            buffer.write_i8(item.inv_type)?;
            buffer.write_u32::<LittleEndian>(item.flags)?;
            buffer.write_u8(item.sale_type)?;
            buffer.write_i32::<LittleEndian>(item.sale_price)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.creation_date)?;
            buffer.write_u32::<LittleEndian>(item.crc)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = BulkUpdateInventory_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(BulkUpdateInventory_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(BulkUpdateInventory_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::BulkUpdateInventory(BulkUpdateInventory {
            agent_data: agent_data,
            folder_data: folder_data,
            item_data: item_data,
        }))
    }
}

impl Message for RequestInventoryAsset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1a])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(self.query_data.agent_id.as_bytes())?;
        buffer.write(self.query_data.owner_id.as_bytes())?;
        buffer.write(self.query_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block QueryData
        let query_data = RequestInventoryAsset_QueryData::read_from(buffer)?;
        Ok(MessageInstance::RequestInventoryAsset(
            RequestInventoryAsset { query_data: query_data },
        ))
    }
}

impl Message for InventoryAssetResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1b])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        buffer.write(self.query_data.asset_id.as_bytes())?;
        buffer.write_u8(self.query_data.is_readable as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block QueryData
        let query_data = InventoryAssetResponse_QueryData::read_from(buffer)?;
        Ok(MessageInstance::InventoryAssetResponse(
            InventoryAssetResponse { query_data: query_data },
        ))
    }
}

impl Message for RemoveInventoryObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        // Block ItemData
        buffer.write_u8(self.item_data.len() as u8)?;
        for item in &self.item_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveInventoryObjects_AgentData::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(RemoveInventoryObjects_FolderData::read_from(buffer)?);
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = buffer.read_u8()?;
        for _ in 0.._item_data_count {
            item_data.push(RemoveInventoryObjects_ItemData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveInventoryObjects(
            RemoveInventoryObjects {
                agent_data: agent_data,
                folder_data: folder_data,
                item_data: item_data,
            },
        ))
    }
}

impl Message for PurgeInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = PurgeInventoryDescendents_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = PurgeInventoryDescendents_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::PurgeInventoryDescendents(
            PurgeInventoryDescendents {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for UpdateTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block UpdateData
        buffer.write_u32::<LittleEndian>(self.update_data.local_id)?;
        buffer.write_u8(self.update_data.key)?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.base_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.next_owner_mask,
        )?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.sale_price,
        )?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.creation_date,
        )?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateTaskInventory_AgentData::read_from(buffer)?;
        // Block UpdateData
        let update_data = UpdateTaskInventory_UpdateData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = UpdateTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::UpdateTaskInventory(UpdateTaskInventory {
            agent_data: agent_data,
            update_data: update_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x1f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.local_id,
        )?;
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RemoveTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RemoveTaskInventory(RemoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x20])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.folder_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.local_id,
        )?;
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MoveTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = MoveTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::MoveTaskInventory(MoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RequestTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x21])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.local_id,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RequestTaskInventory_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RequestTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RequestTaskInventory(
            RequestTaskInventory {
                agent_data: agent_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for ReplyTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x22])?;
        // Block InventoryData
        buffer.write(self.inventory_data.task_id.as_bytes())?;
        buffer.write_i16::<LittleEndian>(self.inventory_data.serial)?;
        buffer.write(&self.inventory_data.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block InventoryData
        let inventory_data = ReplyTaskInventory_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::ReplyTaskInventory(
            ReplyTaskInventory { inventory_data: inventory_data },
        ))
    }
}

impl Message for DeRezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x23])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AgentBlock
        buffer.write(self.agent_block.group_id.as_bytes())?;
        buffer.write_u8(self.agent_block.destination)?;
        buffer.write(self.agent_block.destination_id.as_bytes())?;
        buffer.write(self.agent_block.transaction_id.as_bytes())?;
        buffer.write_u8(self.agent_block.packet_count)?;
        buffer.write_u8(self.agent_block.packet_number)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DeRezObject_AgentData::read_from(buffer)?;
        // Block AgentBlock
        let agent_block = DeRezObject_AgentBlock::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(DeRezObject_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::DeRezObject(DeRezObject {
            agent_data: agent_data,
            agent_block: agent_block,
            object_data: object_data,
        }))
    }
}

impl Message for DeRezAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x24])?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        buffer.write_u8(self.transaction_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TransactionData
        let transaction_data = DeRezAck_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::DeRezAck(
            DeRezAck { transaction_data: transaction_data },
        ))
    }
}

impl Message for RezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x25])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RezData
        buffer.write(self.rez_data.from_task_id.as_bytes())?;
        buffer.write_u8(self.rez_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z)?;
        buffer.write(self.rez_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.rez_data.ray_end_is_intersection as u8)?;
        buffer.write_u8(self.rez_data.rez_selected as u8)?;
        buffer.write_u8(self.rez_data.remove_item as u8)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.item_flags)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(
            self.rez_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.rez_data.next_owner_mask,
        )?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.base_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.next_owner_mask,
        )?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.sale_price,
        )?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.creation_date,
        )?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezObject_AgentData::read_from(buffer)?;
        // Block RezData
        let rez_data = RezObject_RezData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RezObject_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RezObject(RezObject {
            agent_data: agent_data,
            rez_data: rez_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RezObjectFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x26])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RezData
        buffer.write(self.rez_data.from_task_id.as_bytes())?;
        buffer.write_u8(self.rez_data.bypass_raycast)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y)?;
        buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z)?;
        buffer.write(self.rez_data.ray_target_id.as_bytes())?;
        buffer.write_u8(self.rez_data.ray_end_is_intersection as u8)?;
        buffer.write_u8(self.rez_data.rez_selected as u8)?;
        buffer.write_u8(self.rez_data.remove_item as u8)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.item_flags)?;
        buffer.write_u32::<LittleEndian>(self.rez_data.group_mask)?;
        buffer.write_u32::<LittleEndian>(
            self.rez_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.rez_data.next_owner_mask,
        )?;
        // Block NotecardData
        buffer.write(self.notecard_data.notecard_item_id.as_bytes())?;
        buffer.write(self.notecard_data.object_id.as_bytes())?;
        // Block InventoryData
        buffer.write_u8(self.inventory_data.len() as u8)?;
        for item in &self.inventory_data {
            buffer.write(item.item_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezObjectFromNotecard_AgentData::read_from(buffer)?;
        // Block RezData
        let rez_data = RezObjectFromNotecard_RezData::read_from(buffer)?;
        // Block NotecardData
        let notecard_data = RezObjectFromNotecard_NotecardData::read_from(buffer)?;
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = buffer.read_u8()?;
        for _ in 0.._inventory_data_count {
            inventory_data.push(RezObjectFromNotecard_InventoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::RezObjectFromNotecard(
            RezObjectFromNotecard {
                agent_data: agent_data,
                rez_data: rez_data,
                notecard_data: notecard_data,
                inventory_data: inventory_data,
            },
        ))
    }
}

impl Message for TransferInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x27])?;
        // Block InfoBlock
        buffer.write(self.info_block.source_id.as_bytes())?;
        buffer.write(self.info_block.dest_id.as_bytes())?;
        buffer.write(self.info_block.transaction_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u8(self.inventory_block.len() as u8)?;
        for item in &self.inventory_block {
            buffer.write(item.inventory_id.as_bytes())?;
            buffer.write_i8(item.type_)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block InfoBlock
        let info_block = TransferInventory_InfoBlock::read_from(buffer)?;
        // Block InventoryBlock
        let mut inventory_block = Vec::new();
        let _inventory_block_count = buffer.read_u8()?;
        for _ in 0.._inventory_block_count {
            inventory_block.push(TransferInventory_InventoryBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::TransferInventory(TransferInventory {
            info_block: info_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for TransferInventoryAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x28])?;
        // Block InfoBlock
        buffer.write(self.info_block.transaction_id.as_bytes())?;
        buffer.write(self.info_block.inventory_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block InfoBlock
        let info_block = TransferInventoryAck_InfoBlock::read_from(buffer)?;
        Ok(MessageInstance::TransferInventoryAck(
            TransferInventoryAck { info_block: info_block },
        ))
    }
}

impl Message for AcceptFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x29])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(
            self.transaction_block.transaction_id.as_bytes(),
        )?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AcceptFriendship_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = AcceptFriendship_TransactionBlock::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(AcceptFriendship_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::AcceptFriendship(AcceptFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for DeclineFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(
            self.transaction_block.transaction_id.as_bytes(),
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DeclineFriendship_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = DeclineFriendship_TransactionBlock::read_from(buffer)?;
        Ok(MessageInstance::DeclineFriendship(DeclineFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for FormFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2b])?;
        // Block AgentBlock
        buffer.write(self.agent_block.source_id.as_bytes())?;
        buffer.write(self.agent_block.dest_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentBlock
        let agent_block = FormFriendship_AgentBlock::read_from(buffer)?;
        Ok(MessageInstance::FormFriendship(
            FormFriendship { agent_block: agent_block },
        ))
    }
}

impl Message for TerminateFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ExBlock
        buffer.write(self.ex_block.other_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = TerminateFriendship_AgentData::read_from(buffer)?;
        // Block ExBlock
        let ex_block = TerminateFriendship_ExBlock::read_from(buffer)?;
        Ok(MessageInstance::TerminateFriendship(TerminateFriendship {
            agent_data: agent_data,
            ex_block: ex_block,
        }))
    }
}

impl Message for OfferCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AgentBlock
        buffer.write(self.agent_block.dest_id.as_bytes())?;
        buffer.write(self.agent_block.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = OfferCallingCard_AgentData::read_from(buffer)?;
        // Block AgentBlock
        let agent_block = OfferCallingCard_AgentBlock::read_from(buffer)?;
        Ok(MessageInstance::OfferCallingCard(OfferCallingCard {
            agent_data: agent_data,
            agent_block: agent_block,
        }))
    }
}

impl Message for AcceptCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(
            self.transaction_block.transaction_id.as_bytes(),
        )?;
        // Block FolderData
        buffer.write_u8(self.folder_data.len() as u8)?;
        for item in &self.folder_data {
            buffer.write(item.folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AcceptCallingCard_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = AcceptCallingCard_TransactionBlock::read_from(buffer)?;
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = buffer.read_u8()?;
        for _ in 0.._folder_data_count {
            folder_data.push(AcceptCallingCard_FolderData::read_from(buffer)?);
        }
        Ok(MessageInstance::AcceptCallingCard(AcceptCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for DeclineCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x2f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block TransactionBlock
        buffer.write(
            self.transaction_block.transaction_id.as_bytes(),
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DeclineCallingCard_AgentData::read_from(buffer)?;
        // Block TransactionBlock
        let transaction_block = DeclineCallingCard_TransactionBlock::read_from(buffer)?;
        Ok(MessageInstance::DeclineCallingCard(DeclineCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for RezScript {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x30])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block UpdateBlock
        buffer.write_u32::<LittleEndian>(
            self.update_block.object_local_id,
        )?;
        buffer.write_u8(self.update_block.enabled as u8)?;
        // Block InventoryBlock
        buffer.write(self.inventory_block.item_id.as_bytes())?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.creator_id.as_bytes())?;
        buffer.write(self.inventory_block.owner_id.as_bytes())?;
        buffer.write(self.inventory_block.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.base_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.next_owner_mask,
        )?;
        buffer.write_u8(self.inventory_block.group_owned as u8)?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.flags)?;
        buffer.write_u8(self.inventory_block.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_block.sale_price,
        )?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write(&self.inventory_block.description[..])?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_block.creation_date,
        )?;
        buffer.write_u32::<LittleEndian>(self.inventory_block.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezScript_AgentData::read_from(buffer)?;
        // Block UpdateBlock
        let update_block = RezScript_UpdateBlock::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = RezScript_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::RezScript(RezScript {
            agent_data: agent_data,
            update_block: update_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for CreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x31])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.callback_id,
        )?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.next_owner_mask,
        )?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write_u8(self.inventory_block.wearable_type)?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write(&self.inventory_block.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = CreateInventoryItem_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateInventoryItem(CreateInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for CreateLandmarkForEvent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x32])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        // Block InventoryBlock
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(&self.inventory_block.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateLandmarkForEvent_AgentData::read_from(buffer)?;
        // Block EventData
        let event_data = CreateLandmarkForEvent_EventData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = CreateLandmarkForEvent_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateLandmarkForEvent(
            CreateLandmarkForEvent {
                agent_data: agent_data,
                event_data: event_data,
                inventory_block: inventory_block,
            },
        ))
    }
}

impl Message for EventLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x33])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block EventData
        buffer.write_u32::<LittleEndian>(self.event_data.event_id)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block QueryData
        let query_data = EventLocationRequest_QueryData::read_from(buffer)?;
        // Block EventData
        let event_data = EventLocationRequest_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventLocationRequest(
            EventLocationRequest {
                query_data: query_data,
                event_data: event_data,
            },
        ))
    }
}

impl Message for EventLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x34])?;
        // Block QueryData
        buffer.write(self.query_data.query_id.as_bytes())?;
        // Block EventData
        buffer.write_u8(self.event_data.success as u8)?;
        buffer.write(self.event_data.region_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(
            self.event_data.region_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.event_data.region_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.event_data.region_pos.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block QueryData
        let query_data = EventLocationReply_QueryData::read_from(buffer)?;
        // Block EventData
        let event_data = EventLocationReply_EventData::read_from(buffer)?;
        Ok(MessageInstance::EventLocationReply(EventLocationReply {
            query_data: query_data,
            event_data: event_data,
        }))
    }
}

impl Message for RegionHandleRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x35])?;
        // Block RequestBlock
        buffer.write(self.request_block.region_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RequestBlock
        let request_block = RegionHandleRequest_RequestBlock::read_from(buffer)?;
        Ok(MessageInstance::RegionHandleRequest(
            RegionHandleRequest { request_block: request_block },
        ))
    }
}

impl Message for RegionIDAndHandleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x36])?;
        // Block ReplyBlock
        buffer.write(self.reply_block.region_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(
            self.reply_block.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ReplyBlock
        let reply_block = RegionIDAndHandleReply_ReplyBlock::read_from(buffer)?;
        Ok(MessageInstance::RegionIDAndHandleReply(
            RegionIDAndHandleReply { reply_block: reply_block },
        ))
    }
}

impl Message for MoneyTransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x37])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.source_id.as_bytes())?;
        buffer.write(self.money_data.dest_id.as_bytes())?;
        buffer.write_u8(self.money_data.flags)?;
        buffer.write_i32::<LittleEndian>(self.money_data.amount)?;
        buffer.write_u8(self.money_data.aggregate_perm_next_owner)?;
        buffer.write_u8(self.money_data.aggregate_perm_inventory)?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.transaction_type,
        )?;
        buffer.write(&self.money_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MoneyTransferRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = MoneyTransferRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyTransferRequest(
            MoneyTransferRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for MoneyTransferBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x38])?;
        // Block MoneyData
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.money_data.transaction_time,
        )?;
        buffer.write(self.money_data.source_id.as_bytes())?;
        buffer.write(self.money_data.dest_id.as_bytes())?;
        buffer.write_u8(self.money_data.flags)?;
        buffer.write_i32::<LittleEndian>(self.money_data.amount)?;
        buffer.write_u8(self.money_data.aggregate_perm_next_owner)?;
        buffer.write_u8(self.money_data.aggregate_perm_inventory)?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.transaction_type,
        )?;
        buffer.write(self.money_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.money_data.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.money_data.grid_y)?;
        buffer.write(&self.money_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MoneyData
        let money_data = MoneyTransferBackend_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyTransferBackend(
            MoneyTransferBackend { money_data: money_data },
        ))
    }
}

impl Message for MoneyBalanceRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x39])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MoneyBalanceRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = MoneyBalanceRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::MoneyBalanceRequest(MoneyBalanceRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for MoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3a])?;
        // Block MoneyData
        buffer.write(self.money_data.agent_id.as_bytes())?;
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u8(self.money_data.transaction_success as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.money_balance,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.square_meters_credit,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.square_meters_committed,
        )?;
        buffer.write(&self.money_data.description[..])?;
        // Block TransactionInfo
        buffer.write_i32::<LittleEndian>(
            self.transaction_info.transaction_type,
        )?;
        buffer.write(self.transaction_info.source_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_source_group as u8)?;
        buffer.write(self.transaction_info.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_dest_group as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.transaction_info.amount,
        )?;
        buffer.write(&self.transaction_info.item_description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MoneyData
        let money_data = MoneyBalanceReply_MoneyData::read_from(buffer)?;
        // Block TransactionInfo
        let transaction_info = MoneyBalanceReply_TransactionInfo::read_from(buffer)?;
        Ok(MessageInstance::MoneyBalanceReply(MoneyBalanceReply {
            money_data: money_data,
            transaction_info: transaction_info,
        }))
    }
}

impl Message for RoutedMoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3b])?;
        // Block TargetBlock
        buffer.write(&self.target_block.target_ip.octets())?;
        buffer.write_u16::<LittleEndian>(
            self.target_block.target_port,
        )?;
        // Block MoneyData
        buffer.write(self.money_data.agent_id.as_bytes())?;
        buffer.write(self.money_data.transaction_id.as_bytes())?;
        buffer.write_u8(self.money_data.transaction_success as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.money_balance,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.square_meters_credit,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.square_meters_committed,
        )?;
        buffer.write(&self.money_data.description[..])?;
        // Block TransactionInfo
        buffer.write_i32::<LittleEndian>(
            self.transaction_info.transaction_type,
        )?;
        buffer.write(self.transaction_info.source_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_source_group as u8)?;
        buffer.write(self.transaction_info.dest_id.as_bytes())?;
        buffer.write_u8(self.transaction_info.is_dest_group as u8)?;
        buffer.write_i32::<LittleEndian>(
            self.transaction_info.amount,
        )?;
        buffer.write(&self.transaction_info.item_description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TargetBlock
        let target_block = RoutedMoneyBalanceReply_TargetBlock::read_from(buffer)?;
        // Block MoneyData
        let money_data = RoutedMoneyBalanceReply_MoneyData::read_from(buffer)?;
        // Block TransactionInfo
        let transaction_info = RoutedMoneyBalanceReply_TransactionInfo::read_from(buffer)?;
        Ok(MessageInstance::RoutedMoneyBalanceReply(
            RoutedMoneyBalanceReply {
                target_block: target_block,
                money_data: money_data,
                transaction_info: transaction_info,
            },
        ))
    }
}

impl Message for ActivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.gesture_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ActivateGestures_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(ActivateGestures_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::ActivateGestures(ActivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DeactivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.gesture_flags)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = DeactivateGestures_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(DeactivateGestures_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::DeactivateGestures(DeactivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for MuteListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3e])?;
        // Block MuteData
        buffer.write(self.mute_data.agent_id.as_bytes())?;
        buffer.write(&self.mute_data.filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MuteData
        let mute_data = MuteListUpdate_MuteData::read_from(buffer)?;
        Ok(MessageInstance::MuteListUpdate(
            MuteListUpdate { mute_data: mute_data },
        ))
    }
}

impl Message for UseCachedMuteList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x3f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UseCachedMuteList_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UseCachedMuteList(
            UseCachedMuteList { agent_data: agent_data },
        ))
    }
}

impl Message for GrantUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x40])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Rights
        buffer.write_u8(self.rights.len() as u8)?;
        for item in &self.rights {
            buffer.write(item.agent_related.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.related_rights)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GrantUserRights_AgentData::read_from(buffer)?;
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = buffer.read_u8()?;
        for _ in 0.._rights_count {
            rights.push(GrantUserRights_Rights::read_from(buffer)?);
        }
        Ok(MessageInstance::GrantUserRights(GrantUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for ChangeUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x41])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Rights
        buffer.write_u8(self.rights.len() as u8)?;
        for item in &self.rights {
            buffer.write(item.agent_related.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.related_rights)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ChangeUserRights_AgentData::read_from(buffer)?;
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = buffer.read_u8()?;
        for _ in 0.._rights_count {
            rights.push(ChangeUserRights_Rights::read_from(buffer)?);
        }
        Ok(MessageInstance::ChangeUserRights(ChangeUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for OnlineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x42])?;
        // Block AgentBlock
        buffer.write_u8(self.agent_block.len() as u8)?;
        for item in &self.agent_block {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = buffer.read_u8()?;
        for _ in 0.._agent_block_count {
            agent_block.push(OnlineNotification_AgentBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::OnlineNotification(
            OnlineNotification { agent_block: agent_block },
        ))
    }
}

impl Message for OfflineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x43])?;
        // Block AgentBlock
        buffer.write_u8(self.agent_block.len() as u8)?;
        for item in &self.agent_block {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = buffer.read_u8()?;
        for _ in 0.._agent_block_count {
            agent_block.push(OfflineNotification_AgentBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::OfflineNotification(
            OfflineNotification { agent_block: agent_block },
        ))
    }
}

impl Message for SetStartLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x44])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block StartLocationData
        buffer.write(&self.start_location_data.sim_name[..])?;
        buffer.write_u32::<LittleEndian>(
            self.start_location_data.location_id,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SetStartLocationRequest_AgentData::read_from(buffer)?;
        // Block StartLocationData
        let start_location_data = SetStartLocationRequest_StartLocationData::read_from(buffer)?;
        Ok(MessageInstance::SetStartLocationRequest(
            SetStartLocationRequest {
                agent_data: agent_data,
                start_location_data: start_location_data,
            },
        ))
    }
}

impl Message for SetStartLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x45])?;
        // Block StartLocationData
        buffer.write(self.start_location_data.agent_id.as_bytes())?;
        buffer.write(self.start_location_data.region_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.start_location_data.location_id,
        )?;
        buffer.write_u64::<LittleEndian>(
            self.start_location_data.region_handle,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_pos.z,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.x,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.y,
        )?;
        buffer.write_f32::<LittleEndian>(
            self.start_location_data.location_look_at.z,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block StartLocationData
        let start_location_data = SetStartLocation_StartLocationData::read_from(buffer)?;
        Ok(MessageInstance::SetStartLocation(SetStartLocation {
            start_location_data: start_location_data,
        }))
    }
}

impl Message for NetTest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x46])?;
        // Block NetBlock
        buffer.write_u16::<LittleEndian>(self.net_block.port)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block NetBlock
        let net_block = NetTest_NetBlock::read_from(buffer)?;
        Ok(MessageInstance::NetTest(NetTest { net_block: net_block }))
    }
}

impl Message for SetCPURatio {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x47])?;
        // Block Data
        buffer.write_u8(self.data.ratio)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = SetCPURatio_Data::read_from(buffer)?;
        Ok(MessageInstance::SetCPURatio(SetCPURatio { data: data }))
    }
}

impl Message for SimCrashed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x48])?;
        // Block Data
        buffer.write_u32::<LittleEndian>(self.data.region_x)?;
        buffer.write_u32::<LittleEndian>(self.data.region_y)?;
        // Block Users
        buffer.write_u8(self.users.len() as u8)?;
        for item in &self.users {
            buffer.write(item.agent_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block Data
        let data = SimCrashed_Data::read_from(buffer)?;
        // Block Users
        let mut users = Vec::new();
        let _users_count = buffer.read_u8()?;
        for _ in 0.._users_count {
            users.push(SimCrashed_Users::read_from(buffer)?);
        }
        Ok(MessageInstance::SimCrashed(SimCrashed {
            data: data,
            users: users,
        }))
    }
}

impl Message for NameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x49])?;
        // Block TaskData
        buffer.write(self.task_data.id.as_bytes())?;
        // Block NameValueData
        buffer.write_u8(self.name_value_data.len() as u8)?;
        for item in &self.name_value_data {
            buffer.write(&item.nv_pair[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TaskData
        let task_data = NameValuePair_TaskData::read_from(buffer)?;
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = buffer.read_u8()?;
        for _ in 0.._name_value_data_count {
            name_value_data.push(NameValuePair_NameValueData::read_from(buffer)?);
        }
        Ok(MessageInstance::NameValuePair(NameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for RemoveNameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4a])?;
        // Block TaskData
        buffer.write(self.task_data.id.as_bytes())?;
        // Block NameValueData
        buffer.write_u8(self.name_value_data.len() as u8)?;
        for item in &self.name_value_data {
            buffer.write(&item.nv_pair[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TaskData
        let task_data = RemoveNameValuePair_TaskData::read_from(buffer)?;
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = buffer.read_u8()?;
        for _ in 0.._name_value_data_count {
            name_value_data.push(RemoveNameValuePair_NameValueData::read_from(buffer)?);
        }
        Ok(MessageInstance::RemoveNameValuePair(RemoveNameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for UpdateAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AttachmentBlock
        buffer.write_u8(self.attachment_block.attachment_point)?;
        // Block OperationData
        buffer.write_u8(self.operation_data.add_item as u8)?;
        buffer.write_u8(
            self.operation_data.use_existing_asset as u8,
        )?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.base_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.next_owner_mask,
        )?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.asset_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.sale_price,
        )?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.creation_date,
        )?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateAttachment_AgentData::read_from(buffer)?;
        // Block AttachmentBlock
        let attachment_block = UpdateAttachment_AttachmentBlock::read_from(buffer)?;
        // Block OperationData
        let operation_data = UpdateAttachment_OperationData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = UpdateAttachment_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::UpdateAttachment(UpdateAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
            operation_data: operation_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block AttachmentBlock
        buffer.write_u8(self.attachment_block.attachment_point)?;
        buffer.write(self.attachment_block.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RemoveAttachment_AgentData::read_from(buffer)?;
        // Block AttachmentBlock
        let attachment_block = RemoveAttachment_AttachmentBlock::read_from(buffer)?;
        Ok(MessageInstance::RemoveAttachment(RemoveAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
        }))
    }
}

impl Message for SoundTrigger {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0x1d])?;
        // Block SoundData
        buffer.write(self.sound_data.sound_id.as_bytes())?;
        buffer.write(self.sound_data.owner_id.as_bytes())?;
        buffer.write(self.sound_data.object_id.as_bytes())?;
        buffer.write(self.sound_data.parent_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(self.sound_data.handle)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.position.x)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.position.y)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.position.z)?;
        buffer.write_f32::<LittleEndian>(self.sound_data.gain)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block SoundData
        let sound_data = SoundTrigger_SoundData::read_from(buffer)?;
        Ok(MessageInstance::SoundTrigger(
            SoundTrigger { sound_data: sound_data },
        ))
    }
}

impl Message for AttachedSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0d])?;
        // Block DataBlock
        buffer.write(self.data_block.sound_id.as_bytes())?;
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write(self.data_block.owner_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data_block.gain)?;
        buffer.write_u8(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = AttachedSound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::AttachedSound(
            AttachedSound { data_block: data_block },
        ))
    }
}

impl Message for AttachedSoundGainChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0e])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write_f32::<LittleEndian>(self.data_block.gain)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = AttachedSoundGainChange_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::AttachedSoundGainChange(
            AttachedSoundGainChange { data_block: data_block },
        ))
    }
}

impl Message for PreloadSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x0f])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write(item.object_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write(item.sound_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(PreloadSound_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::PreloadSound(
            PreloadSound { data_block: data_block },
        ))
    }
}

impl Message for AssetUploadRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4d])?;
        // Block AssetBlock
        buffer.write(self.asset_block.transaction_id.as_bytes())?;
        buffer.write_i8(self.asset_block.type_)?;
        buffer.write_u8(self.asset_block.tempfile as u8)?;
        buffer.write_u8(self.asset_block.store_local as u8)?;
        buffer.write(&self.asset_block.asset_data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AssetBlock
        let asset_block = AssetUploadRequest_AssetBlock::read_from(buffer)?;
        Ok(MessageInstance::AssetUploadRequest(
            AssetUploadRequest { asset_block: asset_block },
        ))
    }
}

impl Message for AssetUploadComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4e])?;
        // Block AssetBlock
        buffer.write(self.asset_block.uuid.as_bytes())?;
        buffer.write_i8(self.asset_block.type_)?;
        buffer.write_u8(self.asset_block.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AssetBlock
        let asset_block = AssetUploadComplete_AssetBlock::read_from(buffer)?;
        Ok(MessageInstance::AssetUploadComplete(
            AssetUploadComplete { asset_block: asset_block },
        ))
    }
}

impl Message for EmailMessageRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x4f])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write(&self.data_block.from_address[..])?;
        buffer.write(&self.data_block.subject[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = EmailMessageRequest_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::EmailMessageRequest(
            EmailMessageRequest { data_block: data_block },
        ))
    }
}

impl Message for EmailMessageReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x50])?;
        // Block DataBlock
        buffer.write(self.data_block.object_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.more)?;
        buffer.write_u32::<LittleEndian>(self.data_block.time)?;
        buffer.write(&self.data_block.from_address[..])?;
        buffer.write(&self.data_block.subject[..])?;
        buffer.write(&self.data_block.data[..])?;
        buffer.write(&self.data_block.mail_filter[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = EmailMessageReply_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::EmailMessageReply(
            EmailMessageReply { data_block: data_block },
        ))
    }
}

impl Message for InternalScriptMail {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x10])?;
        // Block DataBlock
        buffer.write(&self.data_block.from[..])?;
        buffer.write(self.data_block.to.as_bytes())?;
        buffer.write(&self.data_block.subject[..])?;
        buffer.write(&self.data_block.body[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = InternalScriptMail_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::InternalScriptMail(
            InternalScriptMail { data_block: data_block },
        ))
    }
}

impl Message for ScriptDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x51])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write_u64::<LittleEndian>(item.hash)?;
            buffer.write_i8(item.request_type)?;
            buffer.write(&item.request[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(ScriptDataRequest_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDataRequest(
            ScriptDataRequest { data_block: data_block },
        ))
    }
}

impl Message for ScriptDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x52])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write_u64::<LittleEndian>(item.hash)?;
            buffer.write(&item.reply[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(ScriptDataReply_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::ScriptDataReply(
            ScriptDataReply { data_block: data_block },
        ))
    }
}

impl Message for CreateGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x53])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(&self.group_data.name[..])?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.membership_fee,
        )?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = CreateGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::CreateGroupRequest(CreateGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for CreateGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x54])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block ReplyData
        buffer.write(self.reply_data.group_id.as_bytes())?;
        buffer.write_u8(self.reply_data.success as u8)?;
        buffer.write(&self.reply_data.message[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateGroupReply_AgentData::read_from(buffer)?;
        // Block ReplyData
        let reply_data = CreateGroupReply_ReplyData::read_from(buffer)?;
        Ok(MessageInstance::CreateGroupReply(CreateGroupReply {
            agent_data: agent_data,
            reply_data: reply_data,
        }))
    }
}

impl Message for UpdateGroupInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x55])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.membership_fee,
        )?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateGroupInfo_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = UpdateGroupInfo_GroupData::read_from(buffer)?;
        Ok(MessageInstance::UpdateGroupInfo(UpdateGroupInfo {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupRoleChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x56])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RoleChange
        buffer.write_u8(self.role_change.len() as u8)?;
        for item in &self.role_change {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(item.member_id.as_bytes())?;
            buffer.write_u32::<LittleEndian>(item.change)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleChanges_AgentData::read_from(buffer)?;
        // Block RoleChange
        let mut role_change = Vec::new();
        let _role_change_count = buffer.read_u8()?;
        for _ in 0.._role_change_count {
            role_change.push(GroupRoleChanges_RoleChange::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleChanges(GroupRoleChanges {
            agent_data: agent_data,
            role_change: role_change,
        }))
    }
}

impl Message for JoinGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x57])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = JoinGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = JoinGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::JoinGroupRequest(JoinGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for JoinGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x58])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u8(self.group_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = JoinGroupReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = JoinGroupReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::JoinGroupReply(JoinGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for EjectGroupMemberRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x59])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block EjectData
        buffer.write_u8(self.eject_data.len() as u8)?;
        for item in &self.eject_data {
            buffer.write(item.ejectee_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EjectGroupMemberRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = EjectGroupMemberRequest_GroupData::read_from(buffer)?;
        // Block EjectData
        let mut eject_data = Vec::new();
        let _eject_data_count = buffer.read_u8()?;
        for _ in 0.._eject_data_count {
            eject_data.push(EjectGroupMemberRequest_EjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::EjectGroupMemberRequest(
            EjectGroupMemberRequest {
                agent_data: agent_data,
                group_data: group_data,
                eject_data: eject_data,
            },
        ))
    }
}

impl Message for EjectGroupMemberReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block EjectData
        buffer.write_u8(self.eject_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = EjectGroupMemberReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = EjectGroupMemberReply_GroupData::read_from(buffer)?;
        // Block EjectData
        let eject_data = EjectGroupMemberReply_EjectData::read_from(buffer)?;
        Ok(MessageInstance::EjectGroupMemberReply(
            EjectGroupMemberReply {
                agent_data: agent_data,
                group_data: group_data,
                eject_data: eject_data,
            },
        ))
    }
}

impl Message for LeaveGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LeaveGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = LeaveGroupRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::LeaveGroupRequest(LeaveGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for LeaveGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write_u8(self.group_data.success as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LeaveGroupReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = LeaveGroupReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::LeaveGroupReply(LeaveGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for InviteGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block InviteData
        buffer.write_u8(self.invite_data.len() as u8)?;
        for item in &self.invite_data {
            buffer.write(item.invitee_id.as_bytes())?;
            buffer.write(item.role_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = InviteGroupRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = InviteGroupRequest_GroupData::read_from(buffer)?;
        // Block InviteData
        let mut invite_data = Vec::new();
        let _invite_data_count = buffer.read_u8()?;
        for _ in 0.._invite_data_count {
            invite_data.push(InviteGroupRequest_InviteData::read_from(buffer)?);
        }
        Ok(MessageInstance::InviteGroupRequest(InviteGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
            invite_data: invite_data,
        }))
    }
}

impl Message for InviteGroupResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5e])?;
        // Block InviteData
        buffer.write(self.invite_data.agent_id.as_bytes())?;
        buffer.write(self.invite_data.invitee_id.as_bytes())?;
        buffer.write(self.invite_data.group_id.as_bytes())?;
        buffer.write(self.invite_data.role_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.invite_data.membership_fee,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block InviteData
        let invite_data = InviteGroupResponse_InviteData::read_from(buffer)?;
        Ok(MessageInstance::InviteGroupResponse(
            InviteGroupResponse { invite_data: invite_data },
        ))
    }
}

impl Message for GroupProfileRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x5f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupProfileRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupProfileRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupProfileRequest(GroupProfileRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupProfileReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x60])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(&self.group_data.name[..])?;
        buffer.write(&self.group_data.charter[..])?;
        buffer.write_u8(self.group_data.show_in_list as u8)?;
        buffer.write(&self.group_data.member_title[..])?;
        buffer.write_u64::<LittleEndian>(
            self.group_data.powers_mask,
        )?;
        buffer.write(self.group_data.insignia_id.as_bytes())?;
        buffer.write(self.group_data.founder_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.membership_fee,
        )?;
        buffer.write_u8(self.group_data.open_enrollment as u8)?;
        buffer.write_i32::<LittleEndian>(self.group_data.money)?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.group_membership_count,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.group_roles_count,
        )?;
        buffer.write_u8(self.group_data.allow_publish as u8)?;
        buffer.write_u8(self.group_data.mature_publish as u8)?;
        buffer.write(self.group_data.owner_role.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupProfileReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupProfileReply_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupProfileReply(GroupProfileReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupAccountSummaryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x61])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountSummaryRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountSummaryRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountSummaryRequest(
            GroupAccountSummaryRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountSummaryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x62])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        buffer.write(&self.money_data.start_date[..])?;
        buffer.write_i32::<LittleEndian>(self.money_data.balance)?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.total_credits,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.total_debits,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.object_tax_current,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.light_tax_current,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.land_tax_current,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.group_tax_current,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.parcel_dir_fee_current,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.object_tax_estimate,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.light_tax_estimate,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.land_tax_estimate,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.group_tax_estimate,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.parcel_dir_fee_estimate,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.non_exempt_members,
        )?;
        buffer.write(&self.money_data.last_tax_date[..])?;
        buffer.write(&self.money_data.tax_date[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountSummaryReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountSummaryReply_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountSummaryReply(
            GroupAccountSummaryReply {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountDetailsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x63])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountDetailsRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountDetailsRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountDetailsRequest(
            GroupAccountDetailsRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountDetailsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x64])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        buffer.write(&self.money_data.start_date[..])?;
        // Block HistoryData
        buffer.write_u8(self.history_data.len() as u8)?;
        for item in &self.history_data {
            buffer.write(&item.description[..])?;
            buffer.write_i32::<LittleEndian>(item.amount)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountDetailsReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountDetailsReply_MoneyData::read_from(buffer)?;
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = buffer.read_u8()?;
        for _ in 0.._history_data_count {
            history_data.push(GroupAccountDetailsReply_HistoryData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupAccountDetailsReply(
            GroupAccountDetailsReply {
                agent_data: agent_data,
                money_data: money_data,
                history_data: history_data,
            },
        ))
    }
}

impl Message for GroupAccountTransactionsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x65])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountTransactionsRequest_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountTransactionsRequest_MoneyData::read_from(buffer)?;
        Ok(MessageInstance::GroupAccountTransactionsRequest(
            GroupAccountTransactionsRequest {
                agent_data: agent_data,
                money_data: money_data,
            },
        ))
    }
}

impl Message for GroupAccountTransactionsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x66])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block MoneyData
        buffer.write(self.money_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.interval_days,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.money_data.current_interval,
        )?;
        buffer.write(&self.money_data.start_date[..])?;
        // Block HistoryData
        buffer.write_u8(self.history_data.len() as u8)?;
        for item in &self.history_data {
            buffer.write(&item.time[..])?;
            buffer.write(&item.user[..])?;
            buffer.write_i32::<LittleEndian>(item.type_)?;
            buffer.write(&item.item[..])?;
            buffer.write_i32::<LittleEndian>(item.amount)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupAccountTransactionsReply_AgentData::read_from(buffer)?;
        // Block MoneyData
        let money_data = GroupAccountTransactionsReply_MoneyData::read_from(buffer)?;
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = buffer.read_u8()?;
        for _ in 0.._history_data_count {
            history_data.push(GroupAccountTransactionsReply_HistoryData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::GroupAccountTransactionsReply(
            GroupAccountTransactionsReply {
                agent_data: agent_data,
                money_data: money_data,
                history_data: history_data,
            },
        ))
    }
}

impl Message for GroupActiveProposalsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x67])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupActiveProposalsRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupActiveProposalsRequest_GroupData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupActiveProposalsRequest_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::GroupActiveProposalsRequest(
            GroupActiveProposalsRequest {
                agent_data: agent_data,
                group_data: group_data,
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for GroupActiveProposalItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x68])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        buffer.write_u32::<LittleEndian>(
            self.transaction_data.total_num_items,
        )?;
        // Block ProposalData
        buffer.write_u8(self.proposal_data.len() as u8)?;
        for item in &self.proposal_data {
            buffer.write(item.vote_id.as_bytes())?;
            buffer.write(item.vote_initiator.as_bytes())?;
            buffer.write(&item.terse_date_id[..])?;
            buffer.write(&item.start_date_time[..])?;
            buffer.write(&item.end_date_time[..])?;
            buffer.write_u8(item.already_voted as u8)?;
            buffer.write(&item.vote_cast[..])?;
            buffer.write_f32::<LittleEndian>(item.majority)?;
            buffer.write_i32::<LittleEndian>(item.quorum)?;
            buffer.write(&item.proposal_text[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupActiveProposalItemReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupActiveProposalItemReply_TransactionData::read_from(buffer)?;
        // Block ProposalData
        let mut proposal_data = Vec::new();
        let _proposal_data_count = buffer.read_u8()?;
        for _ in 0.._proposal_data_count {
            proposal_data.push(GroupActiveProposalItemReply_ProposalData::read_from(
                buffer,
            )?);
        }
        Ok(MessageInstance::GroupActiveProposalItemReply(
            GroupActiveProposalItemReply {
                agent_data: agent_data,
                transaction_data: transaction_data,
                proposal_data: proposal_data,
            },
        ))
    }
}

impl Message for GroupVoteHistoryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x69])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupVoteHistoryRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupVoteHistoryRequest_GroupData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupVoteHistoryRequest_TransactionData::read_from(buffer)?;
        Ok(MessageInstance::GroupVoteHistoryRequest(
            GroupVoteHistoryRequest {
                agent_data: agent_data,
                group_data: group_data,
                transaction_data: transaction_data,
            },
        ))
    }
}

impl Message for GroupVoteHistoryItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block TransactionData
        buffer.write(
            self.transaction_data.transaction_id.as_bytes(),
        )?;
        buffer.write_u32::<LittleEndian>(
            self.transaction_data.total_num_items,
        )?;
        // Block HistoryItemData
        buffer.write(self.history_item_data.vote_id.as_bytes())?;
        buffer.write(&self.history_item_data.terse_date_id[..])?;
        buffer.write(&self.history_item_data.start_date_time[..])?;
        buffer.write(&self.history_item_data.end_date_time[..])?;
        buffer.write(
            self.history_item_data.vote_initiator.as_bytes(),
        )?;
        buffer.write(&self.history_item_data.vote_type[..])?;
        buffer.write(&self.history_item_data.vote_result[..])?;
        buffer.write_f32::<LittleEndian>(
            self.history_item_data.majority,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.history_item_data.quorum,
        )?;
        buffer.write(&self.history_item_data.proposal_text[..])?;
        // Block VoteItem
        buffer.write_u8(self.vote_item.len() as u8)?;
        for item in &self.vote_item {
            buffer.write(item.candidate_id.as_bytes())?;
            buffer.write(&item.vote_cast[..])?;
            buffer.write_i32::<LittleEndian>(item.num_votes)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupVoteHistoryItemReply_AgentData::read_from(buffer)?;
        // Block TransactionData
        let transaction_data = GroupVoteHistoryItemReply_TransactionData::read_from(buffer)?;
        // Block HistoryItemData
        let history_item_data = GroupVoteHistoryItemReply_HistoryItemData::read_from(buffer)?;
        // Block VoteItem
        let mut vote_item = Vec::new();
        let _vote_item_count = buffer.read_u8()?;
        for _ in 0.._vote_item_count {
            vote_item.push(GroupVoteHistoryItemReply_VoteItem::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupVoteHistoryItemReply(
            GroupVoteHistoryItemReply {
                agent_data: agent_data,
                transaction_data: transaction_data,
                history_item_data: history_item_data,
                vote_item: vote_item,
            },
        ))
    }
}

impl Message for StartGroupProposal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ProposalData
        buffer.write(self.proposal_data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.proposal_data.quorum)?;
        buffer.write_f32::<LittleEndian>(
            self.proposal_data.majority,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.proposal_data.duration,
        )?;
        buffer.write(&self.proposal_data.proposal_text[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = StartGroupProposal_AgentData::read_from(buffer)?;
        // Block ProposalData
        let proposal_data = StartGroupProposal_ProposalData::read_from(buffer)?;
        Ok(MessageInstance::StartGroupProposal(StartGroupProposal {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for GroupProposalBallot {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ProposalData
        buffer.write(self.proposal_data.proposal_id.as_bytes())?;
        buffer.write(self.proposal_data.group_id.as_bytes())?;
        buffer.write(&self.proposal_data.vote_cast[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupProposalBallot_AgentData::read_from(buffer)?;
        // Block ProposalData
        let proposal_data = GroupProposalBallot_ProposalData::read_from(buffer)?;
        Ok(MessageInstance::GroupProposalBallot(GroupProposalBallot {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for TallyVotes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6d])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::TallyVotes(TallyVotes {}))
    }
}

impl Message for GroupMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupMembersRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupMembersRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupMembersRequest(GroupMembersRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x6f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(
            self.group_data.member_count,
        )?;
        // Block MemberData
        buffer.write_u8(self.member_data.len() as u8)?;
        for item in &self.member_data {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.contribution)?;
            buffer.write(&item.online_status[..])?;
            buffer.write_u64::<LittleEndian>(item.agent_powers)?;
            buffer.write(&item.title[..])?;
            buffer.write_u8(item.is_owner as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupMembersReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupMembersReply_GroupData::read_from(buffer)?;
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = buffer.read_u8()?;
        for _ in 0.._member_data_count {
            member_data.push(GroupMembersReply_MemberData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupMembersReply(GroupMembersReply {
            agent_data: agent_data,
            group_data: group_data,
            member_data: member_data,
        }))
    }
}

impl Message for ActivateGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x70])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ActivateGroup_AgentData::read_from(buffer)?;
        Ok(MessageInstance::ActivateGroup(
            ActivateGroup { agent_data: agent_data },
        ))
    }
}

impl Message for SetGroupContribution {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x71])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.data.contribution)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SetGroupContribution_AgentData::read_from(buffer)?;
        // Block Data
        let data = SetGroupContribution_Data::read_from(buffer)?;
        Ok(MessageInstance::SetGroupContribution(
            SetGroupContribution {
                agent_data: agent_data,
                data: data,
            },
        ))
    }
}

impl Message for SetGroupAcceptNotices {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x72])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Data
        buffer.write(self.data.group_id.as_bytes())?;
        buffer.write_u8(self.data.accept_notices as u8)?;
        // Block NewData
        buffer.write_u8(self.new_data.list_in_profile as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SetGroupAcceptNotices_AgentData::read_from(buffer)?;
        // Block Data
        let data = SetGroupAcceptNotices_Data::read_from(buffer)?;
        // Block NewData
        let new_data = SetGroupAcceptNotices_NewData::read_from(buffer)?;
        Ok(MessageInstance::SetGroupAcceptNotices(
            SetGroupAcceptNotices {
                agent_data: agent_data,
                data: data,
                new_data: new_data,
            },
        ))
    }
}

impl Message for GroupRoleDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x73])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleDataRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleDataRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupRoleDataRequest(
            GroupRoleDataRequest {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for GroupRoleDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x74])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.group_data.role_count)?;
        // Block RoleData
        buffer.write_u8(self.role_data.len() as u8)?;
        for item in &self.role_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.title[..])?;
            buffer.write(&item.description[..])?;
            buffer.write_u64::<LittleEndian>(item.powers)?;
            buffer.write_u32::<LittleEndian>(item.members)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleDataReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleDataReply_GroupData::read_from(buffer)?;
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = buffer.read_u8()?;
        for _ in 0.._role_data_count {
            role_data.push(GroupRoleDataReply_RoleData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleDataReply(GroupRoleDataReply {
            agent_data: agent_data,
            group_data: group_data,
            role_data: role_data,
        }))
    }
}

impl Message for GroupRoleMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x75])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block GroupData
        buffer.write(self.group_data.group_id.as_bytes())?;
        buffer.write(self.group_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleMembersRequest_AgentData::read_from(buffer)?;
        // Block GroupData
        let group_data = GroupRoleMembersRequest_GroupData::read_from(buffer)?;
        Ok(MessageInstance::GroupRoleMembersRequest(
            GroupRoleMembersRequest {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for GroupRoleMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x76])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.agent_data.total_pairs,
        )?;
        // Block MemberData
        buffer.write_u8(self.member_data.len() as u8)?;
        for item in &self.member_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(item.member_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleMembersReply_AgentData::read_from(buffer)?;
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = buffer.read_u8()?;
        for _ in 0.._member_data_count {
            member_data.push(GroupRoleMembersReply_MemberData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleMembersReply(
            GroupRoleMembersReply {
                agent_data: agent_data,
                member_data: member_data,
            },
        ))
    }
}

impl Message for GroupTitlesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x77])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupTitlesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::GroupTitlesRequest(
            GroupTitlesRequest { agent_data: agent_data },
        ))
    }
}

impl Message for GroupTitlesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x78])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.request_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write(&item.title[..])?;
            buffer.write(item.role_id.as_bytes())?;
            buffer.write_u8(item.selected as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupTitlesReply_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(GroupTitlesReply_GroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupTitlesReply(GroupTitlesReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupTitleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x79])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        buffer.write(self.agent_data.title_role_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupTitleUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::GroupTitleUpdate(
            GroupTitleUpdate { agent_data: agent_data },
        ))
    }
}

impl Message for GroupRoleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        // Block RoleData
        buffer.write_u8(self.role_data.len() as u8)?;
        for item in &self.role_data {
            buffer.write(item.role_id.as_bytes())?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
            buffer.write(&item.title[..])?;
            buffer.write_u64::<LittleEndian>(item.powers)?;
            buffer.write_u8(item.update_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = GroupRoleUpdate_AgentData::read_from(buffer)?;
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = buffer.read_u8()?;
        for _ in 0.._role_data_count {
            role_data.push(GroupRoleUpdate_RoleData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupRoleUpdate(GroupRoleUpdate {
            agent_data: agent_data,
            role_data: role_data,
        }))
    }
}

impl Message for LiveHelpGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7b])?;
        // Block RequestData
        buffer.write(self.request_data.request_id.as_bytes())?;
        buffer.write(self.request_data.agent_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RequestData
        let request_data = LiveHelpGroupRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::LiveHelpGroupRequest(
            LiveHelpGroupRequest { request_data: request_data },
        ))
    }
}

impl Message for LiveHelpGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7c])?;
        // Block ReplyData
        buffer.write(self.reply_data.request_id.as_bytes())?;
        buffer.write(self.reply_data.group_id.as_bytes())?;
        buffer.write(&self.reply_data.selection[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ReplyData
        let reply_data = LiveHelpGroupReply_ReplyData::read_from(buffer)?;
        Ok(MessageInstance::LiveHelpGroupReply(
            LiveHelpGroupReply { reply_data: reply_data },
        ))
    }
}

impl Message for AgentWearablesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7d])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentWearablesRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentWearablesRequest(
            AgentWearablesRequest { agent_data: agent_data },
        ))
    }
}

impl Message for AgentWearablesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.asset_id.as_bytes())?;
            buffer.write_u8(item.wearable_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentWearablesUpdate_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentWearablesUpdate_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentWearablesUpdate(
            AgentWearablesUpdate {
                agent_data: agent_data,
                wearable_data: wearable_data,
            },
        ))
    }
}

impl Message for AgentIsNowWearing {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x7f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write_u8(item.wearable_type)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentIsNowWearing_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentIsNowWearing_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentIsNowWearing(AgentIsNowWearing {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentCachedTexture {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x80])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentCachedTexture_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentCachedTexture_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentCachedTexture(AgentCachedTexture {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentCachedTextureResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x81])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_i32::<LittleEndian>(self.agent_data.serial_num)?;
        // Block WearableData
        buffer.write_u8(self.wearable_data.len() as u8)?;
        for item in &self.wearable_data {
            buffer.write(item.texture_id.as_bytes())?;
            buffer.write_u8(item.texture_index)?;
            buffer.write(&item.host_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentCachedTextureResponse_AgentData::read_from(buffer)?;
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = buffer.read_u8()?;
        for _ in 0.._wearable_data_count {
            wearable_data.push(AgentCachedTextureResponse_WearableData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentCachedTextureResponse(
            AgentCachedTextureResponse {
                agent_data: agent_data,
                wearable_data: wearable_data,
            },
        ))
    }
}

impl Message for AgentDataUpdateRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x82])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentDataUpdateRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDataUpdateRequest(
            AgentDataUpdateRequest { agent_data: agent_data },
        ))
    }
}

impl Message for AgentDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x83])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(&self.agent_data.first_name[..])?;
        buffer.write(&self.agent_data.last_name[..])?;
        buffer.write(&self.agent_data.group_title[..])?;
        buffer.write(self.agent_data.active_group_id.as_bytes())?;
        buffer.write_u64::<LittleEndian>(
            self.agent_data.group_powers,
        )?;
        buffer.write(&self.agent_data.group_name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentDataUpdate_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDataUpdate(
            AgentDataUpdate { agent_data: agent_data },
        ))
    }
}

impl Message for GroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x84])?;
        // Block AgentGroupData
        buffer.write_u8(self.agent_group_data.len() as u8)?;
        for item in &self.agent_group_data {
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.agent_powers)?;
            buffer.write(&item.group_title[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentGroupData
        let mut agent_group_data = Vec::new();
        let _agent_group_data_count = buffer.read_u8()?;
        for _ in 0.._agent_group_data_count {
            agent_group_data.push(GroupDataUpdate_AgentGroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::GroupDataUpdate(
            GroupDataUpdate { agent_group_data: agent_group_data },
        ))
    }
}

impl Message for AgentGroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x85])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block GroupData
        buffer.write_u8(self.group_data.len() as u8)?;
        for item in &self.group_data {
            buffer.write(item.group_id.as_bytes())?;
            buffer.write_u64::<LittleEndian>(item.group_powers)?;
            buffer.write_u8(item.accept_notices as u8)?;
            buffer.write(item.group_insignia_id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.contribution)?;
            buffer.write(&item.group_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentGroupDataUpdate_AgentData::read_from(buffer)?;
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = buffer.read_u8()?;
        for _ in 0.._group_data_count {
            group_data.push(AgentGroupDataUpdate_GroupData::read_from(buffer)?);
        }
        Ok(MessageInstance::AgentGroupDataUpdate(
            AgentGroupDataUpdate {
                agent_data: agent_data,
                group_data: group_data,
            },
        ))
    }
}

impl Message for AgentDropGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x86])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.group_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = AgentDropGroup_AgentData::read_from(buffer)?;
        Ok(MessageInstance::AgentDropGroup(
            AgentDropGroup { agent_data: agent_data },
        ))
    }
}

impl Message for LogTextMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x87])?;
        // Block DataBlock
        buffer.write_u8(self.data_block.len() as u8)?;
        for item in &self.data_block {
            buffer.write(item.from_agent_id.as_bytes())?;
            buffer.write(item.to_agent_id.as_bytes())?;
            buffer.write_f64::<LittleEndian>(item.global_x)?;
            buffer.write_f64::<LittleEndian>(item.global_y)?;
            buffer.write_u32::<LittleEndian>(item.time)?;
            buffer.write(&item.message[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = buffer.read_u8()?;
        for _ in 0.._data_block_count {
            data_block.push(LogTextMessage_DataBlock::read_from(buffer)?);
        }
        Ok(MessageInstance::LogTextMessage(
            LogTextMessage { data_block: data_block },
        ))
    }
}

impl Message for ViewerEffect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0x11])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block Effect
        buffer.write_u8(self.effect.len() as u8)?;
        for item in &self.effect {
            buffer.write(item.id.as_bytes())?;
            buffer.write(item.agent_id.as_bytes())?;
            buffer.write_u8(item.type_)?;
            buffer.write_f32::<LittleEndian>(item.duration)?;
            buffer.write(&item.color)?;
            buffer.write(&item.type_data[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ViewerEffect_AgentData::read_from(buffer)?;
        // Block Effect
        let mut effect = Vec::new();
        let _effect_count = buffer.read_u8()?;
        for _ in 0.._effect_count {
            effect.push(ViewerEffect_Effect::read_from(buffer)?);
        }
        Ok(MessageInstance::ViewerEffect(ViewerEffect {
            agent_data: agent_data,
            effect: effect,
        }))
    }
}

impl Message for CreateTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x88])?;
        // Block DataBlock
        buffer.write(self.data_block.end_point_id.as_bytes())?;
        buffer.write(&self.data_block.digest)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = CreateTrustedCircuit_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::CreateTrustedCircuit(
            CreateTrustedCircuit { data_block: data_block },
        ))
    }
}

impl Message for DenyTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x89])?;
        // Block DataBlock
        buffer.write(self.data_block.end_point_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = DenyTrustedCircuit_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::DenyTrustedCircuit(
            DenyTrustedCircuit { data_block: data_block },
        ))
    }
}

impl Message for RequestTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8a])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(_: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        Ok(MessageInstance::RequestTrustedCircuit(
            RequestTrustedCircuit {},
        ))
    }
}

impl Message for RezSingleAttachmentFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write(self.object_data.item_id.as_bytes())?;
        buffer.write(self.object_data.owner_id.as_bytes())?;
        buffer.write_u8(self.object_data.attachment_pt)?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.item_flags,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.object_data.next_owner_mask,
        )?;
        buffer.write(&self.object_data.name[..])?;
        buffer.write(&self.object_data.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezSingleAttachmentFromInv_AgentData::read_from(buffer)?;
        // Block ObjectData
        let object_data = RezSingleAttachmentFromInv_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::RezSingleAttachmentFromInv(
            RezSingleAttachmentFromInv {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RezMultipleAttachmentsFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write(self.header_data.compound_msg_id.as_bytes())?;
        buffer.write_u8(self.header_data.total_objects)?;
        buffer.write_u8(self.header_data.first_detach_all as u8)?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.item_id.as_bytes())?;
            buffer.write(item.owner_id.as_bytes())?;
            buffer.write_u8(item.attachment_pt)?;
            buffer.write_u32::<LittleEndian>(item.item_flags)?;
            buffer.write_u32::<LittleEndian>(item.group_mask)?;
            buffer.write_u32::<LittleEndian>(item.everyone_mask)?;
            buffer.write_u32::<LittleEndian>(item.next_owner_mask)?;
            buffer.write(&item.name[..])?;
            buffer.write(&item.description[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezMultipleAttachmentsFromInv_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = RezMultipleAttachmentsFromInv_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(RezMultipleAttachmentsFromInv_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::RezMultipleAttachmentsFromInv(
            RezMultipleAttachmentsFromInv {
                agent_data: agent_data,
                header_data: header_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for DetachAttachmentIntoInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8d])?;
        // Block ObjectData
        buffer.write(self.object_data.agent_id.as_bytes())?;
        buffer.write(self.object_data.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ObjectData
        let object_data = DetachAttachmentIntoInv_ObjectData::read_from(buffer)?;
        Ok(MessageInstance::DetachAttachmentIntoInv(
            DetachAttachmentIntoInv { object_data: object_data },
        ))
    }
}

impl Message for CreateNewOutfitAttachments {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8e])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block HeaderData
        buffer.write(self.header_data.new_folder_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write(item.old_item_id.as_bytes())?;
            buffer.write(item.old_folder_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = CreateNewOutfitAttachments_AgentData::read_from(buffer)?;
        // Block HeaderData
        let header_data = CreateNewOutfitAttachments_HeaderData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(CreateNewOutfitAttachments_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::CreateNewOutfitAttachments(
            CreateNewOutfitAttachments {
                agent_data: agent_data,
                header_data: header_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for UserInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x8f])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UserInfoRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::UserInfoRequest(
            UserInfoRequest { agent_data: agent_data },
        ))
    }
}

impl Message for UserInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x90])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block UserData
        buffer.write_u8(self.user_data.im_via_e_mail as u8)?;
        buffer.write(&self.user_data.directory_visibility[..])?;
        buffer.write(&self.user_data.e_mail[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UserInfoReply_AgentData::read_from(buffer)?;
        // Block UserData
        let user_data = UserInfoReply_UserData::read_from(buffer)?;
        Ok(MessageInstance::UserInfoReply(UserInfoReply {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for UpdateUserInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x91])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block UserData
        buffer.write_u8(self.user_data.im_via_e_mail as u8)?;
        buffer.write(&self.user_data.directory_visibility[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = UpdateUserInfo_AgentData::read_from(buffer)?;
        // Block UserData
        let user_data = UpdateUserInfo_UserData::read_from(buffer)?;
        Ok(MessageInstance::UpdateUserInfo(UpdateUserInfo {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for ParcelRename {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x92])?;
        // Block ParcelData
        buffer.write_u8(self.parcel_data.len() as u8)?;
        for item in &self.parcel_data {
            buffer.write(item.parcel_id.as_bytes())?;
            buffer.write(&item.new_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = buffer.read_u8()?;
        for _ in 0.._parcel_data_count {
            parcel_data.push(ParcelRename_ParcelData::read_from(buffer)?);
        }
        Ok(MessageInstance::ParcelRename(
            ParcelRename { parcel_data: parcel_data },
        ))
    }
}

impl Message for InitiateDownload {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x93])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block FileData
        buffer.write(&self.file_data.sim_filename[..])?;
        buffer.write(&self.file_data.viewer_filename[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = InitiateDownload_AgentData::read_from(buffer)?;
        // Block FileData
        let file_data = InitiateDownload_FileData::read_from(buffer)?;
        Ok(MessageInstance::InitiateDownload(InitiateDownload {
            agent_data: agent_data,
            file_data: file_data,
        }))
    }
}

impl Message for SystemMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x94])?;
        // Block MethodData
        buffer.write(&self.method_data.method[..])?;
        buffer.write(self.method_data.invoice.as_bytes())?;
        buffer.write(&self.method_data.digest)?;
        // Block ParamList
        buffer.write_u8(self.param_list.len() as u8)?;
        for item in &self.param_list {
            buffer.write(&item.parameter[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block MethodData
        let method_data = SystemMessage_MethodData::read_from(buffer)?;
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = buffer.read_u8()?;
        for _ in 0.._param_list_count {
            param_list.push(SystemMessage_ParamList::read_from(buffer)?);
        }
        Ok(MessageInstance::SystemMessage(SystemMessage {
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for MapLayerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x95])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapLayerRequest_AgentData::read_from(buffer)?;
        Ok(MessageInstance::MapLayerRequest(
            MapLayerRequest { agent_data: agent_data },
        ))
    }
}

impl Message for MapLayerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x96])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block LayerData
        buffer.write_u8(self.layer_data.len() as u8)?;
        for item in &self.layer_data {
            buffer.write_u32::<LittleEndian>(item.left)?;
            buffer.write_u32::<LittleEndian>(item.right)?;
            buffer.write_u32::<LittleEndian>(item.top)?;
            buffer.write_u32::<LittleEndian>(item.bottom)?;
            buffer.write(item.image_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapLayerReply_AgentData::read_from(buffer)?;
        // Block LayerData
        let mut layer_data = Vec::new();
        let _layer_data_count = buffer.read_u8()?;
        for _ in 0.._layer_data_count {
            layer_data.push(MapLayerReply_LayerData::read_from(buffer)?);
        }
        Ok(MessageInstance::MapLayerReply(MapLayerReply {
            agent_data: agent_data,
            layer_data: layer_data,
        }))
    }
}

impl Message for MapBlockRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x97])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block PositionData
        buffer.write_u16::<LittleEndian>(self.position_data.min_x)?;
        buffer.write_u16::<LittleEndian>(self.position_data.max_x)?;
        buffer.write_u16::<LittleEndian>(self.position_data.min_y)?;
        buffer.write_u16::<LittleEndian>(self.position_data.max_y)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapBlockRequest_AgentData::read_from(buffer)?;
        // Block PositionData
        let position_data = MapBlockRequest_PositionData::read_from(buffer)?;
        Ok(MessageInstance::MapBlockRequest(MapBlockRequest {
            agent_data: agent_data,
            position_data: position_data,
        }))
    }
}

impl Message for MapNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x98])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block NameData
        buffer.write(&self.name_data.name[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapNameRequest_AgentData::read_from(buffer)?;
        // Block NameData
        let name_data = MapNameRequest_NameData::read_from(buffer)?;
        Ok(MessageInstance::MapNameRequest(MapNameRequest {
            agent_data: agent_data,
            name_data: name_data,
        }))
    }
}

impl Message for MapBlockReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x99])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u16::<LittleEndian>(item.x)?;
            buffer.write_u16::<LittleEndian>(item.y)?;
            buffer.write(&item.name[..])?;
            buffer.write_u8(item.access)?;
            buffer.write_u32::<LittleEndian>(item.region_flags)?;
            buffer.write_u8(item.water_height)?;
            buffer.write_u8(item.agents)?;
            buffer.write(item.map_image_id.as_bytes())?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapBlockReply_AgentData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(MapBlockReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::MapBlockReply(MapBlockReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for MapItemRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9a])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        buffer.write_u32::<LittleEndian>(self.agent_data.estate_id)?;
        buffer.write_u8(self.agent_data.godlike as u8)?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(
            self.request_data.item_type,
        )?;
        buffer.write_u64::<LittleEndian>(
            self.request_data.region_handle,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapItemRequest_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = MapItemRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::MapItemRequest(MapItemRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for MapItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9b])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.agent_data.flags)?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(
            self.request_data.item_type,
        )?;
        // Block Data
        buffer.write_u8(self.data.len() as u8)?;
        for item in &self.data {
            buffer.write_u32::<LittleEndian>(item.x)?;
            buffer.write_u32::<LittleEndian>(item.y)?;
            buffer.write(item.id.as_bytes())?;
            buffer.write_i32::<LittleEndian>(item.extra)?;
            buffer.write_i32::<LittleEndian>(item.extra2)?;
            buffer.write(&item.name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = MapItemReply_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = MapItemReply_RequestData::read_from(buffer)?;
        // Block Data
        let mut data = Vec::new();
        let _data_count = buffer.read_u8()?;
        for _ in 0.._data_count {
            data.push(MapItemReply_Data::read_from(buffer)?);
        }
        Ok(MessageInstance::MapItemReply(MapItemReply {
            agent_data: agent_data,
            request_data: request_data,
            data: data,
        }))
    }
}

impl Message for SendPostcard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9c])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        buffer.write(self.agent_data.asset_id.as_bytes())?;
        buffer.write_f64::<LittleEndian>(
            self.agent_data.pos_global.x,
        )?;
        buffer.write_f64::<LittleEndian>(
            self.agent_data.pos_global.y,
        )?;
        buffer.write_f64::<LittleEndian>(
            self.agent_data.pos_global.z,
        )?;
        buffer.write(&self.agent_data.to[..])?;
        buffer.write(&self.agent_data.from[..])?;
        buffer.write(&self.agent_data.name[..])?;
        buffer.write(&self.agent_data.subject[..])?;
        buffer.write(&self.agent_data.msg[..])?;
        buffer.write_u8(self.agent_data.allow_publish as u8)?;
        buffer.write_u8(self.agent_data.mature_publish as u8)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = SendPostcard_AgentData::read_from(buffer)?;
        Ok(MessageInstance::SendPostcard(
            SendPostcard { agent_data: agent_data },
        ))
    }
}

impl Message for RpcChannelRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9d])?;
        // Block DataBlock
        buffer.write_u32::<LittleEndian>(self.data_block.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.data_block.grid_y)?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = RpcChannelRequest_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcChannelRequest(
            RpcChannelRequest { data_block: data_block },
        ))
    }
}

impl Message for RpcChannelReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9e])?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = RpcChannelReply_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcChannelReply(
            RpcChannelReply { data_block: data_block },
        ))
    }
}

impl Message for RpcScriptRequestInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0x9f])?;
        // Block TargetBlock
        buffer.write_u32::<LittleEndian>(self.target_block.grid_x)?;
        buffer.write_u32::<LittleEndian>(self.target_block.grid_y)?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block TargetBlock
        let target_block = RpcScriptRequestInbound_TargetBlock::read_from(buffer)?;
        // Block DataBlock
        let data_block = RpcScriptRequestInbound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptRequestInbound(
            RpcScriptRequestInbound {
                target_block: target_block,
                data_block: data_block,
            },
        ))
    }
}

impl Message for RpcScriptRequestInboundForward {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa0])?;
        // Block DataBlock
        buffer.write(&self.data_block.rpc_server_ip.octets())?;
        buffer.write_u16::<LittleEndian>(
            self.data_block.rpc_server_port,
        )?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = RpcScriptRequestInboundForward_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptRequestInboundForward(
            RpcScriptRequestInboundForward { data_block: data_block },
        ))
    }
}

impl Message for RpcScriptReplyInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa1])?;
        // Block DataBlock
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write(self.data_block.item_id.as_bytes())?;
        buffer.write(self.data_block.channel_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.int_value)?;
        buffer.write(&self.data_block.string_value[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = RpcScriptReplyInbound_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::RpcScriptReplyInbound(
            RpcScriptReplyInbound { data_block: data_block },
        ))
    }
}

impl Message for ScriptMailRegistration {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa2])?;
        // Block DataBlock
        buffer.write(&self.data_block.target_ip[..])?;
        buffer.write_u16::<LittleEndian>(
            self.data_block.target_port,
        )?;
        buffer.write(self.data_block.task_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(self.data_block.flags)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = ScriptMailRegistration_DataBlock::read_from(buffer)?;
        Ok(MessageInstance::ScriptMailRegistration(
            ScriptMailRegistration { data_block: data_block },
        ))
    }
}

impl Message for ParcelMediaCommandMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa3])?;
        // Block CommandBlock
        buffer.write_u32::<LittleEndian>(self.command_block.flags)?;
        buffer.write_u32::<LittleEndian>(self.command_block.command)?;
        buffer.write_f32::<LittleEndian>(self.command_block.time)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block CommandBlock
        let command_block = ParcelMediaCommandMessage_CommandBlock::read_from(buffer)?;
        Ok(MessageInstance::ParcelMediaCommandMessage(
            ParcelMediaCommandMessage { command_block: command_block },
        ))
    }
}

impl Message for ParcelMediaUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa4])?;
        // Block DataBlock
        buffer.write(&self.data_block.media_url[..])?;
        buffer.write(self.data_block.media_id.as_bytes())?;
        buffer.write_u8(self.data_block.media_auto_scale)?;
        // Block DataBlockExtended
        buffer.write(&self.data_block_extended.media_type[..])?;
        buffer.write(&self.data_block_extended.media_desc[..])?;
        buffer.write_i32::<LittleEndian>(
            self.data_block_extended.media_width,
        )?;
        buffer.write_i32::<LittleEndian>(
            self.data_block_extended.media_height,
        )?;
        buffer.write_u8(self.data_block_extended.media_loop)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block DataBlock
        let data_block = ParcelMediaUpdate_DataBlock::read_from(buffer)?;
        // Block DataBlockExtended
        let data_block_extended = ParcelMediaUpdate_DataBlockExtended::read_from(buffer)?;
        Ok(MessageInstance::ParcelMediaUpdate(ParcelMediaUpdate {
            data_block: data_block,
            data_block_extended: data_block_extended,
        }))
    }
}

impl Message for LandStatRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa5])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(
            self.request_data.report_type,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.request_data.request_flags,
        )?;
        buffer.write(&self.request_data.filter[..])?;
        buffer.write_i32::<LittleEndian>(
            self.request_data.parcel_local_id,
        )?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LandStatRequest_AgentData::read_from(buffer)?;
        // Block RequestData
        let request_data = LandStatRequest_RequestData::read_from(buffer)?;
        Ok(MessageInstance::LandStatRequest(LandStatRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for LandStatReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa6])?;
        // Block RequestData
        buffer.write_u32::<LittleEndian>(
            self.request_data.report_type,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.request_data.request_flags,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.request_data.total_object_count,
        )?;
        // Block ReportData
        buffer.write_u8(self.report_data.len() as u8)?;
        for item in &self.report_data {
            buffer.write_u32::<LittleEndian>(item.task_local_id)?;
            buffer.write(item.task_id.as_bytes())?;
            buffer.write_f32::<LittleEndian>(item.location_x)?;
            buffer.write_f32::<LittleEndian>(item.location_y)?;
            buffer.write_f32::<LittleEndian>(item.location_z)?;
            buffer.write_f32::<LittleEndian>(item.score)?;
            buffer.write(&item.task_name[..])?;
            buffer.write(&item.owner_name[..])?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block RequestData
        let request_data = LandStatReply_RequestData::read_from(buffer)?;
        // Block ReportData
        let mut report_data = Vec::new();
        let _report_data_count = buffer.read_u8()?;
        for _ in 0.._report_data_count {
            report_data.push(LandStatReply_ReportData::read_from(buffer)?);
        }
        Ok(MessageInstance::LandStatReply(LandStatReply {
            request_data: request_data,
            report_data: report_data,
        }))
    }
}

impl Message for Error {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa7])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        // Block Data
        buffer.write_i32::<LittleEndian>(self.data.code)?;
        buffer.write(&self.data.token[..])?;
        buffer.write(self.data.id.as_bytes())?;
        buffer.write(&self.data.system[..])?;
        buffer.write(&self.data.message[..])?;
        buffer.write(&self.data.data[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = Error_AgentData::read_from(buffer)?;
        // Block Data
        let data = Error_Data::read_from(buffer)?;
        Ok(MessageInstance::Error(Error {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ObjectIncludeInSearch {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa8])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block ObjectData
        buffer.write_u8(self.object_data.len() as u8)?;
        for item in &self.object_data {
            buffer.write_u32::<LittleEndian>(item.object_local_id)?;
            buffer.write_u8(item.include_in_search as u8)?;
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = ObjectIncludeInSearch_AgentData::read_from(buffer)?;
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = buffer.read_u8()?;
        for _ in 0.._object_data_count {
            object_data.push(ObjectIncludeInSearch_ObjectData::read_from(buffer)?);
        }
        Ok(MessageInstance::ObjectIncludeInSearch(
            ObjectIncludeInSearch {
                agent_data: agent_data,
                object_data: object_data,
            },
        ))
    }
}

impl Message for RezRestoreToWorld {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xa9])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryData
        buffer.write(self.inventory_data.item_id.as_bytes())?;
        buffer.write(self.inventory_data.folder_id.as_bytes())?;
        buffer.write(self.inventory_data.creator_id.as_bytes())?;
        buffer.write(self.inventory_data.owner_id.as_bytes())?;
        buffer.write(self.inventory_data.group_id.as_bytes())?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.base_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.owner_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.group_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.everyone_mask,
        )?;
        buffer.write_u32::<LittleEndian>(
            self.inventory_data.next_owner_mask,
        )?;
        buffer.write_u8(self.inventory_data.group_owned as u8)?;
        buffer.write(self.inventory_data.transaction_id.as_bytes())?;
        buffer.write_i8(self.inventory_data.type_)?;
        buffer.write_i8(self.inventory_data.inv_type)?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.flags)?;
        buffer.write_u8(self.inventory_data.sale_type)?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.sale_price,
        )?;
        buffer.write(&self.inventory_data.name[..])?;
        buffer.write(&self.inventory_data.description[..])?;
        buffer.write_i32::<LittleEndian>(
            self.inventory_data.creation_date,
        )?;
        buffer.write_u32::<LittleEndian>(self.inventory_data.crc)?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = RezRestoreToWorld_AgentData::read_from(buffer)?;
        // Block InventoryData
        let inventory_data = RezRestoreToWorld_InventoryData::read_from(buffer)?;
        Ok(MessageInstance::RezRestoreToWorld(RezRestoreToWorld {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for LinkInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
    where
        W: Write,
    {
        // Write the message number.
        buffer.write(&[0xff, 0xff, 0x01, 0xaa])?;
        // Block AgentData
        buffer.write(self.agent_data.agent_id.as_bytes())?;
        buffer.write(self.agent_data.session_id.as_bytes())?;
        // Block InventoryBlock
        buffer.write_u32::<LittleEndian>(
            self.inventory_block.callback_id,
        )?;
        buffer.write(self.inventory_block.folder_id.as_bytes())?;
        buffer.write(self.inventory_block.transaction_id.as_bytes())?;
        buffer.write(self.inventory_block.old_item_id.as_bytes())?;
        buffer.write_i8(self.inventory_block.type_)?;
        buffer.write_i8(self.inventory_block.inv_type)?;
        buffer.write(&self.inventory_block.name[..])?;
        buffer.write(&self.inventory_block.description[..])?;
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where
        R: Read,
    {
        // Block AgentData
        let agent_data = LinkInventoryItem_AgentData::read_from(buffer)?;
        // Block InventoryBlock
        let inventory_block = LinkInventoryItem_InventoryBlock::read_from(buffer)?;
        Ok(MessageInstance::LinkInventoryItem(LinkInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}
