use {Vector3, Vector4, Quaternion, UnitQuaternion, Ip4Addr, Ip4Port, Uuid};
use std::io::{Read, Write};
use byteorder::{LittleEndian, BigEndian, ReadBytesExt, WriteBytesExt};

pub enum WriteMessageError {
    IoError(::std::io::Error)
}

pub enum ReadMessageError {
    IoError(::std::io::Error),

    /// There was an issue parsing one of the types.
    ParseError,

    /// No message struct for the message to be read was found.
    UnknownMessageNumber
}

impl From<::std::io::Error> for WriteMessageError {
    fn from(e: ::std::io::Error) -> WriteMessageError {
        WriteMessageError::IoError(e)
    }
}

impl From<::std::io::Error> for ReadMessageError {
    fn from(e: ::std::io::Error) -> ReadMessageError {
        ReadMessageError::IoError(e)
    }
}

impl From<::uuid::ParseError> for ReadMessageError {
    fn from(e: ::uuid::ParseError) -> ReadMessageError {
        ReadMessageError::ParseError
    }
}

pub type WriteMessageResult = Result<(), WriteMessageError>;

pub trait Message {
    /// Write the message to a buffer for network transmission.
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult where W: Write;

    /// Read the message from a buffer obtained from the network.
    /// When this function is invoked it is assumed that the message number has
    /// already been read from the buffer object and the body of the message
    /// is at the initial buffer position.
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Box<Self>, ReadMessageError> where R: Read;
}

/*
fn read_message<R: Read>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError> {
    // Read the message number.
    // TODO: Actually we will have to read byte by byte and decide if the ID is already over.
    let mut message_number = vec![0; 4];
    buffer.read_exact(&mut message_number);

    // TODO: The body of this function will have to be generated by the script.
    Err(ReadMessageError::UnknownMessageNumber)
}
*/



