use {Vector3, Vector4, Quaternion, UnitQuaternion, Ip4Addr, Ip4Port, Uuid};
use std::io::{Read, Write};
use byteorder::{LittleEndian, BigEndian, WriteBytesExt};

pub enum WriteMessageError {
    IoError(::std::io::Error)
}

pub enum ReadMessageError {
    IoError(::std::io::Error),

    /// No message struct for the message to be read was found.
    UnknownMessageNumber
}

impl From<::std::io::Error> for WriteMessageError {
    fn from(e: ::std::io::Error) -> WriteMessageError {
        WriteMessageError::IoError(e)
    }
}

impl From<::std::io::Error> for ReadMessageError {
    fn from(e: ::std::io::Error) -> ReadMessageError {
        ReadMessageError::IoError(e)
    }
}

pub type WriteMessageResult = Result<(), WriteMessageError>;
pub trait Message {
    /// Write the message to a buffer for network transmission.
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult;

    /*
    /// Read the message from a buffer obtained from the network.
    /// When this function is invoked it is assumed that the message number has
    /// already been read from the message.
    fn read_from<R: Read>(buffer: &mut R) -> Result<Self, ReadMessageError>;
    */
}

/* TODO
fn read_message<R: Read>(buffer: &mut R) -> Result<Box<Message>, ReadMessageError> {
    // Read the message number.
    let mut message_number = vec![0; 4];
    buffer.read(&mut message_number);

    // TODO: The body of this function will have to be generated by the script.
    Err(ReadMessageError::UnknownMessageNumber)
}
*/
