///
/// THIS FILE WAS AUTOGENERATED.
/// DON'T EDIT MANUALLY!
/// If you want to change the file, edit the generator script `generate/generate.rb`.
///

use {Vector3, Vector4, Quaternion, UnitQuaternion, Ip4Addr, IpPort, Uuid};
use std::io::{Read, Write};
use byteorder::{LittleEndian, BigEndian, ReadBytesExt, WriteBytesExt};

pub enum WriteMessageError {
    IoError(::std::io::Error),
}

pub enum ReadMessageError {
    IoError(::std::io::Error),

    /// There was an issue parsing one of the types.
    ParseError,

    /// No message struct for the message to be read was found.
    UnknownMessageNumber,
}

impl From<::std::io::Error> for WriteMessageError {
    fn from(e: ::std::io::Error) -> WriteMessageError {
        WriteMessageError::IoError(e)
    }
}

impl From<::std::io::Error> for ReadMessageError {
    fn from(e: ::std::io::Error) -> ReadMessageError {
        ReadMessageError::IoError(e)
    }
}

impl From<::uuid::ParseError> for ReadMessageError {
    fn from(e: ::uuid::ParseError) -> ReadMessageError {
        ReadMessageError::ParseError
    }
}

pub type WriteMessageResult = Result<(), WriteMessageError>;

pub trait Message {
    /// Write the message to a buffer for network transmission.
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult where W: Write;

    /// Read the message from a buffer obtained from the network.
    /// When this function is invoked it is assumed that the message number has
    /// already been read from the buffer object and the body of the message
    /// is at the initial buffer position.
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError> where R: Read;
}

fn read_message<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
    where R: Read
{
    // High frequency messages.
    match try!(buffer.read_u8()) {
        0x01 => return StartPingCheck::read_from(buffer),
        0x02 => return CompletePingCheck::read_from(buffer),
        0x03 => return NeighborList::read_from(buffer),
        0x04 => return AgentUpdate::read_from(buffer),
        0x05 => return AgentAnimation::read_from(buffer),
        0x06 => return AgentRequestSit::read_from(buffer),
        0x07 => return AgentSit::read_from(buffer),
        0x08 => return RequestImage::read_from(buffer),
        0x09 => return ImageData::read_from(buffer),
        0x0a => return ImagePacket::read_from(buffer),
        0x0b => return LayerData::read_from(buffer),
        0x0c => return ObjectUpdate::read_from(buffer),
        0x0d => return ObjectUpdateCompressed::read_from(buffer),
        0x0e => return ObjectUpdateCached::read_from(buffer),
        0x0f => return ImprovedTerseObjectUpdate::read_from(buffer),
        0x10 => return KillObject::read_from(buffer),
        0x11 => return TransferPacket::read_from(buffer),
        0x12 => return SendXferPacket::read_from(buffer),
        0x13 => return ConfirmXferPacket::read_from(buffer),
        0x14 => return AvatarAnimation::read_from(buffer),
        0x15 => return AvatarSitResponse::read_from(buffer),
        0x16 => return CameraConstraint::read_from(buffer),
        0x17 => return ParcelProperties::read_from(buffer),
        0x18 => return EdgeDataPacket::read_from(buffer),
        0x19 => return ChildAgentUpdate::read_from(buffer),
        0x1a => return ChildAgentAlive::read_from(buffer),
        0x1b => return ChildAgentPositionUpdate::read_from(buffer),
        0x1c => return AtomicPassObject::read_from(buffer),
        0x1d => return SoundTrigger::read_from(buffer),
        0xff => {}
        _ => return Err(ReadMessageError::UnknownMessageNumber),
    }

    // Medium frequency messages.
    match try!(buffer.read_u8()) {
        0x01 => return ObjectAdd::read_from(buffer),
        0x02 => return MultipleObjectUpdate::read_from(buffer),
        0x03 => return RequestMultipleObjects::read_from(buffer),
        0x04 => return ObjectPosition::read_from(buffer),
        0x05 => return RequestObjectPropertiesFamily::read_from(buffer),
        0x06 => return CoarseLocationUpdate::read_from(buffer),
        0x07 => return CrossedRegion::read_from(buffer),
        0x08 => return ConfirmEnableSimulator::read_from(buffer),
        0x09 => return ObjectProperties::read_from(buffer),
        0x0a => return ObjectPropertiesFamily::read_from(buffer),
        0x0b => return ParcelPropertiesRequest::read_from(buffer),
        0x0c => return SimStatus::read_from(buffer),
        0x0d => return AttachedSound::read_from(buffer),
        0x0e => return AttachedSoundGainChange::read_from(buffer),
        0x0f => return PreloadSound::read_from(buffer),
        0x10 => return InternalScriptMail::read_from(buffer),
        0x11 => return ViewerEffect::read_from(buffer),
        0xff => {}
        _ => return Err(ReadMessageError::UnknownMessageNumber),
    }

    // Low and fixed frequency messages.
    match try!(buffer.read_u16::<BigEndian>()) {
        0x0001 => return TestMessage::read_from(buffer),
        0xffFB => return PacketAck::read_from(buffer),
        0xffFC => return OpenCircuit::read_from(buffer),
        0xffFD => return CloseCircuit::read_from(buffer),
        0x0002 => return AddCircuitCode::read_from(buffer),
        0x0003 => return UseCircuitCode::read_from(buffer),
        0x0004 => return AvatarTextureUpdate::read_from(buffer),
        0x0005 => return SimulatorMapUpdate::read_from(buffer),
        0x0006 => return SimulatorSetMap::read_from(buffer),
        0x0007 => return SubscribeLoad::read_from(buffer),
        0x0008 => return UnsubscribeLoad::read_from(buffer),
        0x0009 => return SimulatorReady::read_from(buffer),
        0x000a => return TelehubInfo::read_from(buffer),
        0x000b => return SimulatorPresentAtLocation::read_from(buffer),
        0x000c => return SimulatorLoad::read_from(buffer),
        0x000d => return SimulatorShutdownRequest::read_from(buffer),
        0x000e => return RegionPresenceRequestByRegionID::read_from(buffer),
        0x000f => return RegionPresenceRequestByHandle::read_from(buffer),
        0x0010 => return RegionPresenceResponse::read_from(buffer),
        0x0011 => return UpdateSimulator::read_from(buffer),
        0x0012 => return LogDwellTime::read_from(buffer),
        0x0013 => return FeatureDisabled::read_from(buffer),
        0x0014 => return LogFailedMoneyTransaction::read_from(buffer),
        0x0015 => return UserReportInternal::read_from(buffer),
        0x0016 => return SetSimStatusInDatabase::read_from(buffer),
        0x0017 => return SetSimPresenceInDatabase::read_from(buffer),
        0x0018 => return EconomyDataRequest::read_from(buffer),
        0x0019 => return EconomyData::read_from(buffer),
        0x001a => return AvatarPickerRequest::read_from(buffer),
        0x001b => return AvatarPickerRequestBackend::read_from(buffer),
        0x001c => return AvatarPickerReply::read_from(buffer),
        0x001d => return PlacesQuery::read_from(buffer),
        0x001e => return PlacesReply::read_from(buffer),
        0x001f => return DirFindQuery::read_from(buffer),
        0x0020 => return DirFindQueryBackend::read_from(buffer),
        0x0021 => return DirPlacesQuery::read_from(buffer),
        0x0022 => return DirPlacesQueryBackend::read_from(buffer),
        0x0023 => return DirPlacesReply::read_from(buffer),
        0x0024 => return DirPeopleReply::read_from(buffer),
        0x0025 => return DirEventsReply::read_from(buffer),
        0x0026 => return DirGroupsReply::read_from(buffer),
        0x0027 => return DirClassifiedQuery::read_from(buffer),
        0x0028 => return DirClassifiedQueryBackend::read_from(buffer),
        0x0029 => return DirClassifiedReply::read_from(buffer),
        0x002a => return AvatarClassifiedReply::read_from(buffer),
        0x002b => return ClassifiedInfoRequest::read_from(buffer),
        0x002c => return ClassifiedInfoReply::read_from(buffer),
        0x002d => return ClassifiedInfoUpdate::read_from(buffer),
        0x002e => return ClassifiedDelete::read_from(buffer),
        0x002f => return ClassifiedGodDelete::read_from(buffer),
        0x0030 => return DirLandQuery::read_from(buffer),
        0x0031 => return DirLandQueryBackend::read_from(buffer),
        0x0032 => return DirLandReply::read_from(buffer),
        0x0033 => return DirPopularQuery::read_from(buffer),
        0x0034 => return DirPopularQueryBackend::read_from(buffer),
        0x0035 => return DirPopularReply::read_from(buffer),
        0x0036 => return ParcelInfoRequest::read_from(buffer),
        0x0037 => return ParcelInfoReply::read_from(buffer),
        0x0038 => return ParcelObjectOwnersRequest::read_from(buffer),
        0x0039 => return ParcelObjectOwnersReply::read_from(buffer),
        0x003a => return GroupNoticesListRequest::read_from(buffer),
        0x003b => return GroupNoticesListReply::read_from(buffer),
        0x003c => return GroupNoticeRequest::read_from(buffer),
        0x003d => return GroupNoticeAdd::read_from(buffer),
        0x003e => return TeleportRequest::read_from(buffer),
        0x003f => return TeleportLocationRequest::read_from(buffer),
        0x0040 => return TeleportLocal::read_from(buffer),
        0x0041 => return TeleportLandmarkRequest::read_from(buffer),
        0x0042 => return TeleportProgress::read_from(buffer),
        0x0043 => return DataHomeLocationRequest::read_from(buffer),
        0x0044 => return DataHomeLocationReply::read_from(buffer),
        0x0045 => return TeleportFinish::read_from(buffer),
        0x0046 => return StartLure::read_from(buffer),
        0x0047 => return TeleportLureRequest::read_from(buffer),
        0x0048 => return TeleportCancel::read_from(buffer),
        0x0049 => return TeleportStart::read_from(buffer),
        0x004a => return TeleportFailed::read_from(buffer),
        0x004b => return Undo::read_from(buffer),
        0x004c => return Redo::read_from(buffer),
        0x004d => return UndoLand::read_from(buffer),
        0x004e => return AgentPause::read_from(buffer),
        0x004f => return AgentResume::read_from(buffer),
        0x0050 => return ChatFromViewer::read_from(buffer),
        0x0051 => return AgentThrottle::read_from(buffer),
        0x0052 => return AgentFOV::read_from(buffer),
        0x0053 => return AgentHeightWidth::read_from(buffer),
        0x0054 => return AgentSetAppearance::read_from(buffer),
        0x0055 => return AgentQuitCopy::read_from(buffer),
        0x0056 => return ImageNotInDatabase::read_from(buffer),
        0x0057 => return RebakeAvatarTextures::read_from(buffer),
        0x0058 => return SetAlwaysRun::read_from(buffer),
        0x0059 => return ObjectDelete::read_from(buffer),
        0x005a => return ObjectDuplicate::read_from(buffer),
        0x005b => return ObjectDuplicateOnRay::read_from(buffer),
        0x005c => return ObjectScale::read_from(buffer),
        0x005d => return ObjectRotation::read_from(buffer),
        0x005e => return ObjectFlagUpdate::read_from(buffer),
        0x005f => return ObjectClickAction::read_from(buffer),
        0x0060 => return ObjectImage::read_from(buffer),
        0x0061 => return ObjectMaterial::read_from(buffer),
        0x0062 => return ObjectShape::read_from(buffer),
        0x0063 => return ObjectExtraParams::read_from(buffer),
        0x0064 => return ObjectOwner::read_from(buffer),
        0x0065 => return ObjectGroup::read_from(buffer),
        0x0066 => return ObjectBuy::read_from(buffer),
        0x0067 => return BuyObjectInventory::read_from(buffer),
        0x0068 => return DerezContainer::read_from(buffer),
        0x0069 => return ObjectPermissions::read_from(buffer),
        0x006a => return ObjectSaleInfo::read_from(buffer),
        0x006b => return ObjectName::read_from(buffer),
        0x006c => return ObjectDescription::read_from(buffer),
        0x006d => return ObjectCategory::read_from(buffer),
        0x006e => return ObjectSelect::read_from(buffer),
        0x006f => return ObjectDeselect::read_from(buffer),
        0x0070 => return ObjectAttach::read_from(buffer),
        0x0071 => return ObjectDetach::read_from(buffer),
        0x0072 => return ObjectDrop::read_from(buffer),
        0x0073 => return ObjectLink::read_from(buffer),
        0x0074 => return ObjectDelink::read_from(buffer),
        0x0075 => return ObjectGrab::read_from(buffer),
        0x0076 => return ObjectGrabUpdate::read_from(buffer),
        0x0077 => return ObjectDeGrab::read_from(buffer),
        0x0078 => return ObjectSpinStart::read_from(buffer),
        0x0079 => return ObjectSpinUpdate::read_from(buffer),
        0x007a => return ObjectSpinStop::read_from(buffer),
        0x007b => return ObjectExportSelected::read_from(buffer),
        0x007c => return ModifyLand::read_from(buffer),
        0x007d => return VelocityInterpolateOn::read_from(buffer),
        0x007e => return VelocityInterpolateOff::read_from(buffer),
        0x007f => return StateSave::read_from(buffer),
        0x0080 => return ReportAutosaveCrash::read_from(buffer),
        0x0081 => return SimWideDeletes::read_from(buffer),
        0x0082 => return TrackAgent::read_from(buffer),
        0x0083 => return ViewerStats::read_from(buffer),
        0x0084 => return ScriptAnswerYes::read_from(buffer),
        0x0085 => return UserReport::read_from(buffer),
        0x0086 => return AlertMessage::read_from(buffer),
        0x0087 => return AgentAlertMessage::read_from(buffer),
        0x0088 => return MeanCollisionAlert::read_from(buffer),
        0x0089 => return ViewerFrozenMessage::read_from(buffer),
        0x008a => return HealthMessage::read_from(buffer),
        0x008b => return ChatFromSimulator::read_from(buffer),
        0x008c => return SimStats::read_from(buffer),
        0x008d => return RequestRegionInfo::read_from(buffer),
        0x008e => return RegionInfo::read_from(buffer),
        0x008f => return GodUpdateRegionInfo::read_from(buffer),
        0x0090 => return NearestLandingRegionRequest::read_from(buffer),
        0x0091 => return NearestLandingRegionReply::read_from(buffer),
        0x0092 => return NearestLandingRegionUpdated::read_from(buffer),
        0x0093 => return TeleportLandingStatusChanged::read_from(buffer),
        0x0094 => return RegionHandshake::read_from(buffer),
        0x0095 => return RegionHandshakeReply::read_from(buffer),
        0x0096 => return SimulatorViewerTimeMessage::read_from(buffer),
        0x0097 => return EnableSimulator::read_from(buffer),
        0x0098 => return DisableSimulator::read_from(buffer),
        0x0099 => return TransferRequest::read_from(buffer),
        0x009a => return TransferInfo::read_from(buffer),
        0x009b => return TransferAbort::read_from(buffer),
        0x009c => return RequestXfer::read_from(buffer),
        0x009d => return AbortXfer::read_from(buffer),
        0x009e => return AvatarAppearance::read_from(buffer),
        0x009f => return SetFollowCamProperties::read_from(buffer),
        0x00a0 => return ClearFollowCamProperties::read_from(buffer),
        0x00a1 => return RequestPayPrice::read_from(buffer),
        0x00a2 => return PayPriceReply::read_from(buffer),
        0x00a3 => return KickUser::read_from(buffer),
        0x00a4 => return KickUserAck::read_from(buffer),
        0x00a5 => return GodKickUser::read_from(buffer),
        0x00a6 => return SystemKickUser::read_from(buffer),
        0x00a7 => return EjectUser::read_from(buffer),
        0x00a8 => return FreezeUser::read_from(buffer),
        0x00a9 => return AvatarPropertiesRequest::read_from(buffer),
        0x00aa => return AvatarPropertiesRequestBackend::read_from(buffer),
        0x00ab => return AvatarPropertiesReply::read_from(buffer),
        0x00ac => return AvatarInterestsReply::read_from(buffer),
        0x00ad => return AvatarGroupsReply::read_from(buffer),
        0x00ae => return AvatarPropertiesUpdate::read_from(buffer),
        0x00af => return AvatarInterestsUpdate::read_from(buffer),
        0x00b0 => return AvatarNotesReply::read_from(buffer),
        0x00b1 => return AvatarNotesUpdate::read_from(buffer),
        0x00b2 => return AvatarPicksReply::read_from(buffer),
        0x00b3 => return EventInfoRequest::read_from(buffer),
        0x00b4 => return EventInfoReply::read_from(buffer),
        0x00b5 => return EventNotificationAddRequest::read_from(buffer),
        0x00b6 => return EventNotificationRemoveRequest::read_from(buffer),
        0x00b7 => return EventGodDelete::read_from(buffer),
        0x00b8 => return PickInfoReply::read_from(buffer),
        0x00b9 => return PickInfoUpdate::read_from(buffer),
        0x00ba => return PickDelete::read_from(buffer),
        0x00bb => return PickGodDelete::read_from(buffer),
        0x00bc => return ScriptQuestion::read_from(buffer),
        0x00bd => return ScriptControlChange::read_from(buffer),
        0x00be => return ScriptDialog::read_from(buffer),
        0x00bf => return ScriptDialogReply::read_from(buffer),
        0x00c0 => return ForceScriptControlRelease::read_from(buffer),
        0x00c1 => return RevokePermissions::read_from(buffer),
        0x00c2 => return LoadURL::read_from(buffer),
        0x00c3 => return ScriptTeleportRequest::read_from(buffer),
        0x00c4 => return ParcelOverlay::read_from(buffer),
        0x00c5 => return ParcelPropertiesRequestByID::read_from(buffer),
        0x00c6 => return ParcelPropertiesUpdate::read_from(buffer),
        0x00c7 => return ParcelReturnObjects::read_from(buffer),
        0x00c8 => return ParcelSetOtherCleanTime::read_from(buffer),
        0x00c9 => return ParcelDisableObjects::read_from(buffer),
        0x00ca => return ParcelSelectObjects::read_from(buffer),
        0x00cb => return EstateCovenantRequest::read_from(buffer),
        0x00cc => return EstateCovenantReply::read_from(buffer),
        0x00cd => return ForceObjectSelect::read_from(buffer),
        0x00ce => return ParcelBuyPass::read_from(buffer),
        0x00cf => return ParcelDeedToGroup::read_from(buffer),
        0x00d0 => return ParcelReclaim::read_from(buffer),
        0x00d1 => return ParcelClaim::read_from(buffer),
        0x00d2 => return ParcelJoin::read_from(buffer),
        0x00d3 => return ParcelDivide::read_from(buffer),
        0x00d4 => return ParcelRelease::read_from(buffer),
        0x00d5 => return ParcelBuy::read_from(buffer),
        0x00d6 => return ParcelGodForceOwner::read_from(buffer),
        0x00d7 => return ParcelAccessListRequest::read_from(buffer),
        0x00d8 => return ParcelAccessListReply::read_from(buffer),
        0x00d9 => return ParcelAccessListUpdate::read_from(buffer),
        0x00da => return ParcelDwellRequest::read_from(buffer),
        0x00db => return ParcelDwellReply::read_from(buffer),
        0x00dc => return RequestParcelTransfer::read_from(buffer),
        0x00dd => return UpdateParcel::read_from(buffer),
        0x00de => return RemoveParcel::read_from(buffer),
        0x00df => return MergeParcel::read_from(buffer),
        0x00e0 => return LogParcelChanges::read_from(buffer),
        0x00e1 => return CheckParcelSales::read_from(buffer),
        0x00e2 => return ParcelSales::read_from(buffer),
        0x00e3 => return ParcelGodMarkAsContent::read_from(buffer),
        0x00e4 => return ViewerStartAuction::read_from(buffer),
        0x00e5 => return StartAuction::read_from(buffer),
        0x00e6 => return ConfirmAuctionStart::read_from(buffer),
        0x00e7 => return CompleteAuction::read_from(buffer),
        0x00e8 => return CancelAuction::read_from(buffer),
        0x00e9 => return CheckParcelAuctions::read_from(buffer),
        0x00ea => return ParcelAuctions::read_from(buffer),
        0x00eb => return UUIDNameRequest::read_from(buffer),
        0x00ec => return UUIDNameReply::read_from(buffer),
        0x00ed => return UUIDGroupNameRequest::read_from(buffer),
        0x00ee => return UUIDGroupNameReply::read_from(buffer),
        0x00ef => return ChatPass::read_from(buffer),
        0x00f0 => return ChildAgentDying::read_from(buffer),
        0x00f1 => return ChildAgentUnknown::read_from(buffer),
        0x00f2 => return KillChildAgents::read_from(buffer),
        0x00f3 => return GetScriptRunning::read_from(buffer),
        0x00f4 => return ScriptRunningReply::read_from(buffer),
        0x00f5 => return SetScriptRunning::read_from(buffer),
        0x00f6 => return ScriptReset::read_from(buffer),
        0x00f7 => return ScriptSensorRequest::read_from(buffer),
        0x00f8 => return ScriptSensorReply::read_from(buffer),
        0x00f9 => return CompleteAgentMovement::read_from(buffer),
        0x00fa => return AgentMovementComplete::read_from(buffer),
        0x00fb => return DataServerLogout::read_from(buffer),
        0x00fc => return LogoutRequest::read_from(buffer),
        0x00fd => return LogoutReply::read_from(buffer),
        0x00fe => return ImprovedInstantMessage::read_from(buffer),
        0x00ff => return RetrieveInstantMessages::read_from(buffer),
        0x0100 => return FindAgent::read_from(buffer),
        0x0101 => return RequestGodlikePowers::read_from(buffer),
        0x0102 => return GrantGodlikePowers::read_from(buffer),
        0x0103 => return GodlikeMessage::read_from(buffer),
        0x0104 => return EstateOwnerMessage::read_from(buffer),
        0x0105 => return GenericMessage::read_from(buffer),
        0x0106 => return MuteListRequest::read_from(buffer),
        0x0107 => return UpdateMuteListEntry::read_from(buffer),
        0x0108 => return RemoveMuteListEntry::read_from(buffer),
        0x0109 => return CopyInventoryFromNotecard::read_from(buffer),
        0x010a => return UpdateInventoryItem::read_from(buffer),
        0x010b => return UpdateCreateInventoryItem::read_from(buffer),
        0x010c => return MoveInventoryItem::read_from(buffer),
        0x010d => return CopyInventoryItem::read_from(buffer),
        0x010e => return RemoveInventoryItem::read_from(buffer),
        0x010f => return ChangeInventoryItemFlags::read_from(buffer),
        0x0110 => return SaveAssetIntoInventory::read_from(buffer),
        0x0111 => return CreateInventoryFolder::read_from(buffer),
        0x0112 => return UpdateInventoryFolder::read_from(buffer),
        0x0113 => return MoveInventoryFolder::read_from(buffer),
        0x0114 => return RemoveInventoryFolder::read_from(buffer),
        0x0115 => return FetchInventoryDescendents::read_from(buffer),
        0x0116 => return InventoryDescendents::read_from(buffer),
        0x0117 => return FetchInventory::read_from(buffer),
        0x0118 => return FetchInventoryReply::read_from(buffer),
        0x0119 => return BulkUpdateInventory::read_from(buffer),
        0x011a => return RequestInventoryAsset::read_from(buffer),
        0x011b => return InventoryAssetResponse::read_from(buffer),
        0x011c => return RemoveInventoryObjects::read_from(buffer),
        0x011d => return PurgeInventoryDescendents::read_from(buffer),
        0x011e => return UpdateTaskInventory::read_from(buffer),
        0x011f => return RemoveTaskInventory::read_from(buffer),
        0x0120 => return MoveTaskInventory::read_from(buffer),
        0x0121 => return RequestTaskInventory::read_from(buffer),
        0x0122 => return ReplyTaskInventory::read_from(buffer),
        0x0123 => return DeRezObject::read_from(buffer),
        0x0124 => return DeRezAck::read_from(buffer),
        0x0125 => return RezObject::read_from(buffer),
        0x0126 => return RezObjectFromNotecard::read_from(buffer),
        0x0127 => return TransferInventory::read_from(buffer),
        0x0128 => return TransferInventoryAck::read_from(buffer),
        0x0129 => return AcceptFriendship::read_from(buffer),
        0x012a => return DeclineFriendship::read_from(buffer),
        0x012b => return FormFriendship::read_from(buffer),
        0x012c => return TerminateFriendship::read_from(buffer),
        0x012d => return OfferCallingCard::read_from(buffer),
        0x012e => return AcceptCallingCard::read_from(buffer),
        0x012f => return DeclineCallingCard::read_from(buffer),
        0x0130 => return RezScript::read_from(buffer),
        0x0131 => return CreateInventoryItem::read_from(buffer),
        0x0132 => return CreateLandmarkForEvent::read_from(buffer),
        0x0133 => return EventLocationRequest::read_from(buffer),
        0x0134 => return EventLocationReply::read_from(buffer),
        0x0135 => return RegionHandleRequest::read_from(buffer),
        0x0136 => return RegionIDAndHandleReply::read_from(buffer),
        0x0137 => return MoneyTransferRequest::read_from(buffer),
        0x0138 => return MoneyTransferBackend::read_from(buffer),
        0x0139 => return MoneyBalanceRequest::read_from(buffer),
        0x013a => return MoneyBalanceReply::read_from(buffer),
        0x013b => return RoutedMoneyBalanceReply::read_from(buffer),
        0x013c => return ActivateGestures::read_from(buffer),
        0x013d => return DeactivateGestures::read_from(buffer),
        0x013e => return MuteListUpdate::read_from(buffer),
        0x013f => return UseCachedMuteList::read_from(buffer),
        0x0140 => return GrantUserRights::read_from(buffer),
        0x0141 => return ChangeUserRights::read_from(buffer),
        0x0142 => return OnlineNotification::read_from(buffer),
        0x0143 => return OfflineNotification::read_from(buffer),
        0x0144 => return SetStartLocationRequest::read_from(buffer),
        0x0145 => return SetStartLocation::read_from(buffer),
        0x0146 => return NetTest::read_from(buffer),
        0x0147 => return SetCPURatio::read_from(buffer),
        0x0148 => return SimCrashed::read_from(buffer),
        0x0149 => return NameValuePair::read_from(buffer),
        0x014a => return RemoveNameValuePair::read_from(buffer),
        0x014b => return UpdateAttachment::read_from(buffer),
        0x014c => return RemoveAttachment::read_from(buffer),
        0x014d => return AssetUploadRequest::read_from(buffer),
        0x014e => return AssetUploadComplete::read_from(buffer),
        0x014f => return EmailMessageRequest::read_from(buffer),
        0x0150 => return EmailMessageReply::read_from(buffer),
        0x0151 => return ScriptDataRequest::read_from(buffer),
        0x0152 => return ScriptDataReply::read_from(buffer),
        0x0153 => return CreateGroupRequest::read_from(buffer),
        0x0154 => return CreateGroupReply::read_from(buffer),
        0x0155 => return UpdateGroupInfo::read_from(buffer),
        0x0156 => return GroupRoleChanges::read_from(buffer),
        0x0157 => return JoinGroupRequest::read_from(buffer),
        0x0158 => return JoinGroupReply::read_from(buffer),
        0x0159 => return EjectGroupMemberRequest::read_from(buffer),
        0x015a => return EjectGroupMemberReply::read_from(buffer),
        0x015b => return LeaveGroupRequest::read_from(buffer),
        0x015c => return LeaveGroupReply::read_from(buffer),
        0x015d => return InviteGroupRequest::read_from(buffer),
        0x015e => return InviteGroupResponse::read_from(buffer),
        0x015f => return GroupProfileRequest::read_from(buffer),
        0x0160 => return GroupProfileReply::read_from(buffer),
        0x0161 => return GroupAccountSummaryRequest::read_from(buffer),
        0x0162 => return GroupAccountSummaryReply::read_from(buffer),
        0x0163 => return GroupAccountDetailsRequest::read_from(buffer),
        0x0164 => return GroupAccountDetailsReply::read_from(buffer),
        0x0165 => return GroupAccountTransactionsRequest::read_from(buffer),
        0x0166 => return GroupAccountTransactionsReply::read_from(buffer),
        0x0167 => return GroupActiveProposalsRequest::read_from(buffer),
        0x0168 => return GroupActiveProposalItemReply::read_from(buffer),
        0x0169 => return GroupVoteHistoryRequest::read_from(buffer),
        0x016a => return GroupVoteHistoryItemReply::read_from(buffer),
        0x016b => return StartGroupProposal::read_from(buffer),
        0x016c => return GroupProposalBallot::read_from(buffer),
        0x016d => return TallyVotes::read_from(buffer),
        0x016e => return GroupMembersRequest::read_from(buffer),
        0x016f => return GroupMembersReply::read_from(buffer),
        0x0170 => return ActivateGroup::read_from(buffer),
        0x0171 => return SetGroupContribution::read_from(buffer),
        0x0172 => return SetGroupAcceptNotices::read_from(buffer),
        0x0173 => return GroupRoleDataRequest::read_from(buffer),
        0x0174 => return GroupRoleDataReply::read_from(buffer),
        0x0175 => return GroupRoleMembersRequest::read_from(buffer),
        0x0176 => return GroupRoleMembersReply::read_from(buffer),
        0x0177 => return GroupTitlesRequest::read_from(buffer),
        0x0178 => return GroupTitlesReply::read_from(buffer),
        0x0179 => return GroupTitleUpdate::read_from(buffer),
        0x017a => return GroupRoleUpdate::read_from(buffer),
        0x017b => return LiveHelpGroupRequest::read_from(buffer),
        0x017c => return LiveHelpGroupReply::read_from(buffer),
        0x017d => return AgentWearablesRequest::read_from(buffer),
        0x017e => return AgentWearablesUpdate::read_from(buffer),
        0x017f => return AgentIsNowWearing::read_from(buffer),
        0x0180 => return AgentCachedTexture::read_from(buffer),
        0x0181 => return AgentCachedTextureResponse::read_from(buffer),
        0x0182 => return AgentDataUpdateRequest::read_from(buffer),
        0x0183 => return AgentDataUpdate::read_from(buffer),
        0x0184 => return GroupDataUpdate::read_from(buffer),
        0x0185 => return AgentGroupDataUpdate::read_from(buffer),
        0x0186 => return AgentDropGroup::read_from(buffer),
        0x0187 => return LogTextMessage::read_from(buffer),
        0x0188 => return CreateTrustedCircuit::read_from(buffer),
        0x0189 => return DenyTrustedCircuit::read_from(buffer),
        0x018a => return RequestTrustedCircuit::read_from(buffer),
        0x018b => return RezSingleAttachmentFromInv::read_from(buffer),
        0x018c => return RezMultipleAttachmentsFromInv::read_from(buffer),
        0x018d => return DetachAttachmentIntoInv::read_from(buffer),
        0x018e => return CreateNewOutfitAttachments::read_from(buffer),
        0x018f => return UserInfoRequest::read_from(buffer),
        0x0190 => return UserInfoReply::read_from(buffer),
        0x0191 => return UpdateUserInfo::read_from(buffer),
        0x0192 => return ParcelRename::read_from(buffer),
        0x0193 => return InitiateDownload::read_from(buffer),
        0x0194 => return SystemMessage::read_from(buffer),
        0x0195 => return MapLayerRequest::read_from(buffer),
        0x0196 => return MapLayerReply::read_from(buffer),
        0x0197 => return MapBlockRequest::read_from(buffer),
        0x0198 => return MapNameRequest::read_from(buffer),
        0x0199 => return MapBlockReply::read_from(buffer),
        0x019a => return MapItemRequest::read_from(buffer),
        0x019b => return MapItemReply::read_from(buffer),
        0x019c => return SendPostcard::read_from(buffer),
        0x019d => return RpcChannelRequest::read_from(buffer),
        0x019e => return RpcChannelReply::read_from(buffer),
        0x019f => return RpcScriptRequestInbound::read_from(buffer),
        0x01a0 => return RpcScriptRequestInboundForward::read_from(buffer),
        0x01a1 => return RpcScriptReplyInbound::read_from(buffer),
        0x01a2 => return ScriptMailRegistration::read_from(buffer),
        0x01a3 => return ParcelMediaCommandMessage::read_from(buffer),
        0x01a4 => return ParcelMediaUpdate::read_from(buffer),
        0x01a5 => return LandStatRequest::read_from(buffer),
        0x01a6 => return LandStatReply::read_from(buffer),
        0x01a7 => return Error::read_from(buffer),
        0x01a8 => return ObjectIncludeInSearch::read_from(buffer),
        0x01a9 => return RezRestoreToWorld::read_from(buffer),
        0x01aa => return LinkInventoryItem::read_from(buffer),
        _ => return Err(ReadMessageError::UnknownMessageNumber),
    }

}

#[derive(Debug)]
pub struct TestMessage_TestBlock1 {
    pub test1: u32,
}

#[derive(Debug)]
pub struct TestMessage_NeighborBlock {
    pub test0: u32,
    pub test1: u32,
    pub test2: u32,
}

#[derive(Debug)]
pub struct TestMessage {
    pub test_block1: TestMessage_TestBlock1,
    pub neighbor_block: [TestMessage_NeighborBlock; 4],
}


#[derive(Debug)]
pub struct PacketAck_Packets {
    pub id: u32,
}

#[derive(Debug)]
pub struct PacketAck {
    pub packets: Vec<PacketAck_Packets>,
}


#[derive(Debug)]
pub struct OpenCircuit_CircuitInfo {
    pub ip: Ip4Addr,
    pub port: IpPort,
}

#[derive(Debug)]
pub struct OpenCircuit {
    pub circuit_info: OpenCircuit_CircuitInfo,
}


#[derive(Debug)]
pub struct CloseCircuit {
}


#[derive(Debug)]
pub struct StartPingCheck_PingID {
    pub ping_id: u8,
    pub oldest_unacked: u32,
}

#[derive(Debug)]
pub struct StartPingCheck {
    pub ping_id: StartPingCheck_PingID,
}


#[derive(Debug)]
pub struct CompletePingCheck_PingID {
    pub ping_id: u8,
}

#[derive(Debug)]
pub struct CompletePingCheck {
    pub ping_id: CompletePingCheck_PingID,
}


#[derive(Debug)]
pub struct AddCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AddCircuitCode {
    pub circuit_code: AddCircuitCode_CircuitCode,
}


#[derive(Debug)]
pub struct UseCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub id: Uuid,
}

#[derive(Debug)]
pub struct UseCircuitCode {
    pub circuit_code: UseCircuitCode_CircuitCode,
}


#[derive(Debug)]
pub struct NeighborList_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: IpPort,
    pub public_ip: Ip4Addr,
    pub public_port: IpPort,
    pub region_id: Uuid,
    pub name: Vec<u8>,
    pub sim_access: u8,
}

#[derive(Debug)]
pub struct NeighborList {
    pub neighbor_block: [NeighborList_NeighborBlock; 4],
}


#[derive(Debug)]
pub struct AvatarTextureUpdate_AgentData {
    pub agent_id: Uuid,
    pub textures_changed: bool,
}

#[derive(Debug)]
pub struct AvatarTextureUpdate_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarTextureUpdate_TextureData {
    pub texture_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarTextureUpdate {
    pub agent_data: AvatarTextureUpdate_AgentData,
    pub wearable_data: Vec<AvatarTextureUpdate_WearableData>,
    pub texture_data: Vec<AvatarTextureUpdate_TextureData>,
}


#[derive(Debug)]
pub struct SimulatorMapUpdate_MapData {
    pub flags: u32,
}

#[derive(Debug)]
pub struct SimulatorMapUpdate {
    pub map_data: SimulatorMapUpdate_MapData,
}


#[derive(Debug)]
pub struct SimulatorSetMap_MapData {
    pub region_handle: u64,
    pub type_: i32,
    pub map_image: Uuid,
}

#[derive(Debug)]
pub struct SimulatorSetMap {
    pub map_data: SimulatorSetMap_MapData,
}


#[derive(Debug)]
pub struct SubscribeLoad {
}


#[derive(Debug)]
pub struct UnsubscribeLoad {
}


#[derive(Debug)]
pub struct SimulatorReady_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

#[derive(Debug)]
pub struct SimulatorReady_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

#[derive(Debug)]
pub struct SimulatorReady {
    pub simulator_block: SimulatorReady_SimulatorBlock,
    pub telehub_block: SimulatorReady_TelehubBlock,
}


#[derive(Debug)]
pub struct TelehubInfo_TelehubBlock {
    pub object_id: Uuid,
    pub object_name: Vec<u8>,
    pub telehub_pos: Vector3<f32>,
    pub telehub_rot: Quaternion<f32>,
}

#[derive(Debug)]
pub struct TelehubInfo_SpawnPointBlock {
    pub spawn_point_pos: Vector3<f32>,
}

#[derive(Debug)]
pub struct TelehubInfo {
    pub telehub_block: TelehubInfo_TelehubBlock,
    pub spawn_point_block: Vec<TelehubInfo_SpawnPointBlock>,
}


#[derive(Debug)]
pub struct SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    pub port: IpPort,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: IpPort,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

#[derive(Debug)]
pub struct SimulatorPresentAtLocation {
    pub simulator_public_host_block: SimulatorPresentAtLocation_SimulatorPublicHostBlock,
    pub neighbor_block: [SimulatorPresentAtLocation_NeighborBlock; 4],
    pub simulator_block: SimulatorPresentAtLocation_SimulatorBlock,
    pub telehub_block: Vec<SimulatorPresentAtLocation_TelehubBlock>,
}


#[derive(Debug)]
pub struct SimulatorLoad_SimulatorLoad {
    pub time_dilation: f32,
    pub agent_count: i32,
    pub can_accept_agents: bool,
}

#[derive(Debug)]
pub struct SimulatorLoad_AgentList {
    pub circuit_code: u32,
    pub x: u8,
    pub y: u8,
}

#[derive(Debug)]
pub struct SimulatorLoad {
    pub simulator_load: SimulatorLoad_SimulatorLoad,
    pub agent_list: Vec<SimulatorLoad_AgentList>,
}


#[derive(Debug)]
pub struct SimulatorShutdownRequest {
}


#[derive(Debug)]
pub struct RegionPresenceRequestByRegionID_RegionData {
    pub region_id: Uuid,
}

#[derive(Debug)]
pub struct RegionPresenceRequestByRegionID {
    pub region_data: Vec<RegionPresenceRequestByRegionID_RegionData>,
}


#[derive(Debug)]
pub struct RegionPresenceRequestByHandle_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct RegionPresenceRequestByHandle {
    pub region_data: Vec<RegionPresenceRequestByHandle_RegionData>,
}


#[derive(Debug)]
pub struct RegionPresenceResponse_RegionData {
    pub region_id: Uuid,
    pub region_handle: u64,
    pub internal_region_ip: Ip4Addr,
    pub external_region_ip: Ip4Addr,
    pub region_port: IpPort,
    pub valid_until: f64,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct RegionPresenceResponse {
    pub region_data: Vec<RegionPresenceResponse_RegionData>,
}


#[derive(Debug)]
pub struct UpdateSimulator_SimulatorInfo {
    pub region_id: Uuid,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub sim_access: u8,
}

#[derive(Debug)]
pub struct UpdateSimulator {
    pub simulator_info: UpdateSimulator_SimulatorInfo,
}


#[derive(Debug)]
pub struct LogDwellTime_DwellInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub duration: f32,
    pub sim_name: Vec<u8>,
    pub region_x: u32,
    pub region_y: u32,
    pub avg_agents_in_view: u8,
    pub avg_viewer_fps: u8,
}

#[derive(Debug)]
pub struct LogDwellTime {
    pub dwell_info: LogDwellTime_DwellInfo,
}


#[derive(Debug)]
pub struct FeatureDisabled_FailureInfo {
    pub error_message: Vec<u8>,
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct FeatureDisabled {
    pub failure_info: FeatureDisabled_FailureInfo,
}


#[derive(Debug)]
pub struct LogFailedMoneyTransaction_TransactionData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
    pub failure_type: u8,
}

#[derive(Debug)]
pub struct LogFailedMoneyTransaction {
    pub transaction_data: LogFailedMoneyTransaction_TransactionData,
}


#[derive(Debug)]
pub struct UserReportInternal_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub reporter_id: Uuid,
    pub viewer_position: Vector3<f32>,
    pub agent_position: Vector3<f32>,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub last_owner_id: Uuid,
    pub creator_id: Uuid,
    pub region_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

#[derive(Debug)]
pub struct UserReportInternal {
    pub report_data: UserReportInternal_ReportData,
}


#[derive(Debug)]
pub struct SetSimStatusInDatabase_Data {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub x: i32,
    pub y: i32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

#[derive(Debug)]
pub struct SetSimStatusInDatabase {
    pub data: SetSimStatusInDatabase_Data,
}


#[derive(Debug)]
pub struct SetSimPresenceInDatabase_SimData {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub grid_x: u32,
    pub grid_y: u32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

#[derive(Debug)]
pub struct SetSimPresenceInDatabase {
    pub sim_data: SetSimPresenceInDatabase_SimData,
}


#[derive(Debug)]
pub struct EconomyDataRequest {
}


#[derive(Debug)]
pub struct EconomyData_Info {
    pub object_capacity: i32,
    pub object_count: i32,
    pub price_energy_unit: i32,
    pub price_object_claim: i32,
    pub price_public_object_decay: i32,
    pub price_public_object_delete: i32,
    pub price_parcel_claim: i32,
    pub price_parcel_claim_factor: f32,
    pub price_upload: i32,
    pub price_rent_light: i32,
    pub teleport_min_price: i32,
    pub teleport_price_exponent: f32,
    pub energy_efficiency: f32,
    pub price_object_rent: f32,
    pub price_object_scale_factor: f32,
    pub price_parcel_rent: i32,
    pub price_group_create: i32,
}

#[derive(Debug)]
pub struct EconomyData {
    pub info: EconomyData_Info,
}


#[derive(Debug)]
pub struct AvatarPickerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPickerRequest_Data {
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarPickerRequest {
    pub agent_data: AvatarPickerRequest_AgentData,
    pub data: AvatarPickerRequest_Data,
}


#[derive(Debug)]
pub struct AvatarPickerRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
    pub god_level: u8,
}

#[derive(Debug)]
pub struct AvatarPickerRequestBackend_Data {
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarPickerRequestBackend {
    pub agent_data: AvatarPickerRequestBackend_AgentData,
    pub data: AvatarPickerRequestBackend_Data,
}


#[derive(Debug)]
pub struct AvatarPickerReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPickerReply_Data {
    pub avatar_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarPickerReply {
    pub agent_data: AvatarPickerReply_AgentData,
    pub data: Vec<AvatarPickerReply_Data>,
}


#[derive(Debug)]
pub struct PlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesQuery_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesQuery_QueryData {
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
}

#[derive(Debug)]
pub struct PlacesQuery {
    pub agent_data: PlacesQuery_AgentData,
    pub transaction_data: PlacesQuery_TransactionData,
    pub query_data: PlacesQuery_QueryData,
}


#[derive(Debug)]
pub struct PlacesReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesReply_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct PlacesReply_QueryData {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub price: i32,
}

#[derive(Debug)]
pub struct PlacesReply {
    pub agent_data: PlacesReply_AgentData,
    pub transaction_data: PlacesReply_TransactionData,
    pub query_data: Vec<PlacesReply_QueryData>,
}


#[derive(Debug)]
pub struct DirFindQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirFindQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirFindQuery {
    pub agent_data: DirFindQuery_AgentData,
    pub query_data: DirFindQuery_QueryData,
}


#[derive(Debug)]
pub struct DirFindQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirFindQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct DirFindQueryBackend {
    pub agent_data: DirFindQueryBackend_AgentData,
    pub query_data: DirFindQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirPlacesQuery {
    pub agent_data: DirPlacesQuery_AgentData,
    pub query_data: DirPlacesQuery_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirPlacesQueryBackend {
    pub agent_data: DirPlacesQueryBackend_AgentData,
    pub query_data: DirPlacesQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPlacesReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPlacesReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub for_sale: bool,
    pub auction: bool,
    pub dwell: f32,
}

#[derive(Debug)]
pub struct DirPlacesReply_StatusData {
    pub status: u32,
}

#[derive(Debug)]
pub struct DirPlacesReply {
    pub agent_data: DirPlacesReply_AgentData,
    pub query_data: Vec<DirPlacesReply_QueryData>,
    pub query_replies: Vec<DirPlacesReply_QueryReplies>,
    pub status_data: Vec<DirPlacesReply_StatusData>,
}


#[derive(Debug)]
pub struct DirPeopleReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPeopleReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPeopleReply_QueryReplies {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group: Vec<u8>,
    pub online: bool,
    pub reputation: i32,
}

#[derive(Debug)]
pub struct DirPeopleReply {
    pub agent_data: DirPeopleReply_AgentData,
    pub query_data: DirPeopleReply_QueryData,
    pub query_replies: Vec<DirPeopleReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirEventsReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirEventsReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirEventsReply_QueryReplies {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub event_id: u32,
    pub date: Vec<u8>,
    pub unix_time: u32,
    pub event_flags: u32,
}

#[derive(Debug)]
pub struct DirEventsReply_StatusData {
    pub status: u32,
}

#[derive(Debug)]
pub struct DirEventsReply {
    pub agent_data: DirEventsReply_AgentData,
    pub query_data: DirEventsReply_QueryData,
    pub query_replies: Vec<DirEventsReply_QueryReplies>,
    pub status_data: Vec<DirEventsReply_StatusData>,
}


#[derive(Debug)]
pub struct DirGroupsReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirGroupsReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirGroupsReply_QueryReplies {
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub members: i32,
    pub search_order: f32,
}

#[derive(Debug)]
pub struct DirGroupsReply {
    pub agent_data: DirGroupsReply_AgentData,
    pub query_data: DirGroupsReply_QueryData,
    pub query_replies: Vec<DirGroupsReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirClassifiedQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirClassifiedQuery {
    pub agent_data: DirClassifiedQuery_AgentData,
    pub query_data: DirClassifiedQuery_QueryData,
}


#[derive(Debug)]
pub struct DirClassifiedQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirClassifiedQueryBackend {
    pub agent_data: DirClassifiedQueryBackend_AgentData,
    pub query_data: DirClassifiedQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirClassifiedReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirClassifiedReply_QueryReplies {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
    pub classified_flags: u8,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub price_for_listing: i32,
}

#[derive(Debug)]
pub struct DirClassifiedReply_StatusData {
    pub status: u32,
}

#[derive(Debug)]
pub struct DirClassifiedReply {
    pub agent_data: DirClassifiedReply_AgentData,
    pub query_data: DirClassifiedReply_QueryData,
    pub query_replies: Vec<DirClassifiedReply_QueryReplies>,
    pub status_data: Vec<DirClassifiedReply_StatusData>,
}


#[derive(Debug)]
pub struct AvatarClassifiedReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarClassifiedReply_Data {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarClassifiedReply {
    pub agent_data: AvatarClassifiedReply_AgentData,
    pub data: Vec<AvatarClassifiedReply_Data>,
}


#[derive(Debug)]
pub struct ClassifiedInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoRequest_Data {
    pub classified_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoRequest {
    pub agent_data: ClassifiedInfoRequest_AgentData,
    pub data: ClassifiedInfoRequest_Data,
}


#[derive(Debug)]
pub struct ClassifiedInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoReply_Data {
    pub classified_id: Uuid,
    pub creator_id: Uuid,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub parcel_name: Vec<u8>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

#[derive(Debug)]
pub struct ClassifiedInfoReply {
    pub agent_data: ClassifiedInfoReply_AgentData,
    pub data: ClassifiedInfoReply_Data,
}


#[derive(Debug)]
pub struct ClassifiedInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedInfoUpdate_Data {
    pub classified_id: Uuid,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

#[derive(Debug)]
pub struct ClassifiedInfoUpdate {
    pub agent_data: ClassifiedInfoUpdate_AgentData,
    pub data: ClassifiedInfoUpdate_Data,
}


#[derive(Debug)]
pub struct ClassifiedDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedDelete_Data {
    pub classified_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedDelete {
    pub agent_data: ClassifiedDelete_AgentData,
    pub data: ClassifiedDelete_Data,
}


#[derive(Debug)]
pub struct ClassifiedGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedGodDelete_Data {
    pub classified_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct ClassifiedGodDelete {
    pub agent_data: ClassifiedGodDelete_AgentData,
    pub data: ClassifiedGodDelete_Data,
}


#[derive(Debug)]
pub struct DirLandQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct DirLandQuery {
    pub agent_data: DirLandQuery_AgentData,
    pub query_data: DirLandQuery_QueryData,
}


#[derive(Debug)]
pub struct DirLandQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct DirLandQueryBackend {
    pub agent_data: DirLandQueryBackend_AgentData,
    pub query_data: DirLandQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirLandReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirLandReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub auction: bool,
    pub for_sale: bool,
    pub sale_price: i32,
    pub actual_area: i32,
}

#[derive(Debug)]
pub struct DirLandReply {
    pub agent_data: DirLandReply_AgentData,
    pub query_data: DirLandReply_QueryData,
    pub query_replies: Vec<DirLandReply_QueryReplies>,
}


#[derive(Debug)]
pub struct DirPopularQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
}

#[derive(Debug)]
pub struct DirPopularQuery {
    pub agent_data: DirPopularQuery_AgentData,
    pub query_data: DirPopularQuery_QueryData,
}


#[derive(Debug)]
pub struct DirPopularQueryBackend_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct DirPopularQueryBackend {
    pub agent_data: DirPopularQueryBackend_AgentData,
    pub query_data: DirPopularQueryBackend_QueryData,
}


#[derive(Debug)]
pub struct DirPopularReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct DirPopularReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub dwell: f32,
}

#[derive(Debug)]
pub struct DirPopularReply {
    pub agent_data: DirPopularReply_AgentData,
    pub query_data: DirPopularReply_QueryData,
    pub query_replies: Vec<DirPopularReply_QueryReplies>,
}


#[derive(Debug)]
pub struct ParcelInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelInfoRequest_Data {
    pub parcel_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelInfoRequest {
    pub agent_data: ParcelInfoRequest_AgentData,
    pub data: ParcelInfoRequest_Data,
}


#[derive(Debug)]
pub struct ParcelInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelInfoReply_Data {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub sale_price: i32,
    pub auction_id: i32,
}

#[derive(Debug)]
pub struct ParcelInfoReply {
    pub agent_data: ParcelInfoReply_AgentData,
    pub data: ParcelInfoReply_Data,
}


#[derive(Debug)]
pub struct ParcelObjectOwnersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelObjectOwnersRequest_ParcelData {
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelObjectOwnersRequest {
    pub agent_data: ParcelObjectOwnersRequest_AgentData,
    pub parcel_data: ParcelObjectOwnersRequest_ParcelData,
}


#[derive(Debug)]
pub struct ParcelObjectOwnersReply_Data {
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub count: i32,
    pub online_status: bool,
}

#[derive(Debug)]
pub struct ParcelObjectOwnersReply {
    pub data: Vec<ParcelObjectOwnersReply_Data>,
}


#[derive(Debug)]
pub struct GroupNoticesListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticesListRequest_Data {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticesListRequest {
    pub agent_data: GroupNoticesListRequest_AgentData,
    pub data: GroupNoticesListRequest_Data,
}


#[derive(Debug)]
pub struct GroupNoticesListReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticesListReply_Data {
    pub notice_id: Uuid,
    pub timestamp: u32,
    pub from_name: Vec<u8>,
    pub subject: Vec<u8>,
    pub has_attachment: bool,
    pub asset_type: u8,
}

#[derive(Debug)]
pub struct GroupNoticesListReply {
    pub agent_data: GroupNoticesListReply_AgentData,
    pub data: Vec<GroupNoticesListReply_Data>,
}


#[derive(Debug)]
pub struct GroupNoticeRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticeRequest_Data {
    pub group_notice_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticeRequest {
    pub agent_data: GroupNoticeRequest_AgentData,
    pub data: GroupNoticeRequest_Data,
}


#[derive(Debug)]
pub struct GroupNoticeAdd_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupNoticeAdd_MessageBlock {
    pub to_group_id: Uuid,
    pub id: Uuid,
    pub dialog: u8,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupNoticeAdd {
    pub agent_data: GroupNoticeAdd_AgentData,
    pub message_block: GroupNoticeAdd_MessageBlock,
}


#[derive(Debug)]
pub struct TeleportRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportRequest_Info {
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct TeleportRequest {
    pub agent_data: TeleportRequest_AgentData,
    pub info: TeleportRequest_Info,
}


#[derive(Debug)]
pub struct TeleportLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportLocationRequest_Info {
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct TeleportLocationRequest {
    pub agent_data: TeleportLocationRequest_AgentData,
    pub info: TeleportLocationRequest_Info,
}


#[derive(Debug)]
pub struct TeleportLocal_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub teleport_flags: u32,
}

#[derive(Debug)]
pub struct TeleportLocal {
    pub info: TeleportLocal_Info,
}


#[derive(Debug)]
pub struct TeleportLandmarkRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub landmark_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportLandmarkRequest {
    pub info: TeleportLandmarkRequest_Info,
}


#[derive(Debug)]
pub struct TeleportProgress_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportProgress_Info {
    pub teleport_flags: u32,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct TeleportProgress {
    pub agent_data: TeleportProgress_AgentData,
    pub info: TeleportProgress_Info,
}


#[derive(Debug)]
pub struct DataHomeLocationRequest_Info {
    pub agent_id: Uuid,
    pub kicked_from_estate_id: u32,
}

#[derive(Debug)]
pub struct DataHomeLocationRequest_AgentInfo {
    pub agent_effective_maturity: u32,
}

#[derive(Debug)]
pub struct DataHomeLocationRequest {
    pub info: DataHomeLocationRequest_Info,
    pub agent_info: DataHomeLocationRequest_AgentInfo,
}


#[derive(Debug)]
pub struct DataHomeLocationReply_Info {
    pub agent_id: Uuid,
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct DataHomeLocationReply {
    pub info: DataHomeLocationReply_Info,
}


#[derive(Debug)]
pub struct TeleportFinish_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub sim_ip: Ip4Addr,
    pub sim_port: IpPort,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
    pub sim_access: u8,
    pub teleport_flags: u32,
}

#[derive(Debug)]
pub struct TeleportFinish {
    pub info: TeleportFinish_Info,
}


#[derive(Debug)]
pub struct StartLure_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StartLure_Info {
    pub lure_type: u8,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct StartLure_TargetData {
    pub target_id: Uuid,
}

#[derive(Debug)]
pub struct StartLure {
    pub agent_data: StartLure_AgentData,
    pub info: StartLure_Info,
    pub target_data: Vec<StartLure_TargetData>,
}


#[derive(Debug)]
pub struct TeleportLureRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub lure_id: Uuid,
    pub teleport_flags: u32,
}

#[derive(Debug)]
pub struct TeleportLureRequest {
    pub info: TeleportLureRequest_Info,
}


#[derive(Debug)]
pub struct TeleportCancel_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TeleportCancel {
    pub info: TeleportCancel_Info,
}


#[derive(Debug)]
pub struct TeleportStart_Info {
    pub teleport_flags: u32,
}

#[derive(Debug)]
pub struct TeleportStart {
    pub info: TeleportStart_Info,
}


#[derive(Debug)]
pub struct TeleportFailed_Info {
    pub agent_id: Uuid,
    pub reason: Vec<u8>,
}

#[derive(Debug)]
pub struct TeleportFailed_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

#[derive(Debug)]
pub struct TeleportFailed {
    pub info: TeleportFailed_Info,
    pub alert_info: Vec<TeleportFailed_AlertInfo>,
}


#[derive(Debug)]
pub struct Undo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct Undo_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct Undo {
    pub agent_data: Undo_AgentData,
    pub object_data: Vec<Undo_ObjectData>,
}


#[derive(Debug)]
pub struct Redo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct Redo_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct Redo {
    pub agent_data: Redo_AgentData,
    pub object_data: Vec<Redo_ObjectData>,
}


#[derive(Debug)]
pub struct UndoLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UndoLand {
    pub agent_data: UndoLand_AgentData,
}


#[derive(Debug)]
pub struct AgentPause_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

#[derive(Debug)]
pub struct AgentPause {
    pub agent_data: AgentPause_AgentData,
}


#[derive(Debug)]
pub struct AgentResume_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

#[derive(Debug)]
pub struct AgentResume {
    pub agent_data: AgentResume_AgentData,
}


#[derive(Debug)]
pub struct AgentUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub body_rotation: Quaternion<f32>,
    pub head_rotation: Quaternion<f32>,
    pub state: u8,
    pub camera_center: Vector3<f32>,
    pub camera_at_axis: Vector3<f32>,
    pub camera_left_axis: Vector3<f32>,
    pub camera_up_axis: Vector3<f32>,
    pub far: f32,
    pub control_flags: u32,
    pub flags: u8,
}

#[derive(Debug)]
pub struct AgentUpdate {
    pub agent_data: AgentUpdate_AgentData,
}


#[derive(Debug)]
pub struct ChatFromViewer_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChatFromViewer_ChatData {
    pub message: Vec<u8>,
    pub type_: u8,
    pub channel: i32,
}

#[derive(Debug)]
pub struct ChatFromViewer {
    pub agent_data: ChatFromViewer_AgentData,
    pub chat_data: ChatFromViewer_ChatData,
}


#[derive(Debug)]
pub struct AgentThrottle_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentThrottle_Throttle {
    pub gen_counter: u32,
    pub throttles: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentThrottle {
    pub agent_data: AgentThrottle_AgentData,
    pub throttle: AgentThrottle_Throttle,
}


#[derive(Debug)]
pub struct AgentFOV_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentFOV_FOVBlock {
    pub gen_counter: u32,
    pub vertical_angle: f32,
}

#[derive(Debug)]
pub struct AgentFOV {
    pub agent_data: AgentFOV_AgentData,
    pub fov_block: AgentFOV_FOVBlock,
}


#[derive(Debug)]
pub struct AgentHeightWidth_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentHeightWidth_HeightWidthBlock {
    pub gen_counter: u32,
    pub height: u16,
    pub width: u16,
}

#[derive(Debug)]
pub struct AgentHeightWidth {
    pub agent_data: AgentHeightWidth_AgentData,
    pub height_width_block: AgentHeightWidth_HeightWidthBlock,
}


#[derive(Debug)]
pub struct AgentSetAppearance_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
    pub size: Vector3<f32>,
}

#[derive(Debug)]
pub struct AgentSetAppearance_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
}

#[derive(Debug)]
pub struct AgentSetAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentSetAppearance_VisualParam {
    pub param_value: u8,
}

#[derive(Debug)]
pub struct AgentSetAppearance {
    pub agent_data: AgentSetAppearance_AgentData,
    pub wearable_data: Vec<AgentSetAppearance_WearableData>,
    pub object_data: AgentSetAppearance_ObjectData,
    pub visual_param: Vec<AgentSetAppearance_VisualParam>,
}


#[derive(Debug)]
pub struct AgentAnimation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentAnimation_AnimationList {
    pub anim_id: Uuid,
    pub start_anim: bool,
}

#[derive(Debug)]
pub struct AgentAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentAnimation {
    pub agent_data: AgentAnimation_AgentData,
    pub animation_list: Vec<AgentAnimation_AnimationList>,
    pub physical_avatar_event_list: Vec<AgentAnimation_PhysicalAvatarEventList>,
}


#[derive(Debug)]
pub struct AgentRequestSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentRequestSit_TargetObject {
    pub target_id: Uuid,
    pub offset: Vector3<f32>,
}

#[derive(Debug)]
pub struct AgentRequestSit {
    pub agent_data: AgentRequestSit_AgentData,
    pub target_object: AgentRequestSit_TargetObject,
}


#[derive(Debug)]
pub struct AgentSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentSit {
    pub agent_data: AgentSit_AgentData,
}


#[derive(Debug)]
pub struct AgentQuitCopy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentQuitCopy_FuseBlock {
    pub viewer_circuit_code: u32,
}

#[derive(Debug)]
pub struct AgentQuitCopy {
    pub agent_data: AgentQuitCopy_AgentData,
    pub fuse_block: AgentQuitCopy_FuseBlock,
}


#[derive(Debug)]
pub struct RequestImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestImage_RequestImage {
    pub image: Uuid,
    pub discard_level: i8,
    pub download_priority: f32,
    pub packet: u32,
    pub type_: u8,
}

#[derive(Debug)]
pub struct RequestImage {
    pub agent_data: RequestImage_AgentData,
    pub request_image: Vec<RequestImage_RequestImage>,
}


#[derive(Debug)]
pub struct ImageNotInDatabase_ImageID {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct ImageNotInDatabase {
    pub image_id: ImageNotInDatabase_ImageID,
}


#[derive(Debug)]
pub struct RebakeAvatarTextures_TextureData {
    pub texture_id: Uuid,
}

#[derive(Debug)]
pub struct RebakeAvatarTextures {
    pub texture_data: RebakeAvatarTextures_TextureData,
}


#[derive(Debug)]
pub struct SetAlwaysRun_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub always_run: bool,
}

#[derive(Debug)]
pub struct SetAlwaysRun {
    pub agent_data: SetAlwaysRun_AgentData,
}


#[derive(Debug)]
pub struct ObjectAdd_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectAdd_ObjectData {
    pub p_code: u8,
    pub material: u8,
    pub add_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: u8,
    pub scale: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub state: u8,
}

#[derive(Debug)]
pub struct ObjectAdd {
    pub agent_data: ObjectAdd_AgentData,
    pub object_data: ObjectAdd_ObjectData,
}


#[derive(Debug)]
pub struct ObjectDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub force: bool,
}

#[derive(Debug)]
pub struct ObjectDelete_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDelete {
    pub agent_data: ObjectDelete_AgentData,
    pub object_data: Vec<ObjectDelete_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDuplicate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDuplicate_SharedData {
    pub offset: Vector3<f32>,
    pub duplicate_flags: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicate_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicate {
    pub agent_data: ObjectDuplicate_AgentData,
    pub shared_data: ObjectDuplicate_SharedData,
    pub object_data: Vec<ObjectDuplicate_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDuplicateOnRay_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub bypass_raycast: bool,
    pub ray_end_is_intersection: bool,
    pub copy_centers: bool,
    pub copy_rotates: bool,
    pub ray_target_id: Uuid,
    pub duplicate_flags: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicateOnRay_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDuplicateOnRay {
    pub agent_data: ObjectDuplicateOnRay_AgentData,
    pub object_data: Vec<ObjectDuplicateOnRay_ObjectData>,
}


#[derive(Debug)]
pub struct MultipleObjectUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MultipleObjectUpdate_ObjectData {
    pub object_local_id: u32,
    pub type_: u8,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct MultipleObjectUpdate {
    pub agent_data: MultipleObjectUpdate_AgentData,
    pub object_data: Vec<MultipleObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct RequestMultipleObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestMultipleObjects_ObjectData {
    pub cache_miss_type: u8,
    pub id: u32,
}

#[derive(Debug)]
pub struct RequestMultipleObjects {
    pub agent_data: RequestMultipleObjects_AgentData,
    pub object_data: Vec<RequestMultipleObjects_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectPosition_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectPosition_ObjectData {
    pub object_local_id: u32,
    pub position: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectPosition {
    pub agent_data: ObjectPosition_AgentData,
    pub object_data: Vec<ObjectPosition_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectScale_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectScale_ObjectData {
    pub object_local_id: u32,
    pub scale: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectScale {
    pub agent_data: ObjectScale_AgentData,
    pub object_data: Vec<ObjectScale_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectRotation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectRotation_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

#[derive(Debug)]
pub struct ObjectRotation {
    pub agent_data: ObjectRotation_AgentData,
    pub object_data: Vec<ObjectRotation_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectFlagUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub object_local_id: u32,
    pub use_physics: bool,
    pub is_temporary: bool,
    pub is_phantom: bool,
    pub casts_shadows: bool,
}

#[derive(Debug)]
pub struct ObjectFlagUpdate {
    pub agent_data: ObjectFlagUpdate_AgentData,
}


#[derive(Debug)]
pub struct ObjectClickAction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectClickAction_ObjectData {
    pub object_local_id: u32,
    pub click_action: u8,
}

#[derive(Debug)]
pub struct ObjectClickAction {
    pub agent_data: ObjectClickAction_AgentData,
    pub object_data: Vec<ObjectClickAction_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectImage_ObjectData {
    pub object_local_id: u32,
    pub media_url: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectImage {
    pub agent_data: ObjectImage_AgentData,
    pub object_data: Vec<ObjectImage_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectMaterial_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectMaterial_ObjectData {
    pub object_local_id: u32,
    pub material: u8,
}

#[derive(Debug)]
pub struct ObjectMaterial {
    pub agent_data: ObjectMaterial_AgentData,
    pub object_data: Vec<ObjectMaterial_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectShape_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectShape_ObjectData {
    pub object_local_id: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
}

#[derive(Debug)]
pub struct ObjectShape {
    pub agent_data: ObjectShape_AgentData,
    pub object_data: Vec<ObjectShape_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectExtraParams_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectExtraParams_ObjectData {
    pub object_local_id: u32,
    pub param_type: u16,
    pub param_in_use: bool,
    pub param_size: u32,
    pub param_data: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectExtraParams {
    pub agent_data: ObjectExtraParams_AgentData,
    pub object_data: Vec<ObjectExtraParams_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectOwner_HeaderData {
    pub override_: bool,
    pub owner_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectOwner_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectOwner {
    pub agent_data: ObjectOwner_AgentData,
    pub header_data: ObjectOwner_HeaderData,
    pub object_data: Vec<ObjectOwner_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGroup_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectGroup {
    pub agent_data: ObjectGroup_AgentData,
    pub object_data: Vec<ObjectGroup_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub category_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectBuy_ObjectData {
    pub object_local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

#[derive(Debug)]
pub struct ObjectBuy {
    pub agent_data: ObjectBuy_AgentData,
    pub object_data: Vec<ObjectBuy_ObjectData>,
}


#[derive(Debug)]
pub struct BuyObjectInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct BuyObjectInventory_Data {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct BuyObjectInventory {
    pub agent_data: BuyObjectInventory_AgentData,
    pub data: BuyObjectInventory_Data,
}


#[derive(Debug)]
pub struct DerezContainer_Data {
    pub object_id: Uuid,
    pub delete: bool,
}

#[derive(Debug)]
pub struct DerezContainer {
    pub data: DerezContainer_Data,
}


#[derive(Debug)]
pub struct ObjectPermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectPermissions_HeaderData {
    pub override_: bool,
}

#[derive(Debug)]
pub struct ObjectPermissions_ObjectData {
    pub object_local_id: u32,
    pub field: u8,
    pub set: u8,
    pub mask: u32,
}

#[derive(Debug)]
pub struct ObjectPermissions {
    pub agent_data: ObjectPermissions_AgentData,
    pub header_data: ObjectPermissions_HeaderData,
    pub object_data: Vec<ObjectPermissions_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectSaleInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSaleInfo_ObjectData {
    pub local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

#[derive(Debug)]
pub struct ObjectSaleInfo {
    pub agent_data: ObjectSaleInfo_AgentData,
    pub object_data: Vec<ObjectSaleInfo_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectName_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectName_ObjectData {
    pub local_id: u32,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectName {
    pub agent_data: ObjectName_AgentData,
    pub object_data: Vec<ObjectName_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDescription_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDescription_ObjectData {
    pub local_id: u32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectDescription {
    pub agent_data: ObjectDescription_AgentData,
    pub object_data: Vec<ObjectDescription_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectCategory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectCategory_ObjectData {
    pub local_id: u32,
    pub category: u32,
}

#[derive(Debug)]
pub struct ObjectCategory {
    pub agent_data: ObjectCategory_AgentData,
    pub object_data: Vec<ObjectCategory_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectSelect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSelect_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectSelect {
    pub agent_data: ObjectSelect_AgentData,
    pub object_data: Vec<ObjectSelect_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDeselect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDeselect_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDeselect {
    pub agent_data: ObjectDeselect_AgentData,
    pub object_data: Vec<ObjectDeselect_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectAttach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub attachment_point: u8,
}

#[derive(Debug)]
pub struct ObjectAttach_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

#[derive(Debug)]
pub struct ObjectAttach {
    pub agent_data: ObjectAttach_AgentData,
    pub object_data: Vec<ObjectAttach_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDetach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDetach_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDetach {
    pub agent_data: ObjectDetach_AgentData,
    pub object_data: Vec<ObjectDetach_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDrop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDrop_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDrop {
    pub agent_data: ObjectDrop_AgentData,
    pub object_data: Vec<ObjectDrop_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectLink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectLink_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectLink {
    pub agent_data: ObjectLink_AgentData,
    pub object_data: Vec<ObjectLink_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectDelink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDelink_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDelink {
    pub agent_data: ObjectDelink_AgentData,
    pub object_data: Vec<ObjectDelink_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGrab_ObjectData {
    pub local_id: u32,
    pub grab_offset: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectGrab {
    pub agent_data: ObjectGrab_AgentData,
    pub object_data: ObjectGrab_ObjectData,
    pub surface_info: Vec<ObjectGrab_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectGrabUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectGrabUpdate_ObjectData {
    pub object_id: Uuid,
    pub grab_offset_initial: Vector3<f32>,
    pub grab_position: Vector3<f32>,
    pub time_since_last: u32,
}

#[derive(Debug)]
pub struct ObjectGrabUpdate_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectGrabUpdate {
    pub agent_data: ObjectGrabUpdate_AgentData,
    pub object_data: ObjectGrabUpdate_ObjectData,
    pub surface_info: Vec<ObjectGrabUpdate_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectDeGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectDeGrab_ObjectData {
    pub local_id: u32,
}

#[derive(Debug)]
pub struct ObjectDeGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectDeGrab {
    pub agent_data: ObjectDeGrab_AgentData,
    pub object_data: ObjectDeGrab_ObjectData,
    pub surface_info: Vec<ObjectDeGrab_SurfaceInfo>,
}


#[derive(Debug)]
pub struct ObjectSpinStart_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStart_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStart {
    pub agent_data: ObjectSpinStart_AgentData,
    pub object_data: ObjectSpinStart_ObjectData,
}


#[derive(Debug)]
pub struct ObjectSpinUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinUpdate_ObjectData {
    pub object_id: Uuid,
    pub rotation: Quaternion<f32>,
}

#[derive(Debug)]
pub struct ObjectSpinUpdate {
    pub agent_data: ObjectSpinUpdate_AgentData,
    pub object_data: ObjectSpinUpdate_ObjectData,
}


#[derive(Debug)]
pub struct ObjectSpinStop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStop_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectSpinStop {
    pub agent_data: ObjectSpinStop_AgentData,
    pub object_data: ObjectSpinStop_ObjectData,
}


#[derive(Debug)]
pub struct ObjectExportSelected_AgentData {
    pub agent_id: Uuid,
    pub request_id: Uuid,
    pub volume_detail: i16,
}

#[derive(Debug)]
pub struct ObjectExportSelected_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectExportSelected {
    pub agent_data: ObjectExportSelected_AgentData,
    pub object_data: Vec<ObjectExportSelected_ObjectData>,
}


#[derive(Debug)]
pub struct ModifyLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ModifyLand_ModifyBlock {
    pub action: u8,
    pub brush_size: u8,
    pub seconds: f32,
    pub height: f32,
}

#[derive(Debug)]
pub struct ModifyLand_ParcelData {
    pub local_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

#[derive(Debug)]
pub struct ModifyLand_ModifyBlockExtended {
    pub brush_size: f32,
}

#[derive(Debug)]
pub struct ModifyLand {
    pub agent_data: ModifyLand_AgentData,
    pub modify_block: ModifyLand_ModifyBlock,
    pub parcel_data: Vec<ModifyLand_ParcelData>,
    pub modify_block_extended: Vec<ModifyLand_ModifyBlockExtended>,
}


#[derive(Debug)]
pub struct VelocityInterpolateOn_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct VelocityInterpolateOn {
    pub agent_data: VelocityInterpolateOn_AgentData,
}


#[derive(Debug)]
pub struct VelocityInterpolateOff_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct VelocityInterpolateOff {
    pub agent_data: VelocityInterpolateOff_AgentData,
}


#[derive(Debug)]
pub struct StateSave_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StateSave_DataBlock {
    pub filename: Vec<u8>,
}

#[derive(Debug)]
pub struct StateSave {
    pub agent_data: StateSave_AgentData,
    pub data_block: StateSave_DataBlock,
}


#[derive(Debug)]
pub struct ReportAutosaveCrash_AutosaveData {
    pub pid: i32,
    pub status: i32,
}

#[derive(Debug)]
pub struct ReportAutosaveCrash {
    pub autosave_data: ReportAutosaveCrash_AutosaveData,
}


#[derive(Debug)]
pub struct SimWideDeletes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SimWideDeletes_DataBlock {
    pub target_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct SimWideDeletes {
    pub agent_data: SimWideDeletes_AgentData,
    pub data_block: SimWideDeletes_DataBlock,
}


#[derive(Debug)]
pub struct RequestObjectPropertiesFamily_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct RequestObjectPropertiesFamily {
    pub agent_data: RequestObjectPropertiesFamily_AgentData,
    pub object_data: RequestObjectPropertiesFamily_ObjectData,
}


#[derive(Debug)]
pub struct TrackAgent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TrackAgent_TargetData {
    pub prey_id: Uuid,
}

#[derive(Debug)]
pub struct TrackAgent {
    pub agent_data: TrackAgent_AgentData,
    pub target_data: TrackAgent_TargetData,
}


#[derive(Debug)]
pub struct ViewerStats_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub ip: Ip4Addr,
    pub start_time: u32,
    pub run_time: f32,
    pub sim_fps: f32,
    pub fps: f32,
    pub agents_in_view: u8,
    pub ping: f32,
    pub meters_traveled: f64,
    pub regions_visited: i32,
    pub sys_ram: u32,
    pub sys_os: Vec<u8>,
    pub sys_cpu: Vec<u8>,
    pub sys_gpu: Vec<u8>,
}

#[derive(Debug)]
pub struct ViewerStats_DownloadTotals {
    pub world: u32,
    pub objects: u32,
    pub textures: u32,
}

#[derive(Debug)]
pub struct ViewerStats_NetStats {
    pub bytes: u32,
    pub packets: u32,
    pub compressed: u32,
    pub savings: u32,
}

#[derive(Debug)]
pub struct ViewerStats_FailStats {
    pub send_packet: u32,
    pub dropped: u32,
    pub resent: u32,
    pub failed_resends: u32,
    pub off_circuit: u32,
    pub invalid: u32,
}

#[derive(Debug)]
pub struct ViewerStats_MiscStats {
    pub type_: u32,
    pub value: f64,
}

#[derive(Debug)]
pub struct ViewerStats {
    pub agent_data: ViewerStats_AgentData,
    pub download_totals: ViewerStats_DownloadTotals,
    pub net_stats: [ViewerStats_NetStats; 2],
    pub fail_stats: ViewerStats_FailStats,
    pub misc_stats: Vec<ViewerStats_MiscStats>,
}


#[derive(Debug)]
pub struct ScriptAnswerYes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptAnswerYes_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub questions: i32,
}

#[derive(Debug)]
pub struct ScriptAnswerYes {
    pub agent_data: ScriptAnswerYes_AgentData,
    pub data: ScriptAnswerYes_Data,
}


#[derive(Debug)]
pub struct UserReport_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UserReport_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub position: Vector3<f32>,
    pub check_flags: u8,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

#[derive(Debug)]
pub struct UserReport {
    pub agent_data: UserReport_AgentData,
    pub report_data: UserReport_ReportData,
}


#[derive(Debug)]
pub struct AlertMessage_AlertData {
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct AlertMessage_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

#[derive(Debug)]
pub struct AlertMessage {
    pub alert_data: AlertMessage_AlertData,
    pub alert_info: Vec<AlertMessage_AlertInfo>,
}


#[derive(Debug)]
pub struct AgentAlertMessage_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AgentAlertMessage_AlertData {
    pub modal: bool,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentAlertMessage {
    pub agent_data: AgentAlertMessage_AgentData,
    pub alert_data: AgentAlertMessage_AlertData,
}


#[derive(Debug)]
pub struct MeanCollisionAlert_MeanCollision {
    pub victim: Uuid,
    pub perp: Uuid,
    pub time: u32,
    pub mag: f32,
    pub type_: u8,
}

#[derive(Debug)]
pub struct MeanCollisionAlert {
    pub mean_collision: Vec<MeanCollisionAlert_MeanCollision>,
}


#[derive(Debug)]
pub struct ViewerFrozenMessage_FrozenData {
    pub data: bool,
}

#[derive(Debug)]
pub struct ViewerFrozenMessage {
    pub frozen_data: ViewerFrozenMessage_FrozenData,
}


#[derive(Debug)]
pub struct HealthMessage_HealthData {
    pub health: f32,
}

#[derive(Debug)]
pub struct HealthMessage {
    pub health_data: HealthMessage_HealthData,
}


#[derive(Debug)]
pub struct ChatFromSimulator_ChatData {
    pub from_name: Vec<u8>,
    pub source_id: Uuid,
    pub owner_id: Uuid,
    pub source_type: u8,
    pub chat_type: u8,
    pub audible: u8,
    pub position: Vector3<f32>,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct ChatFromSimulator {
    pub chat_data: ChatFromSimulator_ChatData,
}


#[derive(Debug)]
pub struct SimStats_Region {
    pub region_x: u32,
    pub region_y: u32,
    pub region_flags: u32,
    pub object_capacity: u32,
}

#[derive(Debug)]
pub struct SimStats_Stat {
    pub stat_id: u32,
    pub stat_value: f32,
}

#[derive(Debug)]
pub struct SimStats_PidStat {
    pub pid: i32,
}

#[derive(Debug)]
pub struct SimStats {
    pub region: SimStats_Region,
    pub stat: Vec<SimStats_Stat>,
    pub pid_stat: SimStats_PidStat,
}


#[derive(Debug)]
pub struct RequestRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestRegionInfo {
    pub agent_data: RequestRegionInfo_AgentData,
}


#[derive(Debug)]
pub struct RegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub sim_access: u8,
    pub max_agents: u8,
    pub billable_factor: f32,
    pub object_bonus_factor: f32,
    pub water_height: f32,
    pub terrain_raise_limit: f32,
    pub terrain_lower_limit: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
    pub use_estate_sun: bool,
    pub sun_hour: f32,
}

#[derive(Debug)]
pub struct RegionInfo_RegionInfo2 {
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
    pub max_agents32: u32,
    pub hard_max_agents: u32,
    pub hard_max_objects: u32,
}

#[derive(Debug)]
pub struct RegionInfo {
    pub agent_data: RegionInfo_AgentData,
    pub region_info: RegionInfo_RegionInfo,
    pub region_info2: RegionInfo_RegionInfo2,
}


#[derive(Debug)]
pub struct GodUpdateRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GodUpdateRegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub billable_factor: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
}

#[derive(Debug)]
pub struct GodUpdateRegionInfo {
    pub agent_data: GodUpdateRegionInfo_AgentData,
    pub region_info: GodUpdateRegionInfo_RegionInfo,
}


#[derive(Debug)]
pub struct NearestLandingRegionRequest_RequestingRegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct NearestLandingRegionRequest {
    pub requesting_region_data: NearestLandingRegionRequest_RequestingRegionData,
}


#[derive(Debug)]
pub struct NearestLandingRegionReply_LandingRegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct NearestLandingRegionReply {
    pub landing_region_data: NearestLandingRegionReply_LandingRegionData,
}


#[derive(Debug)]
pub struct NearestLandingRegionUpdated_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct NearestLandingRegionUpdated {
    pub region_data: NearestLandingRegionUpdated_RegionData,
}


#[derive(Debug)]
pub struct TeleportLandingStatusChanged_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct TeleportLandingStatusChanged {
    pub region_data: TeleportLandingStatusChanged_RegionData,
}


#[derive(Debug)]
pub struct RegionHandshake_RegionInfo {
    pub region_flags: u32,
    pub sim_access: u8,
    pub sim_name: Vec<u8>,
    pub sim_owner: Uuid,
    pub is_estate_manager: bool,
    pub water_height: f32,
    pub billable_factor: f32,
    pub cache_id: Uuid,
    pub terrain_base0: Uuid,
    pub terrain_base1: Uuid,
    pub terrain_base2: Uuid,
    pub terrain_base3: Uuid,
    pub terrain_detail0: Uuid,
    pub terrain_detail1: Uuid,
    pub terrain_detail2: Uuid,
    pub terrain_detail3: Uuid,
    pub terrain_start_height00: f32,
    pub terrain_start_height01: f32,
    pub terrain_start_height10: f32,
    pub terrain_start_height11: f32,
    pub terrain_height_range00: f32,
    pub terrain_height_range01: f32,
    pub terrain_height_range10: f32,
    pub terrain_height_range11: f32,
}

#[derive(Debug)]
pub struct RegionHandshake_RegionInfo2 {
    pub region_id: Uuid,
}

#[derive(Debug)]
pub struct RegionHandshake_RegionInfo3 {
    pub cpu_class_id: i32,
    pub cpu_ratio: i32,
    pub colo_name: Vec<u8>,
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
}

#[derive(Debug)]
pub struct RegionHandshake {
    pub region_info: RegionHandshake_RegionInfo,
    pub region_info2: RegionHandshake_RegionInfo2,
    pub region_info3: RegionHandshake_RegionInfo3,
}


#[derive(Debug)]
pub struct RegionHandshakeReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RegionHandshakeReply_RegionInfo {
    pub flags: u32,
}

#[derive(Debug)]
pub struct RegionHandshakeReply {
    pub agent_data: RegionHandshakeReply_AgentData,
    pub region_info: RegionHandshakeReply_RegionInfo,
}


#[derive(Debug)]
pub struct CoarseLocationUpdate_Location {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}

#[derive(Debug)]
pub struct CoarseLocationUpdate_Index {
    pub you: i16,
    pub prey: i16,
}

#[derive(Debug)]
pub struct CoarseLocationUpdate_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct CoarseLocationUpdate {
    pub location: Vec<CoarseLocationUpdate_Location>,
    pub index: CoarseLocationUpdate_Index,
    pub agent_data: Vec<CoarseLocationUpdate_AgentData>,
}


#[derive(Debug)]
pub struct ImageData_ImageID {
    pub id: Uuid,
    pub codec: u8,
    pub size: u32,
    pub packets: u16,
}

#[derive(Debug)]
pub struct ImageData_ImageData {
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct ImageData {
    pub image_id: ImageData_ImageID,
    pub image_data: ImageData_ImageData,
}


#[derive(Debug)]
pub struct ImagePacket_ImageID {
    pub id: Uuid,
    pub packet: u16,
}

#[derive(Debug)]
pub struct ImagePacket_ImageData {
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct ImagePacket {
    pub image_id: ImagePacket_ImageID,
    pub image_data: ImagePacket_ImageData,
}


#[derive(Debug)]
pub struct LayerData_LayerID {
    pub type_: u8,
}

#[derive(Debug)]
pub struct LayerData_LayerData {
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct LayerData {
    pub layer_id: LayerData_LayerID,
    pub layer_data: LayerData_LayerData,
}


#[derive(Debug)]
pub struct ObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdate_ObjectData {
    pub id: u32,
    pub state: u8,
    pub full_id: Uuid,
    pub crc: u32,
    pub p_code: u8,
    pub material: u8,
    pub click_action: u8,
    pub scale: Vector3<f32>,
    pub object_data: Vec<u8>,
    pub parent_id: u32,
    pub update_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub texture_entry: Vec<u8>,
    pub texture_anim: Vec<u8>,
    pub name_value: Vec<u8>,
    pub data: Vec<u8>,
    pub text: Vec<u8>,
    pub text_color: [u8; 4],
    pub media_url: Vec<u8>,
    pub ps_block: Vec<u8>,
    pub extra_params: Vec<u8>,
    pub sound: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
    pub radius: f32,
    pub joint_type: u8,
    pub joint_pivot: Vector3<f32>,
    pub joint_axis_or_anchor: Vector3<f32>,
}

#[derive(Debug)]
pub struct ObjectUpdate {
    pub region_data: ObjectUpdate_RegionData,
    pub object_data: Vec<ObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectUpdateCompressed_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdateCompressed_ObjectData {
    pub update_flags: u32,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectUpdateCompressed {
    pub region_data: ObjectUpdateCompressed_RegionData,
    pub object_data: Vec<ObjectUpdateCompressed_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectUpdateCached_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ObjectUpdateCached_ObjectData {
    pub id: u32,
    pub crc: u32,
    pub update_flags: u32,
}

#[derive(Debug)]
pub struct ObjectUpdateCached {
    pub region_data: ObjectUpdateCached_RegionData,
    pub object_data: Vec<ObjectUpdateCached_ObjectData>,
}


#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate_ObjectData {
    pub data: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct ImprovedTerseObjectUpdate {
    pub region_data: ImprovedTerseObjectUpdate_RegionData,
    pub object_data: Vec<ImprovedTerseObjectUpdate_ObjectData>,
}


#[derive(Debug)]
pub struct KillObject_ObjectData {
    pub id: u32,
}

#[derive(Debug)]
pub struct KillObject {
    pub object_data: Vec<KillObject_ObjectData>,
}


#[derive(Debug)]
pub struct CrossedRegion_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CrossedRegion_RegionData {
    pub sim_ip: Ip4Addr,
    pub sim_port: IpPort,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
}

#[derive(Debug)]
pub struct CrossedRegion_Info {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct CrossedRegion {
    pub agent_data: CrossedRegion_AgentData,
    pub region_data: CrossedRegion_RegionData,
    pub info: CrossedRegion_Info,
}


#[derive(Debug)]
pub struct SimulatorViewerTimeMessage_TimeInfo {
    pub usec_since_start: u64,
    pub sec_per_day: u32,
    pub sec_per_year: u32,
    pub sun_direction: Vector3<f32>,
    pub sun_phase: f32,
    pub sun_ang_velocity: Vector3<f32>,
}

#[derive(Debug)]
pub struct SimulatorViewerTimeMessage {
    pub time_info: SimulatorViewerTimeMessage_TimeInfo,
}


#[derive(Debug)]
pub struct EnableSimulator_SimulatorInfo {
    pub handle: u64,
    pub ip: Ip4Addr,
    pub port: IpPort,
}

#[derive(Debug)]
pub struct EnableSimulator {
    pub simulator_info: EnableSimulator_SimulatorInfo,
}


#[derive(Debug)]
pub struct DisableSimulator {
}


#[derive(Debug)]
pub struct ConfirmEnableSimulator_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ConfirmEnableSimulator {
    pub agent_data: ConfirmEnableSimulator_AgentData,
}


#[derive(Debug)]
pub struct TransferRequest_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub source_type: i32,
    pub priority: f32,
    pub params: Vec<u8>,
}

#[derive(Debug)]
pub struct TransferRequest {
    pub transfer_info: TransferRequest_TransferInfo,
}


#[derive(Debug)]
pub struct TransferInfo_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub target_type: i32,
    pub status: i32,
    pub size: i32,
    pub params: Vec<u8>,
}

#[derive(Debug)]
pub struct TransferInfo {
    pub transfer_info: TransferInfo_TransferInfo,
}


#[derive(Debug)]
pub struct TransferPacket_TransferData {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub packet: i32,
    pub status: i32,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct TransferPacket {
    pub transfer_data: TransferPacket_TransferData,
}


#[derive(Debug)]
pub struct TransferAbort_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
}

#[derive(Debug)]
pub struct TransferAbort {
    pub transfer_info: TransferAbort_TransferInfo,
}


#[derive(Debug)]
pub struct RequestXfer_XferID {
    pub id: u64,
    pub filename: Vec<u8>,
    pub file_path: u8,
    pub delete_on_completion: bool,
    pub use_big_packets: bool,
    pub v_file_id: Uuid,
    pub v_file_type: i16,
}

#[derive(Debug)]
pub struct RequestXfer {
    pub xfer_id: RequestXfer_XferID,
}


#[derive(Debug)]
pub struct SendXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

#[derive(Debug)]
pub struct SendXferPacket_DataPacket {
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct SendXferPacket {
    pub xfer_id: SendXferPacket_XferID,
    pub data_packet: SendXferPacket_DataPacket,
}


#[derive(Debug)]
pub struct ConfirmXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

#[derive(Debug)]
pub struct ConfirmXferPacket {
    pub xfer_id: ConfirmXferPacket_XferID,
}


#[derive(Debug)]
pub struct AbortXfer_XferID {
    pub id: u64,
    pub result: i32,
}

#[derive(Debug)]
pub struct AbortXfer {
    pub xfer_id: AbortXfer_XferID,
}


#[derive(Debug)]
pub struct AvatarAnimation_Sender {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct AvatarAnimation_AnimationList {
    pub anim_id: Uuid,
    pub anim_sequence_id: i32,
}

#[derive(Debug)]
pub struct AvatarAnimation_AnimationSourceList {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarAnimation {
    pub sender: AvatarAnimation_Sender,
    pub animation_list: Vec<AvatarAnimation_AnimationList>,
    pub animation_source_list: Vec<AvatarAnimation_AnimationSourceList>,
    pub physical_avatar_event_list: Vec<AvatarAnimation_PhysicalAvatarEventList>,
}


#[derive(Debug)]
pub struct AvatarAppearance_Sender {
    pub id: Uuid,
    pub is_trial: bool,
}

#[derive(Debug)]
pub struct AvatarAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarAppearance_VisualParam {
    pub param_value: u8,
}

#[derive(Debug)]
pub struct AvatarAppearance {
    pub sender: AvatarAppearance_Sender,
    pub object_data: AvatarAppearance_ObjectData,
    pub visual_param: Vec<AvatarAppearance_VisualParam>,
}


#[derive(Debug)]
pub struct AvatarSitResponse_SitObject {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct AvatarSitResponse_SitTransform {
    pub auto_pilot: bool,
    pub sit_position: Vector3<f32>,
    pub sit_rotation: Quaternion<f32>,
    pub camera_eye_offset: Vector3<f32>,
    pub camera_at_offset: Vector3<f32>,
    pub force_mouselook: bool,
}

#[derive(Debug)]
pub struct AvatarSitResponse {
    pub sit_object: AvatarSitResponse_SitObject,
    pub sit_transform: AvatarSitResponse_SitTransform,
}


#[derive(Debug)]
pub struct SetFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct SetFollowCamProperties_CameraProperty {
    pub type_: i32,
    pub value: f32,
}

#[derive(Debug)]
pub struct SetFollowCamProperties {
    pub object_data: SetFollowCamProperties_ObjectData,
    pub camera_property: Vec<SetFollowCamProperties_CameraProperty>,
}


#[derive(Debug)]
pub struct ClearFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ClearFollowCamProperties {
    pub object_data: ClearFollowCamProperties_ObjectData,
}


#[derive(Debug)]
pub struct CameraConstraint_CameraCollidePlane {
    pub plane: Vector4<f32>,
}

#[derive(Debug)]
pub struct CameraConstraint {
    pub camera_collide_plane: CameraConstraint_CameraCollidePlane,
}


#[derive(Debug)]
pub struct ObjectProperties_ObjectData {
    pub object_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub creation_date: u64,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub aggregate_perms: u8,
    pub aggregate_perm_textures: u8,
    pub aggregate_perm_textures_owner: u8,
    pub category: u32,
    pub inventory_serial: i16,
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub from_task_id: Uuid,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub touch_name: Vec<u8>,
    pub sit_name: Vec<u8>,
    pub texture_id: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectProperties {
    pub object_data: Vec<ObjectProperties_ObjectData>,
}


#[derive(Debug)]
pub struct ObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub category: u32,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct ObjectPropertiesFamily {
    pub object_data: ObjectPropertiesFamily_ObjectData,
}


#[derive(Debug)]
pub struct RequestPayPrice_ObjectData {
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct RequestPayPrice {
    pub object_data: RequestPayPrice_ObjectData,
}


#[derive(Debug)]
pub struct PayPriceReply_ObjectData {
    pub object_id: Uuid,
    pub default_pay_price: i32,
}

#[derive(Debug)]
pub struct PayPriceReply_ButtonData {
    pub pay_button: i32,
}

#[derive(Debug)]
pub struct PayPriceReply {
    pub object_data: PayPriceReply_ObjectData,
    pub button_data: Vec<PayPriceReply_ButtonData>,
}


#[derive(Debug)]
pub struct KickUser_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: IpPort,
}

#[derive(Debug)]
pub struct KickUser_UserInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub reason: Vec<u8>,
}

#[derive(Debug)]
pub struct KickUser {
    pub target_block: KickUser_TargetBlock,
    pub user_info: KickUser_UserInfo,
}


#[derive(Debug)]
pub struct KickUserAck_UserInfo {
    pub session_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct KickUserAck {
    pub user_info: KickUserAck_UserInfo,
}


#[derive(Debug)]
pub struct GodKickUser_UserInfo {
    pub god_id: Uuid,
    pub god_session_id: Uuid,
    pub agent_id: Uuid,
    pub kick_flags: u32,
    pub reason: Vec<u8>,
}

#[derive(Debug)]
pub struct GodKickUser {
    pub user_info: GodKickUser_UserInfo,
}


#[derive(Debug)]
pub struct SystemKickUser_AgentInfo {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct SystemKickUser {
    pub agent_info: Vec<SystemKickUser_AgentInfo>,
}


#[derive(Debug)]
pub struct EjectUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EjectUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct EjectUser {
    pub agent_data: EjectUser_AgentData,
    pub data: EjectUser_Data,
}


#[derive(Debug)]
pub struct FreezeUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FreezeUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct FreezeUser {
    pub agent_data: FreezeUser_AgentData,
    pub data: FreezeUser_Data,
}


#[derive(Debug)]
pub struct AvatarPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPropertiesRequest {
    pub agent_data: AvatarPropertiesRequest_AgentData,
}


#[derive(Debug)]
pub struct AvatarPropertiesRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
    pub god_level: u8,
    pub web_profiles_disabled: bool,
}

#[derive(Debug)]
pub struct AvatarPropertiesRequestBackend {
    pub agent_data: AvatarPropertiesRequestBackend_AgentData,
}


#[derive(Debug)]
pub struct AvatarPropertiesReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPropertiesReply_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub partner_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub born_on: Vec<u8>,
    pub profile_url: Vec<u8>,
    pub charter_member: Vec<u8>,
    pub flags: u32,
}

#[derive(Debug)]
pub struct AvatarPropertiesReply {
    pub agent_data: AvatarPropertiesReply_AgentData,
    pub properties_data: AvatarPropertiesReply_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarInterestsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarInterestsReply_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarInterestsReply {
    pub agent_data: AvatarInterestsReply_AgentData,
    pub properties_data: AvatarInterestsReply_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarGroupsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarGroupsReply_GroupData {
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_title: Vec<u8>,
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub group_insignia_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarGroupsReply_NewGroupData {
    pub list_in_profile: bool,
}

#[derive(Debug)]
pub struct AvatarGroupsReply {
    pub agent_data: AvatarGroupsReply_AgentData,
    pub group_data: Vec<AvatarGroupsReply_GroupData>,
    pub new_group_data: AvatarGroupsReply_NewGroupData,
}


#[derive(Debug)]
pub struct AvatarPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPropertiesUpdate_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub profile_url: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarPropertiesUpdate {
    pub agent_data: AvatarPropertiesUpdate_AgentData,
    pub properties_data: AvatarPropertiesUpdate_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarInterestsUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarInterestsUpdate_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarInterestsUpdate {
    pub agent_data: AvatarInterestsUpdate_AgentData,
    pub properties_data: AvatarInterestsUpdate_PropertiesData,
}


#[derive(Debug)]
pub struct AvatarNotesReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarNotesReply_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarNotesReply {
    pub agent_data: AvatarNotesReply_AgentData,
    pub data: AvatarNotesReply_Data,
}


#[derive(Debug)]
pub struct AvatarNotesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarNotesUpdate_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarNotesUpdate {
    pub agent_data: AvatarNotesUpdate_AgentData,
    pub data: AvatarNotesUpdate_Data,
}


#[derive(Debug)]
pub struct AvatarPicksReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

#[derive(Debug)]
pub struct AvatarPicksReply_Data {
    pub pick_id: Uuid,
    pub pick_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AvatarPicksReply {
    pub agent_data: AvatarPicksReply_AgentData,
    pub data: Vec<AvatarPicksReply_Data>,
}


#[derive(Debug)]
pub struct EventInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventInfoRequest_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventInfoRequest {
    pub agent_data: EventInfoRequest_AgentData,
    pub event_data: EventInfoRequest_EventData,
}


#[derive(Debug)]
pub struct EventInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct EventInfoReply_EventData {
    pub event_id: u32,
    pub creator: Vec<u8>,
    pub name: Vec<u8>,
    pub category: Vec<u8>,
    pub desc: Vec<u8>,
    pub date: Vec<u8>,
    pub date_utc: u32,
    pub duration: u32,
    pub cover: u32,
    pub amount: u32,
    pub sim_name: Vec<u8>,
    pub global_pos: Vector3<f64>,
    pub event_flags: u32,
}

#[derive(Debug)]
pub struct EventInfoReply {
    pub agent_data: EventInfoReply_AgentData,
    pub event_data: EventInfoReply_EventData,
}


#[derive(Debug)]
pub struct EventNotificationAddRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventNotificationAddRequest_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventNotificationAddRequest {
    pub agent_data: EventNotificationAddRequest_AgentData,
    pub event_data: EventNotificationAddRequest_EventData,
}


#[derive(Debug)]
pub struct EventNotificationRemoveRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventNotificationRemoveRequest_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventNotificationRemoveRequest {
    pub agent_data: EventNotificationRemoveRequest_AgentData,
    pub event_data: EventNotificationRemoveRequest_EventData,
}


#[derive(Debug)]
pub struct EventGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EventGodDelete_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventGodDelete_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

#[derive(Debug)]
pub struct EventGodDelete {
    pub agent_data: EventGodDelete_AgentData,
    pub event_data: EventGodDelete_EventData,
    pub query_data: EventGodDelete_QueryData,
}


#[derive(Debug)]
pub struct PickInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct PickInfoReply_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub user: Vec<u8>,
    pub original_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

#[derive(Debug)]
pub struct PickInfoReply {
    pub agent_data: PickInfoReply_AgentData,
    pub data: PickInfoReply_Data,
}


#[derive(Debug)]
pub struct PickInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickInfoUpdate_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

#[derive(Debug)]
pub struct PickInfoUpdate {
    pub agent_data: PickInfoUpdate_AgentData,
    pub data: PickInfoUpdate_Data,
}


#[derive(Debug)]
pub struct PickDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickDelete_Data {
    pub pick_id: Uuid,
}

#[derive(Debug)]
pub struct PickDelete {
    pub agent_data: PickDelete_AgentData,
    pub data: PickDelete_Data,
}


#[derive(Debug)]
pub struct PickGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PickGodDelete_Data {
    pub pick_id: Uuid,
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct PickGodDelete {
    pub agent_data: PickGodDelete_AgentData,
    pub data: PickGodDelete_Data,
}


#[derive(Debug)]
pub struct ScriptQuestion_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub object_name: Vec<u8>,
    pub object_owner: Vec<u8>,
    pub questions: i32,
}

#[derive(Debug)]
pub struct ScriptQuestion {
    pub data: ScriptQuestion_Data,
}


#[derive(Debug)]
pub struct ScriptControlChange_Data {
    pub take_controls: bool,
    pub controls: u32,
    pub pass_to_agent: bool,
}

#[derive(Debug)]
pub struct ScriptControlChange {
    pub data: Vec<ScriptControlChange_Data>,
}


#[derive(Debug)]
pub struct ScriptDialog_Data {
    pub object_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub object_name: Vec<u8>,
    pub message: Vec<u8>,
    pub chat_channel: i32,
    pub image_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptDialog_Buttons {
    pub button_label: Vec<u8>,
}

#[derive(Debug)]
pub struct ScriptDialog_OwnerData {
    pub owner_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptDialog {
    pub data: ScriptDialog_Data,
    pub buttons: Vec<ScriptDialog_Buttons>,
    pub owner_data: Vec<ScriptDialog_OwnerData>,
}


#[derive(Debug)]
pub struct ScriptDialogReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptDialogReply_Data {
    pub object_id: Uuid,
    pub chat_channel: i32,
    pub button_index: i32,
    pub button_label: Vec<u8>,
}

#[derive(Debug)]
pub struct ScriptDialogReply {
    pub agent_data: ScriptDialogReply_AgentData,
    pub data: ScriptDialogReply_Data,
}


#[derive(Debug)]
pub struct ForceScriptControlRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ForceScriptControlRelease {
    pub agent_data: ForceScriptControlRelease_AgentData,
}


#[derive(Debug)]
pub struct RevokePermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RevokePermissions_Data {
    pub object_id: Uuid,
    pub object_permissions: u32,
}

#[derive(Debug)]
pub struct RevokePermissions {
    pub agent_data: RevokePermissions_AgentData,
    pub data: RevokePermissions_Data,
}


#[derive(Debug)]
pub struct LoadURL_Data {
    pub object_name: Vec<u8>,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub owner_is_group: bool,
    pub message: Vec<u8>,
    pub url: Vec<u8>,
}

#[derive(Debug)]
pub struct LoadURL {
    pub data: LoadURL_Data,
}


#[derive(Debug)]
pub struct ScriptTeleportRequest_Data {
    pub object_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub sim_position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct ScriptTeleportRequest {
    pub data: ScriptTeleportRequest_Data,
}


#[derive(Debug)]
pub struct ParcelOverlay_ParcelData {
    pub sequence_id: i32,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct ParcelOverlay {
    pub parcel_data: ParcelOverlay_ParcelData,
}


#[derive(Debug)]
pub struct ParcelPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequest_ParcelData {
    pub sequence_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
    pub snap_selection: bool,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequest {
    pub agent_data: ParcelPropertiesRequest_AgentData,
    pub parcel_data: ParcelPropertiesRequest_ParcelData,
}


#[derive(Debug)]
pub struct ParcelPropertiesRequestByID_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequestByID_ParcelData {
    pub sequence_id: i32,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelPropertiesRequestByID {
    pub agent_data: ParcelPropertiesRequestByID_AgentData,
    pub parcel_data: ParcelPropertiesRequestByID_ParcelData,
}


#[derive(Debug)]
pub struct ParcelProperties_ParcelData {
    pub request_result: i32,
    pub sequence_id: i32,
    pub snap_selection: bool,
    pub self_count: i32,
    pub other_count: i32,
    pub public_count: i32,
    pub local_id: i32,
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub auction_id: u32,
    pub claim_date: i32,
    pub claim_price: i32,
    pub rent_price: i32,
    pub aabb_min: Vector3<f32>,
    pub aabb_max: Vector3<f32>,
    pub bitmap: Vec<u8>,
    pub area: i32,
    pub status: u8,
    pub sim_wide_max_prims: i32,
    pub sim_wide_total_prims: i32,
    pub max_prims: i32,
    pub total_prims: i32,
    pub owner_prims: i32,
    pub group_prims: i32,
    pub other_prims: i32,
    pub selected_prims: i32,
    pub parcel_prim_bonus: f32,
    pub other_clean_time: i32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
    pub region_push_override: bool,
    pub region_deny_anonymous: bool,
    pub region_deny_identified: bool,
    pub region_deny_transacted: bool,
}

#[derive(Debug)]
pub struct ParcelProperties_AgeVerificationBlock {
    pub region_deny_age_unverified: bool,
}

#[derive(Debug)]
pub struct ParcelProperties {
    pub parcel_data: ParcelProperties_ParcelData,
    pub age_verification_block: ParcelProperties_AgeVerificationBlock,
}


#[derive(Debug)]
pub struct ParcelPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelPropertiesUpdate_ParcelData {
    pub local_id: i32,
    pub flags: u32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
}

#[derive(Debug)]
pub struct ParcelPropertiesUpdate {
    pub agent_data: ParcelPropertiesUpdate_AgentData,
    pub parcel_data: ParcelPropertiesUpdate_ParcelData,
}


#[derive(Debug)]
pub struct ParcelReturnObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_TaskIDs {
    pub task_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReturnObjects_OwnerIDs {
    pub owner_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReturnObjects {
    pub agent_data: ParcelReturnObjects_AgentData,
    pub parcel_data: ParcelReturnObjects_ParcelData,
    pub task_i_ds: Vec<ParcelReturnObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelReturnObjects_OwnerIDs>,
}


#[derive(Debug)]
pub struct ParcelSetOtherCleanTime_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSetOtherCleanTime_ParcelData {
    pub local_id: i32,
    pub other_clean_time: i32,
}

#[derive(Debug)]
pub struct ParcelSetOtherCleanTime {
    pub agent_data: ParcelSetOtherCleanTime_AgentData,
    pub parcel_data: ParcelSetOtherCleanTime_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDisableObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_TaskIDs {
    pub task_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDisableObjects_OwnerIDs {
    pub owner_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDisableObjects {
    pub agent_data: ParcelDisableObjects_AgentData,
    pub parcel_data: ParcelDisableObjects_ParcelData,
    pub task_i_ds: Vec<ParcelDisableObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelDisableObjects_OwnerIDs>,
}


#[derive(Debug)]
pub struct ParcelSelectObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSelectObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

#[derive(Debug)]
pub struct ParcelSelectObjects_ReturnIDs {
    pub return_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSelectObjects {
    pub agent_data: ParcelSelectObjects_AgentData,
    pub parcel_data: ParcelSelectObjects_ParcelData,
    pub return_i_ds: Vec<ParcelSelectObjects_ReturnIDs>,
}


#[derive(Debug)]
pub struct EstateCovenantRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EstateCovenantRequest {
    pub agent_data: EstateCovenantRequest_AgentData,
}


#[derive(Debug)]
pub struct EstateCovenantReply_Data {
    pub covenant_id: Uuid,
    pub covenant_timestamp: u32,
    pub estate_name: Vec<u8>,
    pub estate_owner_id: Uuid,
}

#[derive(Debug)]
pub struct EstateCovenantReply {
    pub data: EstateCovenantReply_Data,
}


#[derive(Debug)]
pub struct ForceObjectSelect_Header {
    pub reset_list: bool,
}

#[derive(Debug)]
pub struct ForceObjectSelect_Data {
    pub local_id: u32,
}

#[derive(Debug)]
pub struct ForceObjectSelect {
    pub header: ForceObjectSelect_Header,
    pub data: Vec<ForceObjectSelect_Data>,
}


#[derive(Debug)]
pub struct ParcelBuyPass_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelBuyPass_ParcelData {
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelBuyPass {
    pub agent_data: ParcelBuyPass_AgentData,
    pub parcel_data: ParcelBuyPass_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDeedToGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDeedToGroup_Data {
    pub group_id: Uuid,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelDeedToGroup {
    pub agent_data: ParcelDeedToGroup_AgentData,
    pub data: ParcelDeedToGroup_Data,
}


#[derive(Debug)]
pub struct ParcelReclaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelReclaim_Data {
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelReclaim {
    pub agent_data: ParcelReclaim_AgentData,
    pub data: ParcelReclaim_Data,
}


#[derive(Debug)]
pub struct ParcelClaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelClaim_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub final_: bool,
}

#[derive(Debug)]
pub struct ParcelClaim_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

#[derive(Debug)]
pub struct ParcelClaim {
    pub agent_data: ParcelClaim_AgentData,
    pub data: ParcelClaim_Data,
    pub parcel_data: Vec<ParcelClaim_ParcelData>,
}


#[derive(Debug)]
pub struct ParcelJoin_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelJoin_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

#[derive(Debug)]
pub struct ParcelJoin {
    pub agent_data: ParcelJoin_AgentData,
    pub parcel_data: ParcelJoin_ParcelData,
}


#[derive(Debug)]
pub struct ParcelDivide_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDivide_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

#[derive(Debug)]
pub struct ParcelDivide {
    pub agent_data: ParcelDivide_AgentData,
    pub parcel_data: ParcelDivide_ParcelData,
}


#[derive(Debug)]
pub struct ParcelRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelRelease_Data {
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelRelease {
    pub agent_data: ParcelRelease_AgentData,
    pub data: ParcelRelease_Data,
}


#[derive(Debug)]
pub struct ParcelBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelBuy_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub remove_contribution: bool,
    pub local_id: i32,
    pub final_: bool,
}

#[derive(Debug)]
pub struct ParcelBuy_ParcelData {
    pub price: i32,
    pub area: i32,
}

#[derive(Debug)]
pub struct ParcelBuy {
    pub agent_data: ParcelBuy_AgentData,
    pub data: ParcelBuy_Data,
    pub parcel_data: ParcelBuy_ParcelData,
}


#[derive(Debug)]
pub struct ParcelGodForceOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelGodForceOwner_Data {
    pub owner_id: Uuid,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelGodForceOwner {
    pub agent_data: ParcelGodForceOwner_AgentData,
    pub data: ParcelGodForceOwner_Data,
}


#[derive(Debug)]
pub struct ParcelAccessListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelAccessListRequest_Data {
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelAccessListRequest {
    pub agent_data: ParcelAccessListRequest_AgentData,
    pub data: ParcelAccessListRequest_Data,
}


#[derive(Debug)]
pub struct ParcelAccessListReply_Data {
    pub agent_id: Uuid,
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelAccessListReply_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ParcelAccessListReply {
    pub data: ParcelAccessListReply_Data,
    pub list: Vec<ParcelAccessListReply_List>,
}


#[derive(Debug)]
pub struct ParcelAccessListUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelAccessListUpdate_Data {
    pub flags: u32,
    pub local_id: i32,
    pub transaction_id: Uuid,
    pub sequence_id: i32,
    pub sections: i32,
}

#[derive(Debug)]
pub struct ParcelAccessListUpdate_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ParcelAccessListUpdate {
    pub agent_data: ParcelAccessListUpdate_AgentData,
    pub data: ParcelAccessListUpdate_Data,
    pub list: Vec<ParcelAccessListUpdate_List>,
}


#[derive(Debug)]
pub struct ParcelDwellRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDwellRequest_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDwellRequest {
    pub agent_data: ParcelDwellRequest_AgentData,
    pub data: ParcelDwellRequest_Data,
}


#[derive(Debug)]
pub struct ParcelDwellReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelDwellReply_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
    pub dwell: f32,
}

#[derive(Debug)]
pub struct ParcelDwellReply {
    pub agent_data: ParcelDwellReply_AgentData,
    pub data: ParcelDwellReply_Data,
}


#[derive(Debug)]
pub struct RequestParcelTransfer_Data {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub owner_id: Uuid,
    pub flags: u8,
    pub transaction_type: i32,
    pub amount: i32,
    pub billable_area: i32,
    pub actual_area: i32,
    pub final_: bool,
}

#[derive(Debug)]
pub struct RequestParcelTransfer_RegionData {
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
}

#[derive(Debug)]
pub struct RequestParcelTransfer {
    pub data: RequestParcelTransfer_Data,
    pub region_data: RequestParcelTransfer_RegionData,
}


#[derive(Debug)]
pub struct UpdateParcel_ParcelData {
    pub parcel_id: Uuid,
    pub region_handle: u64,
    pub owner_id: Uuid,
    pub group_owned: bool,
    pub status: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub music_url: Vec<u8>,
    pub region_x: f32,
    pub region_y: f32,
    pub actual_area: i32,
    pub billable_area: i32,
    pub show_dir: bool,
    pub is_for_sale: bool,
    pub category: u8,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub sale_price: i32,
    pub authorized_buyer_id: Uuid,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

#[derive(Debug)]
pub struct UpdateParcel {
    pub parcel_data: UpdateParcel_ParcelData,
}


#[derive(Debug)]
pub struct RemoveParcel_ParcelData {
    pub parcel_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveParcel {
    pub parcel_data: Vec<RemoveParcel_ParcelData>,
}


#[derive(Debug)]
pub struct MergeParcel_MasterParcelData {
    pub master_id: Uuid,
}

#[derive(Debug)]
pub struct MergeParcel_SlaveParcelData {
    pub slave_id: Uuid,
}

#[derive(Debug)]
pub struct MergeParcel {
    pub master_parcel_data: MergeParcel_MasterParcelData,
    pub slave_parcel_data: Vec<MergeParcel_SlaveParcelData>,
}


#[derive(Debug)]
pub struct LogParcelChanges_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct LogParcelChanges_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct LogParcelChanges_ParcelData {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub is_owner_group: bool,
    pub actual_area: i32,
    pub action: i8,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct LogParcelChanges {
    pub agent_data: LogParcelChanges_AgentData,
    pub region_data: LogParcelChanges_RegionData,
    pub parcel_data: Vec<LogParcelChanges_ParcelData>,
}


#[derive(Debug)]
pub struct CheckParcelSales_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct CheckParcelSales {
    pub region_data: Vec<CheckParcelSales_RegionData>,
}


#[derive(Debug)]
pub struct ParcelSales_ParcelData {
    pub parcel_id: Uuid,
    pub buyer_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelSales {
    pub parcel_data: Vec<ParcelSales_ParcelData>,
}


#[derive(Debug)]
pub struct ParcelGodMarkAsContent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelGodMarkAsContent_ParcelData {
    pub local_id: i32,
}

#[derive(Debug)]
pub struct ParcelGodMarkAsContent {
    pub agent_data: ParcelGodMarkAsContent_AgentData,
    pub parcel_data: ParcelGodMarkAsContent_ParcelData,
}


#[derive(Debug)]
pub struct ViewerStartAuction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ViewerStartAuction_ParcelData {
    pub local_id: i32,
    pub snapshot_id: Uuid,
}

#[derive(Debug)]
pub struct ViewerStartAuction {
    pub agent_data: ViewerStartAuction_AgentData,
    pub parcel_data: ViewerStartAuction_ParcelData,
}


#[derive(Debug)]
pub struct StartAuction_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct StartAuction_ParcelData {
    pub parcel_id: Uuid,
    pub snapshot_id: Uuid,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct StartAuction {
    pub agent_data: StartAuction_AgentData,
    pub parcel_data: StartAuction_ParcelData,
}


#[derive(Debug)]
pub struct ConfirmAuctionStart_AuctionData {
    pub parcel_id: Uuid,
    pub auction_id: u32,
}

#[derive(Debug)]
pub struct ConfirmAuctionStart {
    pub auction_data: ConfirmAuctionStart_AuctionData,
}


#[derive(Debug)]
pub struct CompleteAuction_ParcelData {
    pub parcel_id: Uuid,
}

#[derive(Debug)]
pub struct CompleteAuction {
    pub parcel_data: Vec<CompleteAuction_ParcelData>,
}


#[derive(Debug)]
pub struct CancelAuction_ParcelData {
    pub parcel_id: Uuid,
}

#[derive(Debug)]
pub struct CancelAuction {
    pub parcel_data: Vec<CancelAuction_ParcelData>,
}


#[derive(Debug)]
pub struct CheckParcelAuctions_RegionData {
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct CheckParcelAuctions {
    pub region_data: Vec<CheckParcelAuctions_RegionData>,
}


#[derive(Debug)]
pub struct ParcelAuctions_ParcelData {
    pub parcel_id: Uuid,
    pub winner_id: Uuid,
}

#[derive(Debug)]
pub struct ParcelAuctions {
    pub parcel_data: Vec<ParcelAuctions_ParcelData>,
}


#[derive(Debug)]
pub struct UUIDNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct UUIDNameRequest {
    pub uuid_name_block: Vec<UUIDNameRequest_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

#[derive(Debug)]
pub struct UUIDNameReply {
    pub uuid_name_block: Vec<UUIDNameReply_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDGroupNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct UUIDGroupNameRequest {
    pub uuid_name_block: Vec<UUIDGroupNameRequest_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct UUIDGroupNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub group_name: Vec<u8>,
}

#[derive(Debug)]
pub struct UUIDGroupNameReply {
    pub uuid_name_block: Vec<UUIDGroupNameReply_UUIDNameBlock>,
}


#[derive(Debug)]
pub struct ChatPass_ChatData {
    pub channel: i32,
    pub position: Vector3<f32>,
    pub id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub source_type: u8,
    pub type_: u8,
    pub radius: f32,
    pub sim_access: u8,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct ChatPass {
    pub chat_data: ChatPass_ChatData,
}


#[derive(Debug)]
pub struct EdgeDataPacket_EdgeData {
    pub layer_type: u8,
    pub direction: u8,
    pub layer_data: Vec<u8>,
}

#[derive(Debug)]
pub struct EdgeDataPacket {
    pub edge_data: EdgeDataPacket_EdgeData,
}


#[derive(Debug)]
pub struct SimStatus_SimStatus {
    pub can_accept_agents: bool,
    pub can_accept_tasks: bool,
}

#[derive(Debug)]
pub struct SimStatus {
    pub sim_status: SimStatus_SimStatus,
}


#[derive(Debug)]
pub struct ChildAgentUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
    pub far: f32,
    pub aspect: f32,
    pub throttles: Vec<u8>,
    pub locomotion_state: u32,
    pub head_rotation: Quaternion<f32>,
    pub body_rotation: Quaternion<f32>,
    pub control_flags: u32,
    pub energy_level: f32,
    pub god_level: u8,
    pub always_run: bool,
    pub prey_agent: Uuid,
    pub agent_access: u8,
    pub agent_textures: Vec<u8>,
    pub active_group_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AnimationData {
    pub animation: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_GranterBlock {
    pub granter_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_NVPairData {
    pub nv_pairs: Vec<u8>,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_VisualParam {
    pub param_value: u8,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AgentAccess {
    pub agent_legacy_access: u8,
    pub agent_max_access: u8,
}

#[derive(Debug)]
pub struct ChildAgentUpdate_AgentInfo {
    pub flags: u32,
}

#[derive(Debug)]
pub struct ChildAgentUpdate {
    pub agent_data: ChildAgentUpdate_AgentData,
    pub group_data: Vec<ChildAgentUpdate_GroupData>,
    pub animation_data: Vec<ChildAgentUpdate_AnimationData>,
    pub granter_block: Vec<ChildAgentUpdate_GranterBlock>,
    pub nv_pair_data: Vec<ChildAgentUpdate_NVPairData>,
    pub visual_param: Vec<ChildAgentUpdate_VisualParam>,
    pub agent_access: Vec<ChildAgentUpdate_AgentAccess>,
    pub agent_info: Vec<ChildAgentUpdate_AgentInfo>,
}


#[derive(Debug)]
pub struct ChildAgentAlive_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentAlive {
    pub agent_data: ChildAgentAlive_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentPositionUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
}

#[derive(Debug)]
pub struct ChildAgentPositionUpdate {
    pub agent_data: ChildAgentPositionUpdate_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentDying_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentDying {
    pub agent_data: ChildAgentDying_AgentData,
}


#[derive(Debug)]
pub struct ChildAgentUnknown_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChildAgentUnknown {
    pub agent_data: ChildAgentUnknown_AgentData,
}


#[derive(Debug)]
pub struct AtomicPassObject_TaskData {
    pub task_id: Uuid,
    pub attachment_needs_save: bool,
}

#[derive(Debug)]
pub struct AtomicPassObject {
    pub task_data: AtomicPassObject_TaskData,
}


#[derive(Debug)]
pub struct KillChildAgents_IDBlock {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct KillChildAgents {
    pub id_block: KillChildAgents_IDBlock,
}


#[derive(Debug)]
pub struct GetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct GetScriptRunning {
    pub script: GetScriptRunning_Script,
}


#[derive(Debug)]
pub struct ScriptRunningReply_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

#[derive(Debug)]
pub struct ScriptRunningReply {
    pub script: ScriptRunningReply_Script,
}


#[derive(Debug)]
pub struct SetScriptRunning_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

#[derive(Debug)]
pub struct SetScriptRunning {
    pub agent_data: SetScriptRunning_AgentData,
    pub script: SetScriptRunning_Script,
}


#[derive(Debug)]
pub struct ScriptReset_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptReset_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptReset {
    pub agent_data: ScriptReset_AgentData,
    pub script: ScriptReset_Script,
}


#[derive(Debug)]
pub struct ScriptSensorRequest_Requester {
    pub source_id: Uuid,
    pub request_id: Uuid,
    pub search_id: Uuid,
    pub search_pos: Vector3<f32>,
    pub search_dir: Quaternion<f32>,
    pub search_name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
    pub arc: f32,
    pub region_handle: u64,
    pub search_regions: u8,
}

#[derive(Debug)]
pub struct ScriptSensorRequest {
    pub requester: ScriptSensorRequest_Requester,
}


#[derive(Debug)]
pub struct ScriptSensorReply_Requester {
    pub source_id: Uuid,
}

#[derive(Debug)]
pub struct ScriptSensorReply_SensedData {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub position: Vector3<f32>,
    pub velocity: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
}

#[derive(Debug)]
pub struct ScriptSensorReply {
    pub requester: ScriptSensorReply_Requester,
    pub sensed_data: Vec<ScriptSensorReply_SensedData>,
}


#[derive(Debug)]
pub struct CompleteAgentMovement_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

#[derive(Debug)]
pub struct CompleteAgentMovement {
    pub agent_data: CompleteAgentMovement_AgentData,
}


#[derive(Debug)]
pub struct AgentMovementComplete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentMovementComplete_Data {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub region_handle: u64,
    pub timestamp: u32,
}

#[derive(Debug)]
pub struct AgentMovementComplete_SimData {
    pub channel_version: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentMovementComplete {
    pub agent_data: AgentMovementComplete_AgentData,
    pub data: AgentMovementComplete_Data,
    pub sim_data: AgentMovementComplete_SimData,
}


#[derive(Debug)]
pub struct DataServerLogout_UserData {
    pub agent_id: Uuid,
    pub viewer_ip: Ip4Addr,
    pub disconnect: bool,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DataServerLogout {
    pub user_data: DataServerLogout_UserData,
}


#[derive(Debug)]
pub struct LogoutRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LogoutRequest {
    pub agent_data: LogoutRequest_AgentData,
}


#[derive(Debug)]
pub struct LogoutReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LogoutReply_InventoryData {
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct LogoutReply {
    pub agent_data: LogoutReply_AgentData,
    pub inventory_data: Vec<LogoutReply_InventoryData>,
}


#[derive(Debug)]
pub struct ImprovedInstantMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ImprovedInstantMessage_MessageBlock {
    pub from_group: bool,
    pub to_agent_id: Uuid,
    pub parent_estate_id: u32,
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub offline: u8,
    pub dialog: u8,
    pub id: Uuid,
    pub timestamp: u32,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

#[derive(Debug)]
pub struct ImprovedInstantMessage {
    pub agent_data: ImprovedInstantMessage_AgentData,
    pub message_block: ImprovedInstantMessage_MessageBlock,
}


#[derive(Debug)]
pub struct RetrieveInstantMessages_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RetrieveInstantMessages {
    pub agent_data: RetrieveInstantMessages_AgentData,
}


#[derive(Debug)]
pub struct FindAgent_AgentBlock {
    pub hunter: Uuid,
    pub prey: Uuid,
    pub space_ip: Ip4Addr,
}

#[derive(Debug)]
pub struct FindAgent_LocationBlock {
    pub global_x: f64,
    pub global_y: f64,
}

#[derive(Debug)]
pub struct FindAgent {
    pub agent_block: FindAgent_AgentBlock,
    pub location_block: Vec<FindAgent_LocationBlock>,
}


#[derive(Debug)]
pub struct RequestGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestGodlikePowers_RequestBlock {
    pub godlike: bool,
    pub token: Uuid,
}

#[derive(Debug)]
pub struct RequestGodlikePowers {
    pub agent_data: RequestGodlikePowers_AgentData,
    pub request_block: RequestGodlikePowers_RequestBlock,
}


#[derive(Debug)]
pub struct GrantGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GrantGodlikePowers_GrantData {
    pub god_level: u8,
    pub token: Uuid,
}

#[derive(Debug)]
pub struct GrantGodlikePowers {
    pub agent_data: GrantGodlikePowers_AgentData,
    pub grant_data: GrantGodlikePowers_GrantData,
}


#[derive(Debug)]
pub struct GodlikeMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GodlikeMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct GodlikeMessage_ParamList {
    pub parameter: Vec<u8>,
}

#[derive(Debug)]
pub struct GodlikeMessage {
    pub agent_data: GodlikeMessage_AgentData,
    pub method_data: GodlikeMessage_MethodData,
    pub param_list: Vec<GodlikeMessage_ParamList>,
}


#[derive(Debug)]
pub struct EstateOwnerMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct EstateOwnerMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct EstateOwnerMessage_ParamList {
    pub parameter: Vec<u8>,
}

#[derive(Debug)]
pub struct EstateOwnerMessage {
    pub agent_data: EstateOwnerMessage_AgentData,
    pub method_data: EstateOwnerMessage_MethodData,
    pub param_list: Vec<EstateOwnerMessage_ParamList>,
}


#[derive(Debug)]
pub struct GenericMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GenericMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

#[derive(Debug)]
pub struct GenericMessage_ParamList {
    pub parameter: Vec<u8>,
}

#[derive(Debug)]
pub struct GenericMessage {
    pub agent_data: GenericMessage_AgentData,
    pub method_data: GenericMessage_MethodData,
    pub param_list: Vec<GenericMessage_ParamList>,
}


#[derive(Debug)]
pub struct MuteListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MuteListRequest_MuteData {
    pub mute_crc: u32,
}

#[derive(Debug)]
pub struct MuteListRequest {
    pub agent_data: MuteListRequest_AgentData,
    pub mute_data: MuteListRequest_MuteData,
}


#[derive(Debug)]
pub struct UpdateMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
    pub mute_type: i32,
    pub mute_flags: u32,
}

#[derive(Debug)]
pub struct UpdateMuteListEntry {
    pub agent_data: UpdateMuteListEntry_AgentData,
    pub mute_data: UpdateMuteListEntry_MuteData,
}


#[derive(Debug)]
pub struct RemoveMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
}

#[derive(Debug)]
pub struct RemoveMuteListEntry {
    pub agent_data: RemoveMuteListEntry_AgentData,
    pub mute_data: RemoveMuteListEntry_MuteData,
}


#[derive(Debug)]
pub struct CopyInventoryFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryFromNotecard_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryFromNotecard {
    pub agent_data: CopyInventoryFromNotecard_AgentData,
    pub notecard_data: CopyInventoryFromNotecard_NotecardData,
    pub inventory_data: Vec<CopyInventoryFromNotecard_InventoryData>,
}


#[derive(Debug)]
pub struct UpdateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct UpdateInventoryItem {
    pub agent_data: UpdateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct UpdateCreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub sim_approved: bool,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateCreateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct UpdateCreateInventoryItem {
    pub agent_data: UpdateCreateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateCreateInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct MoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

#[derive(Debug)]
pub struct MoveInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub new_name: Vec<u8>,
}

#[derive(Debug)]
pub struct MoveInventoryItem {
    pub agent_data: MoveInventoryItem_AgentData,
    pub inventory_data: Vec<MoveInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct CopyInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CopyInventoryItem_InventoryData {
    pub callback_id: u32,
    pub old_agent_id: Uuid,
    pub old_item_id: Uuid,
    pub new_folder_id: Uuid,
    pub new_name: Vec<u8>,
}

#[derive(Debug)]
pub struct CopyInventoryItem {
    pub agent_data: CopyInventoryItem_AgentData,
    pub inventory_data: Vec<CopyInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct RemoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryItem_InventoryData {
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryItem {
    pub agent_data: RemoveInventoryItem_AgentData,
    pub inventory_data: Vec<RemoveInventoryItem_InventoryData>,
}


#[derive(Debug)]
pub struct ChangeInventoryItemFlags_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ChangeInventoryItemFlags_InventoryData {
    pub item_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ChangeInventoryItemFlags {
    pub agent_data: ChangeInventoryItemFlags_AgentData,
    pub inventory_data: Vec<ChangeInventoryItemFlags_InventoryData>,
}


#[derive(Debug)]
pub struct SaveAssetIntoInventory_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct SaveAssetIntoInventory_InventoryData {
    pub item_id: Uuid,
    pub new_asset_id: Uuid,
}

#[derive(Debug)]
pub struct SaveAssetIntoInventory {
    pub agent_data: SaveAssetIntoInventory_AgentData,
    pub inventory_data: SaveAssetIntoInventory_InventoryData,
}


#[derive(Debug)]
pub struct CreateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct CreateInventoryFolder {
    pub agent_data: CreateInventoryFolder_AgentData,
    pub folder_data: CreateInventoryFolder_FolderData,
}


#[derive(Debug)]
pub struct UpdateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct UpdateInventoryFolder {
    pub agent_data: UpdateInventoryFolder_AgentData,
    pub folder_data: Vec<UpdateInventoryFolder_FolderData>,
}


#[derive(Debug)]
pub struct MoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

#[derive(Debug)]
pub struct MoveInventoryFolder_InventoryData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
}

#[derive(Debug)]
pub struct MoveInventoryFolder {
    pub agent_data: MoveInventoryFolder_AgentData,
    pub inventory_data: Vec<MoveInventoryFolder_InventoryData>,
}


#[derive(Debug)]
pub struct RemoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryFolder_FolderData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryFolder {
    pub agent_data: RemoveInventoryFolder_AgentData,
    pub folder_data: Vec<RemoveInventoryFolder_FolderData>,
}


#[derive(Debug)]
pub struct FetchInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub sort_order: i32,
    pub fetch_folders: bool,
    pub fetch_items: bool,
}

#[derive(Debug)]
pub struct FetchInventoryDescendents {
    pub agent_data: FetchInventoryDescendents_AgentData,
    pub inventory_data: FetchInventoryDescendents_InventoryData,
}


#[derive(Debug)]
pub struct InventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub version: i32,
    pub descendents: i32,
}

#[derive(Debug)]
pub struct InventoryDescendents_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct InventoryDescendents_ItemData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct InventoryDescendents {
    pub agent_data: InventoryDescendents_AgentData,
    pub folder_data: Vec<InventoryDescendents_FolderData>,
    pub item_data: Vec<InventoryDescendents_ItemData>,
}


#[derive(Debug)]
pub struct FetchInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventory_InventoryData {
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventory {
    pub agent_data: FetchInventory_AgentData,
    pub inventory_data: Vec<FetchInventory_InventoryData>,
}


#[derive(Debug)]
pub struct FetchInventoryReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct FetchInventoryReply_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct FetchInventoryReply {
    pub agent_data: FetchInventoryReply_AgentData,
    pub inventory_data: Vec<FetchInventoryReply_InventoryData>,
}


#[derive(Debug)]
pub struct BulkUpdateInventory_AgentData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct BulkUpdateInventory_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct BulkUpdateInventory_ItemData {
    pub item_id: Uuid,
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct BulkUpdateInventory {
    pub agent_data: BulkUpdateInventory_AgentData,
    pub folder_data: Vec<BulkUpdateInventory_FolderData>,
    pub item_data: Vec<BulkUpdateInventory_ItemData>,
}


#[derive(Debug)]
pub struct RequestInventoryAsset_QueryData {
    pub query_id: Uuid,
    pub agent_id: Uuid,
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RequestInventoryAsset {
    pub query_data: RequestInventoryAsset_QueryData,
}


#[derive(Debug)]
pub struct InventoryAssetResponse_QueryData {
    pub query_id: Uuid,
    pub asset_id: Uuid,
    pub is_readable: bool,
}

#[derive(Debug)]
pub struct InventoryAssetResponse {
    pub query_data: InventoryAssetResponse_QueryData,
}


#[derive(Debug)]
pub struct RemoveInventoryObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryObjects_FolderData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryObjects_ItemData {
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveInventoryObjects {
    pub agent_data: RemoveInventoryObjects_AgentData,
    pub folder_data: Vec<RemoveInventoryObjects_FolderData>,
    pub item_data: Vec<RemoveInventoryObjects_ItemData>,
}


#[derive(Debug)]
pub struct PurgeInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct PurgeInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct PurgeInventoryDescendents {
    pub agent_data: PurgeInventoryDescendents_AgentData,
    pub inventory_data: PurgeInventoryDescendents_InventoryData,
}


#[derive(Debug)]
pub struct UpdateTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateTaskInventory_UpdateData {
    pub local_id: u32,
    pub key: u8,
}

#[derive(Debug)]
pub struct UpdateTaskInventory_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct UpdateTaskInventory {
    pub agent_data: UpdateTaskInventory_AgentData,
    pub update_data: UpdateTaskInventory_UpdateData,
    pub inventory_data: UpdateTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct RemoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveTaskInventory {
    pub agent_data: RemoveTaskInventory_AgentData,
    pub inventory_data: RemoveTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct MoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct MoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct MoveTaskInventory {
    pub agent_data: MoveTaskInventory_AgentData,
    pub inventory_data: MoveTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct RequestTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RequestTaskInventory_InventoryData {
    pub local_id: u32,
}

#[derive(Debug)]
pub struct RequestTaskInventory {
    pub agent_data: RequestTaskInventory_AgentData,
    pub inventory_data: RequestTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct ReplyTaskInventory_InventoryData {
    pub task_id: Uuid,
    pub serial: i16,
    pub filename: Vec<u8>,
}

#[derive(Debug)]
pub struct ReplyTaskInventory {
    pub inventory_data: ReplyTaskInventory_InventoryData,
}


#[derive(Debug)]
pub struct DeRezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeRezObject_AgentBlock {
    pub group_id: Uuid,
    pub destination: u8,
    pub destination_id: Uuid,
    pub transaction_id: Uuid,
    pub packet_count: u8,
    pub packet_number: u8,
}

#[derive(Debug)]
pub struct DeRezObject_ObjectData {
    pub object_local_id: u32,
}

#[derive(Debug)]
pub struct DeRezObject {
    pub agent_data: DeRezObject_AgentData,
    pub agent_block: DeRezObject_AgentBlock,
    pub object_data: Vec<DeRezObject_ObjectData>,
}


#[derive(Debug)]
pub struct DeRezAck_TransactionData {
    pub transaction_id: Uuid,
    pub success: bool,
}

#[derive(Debug)]
pub struct DeRezAck {
    pub transaction_data: DeRezAck_TransactionData,
}


#[derive(Debug)]
pub struct RezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezObject_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

#[derive(Debug)]
pub struct RezObject_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct RezObject {
    pub agent_data: RezObject_AgentData,
    pub rez_data: RezObject_RezData,
    pub inventory_data: RezObject_InventoryData,
}


#[derive(Debug)]
pub struct RezObjectFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard_InventoryData {
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RezObjectFromNotecard {
    pub agent_data: RezObjectFromNotecard_AgentData,
    pub rez_data: RezObjectFromNotecard_RezData,
    pub notecard_data: RezObjectFromNotecard_NotecardData,
    pub inventory_data: Vec<RezObjectFromNotecard_InventoryData>,
}


#[derive(Debug)]
pub struct TransferInventory_InfoBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct TransferInventory_InventoryBlock {
    pub inventory_id: Uuid,
    pub type_: i8,
}

#[derive(Debug)]
pub struct TransferInventory {
    pub info_block: TransferInventory_InfoBlock,
    pub inventory_block: Vec<TransferInventory_InventoryBlock>,
}


#[derive(Debug)]
pub struct TransferInventoryAck_InfoBlock {
    pub transaction_id: Uuid,
    pub inventory_id: Uuid,
}

#[derive(Debug)]
pub struct TransferInventoryAck {
    pub info_block: TransferInventoryAck_InfoBlock,
}


#[derive(Debug)]
pub struct AcceptFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptFriendship_FolderData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptFriendship {
    pub agent_data: AcceptFriendship_AgentData,
    pub transaction_block: AcceptFriendship_TransactionBlock,
    pub folder_data: Vec<AcceptFriendship_FolderData>,
}


#[derive(Debug)]
pub struct DeclineFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineFriendship {
    pub agent_data: DeclineFriendship_AgentData,
    pub transaction_block: DeclineFriendship_TransactionBlock,
}


#[derive(Debug)]
pub struct FormFriendship_AgentBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
}

#[derive(Debug)]
pub struct FormFriendship {
    pub agent_block: FormFriendship_AgentBlock,
}


#[derive(Debug)]
pub struct TerminateFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct TerminateFriendship_ExBlock {
    pub other_id: Uuid,
}

#[derive(Debug)]
pub struct TerminateFriendship {
    pub agent_data: TerminateFriendship_AgentData,
    pub ex_block: TerminateFriendship_ExBlock,
}


#[derive(Debug)]
pub struct OfferCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct OfferCallingCard_AgentBlock {
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct OfferCallingCard {
    pub agent_data: OfferCallingCard_AgentData,
    pub agent_block: OfferCallingCard_AgentBlock,
}


#[derive(Debug)]
pub struct AcceptCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptCallingCard_FolderData {
    pub folder_id: Uuid,
}

#[derive(Debug)]
pub struct AcceptCallingCard {
    pub agent_data: AcceptCallingCard_AgentData,
    pub transaction_block: AcceptCallingCard_TransactionBlock,
    pub folder_data: Vec<AcceptCallingCard_FolderData>,
}


#[derive(Debug)]
pub struct DeclineCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct DeclineCallingCard {
    pub agent_data: DeclineCallingCard_AgentData,
    pub transaction_block: DeclineCallingCard_TransactionBlock,
}


#[derive(Debug)]
pub struct RezScript_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct RezScript_UpdateBlock {
    pub object_local_id: u32,
    pub enabled: bool,
}

#[derive(Debug)]
pub struct RezScript_InventoryBlock {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct RezScript {
    pub agent_data: RezScript_AgentData,
    pub update_block: RezScript_UpdateBlock,
    pub inventory_block: RezScript_InventoryBlock,
}


#[derive(Debug)]
pub struct CreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub next_owner_mask: u32,
    pub type_: i8,
    pub inv_type: i8,
    pub wearable_type: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct CreateInventoryItem {
    pub agent_data: CreateInventoryItem_AgentData,
    pub inventory_block: CreateInventoryItem_InventoryBlock,
}


#[derive(Debug)]
pub struct CreateLandmarkForEvent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateLandmarkForEvent_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct CreateLandmarkForEvent_InventoryBlock {
    pub folder_id: Uuid,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct CreateLandmarkForEvent {
    pub agent_data: CreateLandmarkForEvent_AgentData,
    pub event_data: CreateLandmarkForEvent_EventData,
    pub inventory_block: CreateLandmarkForEvent_InventoryBlock,
}


#[derive(Debug)]
pub struct EventLocationRequest_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct EventLocationRequest_EventData {
    pub event_id: u32,
}

#[derive(Debug)]
pub struct EventLocationRequest {
    pub query_data: EventLocationRequest_QueryData,
    pub event_data: EventLocationRequest_EventData,
}


#[derive(Debug)]
pub struct EventLocationReply_QueryData {
    pub query_id: Uuid,
}

#[derive(Debug)]
pub struct EventLocationReply_EventData {
    pub success: bool,
    pub region_id: Uuid,
    pub region_pos: Vector3<f32>,
}

#[derive(Debug)]
pub struct EventLocationReply {
    pub query_data: EventLocationReply_QueryData,
    pub event_data: EventLocationReply_EventData,
}


#[derive(Debug)]
pub struct RegionHandleRequest_RequestBlock {
    pub region_id: Uuid,
}

#[derive(Debug)]
pub struct RegionHandleRequest {
    pub request_block: RegionHandleRequest_RequestBlock,
}


#[derive(Debug)]
pub struct RegionIDAndHandleReply_ReplyBlock {
    pub region_id: Uuid,
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct RegionIDAndHandleReply {
    pub reply_block: RegionIDAndHandleReply_ReplyBlock,
}


#[derive(Debug)]
pub struct MoneyTransferRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MoneyTransferRequest_MoneyData {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct MoneyTransferRequest {
    pub agent_data: MoneyTransferRequest_AgentData,
    pub money_data: MoneyTransferRequest_MoneyData,
}


#[derive(Debug)]
pub struct MoneyTransferBackend_MoneyData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct MoneyTransferBackend {
    pub money_data: MoneyTransferBackend_MoneyData,
}


#[derive(Debug)]
pub struct MoneyBalanceRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct MoneyBalanceRequest_MoneyData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct MoneyBalanceRequest {
    pub agent_data: MoneyBalanceRequest_AgentData,
    pub money_data: MoneyBalanceRequest_MoneyData,
}


#[derive(Debug)]
pub struct MoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct MoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

#[derive(Debug)]
pub struct MoneyBalanceReply {
    pub money_data: MoneyBalanceReply_MoneyData,
    pub transaction_info: MoneyBalanceReply_TransactionInfo,
}


#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: IpPort,
}

#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct RoutedMoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

#[derive(Debug)]
pub struct RoutedMoneyBalanceReply {
    pub target_block: RoutedMoneyBalanceReply_TargetBlock,
    pub money_data: RoutedMoneyBalanceReply_MoneyData,
    pub transaction_info: RoutedMoneyBalanceReply_TransactionInfo,
}


#[derive(Debug)]
pub struct ActivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ActivateGestures_Data {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub gesture_flags: u32,
}

#[derive(Debug)]
pub struct ActivateGestures {
    pub agent_data: ActivateGestures_AgentData,
    pub data: Vec<ActivateGestures_Data>,
}


#[derive(Debug)]
pub struct DeactivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct DeactivateGestures_Data {
    pub item_id: Uuid,
    pub gesture_flags: u32,
}

#[derive(Debug)]
pub struct DeactivateGestures {
    pub agent_data: DeactivateGestures_AgentData,
    pub data: Vec<DeactivateGestures_Data>,
}


#[derive(Debug)]
pub struct MuteListUpdate_MuteData {
    pub agent_id: Uuid,
    pub filename: Vec<u8>,
}

#[derive(Debug)]
pub struct MuteListUpdate {
    pub mute_data: MuteListUpdate_MuteData,
}


#[derive(Debug)]
pub struct UseCachedMuteList_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct UseCachedMuteList {
    pub agent_data: UseCachedMuteList_AgentData,
}


#[derive(Debug)]
pub struct GrantUserRights_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GrantUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

#[derive(Debug)]
pub struct GrantUserRights {
    pub agent_data: GrantUserRights_AgentData,
    pub rights: Vec<GrantUserRights_Rights>,
}


#[derive(Debug)]
pub struct ChangeUserRights_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct ChangeUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

#[derive(Debug)]
pub struct ChangeUserRights {
    pub agent_data: ChangeUserRights_AgentData,
    pub rights: Vec<ChangeUserRights_Rights>,
}


#[derive(Debug)]
pub struct OnlineNotification_AgentBlock {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct OnlineNotification {
    pub agent_block: Vec<OnlineNotification_AgentBlock>,
}


#[derive(Debug)]
pub struct OfflineNotification_AgentBlock {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct OfflineNotification {
    pub agent_block: Vec<OfflineNotification_AgentBlock>,
}


#[derive(Debug)]
pub struct SetStartLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetStartLocationRequest_StartLocationData {
    pub sim_name: Vec<u8>,
    pub location_id: u32,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct SetStartLocationRequest {
    pub agent_data: SetStartLocationRequest_AgentData,
    pub start_location_data: SetStartLocationRequest_StartLocationData,
}


#[derive(Debug)]
pub struct SetStartLocation_StartLocationData {
    pub agent_id: Uuid,
    pub region_id: Uuid,
    pub location_id: u32,
    pub region_handle: u64,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

#[derive(Debug)]
pub struct SetStartLocation {
    pub start_location_data: SetStartLocation_StartLocationData,
}


#[derive(Debug)]
pub struct NetTest_NetBlock {
    pub port: IpPort,
}

#[derive(Debug)]
pub struct NetTest {
    pub net_block: NetTest_NetBlock,
}


#[derive(Debug)]
pub struct SetCPURatio_Data {
    pub ratio: u8,
}

#[derive(Debug)]
pub struct SetCPURatio {
    pub data: SetCPURatio_Data,
}


#[derive(Debug)]
pub struct SimCrashed_Data {
    pub region_x: u32,
    pub region_y: u32,
}

#[derive(Debug)]
pub struct SimCrashed_Users {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct SimCrashed {
    pub data: SimCrashed_Data,
    pub users: Vec<SimCrashed_Users>,
}


#[derive(Debug)]
pub struct NameValuePair_TaskData {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct NameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

#[derive(Debug)]
pub struct NameValuePair {
    pub task_data: NameValuePair_TaskData,
    pub name_value_data: Vec<NameValuePair_NameValueData>,
}


#[derive(Debug)]
pub struct RemoveNameValuePair_TaskData {
    pub id: Uuid,
}

#[derive(Debug)]
pub struct RemoveNameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

#[derive(Debug)]
pub struct RemoveNameValuePair {
    pub task_data: RemoveNameValuePair_TaskData,
    pub name_value_data: Vec<RemoveNameValuePair_NameValueData>,
}


#[derive(Debug)]
pub struct UpdateAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateAttachment_AttachmentBlock {
    pub attachment_point: u8,
}

#[derive(Debug)]
pub struct UpdateAttachment_OperationData {
    pub add_item: bool,
    pub use_existing_asset: bool,
}

#[derive(Debug)]
pub struct UpdateAttachment_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct UpdateAttachment {
    pub agent_data: UpdateAttachment_AgentData,
    pub attachment_block: UpdateAttachment_AttachmentBlock,
    pub operation_data: UpdateAttachment_OperationData,
    pub inventory_data: UpdateAttachment_InventoryData,
}


#[derive(Debug)]
pub struct RemoveAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveAttachment_AttachmentBlock {
    pub attachment_point: u8,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RemoveAttachment {
    pub agent_data: RemoveAttachment_AgentData,
    pub attachment_block: RemoveAttachment_AttachmentBlock,
}


#[derive(Debug)]
pub struct SoundTrigger_SoundData {
    pub sound_id: Uuid,
    pub owner_id: Uuid,
    pub object_id: Uuid,
    pub parent_id: Uuid,
    pub handle: u64,
    pub position: Vector3<f32>,
    pub gain: f32,
}

#[derive(Debug)]
pub struct SoundTrigger {
    pub sound_data: SoundTrigger_SoundData,
}


#[derive(Debug)]
pub struct AttachedSound_DataBlock {
    pub sound_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
}

#[derive(Debug)]
pub struct AttachedSound {
    pub data_block: AttachedSound_DataBlock,
}


#[derive(Debug)]
pub struct AttachedSoundGainChange_DataBlock {
    pub object_id: Uuid,
    pub gain: f32,
}

#[derive(Debug)]
pub struct AttachedSoundGainChange {
    pub data_block: AttachedSoundGainChange_DataBlock,
}


#[derive(Debug)]
pub struct PreloadSound_DataBlock {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub sound_id: Uuid,
}

#[derive(Debug)]
pub struct PreloadSound {
    pub data_block: Vec<PreloadSound_DataBlock>,
}


#[derive(Debug)]
pub struct AssetUploadRequest_AssetBlock {
    pub transaction_id: Uuid,
    pub type_: i8,
    pub tempfile: bool,
    pub store_local: bool,
    pub asset_data: Vec<u8>,
}

#[derive(Debug)]
pub struct AssetUploadRequest {
    pub asset_block: AssetUploadRequest_AssetBlock,
}


#[derive(Debug)]
pub struct AssetUploadComplete_AssetBlock {
    pub uuid: Uuid,
    pub type_: i8,
    pub success: bool,
}

#[derive(Debug)]
pub struct AssetUploadComplete {
    pub asset_block: AssetUploadComplete_AssetBlock,
}


#[derive(Debug)]
pub struct EmailMessageRequest_DataBlock {
    pub object_id: Uuid,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
}

#[derive(Debug)]
pub struct EmailMessageRequest {
    pub data_block: EmailMessageRequest_DataBlock,
}


#[derive(Debug)]
pub struct EmailMessageReply_DataBlock {
    pub object_id: Uuid,
    pub more: u32,
    pub time: u32,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
    pub data: Vec<u8>,
    pub mail_filter: Vec<u8>,
}

#[derive(Debug)]
pub struct EmailMessageReply {
    pub data_block: EmailMessageReply_DataBlock,
}


#[derive(Debug)]
pub struct InternalScriptMail_DataBlock {
    pub from: Vec<u8>,
    pub to: Uuid,
    pub subject: Vec<u8>,
    pub body: Vec<u8>,
}

#[derive(Debug)]
pub struct InternalScriptMail {
    pub data_block: InternalScriptMail_DataBlock,
}


#[derive(Debug)]
pub struct ScriptDataRequest_DataBlock {
    pub hash: u64,
    pub request_type: i8,
    pub request: Vec<u8>,
}

#[derive(Debug)]
pub struct ScriptDataRequest {
    pub data_block: Vec<ScriptDataRequest_DataBlock>,
}


#[derive(Debug)]
pub struct ScriptDataReply_DataBlock {
    pub hash: u64,
    pub reply: Vec<u8>,
}

#[derive(Debug)]
pub struct ScriptDataReply {
    pub data_block: Vec<ScriptDataReply_DataBlock>,
}


#[derive(Debug)]
pub struct CreateGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateGroupRequest_GroupData {
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

#[derive(Debug)]
pub struct CreateGroupRequest {
    pub agent_data: CreateGroupRequest_AgentData,
    pub group_data: CreateGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct CreateGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct CreateGroupReply_ReplyData {
    pub group_id: Uuid,
    pub success: bool,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct CreateGroupReply {
    pub agent_data: CreateGroupReply_AgentData,
    pub reply_data: CreateGroupReply_ReplyData,
}


#[derive(Debug)]
pub struct UpdateGroupInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateGroupInfo_GroupData {
    pub group_id: Uuid,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

#[derive(Debug)]
pub struct UpdateGroupInfo {
    pub agent_data: UpdateGroupInfo_AgentData,
    pub group_data: UpdateGroupInfo_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleChanges_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleChanges_RoleChange {
    pub role_id: Uuid,
    pub member_id: Uuid,
    pub change: u32,
}

#[derive(Debug)]
pub struct GroupRoleChanges {
    pub agent_data: GroupRoleChanges_AgentData,
    pub role_change: Vec<GroupRoleChanges_RoleChange>,
}


#[derive(Debug)]
pub struct JoinGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct JoinGroupRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct JoinGroupRequest {
    pub agent_data: JoinGroupRequest_AgentData,
    pub group_data: JoinGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct JoinGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct JoinGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

#[derive(Debug)]
pub struct JoinGroupReply {
    pub agent_data: JoinGroupReply_AgentData,
    pub group_data: JoinGroupReply_GroupData,
}


#[derive(Debug)]
pub struct EjectGroupMemberRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberRequest_EjectData {
    pub ejectee_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberRequest {
    pub agent_data: EjectGroupMemberRequest_AgentData,
    pub group_data: EjectGroupMemberRequest_GroupData,
    pub eject_data: Vec<EjectGroupMemberRequest_EjectData>,
}


#[derive(Debug)]
pub struct EjectGroupMemberReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberReply_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct EjectGroupMemberReply_EjectData {
    pub success: bool,
}

#[derive(Debug)]
pub struct EjectGroupMemberReply {
    pub agent_data: EjectGroupMemberReply_AgentData,
    pub group_data: EjectGroupMemberReply_GroupData,
    pub eject_data: EjectGroupMemberReply_EjectData,
}


#[derive(Debug)]
pub struct LeaveGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LeaveGroupRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct LeaveGroupRequest {
    pub agent_data: LeaveGroupRequest_AgentData,
    pub group_data: LeaveGroupRequest_GroupData,
}


#[derive(Debug)]
pub struct LeaveGroupReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct LeaveGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

#[derive(Debug)]
pub struct LeaveGroupReply {
    pub agent_data: LeaveGroupReply_AgentData,
    pub group_data: LeaveGroupReply_GroupData,
}


#[derive(Debug)]
pub struct InviteGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct InviteGroupRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct InviteGroupRequest_InviteData {
    pub invitee_id: Uuid,
    pub role_id: Uuid,
}

#[derive(Debug)]
pub struct InviteGroupRequest {
    pub agent_data: InviteGroupRequest_AgentData,
    pub group_data: InviteGroupRequest_GroupData,
    pub invite_data: Vec<InviteGroupRequest_InviteData>,
}


#[derive(Debug)]
pub struct InviteGroupResponse_InviteData {
    pub agent_id: Uuid,
    pub invitee_id: Uuid,
    pub group_id: Uuid,
    pub role_id: Uuid,
    pub membership_fee: i32,
}

#[derive(Debug)]
pub struct InviteGroupResponse {
    pub invite_data: InviteGroupResponse_InviteData,
}


#[derive(Debug)]
pub struct GroupProfileRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileRequest {
    pub agent_data: GroupProfileRequest_AgentData,
    pub group_data: GroupProfileRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupProfileReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileReply_GroupData {
    pub group_id: Uuid,
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub member_title: Vec<u8>,
    pub powers_mask: u64,
    pub insignia_id: Uuid,
    pub founder_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub money: i32,
    pub group_membership_count: i32,
    pub group_roles_count: i32,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub owner_role: Uuid,
}

#[derive(Debug)]
pub struct GroupProfileReply {
    pub agent_data: GroupProfileReply_AgentData,
    pub group_data: GroupProfileReply_GroupData,
}


#[derive(Debug)]
pub struct GroupAccountSummaryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountSummaryRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

#[derive(Debug)]
pub struct GroupAccountSummaryRequest {
    pub agent_data: GroupAccountSummaryRequest_AgentData,
    pub money_data: GroupAccountSummaryRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountSummaryReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountSummaryReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
    pub balance: i32,
    pub total_credits: i32,
    pub total_debits: i32,
    pub object_tax_current: i32,
    pub light_tax_current: i32,
    pub land_tax_current: i32,
    pub group_tax_current: i32,
    pub parcel_dir_fee_current: i32,
    pub object_tax_estimate: i32,
    pub light_tax_estimate: i32,
    pub land_tax_estimate: i32,
    pub group_tax_estimate: i32,
    pub parcel_dir_fee_estimate: i32,
    pub non_exempt_members: i32,
    pub last_tax_date: Vec<u8>,
    pub tax_date: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupAccountSummaryReply {
    pub agent_data: GroupAccountSummaryReply_AgentData,
    pub money_data: GroupAccountSummaryReply_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountDetailsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountDetailsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

#[derive(Debug)]
pub struct GroupAccountDetailsRequest {
    pub agent_data: GroupAccountDetailsRequest_AgentData,
    pub money_data: GroupAccountDetailsRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountDetailsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountDetailsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupAccountDetailsReply_HistoryData {
    pub description: Vec<u8>,
    pub amount: i32,
}

#[derive(Debug)]
pub struct GroupAccountDetailsReply {
    pub agent_data: GroupAccountDetailsReply_AgentData,
    pub money_data: GroupAccountDetailsReply_MoneyData,
    pub history_data: Vec<GroupAccountDetailsReply_HistoryData>,
}


#[derive(Debug)]
pub struct GroupAccountTransactionsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsRequest {
    pub agent_data: GroupAccountTransactionsRequest_AgentData,
    pub money_data: GroupAccountTransactionsRequest_MoneyData,
}


#[derive(Debug)]
pub struct GroupAccountTransactionsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsReply_HistoryData {
    pub time: Vec<u8>,
    pub user: Vec<u8>,
    pub type_: i32,
    pub item: Vec<u8>,
    pub amount: i32,
}

#[derive(Debug)]
pub struct GroupAccountTransactionsReply {
    pub agent_data: GroupAccountTransactionsReply_AgentData,
    pub money_data: GroupAccountTransactionsReply_MoneyData,
    pub history_data: Vec<GroupAccountTransactionsReply_HistoryData>,
}


#[derive(Debug)]
pub struct GroupActiveProposalsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalsRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalsRequest_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalsRequest {
    pub agent_data: GroupActiveProposalsRequest_AgentData,
    pub group_data: GroupActiveProposalsRequest_GroupData,
    pub transaction_data: GroupActiveProposalsRequest_TransactionData,
}


#[derive(Debug)]
pub struct GroupActiveProposalItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupActiveProposalItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

#[derive(Debug)]
pub struct GroupActiveProposalItemReply_ProposalData {
    pub vote_id: Uuid,
    pub vote_initiator: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub already_voted: bool,
    pub vote_cast: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupActiveProposalItemReply {
    pub agent_data: GroupActiveProposalItemReply_AgentData,
    pub transaction_data: GroupActiveProposalItemReply_TransactionData,
    pub proposal_data: Vec<GroupActiveProposalItemReply_ProposalData>,
}


#[derive(Debug)]
pub struct GroupVoteHistoryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryRequest_GroupData {
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryRequest_TransactionData {
    pub transaction_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryRequest {
    pub agent_data: GroupVoteHistoryRequest_AgentData,
    pub group_data: GroupVoteHistoryRequest_GroupData,
    pub transaction_data: GroupVoteHistoryRequest_TransactionData,
}


#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_HistoryItemData {
    pub vote_id: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub vote_initiator: Uuid,
    pub vote_type: Vec<u8>,
    pub vote_result: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply_VoteItem {
    pub candidate_id: Uuid,
    pub vote_cast: Vec<u8>,
    pub num_votes: i32,
}

#[derive(Debug)]
pub struct GroupVoteHistoryItemReply {
    pub agent_data: GroupVoteHistoryItemReply_AgentData,
    pub transaction_data: GroupVoteHistoryItemReply_TransactionData,
    pub history_item_data: GroupVoteHistoryItemReply_HistoryItemData,
    pub vote_item: Vec<GroupVoteHistoryItemReply_VoteItem>,
}


#[derive(Debug)]
pub struct StartGroupProposal_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct StartGroupProposal_ProposalData {
    pub group_id: Uuid,
    pub quorum: i32,
    pub majority: f32,
    pub duration: i32,
    pub proposal_text: Vec<u8>,
}

#[derive(Debug)]
pub struct StartGroupProposal {
    pub agent_data: StartGroupProposal_AgentData,
    pub proposal_data: StartGroupProposal_ProposalData,
}


#[derive(Debug)]
pub struct GroupProposalBallot_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupProposalBallot_ProposalData {
    pub proposal_id: Uuid,
    pub group_id: Uuid,
    pub vote_cast: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupProposalBallot {
    pub agent_data: GroupProposalBallot_AgentData,
    pub proposal_data: GroupProposalBallot_ProposalData,
}


#[derive(Debug)]
pub struct TallyVotes {
}


#[derive(Debug)]
pub struct GroupMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupMembersRequest {
    pub agent_data: GroupMembersRequest_AgentData,
    pub group_data: GroupMembersRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupMembersReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupMembersReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub member_count: i32,
}

#[derive(Debug)]
pub struct GroupMembersReply_MemberData {
    pub agent_id: Uuid,
    pub contribution: i32,
    pub online_status: Vec<u8>,
    pub agent_powers: u64,
    pub title: Vec<u8>,
    pub is_owner: bool,
}

#[derive(Debug)]
pub struct GroupMembersReply {
    pub agent_data: GroupMembersReply_AgentData,
    pub group_data: GroupMembersReply_GroupData,
    pub member_data: Vec<GroupMembersReply_MemberData>,
}


#[derive(Debug)]
pub struct ActivateGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct ActivateGroup {
    pub agent_data: ActivateGroup_AgentData,
}


#[derive(Debug)]
pub struct SetGroupContribution_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetGroupContribution_Data {
    pub group_id: Uuid,
    pub contribution: i32,
}

#[derive(Debug)]
pub struct SetGroupContribution {
    pub agent_data: SetGroupContribution_AgentData,
    pub data: SetGroupContribution_Data,
}


#[derive(Debug)]
pub struct SetGroupAcceptNotices_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct SetGroupAcceptNotices_Data {
    pub group_id: Uuid,
    pub accept_notices: bool,
}

#[derive(Debug)]
pub struct SetGroupAcceptNotices_NewData {
    pub list_in_profile: bool,
}

#[derive(Debug)]
pub struct SetGroupAcceptNotices {
    pub agent_data: SetGroupAcceptNotices_AgentData,
    pub data: SetGroupAcceptNotices_Data,
    pub new_data: SetGroupAcceptNotices_NewData,
}


#[derive(Debug)]
pub struct GroupRoleDataRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleDataRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleDataRequest {
    pub agent_data: GroupRoleDataRequest_AgentData,
    pub group_data: GroupRoleDataRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleDataReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleDataReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub role_count: i32,
}

#[derive(Debug)]
pub struct GroupRoleDataReply_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub title: Vec<u8>,
    pub description: Vec<u8>,
    pub powers: u64,
    pub members: u32,
}

#[derive(Debug)]
pub struct GroupRoleDataReply {
    pub agent_data: GroupRoleDataReply_AgentData,
    pub group_data: GroupRoleDataReply_GroupData,
    pub role_data: Vec<GroupRoleDataReply_RoleData>,
}


#[derive(Debug)]
pub struct GroupRoleMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleMembersRequest {
    pub agent_data: GroupRoleMembersRequest_AgentData,
    pub group_data: GroupRoleMembersRequest_GroupData,
}


#[derive(Debug)]
pub struct GroupRoleMembersReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub total_pairs: u32,
}

#[derive(Debug)]
pub struct GroupRoleMembersReply_MemberData {
    pub role_id: Uuid,
    pub member_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleMembersReply {
    pub agent_data: GroupRoleMembersReply_AgentData,
    pub member_data: Vec<GroupRoleMembersReply_MemberData>,
}


#[derive(Debug)]
pub struct GroupTitlesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupTitlesRequest {
    pub agent_data: GroupTitlesRequest_AgentData,
}


#[derive(Debug)]
pub struct GroupTitlesReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

#[derive(Debug)]
pub struct GroupTitlesReply_GroupData {
    pub title: Vec<u8>,
    pub role_id: Uuid,
    pub selected: bool,
}

#[derive(Debug)]
pub struct GroupTitlesReply {
    pub agent_data: GroupTitlesReply_AgentData,
    pub group_data: Vec<GroupTitlesReply_GroupData>,
}


#[derive(Debug)]
pub struct GroupTitleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub title_role_id: Uuid,
}

#[derive(Debug)]
pub struct GroupTitleUpdate {
    pub agent_data: GroupTitleUpdate_AgentData,
}


#[derive(Debug)]
pub struct GroupRoleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct GroupRoleUpdate_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub title: Vec<u8>,
    pub powers: u64,
    pub update_type: u8,
}

#[derive(Debug)]
pub struct GroupRoleUpdate {
    pub agent_data: GroupRoleUpdate_AgentData,
    pub role_data: Vec<GroupRoleUpdate_RoleData>,
}


#[derive(Debug)]
pub struct LiveHelpGroupRequest_RequestData {
    pub request_id: Uuid,
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct LiveHelpGroupRequest {
    pub request_data: LiveHelpGroupRequest_RequestData,
}


#[derive(Debug)]
pub struct LiveHelpGroupReply_ReplyData {
    pub request_id: Uuid,
    pub group_id: Uuid,
    pub selection: Vec<u8>,
}

#[derive(Debug)]
pub struct LiveHelpGroupReply {
    pub reply_data: LiveHelpGroupReply_ReplyData,
}


#[derive(Debug)]
pub struct AgentWearablesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentWearablesRequest {
    pub agent_data: AgentWearablesRequest_AgentData,
}


#[derive(Debug)]
pub struct AgentWearablesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

#[derive(Debug)]
pub struct AgentWearablesUpdate_WearableData {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub wearable_type: u8,
}

#[derive(Debug)]
pub struct AgentWearablesUpdate {
    pub agent_data: AgentWearablesUpdate_AgentData,
    pub wearable_data: Vec<AgentWearablesUpdate_WearableData>,
}


#[derive(Debug)]
pub struct AgentIsNowWearing_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentIsNowWearing_WearableData {
    pub item_id: Uuid,
    pub wearable_type: u8,
}

#[derive(Debug)]
pub struct AgentIsNowWearing {
    pub agent_data: AgentIsNowWearing_AgentData,
    pub wearable_data: Vec<AgentIsNowWearing_WearableData>,
}


#[derive(Debug)]
pub struct AgentCachedTexture_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

#[derive(Debug)]
pub struct AgentCachedTexture_WearableData {
    pub id: Uuid,
    pub texture_index: u8,
}

#[derive(Debug)]
pub struct AgentCachedTexture {
    pub agent_data: AgentCachedTexture_AgentData,
    pub wearable_data: Vec<AgentCachedTexture_WearableData>,
}


#[derive(Debug)]
pub struct AgentCachedTextureResponse_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

#[derive(Debug)]
pub struct AgentCachedTextureResponse_WearableData {
    pub texture_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentCachedTextureResponse {
    pub agent_data: AgentCachedTextureResponse_AgentData,
    pub wearable_data: Vec<AgentCachedTextureResponse_WearableData>,
}


#[derive(Debug)]
pub struct AgentDataUpdateRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct AgentDataUpdateRequest {
    pub agent_data: AgentDataUpdateRequest_AgentData,
}


#[derive(Debug)]
pub struct AgentDataUpdate_AgentData {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group_title: Vec<u8>,
    pub active_group_id: Uuid,
    pub group_powers: u64,
    pub group_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentDataUpdate {
    pub agent_data: AgentDataUpdate_AgentData,
}


#[derive(Debug)]
pub struct GroupDataUpdate_AgentGroupData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub agent_powers: u64,
    pub group_title: Vec<u8>,
}

#[derive(Debug)]
pub struct GroupDataUpdate {
    pub agent_group_data: Vec<GroupDataUpdate_AgentGroupData>,
}


#[derive(Debug)]
pub struct AgentGroupDataUpdate_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct AgentGroupDataUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_insignia_id: Uuid,
    pub contribution: i32,
    pub group_name: Vec<u8>,
}

#[derive(Debug)]
pub struct AgentGroupDataUpdate {
    pub agent_data: AgentGroupDataUpdate_AgentData,
    pub group_data: Vec<AgentGroupDataUpdate_GroupData>,
}


#[derive(Debug)]
pub struct AgentDropGroup_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

#[derive(Debug)]
pub struct AgentDropGroup {
    pub agent_data: AgentDropGroup_AgentData,
}


#[derive(Debug)]
pub struct LogTextMessage_DataBlock {
    pub from_agent_id: Uuid,
    pub to_agent_id: Uuid,
    pub global_x: f64,
    pub global_y: f64,
    pub time: u32,
    pub message: Vec<u8>,
}

#[derive(Debug)]
pub struct LogTextMessage {
    pub data_block: Vec<LogTextMessage_DataBlock>,
}


#[derive(Debug)]
pub struct ViewerEffect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ViewerEffect_Effect {
    pub id: Uuid,
    pub agent_id: Uuid,
    pub type_: u8,
    pub duration: f32,
    pub color: [u8; 4],
    pub type_data: Vec<u8>,
}

#[derive(Debug)]
pub struct ViewerEffect {
    pub agent_data: ViewerEffect_AgentData,
    pub effect: Vec<ViewerEffect_Effect>,
}


#[derive(Debug)]
pub struct CreateTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
    pub digest: [u8; 32],
}

#[derive(Debug)]
pub struct CreateTrustedCircuit {
    pub data_block: CreateTrustedCircuit_DataBlock,
}


#[derive(Debug)]
pub struct DenyTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
}

#[derive(Debug)]
pub struct DenyTrustedCircuit {
    pub data_block: DenyTrustedCircuit_DataBlock,
}


#[derive(Debug)]
pub struct RequestTrustedCircuit {
}


#[derive(Debug)]
pub struct RezSingleAttachmentFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezSingleAttachmentFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct RezSingleAttachmentFromInv {
    pub agent_data: RezSingleAttachmentFromInv_AgentData,
    pub object_data: RezSingleAttachmentFromInv_ObjectData,
}


#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_HeaderData {
    pub compound_msg_id: Uuid,
    pub total_objects: u8,
    pub first_detach_all: bool,
}

#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct RezMultipleAttachmentsFromInv {
    pub agent_data: RezMultipleAttachmentsFromInv_AgentData,
    pub header_data: RezMultipleAttachmentsFromInv_HeaderData,
    pub object_data: Vec<RezMultipleAttachmentsFromInv_ObjectData>,
}


#[derive(Debug)]
pub struct DetachAttachmentIntoInv_ObjectData {
    pub agent_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct DetachAttachmentIntoInv {
    pub object_data: DetachAttachmentIntoInv_ObjectData,
}


#[derive(Debug)]
pub struct CreateNewOutfitAttachments_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct CreateNewOutfitAttachments_HeaderData {
    pub new_folder_id: Uuid,
}

#[derive(Debug)]
pub struct CreateNewOutfitAttachments_ObjectData {
    pub old_item_id: Uuid,
    pub old_folder_id: Uuid,
}

#[derive(Debug)]
pub struct CreateNewOutfitAttachments {
    pub agent_data: CreateNewOutfitAttachments_AgentData,
    pub header_data: CreateNewOutfitAttachments_HeaderData,
    pub object_data: Vec<CreateNewOutfitAttachments_ObjectData>,
}


#[derive(Debug)]
pub struct UserInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UserInfoRequest {
    pub agent_data: UserInfoRequest_AgentData,
}


#[derive(Debug)]
pub struct UserInfoReply_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct UserInfoReply_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
    pub e_mail: Vec<u8>,
}

#[derive(Debug)]
pub struct UserInfoReply {
    pub agent_data: UserInfoReply_AgentData,
    pub user_data: UserInfoReply_UserData,
}


#[derive(Debug)]
pub struct UpdateUserInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct UpdateUserInfo_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
}

#[derive(Debug)]
pub struct UpdateUserInfo {
    pub agent_data: UpdateUserInfo_AgentData,
    pub user_data: UpdateUserInfo_UserData,
}


#[derive(Debug)]
pub struct ParcelRename_ParcelData {
    pub parcel_id: Uuid,
    pub new_name: Vec<u8>,
}

#[derive(Debug)]
pub struct ParcelRename {
    pub parcel_data: Vec<ParcelRename_ParcelData>,
}


#[derive(Debug)]
pub struct InitiateDownload_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct InitiateDownload_FileData {
    pub sim_filename: Vec<u8>,
    pub viewer_filename: Vec<u8>,
}

#[derive(Debug)]
pub struct InitiateDownload {
    pub agent_data: InitiateDownload_AgentData,
    pub file_data: InitiateDownload_FileData,
}


#[derive(Debug)]
pub struct SystemMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
    pub digest: [u8; 32],
}

#[derive(Debug)]
pub struct SystemMessage_ParamList {
    pub parameter: Vec<u8>,
}

#[derive(Debug)]
pub struct SystemMessage {
    pub method_data: SystemMessage_MethodData,
    pub param_list: Vec<SystemMessage_ParamList>,
}


#[derive(Debug)]
pub struct MapLayerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapLayerRequest {
    pub agent_data: MapLayerRequest_AgentData,
}


#[derive(Debug)]
pub struct MapLayerReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapLayerReply_LayerData {
    pub left: u32,
    pub right: u32,
    pub top: u32,
    pub bottom: u32,
    pub image_id: Uuid,
}

#[derive(Debug)]
pub struct MapLayerReply {
    pub agent_data: MapLayerReply_AgentData,
    pub layer_data: Vec<MapLayerReply_LayerData>,
}


#[derive(Debug)]
pub struct MapBlockRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapBlockRequest_PositionData {
    pub min_x: u16,
    pub max_x: u16,
    pub min_y: u16,
    pub max_y: u16,
}

#[derive(Debug)]
pub struct MapBlockRequest {
    pub agent_data: MapBlockRequest_AgentData,
    pub position_data: MapBlockRequest_PositionData,
}


#[derive(Debug)]
pub struct MapNameRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapNameRequest_NameData {
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct MapNameRequest {
    pub agent_data: MapNameRequest_AgentData,
    pub name_data: MapNameRequest_NameData,
}


#[derive(Debug)]
pub struct MapBlockReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapBlockReply_Data {
    pub x: u16,
    pub y: u16,
    pub name: Vec<u8>,
    pub access: u8,
    pub region_flags: u32,
    pub water_height: u8,
    pub agents: u8,
    pub map_image_id: Uuid,
}

#[derive(Debug)]
pub struct MapBlockReply {
    pub agent_data: MapBlockReply_AgentData,
    pub data: Vec<MapBlockReply_Data>,
}


#[derive(Debug)]
pub struct MapItemRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

#[derive(Debug)]
pub struct MapItemRequest_RequestData {
    pub item_type: u32,
    pub region_handle: u64,
}

#[derive(Debug)]
pub struct MapItemRequest {
    pub agent_data: MapItemRequest_AgentData,
    pub request_data: MapItemRequest_RequestData,
}


#[derive(Debug)]
pub struct MapItemReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct MapItemReply_RequestData {
    pub item_type: u32,
}

#[derive(Debug)]
pub struct MapItemReply_Data {
    pub x: u32,
    pub y: u32,
    pub id: Uuid,
    pub extra: i32,
    pub extra2: i32,
    pub name: Vec<u8>,
}

#[derive(Debug)]
pub struct MapItemReply {
    pub agent_data: MapItemReply_AgentData,
    pub request_data: MapItemReply_RequestData,
    pub data: Vec<MapItemReply_Data>,
}


#[derive(Debug)]
pub struct SendPostcard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub asset_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub to: Vec<u8>,
    pub from: Vec<u8>,
    pub name: Vec<u8>,
    pub subject: Vec<u8>,
    pub msg: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

#[derive(Debug)]
pub struct SendPostcard {
    pub agent_data: SendPostcard_AgentData,
}


#[derive(Debug)]
pub struct RpcChannelRequest_DataBlock {
    pub grid_x: u32,
    pub grid_y: u32,
    pub task_id: Uuid,
    pub item_id: Uuid,
}

#[derive(Debug)]
pub struct RpcChannelRequest {
    pub data_block: RpcChannelRequest_DataBlock,
}


#[derive(Debug)]
pub struct RpcChannelReply_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
}

#[derive(Debug)]
pub struct RpcChannelReply {
    pub data_block: RpcChannelReply_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptRequestInbound_TargetBlock {
    pub grid_x: u32,
    pub grid_y: u32,
}

#[derive(Debug)]
pub struct RpcScriptRequestInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

#[derive(Debug)]
pub struct RpcScriptRequestInbound {
    pub target_block: RpcScriptRequestInbound_TargetBlock,
    pub data_block: RpcScriptRequestInbound_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptRequestInboundForward_DataBlock {
    pub rpc_server_ip: Ip4Addr,
    pub rpc_server_port: IpPort,
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

#[derive(Debug)]
pub struct RpcScriptRequestInboundForward {
    pub data_block: RpcScriptRequestInboundForward_DataBlock,
}


#[derive(Debug)]
pub struct RpcScriptReplyInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

#[derive(Debug)]
pub struct RpcScriptReplyInbound {
    pub data_block: RpcScriptReplyInbound_DataBlock,
}


#[derive(Debug)]
pub struct ScriptMailRegistration_DataBlock {
    pub target_ip: Vec<u8>,
    pub target_port: IpPort,
    pub task_id: Uuid,
    pub flags: u32,
}

#[derive(Debug)]
pub struct ScriptMailRegistration {
    pub data_block: ScriptMailRegistration_DataBlock,
}


#[derive(Debug)]
pub struct ParcelMediaCommandMessage_CommandBlock {
    pub flags: u32,
    pub command: u32,
    pub time: f32,
}

#[derive(Debug)]
pub struct ParcelMediaCommandMessage {
    pub command_block: ParcelMediaCommandMessage_CommandBlock,
}


#[derive(Debug)]
pub struct ParcelMediaUpdate_DataBlock {
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
}

#[derive(Debug)]
pub struct ParcelMediaUpdate_DataBlockExtended {
    pub media_type: Vec<u8>,
    pub media_desc: Vec<u8>,
    pub media_width: i32,
    pub media_height: i32,
    pub media_loop: u8,
}

#[derive(Debug)]
pub struct ParcelMediaUpdate {
    pub data_block: ParcelMediaUpdate_DataBlock,
    pub data_block_extended: ParcelMediaUpdate_DataBlockExtended,
}


#[derive(Debug)]
pub struct LandStatRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LandStatRequest_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub filter: Vec<u8>,
    pub parcel_local_id: i32,
}

#[derive(Debug)]
pub struct LandStatRequest {
    pub agent_data: LandStatRequest_AgentData,
    pub request_data: LandStatRequest_RequestData,
}


#[derive(Debug)]
pub struct LandStatReply_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub total_object_count: u32,
}

#[derive(Debug)]
pub struct LandStatReply_ReportData {
    pub task_local_id: u32,
    pub task_id: Uuid,
    pub location_x: f32,
    pub location_y: f32,
    pub location_z: f32,
    pub score: f32,
    pub task_name: Vec<u8>,
    pub owner_name: Vec<u8>,
}

#[derive(Debug)]
pub struct LandStatReply {
    pub request_data: LandStatReply_RequestData,
    pub report_data: Vec<LandStatReply_ReportData>,
}


#[derive(Debug)]
pub struct Error_AgentData {
    pub agent_id: Uuid,
}

#[derive(Debug)]
pub struct Error_Data {
    pub code: i32,
    pub token: Vec<u8>,
    pub id: Uuid,
    pub system: Vec<u8>,
    pub message: Vec<u8>,
    pub data: Vec<u8>,
}

#[derive(Debug)]
pub struct Error {
    pub agent_data: Error_AgentData,
    pub data: Error_Data,
}


#[derive(Debug)]
pub struct ObjectIncludeInSearch_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct ObjectIncludeInSearch_ObjectData {
    pub object_local_id: u32,
    pub include_in_search: bool,
}

#[derive(Debug)]
pub struct ObjectIncludeInSearch {
    pub agent_data: ObjectIncludeInSearch_AgentData,
    pub object_data: Vec<ObjectIncludeInSearch_ObjectData>,
}


#[derive(Debug)]
pub struct RezRestoreToWorld_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct RezRestoreToWorld_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

#[derive(Debug)]
pub struct RezRestoreToWorld {
    pub agent_data: RezRestoreToWorld_AgentData,
    pub inventory_data: RezRestoreToWorld_InventoryData,
}


#[derive(Debug)]
pub struct LinkInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

#[derive(Debug)]
pub struct LinkInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub old_item_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

#[derive(Debug)]
pub struct LinkInventoryItem {
    pub agent_data: LinkInventoryItem_AgentData,
    pub inventory_block: LinkInventoryItem_InventoryBlock,
}


pub enum MessageInstance {
    TestMessage(TestMessage),
    PacketAck(PacketAck),
    OpenCircuit(OpenCircuit),
    CloseCircuit(CloseCircuit),
    StartPingCheck(StartPingCheck),
    CompletePingCheck(CompletePingCheck),
    AddCircuitCode(AddCircuitCode),
    UseCircuitCode(UseCircuitCode),
    NeighborList(NeighborList),
    AvatarTextureUpdate(AvatarTextureUpdate),
    SimulatorMapUpdate(SimulatorMapUpdate),
    SimulatorSetMap(SimulatorSetMap),
    SubscribeLoad(SubscribeLoad),
    UnsubscribeLoad(UnsubscribeLoad),
    SimulatorReady(SimulatorReady),
    TelehubInfo(TelehubInfo),
    SimulatorPresentAtLocation(SimulatorPresentAtLocation),
    SimulatorLoad(SimulatorLoad),
    SimulatorShutdownRequest(SimulatorShutdownRequest),
    RegionPresenceRequestByRegionID(RegionPresenceRequestByRegionID),
    RegionPresenceRequestByHandle(RegionPresenceRequestByHandle),
    RegionPresenceResponse(RegionPresenceResponse),
    UpdateSimulator(UpdateSimulator),
    LogDwellTime(LogDwellTime),
    FeatureDisabled(FeatureDisabled),
    LogFailedMoneyTransaction(LogFailedMoneyTransaction),
    UserReportInternal(UserReportInternal),
    SetSimStatusInDatabase(SetSimStatusInDatabase),
    SetSimPresenceInDatabase(SetSimPresenceInDatabase),
    EconomyDataRequest(EconomyDataRequest),
    EconomyData(EconomyData),
    AvatarPickerRequest(AvatarPickerRequest),
    AvatarPickerRequestBackend(AvatarPickerRequestBackend),
    AvatarPickerReply(AvatarPickerReply),
    PlacesQuery(PlacesQuery),
    PlacesReply(PlacesReply),
    DirFindQuery(DirFindQuery),
    DirFindQueryBackend(DirFindQueryBackend),
    DirPlacesQuery(DirPlacesQuery),
    DirPlacesQueryBackend(DirPlacesQueryBackend),
    DirPlacesReply(DirPlacesReply),
    DirPeopleReply(DirPeopleReply),
    DirEventsReply(DirEventsReply),
    DirGroupsReply(DirGroupsReply),
    DirClassifiedQuery(DirClassifiedQuery),
    DirClassifiedQueryBackend(DirClassifiedQueryBackend),
    DirClassifiedReply(DirClassifiedReply),
    AvatarClassifiedReply(AvatarClassifiedReply),
    ClassifiedInfoRequest(ClassifiedInfoRequest),
    ClassifiedInfoReply(ClassifiedInfoReply),
    ClassifiedInfoUpdate(ClassifiedInfoUpdate),
    ClassifiedDelete(ClassifiedDelete),
    ClassifiedGodDelete(ClassifiedGodDelete),
    DirLandQuery(DirLandQuery),
    DirLandQueryBackend(DirLandQueryBackend),
    DirLandReply(DirLandReply),
    DirPopularQuery(DirPopularQuery),
    DirPopularQueryBackend(DirPopularQueryBackend),
    DirPopularReply(DirPopularReply),
    ParcelInfoRequest(ParcelInfoRequest),
    ParcelInfoReply(ParcelInfoReply),
    ParcelObjectOwnersRequest(ParcelObjectOwnersRequest),
    ParcelObjectOwnersReply(ParcelObjectOwnersReply),
    GroupNoticesListRequest(GroupNoticesListRequest),
    GroupNoticesListReply(GroupNoticesListReply),
    GroupNoticeRequest(GroupNoticeRequest),
    GroupNoticeAdd(GroupNoticeAdd),
    TeleportRequest(TeleportRequest),
    TeleportLocationRequest(TeleportLocationRequest),
    TeleportLocal(TeleportLocal),
    TeleportLandmarkRequest(TeleportLandmarkRequest),
    TeleportProgress(TeleportProgress),
    DataHomeLocationRequest(DataHomeLocationRequest),
    DataHomeLocationReply(DataHomeLocationReply),
    TeleportFinish(TeleportFinish),
    StartLure(StartLure),
    TeleportLureRequest(TeleportLureRequest),
    TeleportCancel(TeleportCancel),
    TeleportStart(TeleportStart),
    TeleportFailed(TeleportFailed),
    Undo(Undo),
    Redo(Redo),
    UndoLand(UndoLand),
    AgentPause(AgentPause),
    AgentResume(AgentResume),
    AgentUpdate(AgentUpdate),
    ChatFromViewer(ChatFromViewer),
    AgentThrottle(AgentThrottle),
    AgentFOV(AgentFOV),
    AgentHeightWidth(AgentHeightWidth),
    AgentSetAppearance(AgentSetAppearance),
    AgentAnimation(AgentAnimation),
    AgentRequestSit(AgentRequestSit),
    AgentSit(AgentSit),
    AgentQuitCopy(AgentQuitCopy),
    RequestImage(RequestImage),
    ImageNotInDatabase(ImageNotInDatabase),
    RebakeAvatarTextures(RebakeAvatarTextures),
    SetAlwaysRun(SetAlwaysRun),
    ObjectAdd(ObjectAdd),
    ObjectDelete(ObjectDelete),
    ObjectDuplicate(ObjectDuplicate),
    ObjectDuplicateOnRay(ObjectDuplicateOnRay),
    MultipleObjectUpdate(MultipleObjectUpdate),
    RequestMultipleObjects(RequestMultipleObjects),
    ObjectPosition(ObjectPosition),
    ObjectScale(ObjectScale),
    ObjectRotation(ObjectRotation),
    ObjectFlagUpdate(ObjectFlagUpdate),
    ObjectClickAction(ObjectClickAction),
    ObjectImage(ObjectImage),
    ObjectMaterial(ObjectMaterial),
    ObjectShape(ObjectShape),
    ObjectExtraParams(ObjectExtraParams),
    ObjectOwner(ObjectOwner),
    ObjectGroup(ObjectGroup),
    ObjectBuy(ObjectBuy),
    BuyObjectInventory(BuyObjectInventory),
    DerezContainer(DerezContainer),
    ObjectPermissions(ObjectPermissions),
    ObjectSaleInfo(ObjectSaleInfo),
    ObjectName(ObjectName),
    ObjectDescription(ObjectDescription),
    ObjectCategory(ObjectCategory),
    ObjectSelect(ObjectSelect),
    ObjectDeselect(ObjectDeselect),
    ObjectAttach(ObjectAttach),
    ObjectDetach(ObjectDetach),
    ObjectDrop(ObjectDrop),
    ObjectLink(ObjectLink),
    ObjectDelink(ObjectDelink),
    ObjectGrab(ObjectGrab),
    ObjectGrabUpdate(ObjectGrabUpdate),
    ObjectDeGrab(ObjectDeGrab),
    ObjectSpinStart(ObjectSpinStart),
    ObjectSpinUpdate(ObjectSpinUpdate),
    ObjectSpinStop(ObjectSpinStop),
    ObjectExportSelected(ObjectExportSelected),
    ModifyLand(ModifyLand),
    VelocityInterpolateOn(VelocityInterpolateOn),
    VelocityInterpolateOff(VelocityInterpolateOff),
    StateSave(StateSave),
    ReportAutosaveCrash(ReportAutosaveCrash),
    SimWideDeletes(SimWideDeletes),
    RequestObjectPropertiesFamily(RequestObjectPropertiesFamily),
    TrackAgent(TrackAgent),
    ViewerStats(ViewerStats),
    ScriptAnswerYes(ScriptAnswerYes),
    UserReport(UserReport),
    AlertMessage(AlertMessage),
    AgentAlertMessage(AgentAlertMessage),
    MeanCollisionAlert(MeanCollisionAlert),
    ViewerFrozenMessage(ViewerFrozenMessage),
    HealthMessage(HealthMessage),
    ChatFromSimulator(ChatFromSimulator),
    SimStats(SimStats),
    RequestRegionInfo(RequestRegionInfo),
    RegionInfo(RegionInfo),
    GodUpdateRegionInfo(GodUpdateRegionInfo),
    NearestLandingRegionRequest(NearestLandingRegionRequest),
    NearestLandingRegionReply(NearestLandingRegionReply),
    NearestLandingRegionUpdated(NearestLandingRegionUpdated),
    TeleportLandingStatusChanged(TeleportLandingStatusChanged),
    RegionHandshake(RegionHandshake),
    RegionHandshakeReply(RegionHandshakeReply),
    CoarseLocationUpdate(CoarseLocationUpdate),
    ImageData(ImageData),
    ImagePacket(ImagePacket),
    LayerData(LayerData),
    ObjectUpdate(ObjectUpdate),
    ObjectUpdateCompressed(ObjectUpdateCompressed),
    ObjectUpdateCached(ObjectUpdateCached),
    ImprovedTerseObjectUpdate(ImprovedTerseObjectUpdate),
    KillObject(KillObject),
    CrossedRegion(CrossedRegion),
    SimulatorViewerTimeMessage(SimulatorViewerTimeMessage),
    EnableSimulator(EnableSimulator),
    DisableSimulator(DisableSimulator),
    ConfirmEnableSimulator(ConfirmEnableSimulator),
    TransferRequest(TransferRequest),
    TransferInfo(TransferInfo),
    TransferPacket(TransferPacket),
    TransferAbort(TransferAbort),
    RequestXfer(RequestXfer),
    SendXferPacket(SendXferPacket),
    ConfirmXferPacket(ConfirmXferPacket),
    AbortXfer(AbortXfer),
    AvatarAnimation(AvatarAnimation),
    AvatarAppearance(AvatarAppearance),
    AvatarSitResponse(AvatarSitResponse),
    SetFollowCamProperties(SetFollowCamProperties),
    ClearFollowCamProperties(ClearFollowCamProperties),
    CameraConstraint(CameraConstraint),
    ObjectProperties(ObjectProperties),
    ObjectPropertiesFamily(ObjectPropertiesFamily),
    RequestPayPrice(RequestPayPrice),
    PayPriceReply(PayPriceReply),
    KickUser(KickUser),
    KickUserAck(KickUserAck),
    GodKickUser(GodKickUser),
    SystemKickUser(SystemKickUser),
    EjectUser(EjectUser),
    FreezeUser(FreezeUser),
    AvatarPropertiesRequest(AvatarPropertiesRequest),
    AvatarPropertiesRequestBackend(AvatarPropertiesRequestBackend),
    AvatarPropertiesReply(AvatarPropertiesReply),
    AvatarInterestsReply(AvatarInterestsReply),
    AvatarGroupsReply(AvatarGroupsReply),
    AvatarPropertiesUpdate(AvatarPropertiesUpdate),
    AvatarInterestsUpdate(AvatarInterestsUpdate),
    AvatarNotesReply(AvatarNotesReply),
    AvatarNotesUpdate(AvatarNotesUpdate),
    AvatarPicksReply(AvatarPicksReply),
    EventInfoRequest(EventInfoRequest),
    EventInfoReply(EventInfoReply),
    EventNotificationAddRequest(EventNotificationAddRequest),
    EventNotificationRemoveRequest(EventNotificationRemoveRequest),
    EventGodDelete(EventGodDelete),
    PickInfoReply(PickInfoReply),
    PickInfoUpdate(PickInfoUpdate),
    PickDelete(PickDelete),
    PickGodDelete(PickGodDelete),
    ScriptQuestion(ScriptQuestion),
    ScriptControlChange(ScriptControlChange),
    ScriptDialog(ScriptDialog),
    ScriptDialogReply(ScriptDialogReply),
    ForceScriptControlRelease(ForceScriptControlRelease),
    RevokePermissions(RevokePermissions),
    LoadURL(LoadURL),
    ScriptTeleportRequest(ScriptTeleportRequest),
    ParcelOverlay(ParcelOverlay),
    ParcelPropertiesRequest(ParcelPropertiesRequest),
    ParcelPropertiesRequestByID(ParcelPropertiesRequestByID),
    ParcelProperties(ParcelProperties),
    ParcelPropertiesUpdate(ParcelPropertiesUpdate),
    ParcelReturnObjects(ParcelReturnObjects),
    ParcelSetOtherCleanTime(ParcelSetOtherCleanTime),
    ParcelDisableObjects(ParcelDisableObjects),
    ParcelSelectObjects(ParcelSelectObjects),
    EstateCovenantRequest(EstateCovenantRequest),
    EstateCovenantReply(EstateCovenantReply),
    ForceObjectSelect(ForceObjectSelect),
    ParcelBuyPass(ParcelBuyPass),
    ParcelDeedToGroup(ParcelDeedToGroup),
    ParcelReclaim(ParcelReclaim),
    ParcelClaim(ParcelClaim),
    ParcelJoin(ParcelJoin),
    ParcelDivide(ParcelDivide),
    ParcelRelease(ParcelRelease),
    ParcelBuy(ParcelBuy),
    ParcelGodForceOwner(ParcelGodForceOwner),
    ParcelAccessListRequest(ParcelAccessListRequest),
    ParcelAccessListReply(ParcelAccessListReply),
    ParcelAccessListUpdate(ParcelAccessListUpdate),
    ParcelDwellRequest(ParcelDwellRequest),
    ParcelDwellReply(ParcelDwellReply),
    RequestParcelTransfer(RequestParcelTransfer),
    UpdateParcel(UpdateParcel),
    RemoveParcel(RemoveParcel),
    MergeParcel(MergeParcel),
    LogParcelChanges(LogParcelChanges),
    CheckParcelSales(CheckParcelSales),
    ParcelSales(ParcelSales),
    ParcelGodMarkAsContent(ParcelGodMarkAsContent),
    ViewerStartAuction(ViewerStartAuction),
    StartAuction(StartAuction),
    ConfirmAuctionStart(ConfirmAuctionStart),
    CompleteAuction(CompleteAuction),
    CancelAuction(CancelAuction),
    CheckParcelAuctions(CheckParcelAuctions),
    ParcelAuctions(ParcelAuctions),
    UUIDNameRequest(UUIDNameRequest),
    UUIDNameReply(UUIDNameReply),
    UUIDGroupNameRequest(UUIDGroupNameRequest),
    UUIDGroupNameReply(UUIDGroupNameReply),
    ChatPass(ChatPass),
    EdgeDataPacket(EdgeDataPacket),
    SimStatus(SimStatus),
    ChildAgentUpdate(ChildAgentUpdate),
    ChildAgentAlive(ChildAgentAlive),
    ChildAgentPositionUpdate(ChildAgentPositionUpdate),
    ChildAgentDying(ChildAgentDying),
    ChildAgentUnknown(ChildAgentUnknown),
    AtomicPassObject(AtomicPassObject),
    KillChildAgents(KillChildAgents),
    GetScriptRunning(GetScriptRunning),
    ScriptRunningReply(ScriptRunningReply),
    SetScriptRunning(SetScriptRunning),
    ScriptReset(ScriptReset),
    ScriptSensorRequest(ScriptSensorRequest),
    ScriptSensorReply(ScriptSensorReply),
    CompleteAgentMovement(CompleteAgentMovement),
    AgentMovementComplete(AgentMovementComplete),
    DataServerLogout(DataServerLogout),
    LogoutRequest(LogoutRequest),
    LogoutReply(LogoutReply),
    ImprovedInstantMessage(ImprovedInstantMessage),
    RetrieveInstantMessages(RetrieveInstantMessages),
    FindAgent(FindAgent),
    RequestGodlikePowers(RequestGodlikePowers),
    GrantGodlikePowers(GrantGodlikePowers),
    GodlikeMessage(GodlikeMessage),
    EstateOwnerMessage(EstateOwnerMessage),
    GenericMessage(GenericMessage),
    MuteListRequest(MuteListRequest),
    UpdateMuteListEntry(UpdateMuteListEntry),
    RemoveMuteListEntry(RemoveMuteListEntry),
    CopyInventoryFromNotecard(CopyInventoryFromNotecard),
    UpdateInventoryItem(UpdateInventoryItem),
    UpdateCreateInventoryItem(UpdateCreateInventoryItem),
    MoveInventoryItem(MoveInventoryItem),
    CopyInventoryItem(CopyInventoryItem),
    RemoveInventoryItem(RemoveInventoryItem),
    ChangeInventoryItemFlags(ChangeInventoryItemFlags),
    SaveAssetIntoInventory(SaveAssetIntoInventory),
    CreateInventoryFolder(CreateInventoryFolder),
    UpdateInventoryFolder(UpdateInventoryFolder),
    MoveInventoryFolder(MoveInventoryFolder),
    RemoveInventoryFolder(RemoveInventoryFolder),
    FetchInventoryDescendents(FetchInventoryDescendents),
    InventoryDescendents(InventoryDescendents),
    FetchInventory(FetchInventory),
    FetchInventoryReply(FetchInventoryReply),
    BulkUpdateInventory(BulkUpdateInventory),
    RequestInventoryAsset(RequestInventoryAsset),
    InventoryAssetResponse(InventoryAssetResponse),
    RemoveInventoryObjects(RemoveInventoryObjects),
    PurgeInventoryDescendents(PurgeInventoryDescendents),
    UpdateTaskInventory(UpdateTaskInventory),
    RemoveTaskInventory(RemoveTaskInventory),
    MoveTaskInventory(MoveTaskInventory),
    RequestTaskInventory(RequestTaskInventory),
    ReplyTaskInventory(ReplyTaskInventory),
    DeRezObject(DeRezObject),
    DeRezAck(DeRezAck),
    RezObject(RezObject),
    RezObjectFromNotecard(RezObjectFromNotecard),
    TransferInventory(TransferInventory),
    TransferInventoryAck(TransferInventoryAck),
    AcceptFriendship(AcceptFriendship),
    DeclineFriendship(DeclineFriendship),
    FormFriendship(FormFriendship),
    TerminateFriendship(TerminateFriendship),
    OfferCallingCard(OfferCallingCard),
    AcceptCallingCard(AcceptCallingCard),
    DeclineCallingCard(DeclineCallingCard),
    RezScript(RezScript),
    CreateInventoryItem(CreateInventoryItem),
    CreateLandmarkForEvent(CreateLandmarkForEvent),
    EventLocationRequest(EventLocationRequest),
    EventLocationReply(EventLocationReply),
    RegionHandleRequest(RegionHandleRequest),
    RegionIDAndHandleReply(RegionIDAndHandleReply),
    MoneyTransferRequest(MoneyTransferRequest),
    MoneyTransferBackend(MoneyTransferBackend),
    MoneyBalanceRequest(MoneyBalanceRequest),
    MoneyBalanceReply(MoneyBalanceReply),
    RoutedMoneyBalanceReply(RoutedMoneyBalanceReply),
    ActivateGestures(ActivateGestures),
    DeactivateGestures(DeactivateGestures),
    MuteListUpdate(MuteListUpdate),
    UseCachedMuteList(UseCachedMuteList),
    GrantUserRights(GrantUserRights),
    ChangeUserRights(ChangeUserRights),
    OnlineNotification(OnlineNotification),
    OfflineNotification(OfflineNotification),
    SetStartLocationRequest(SetStartLocationRequest),
    SetStartLocation(SetStartLocation),
    NetTest(NetTest),
    SetCPURatio(SetCPURatio),
    SimCrashed(SimCrashed),
    NameValuePair(NameValuePair),
    RemoveNameValuePair(RemoveNameValuePair),
    UpdateAttachment(UpdateAttachment),
    RemoveAttachment(RemoveAttachment),
    SoundTrigger(SoundTrigger),
    AttachedSound(AttachedSound),
    AttachedSoundGainChange(AttachedSoundGainChange),
    PreloadSound(PreloadSound),
    AssetUploadRequest(AssetUploadRequest),
    AssetUploadComplete(AssetUploadComplete),
    EmailMessageRequest(EmailMessageRequest),
    EmailMessageReply(EmailMessageReply),
    InternalScriptMail(InternalScriptMail),
    ScriptDataRequest(ScriptDataRequest),
    ScriptDataReply(ScriptDataReply),
    CreateGroupRequest(CreateGroupRequest),
    CreateGroupReply(CreateGroupReply),
    UpdateGroupInfo(UpdateGroupInfo),
    GroupRoleChanges(GroupRoleChanges),
    JoinGroupRequest(JoinGroupRequest),
    JoinGroupReply(JoinGroupReply),
    EjectGroupMemberRequest(EjectGroupMemberRequest),
    EjectGroupMemberReply(EjectGroupMemberReply),
    LeaveGroupRequest(LeaveGroupRequest),
    LeaveGroupReply(LeaveGroupReply),
    InviteGroupRequest(InviteGroupRequest),
    InviteGroupResponse(InviteGroupResponse),
    GroupProfileRequest(GroupProfileRequest),
    GroupProfileReply(GroupProfileReply),
    GroupAccountSummaryRequest(GroupAccountSummaryRequest),
    GroupAccountSummaryReply(GroupAccountSummaryReply),
    GroupAccountDetailsRequest(GroupAccountDetailsRequest),
    GroupAccountDetailsReply(GroupAccountDetailsReply),
    GroupAccountTransactionsRequest(GroupAccountTransactionsRequest),
    GroupAccountTransactionsReply(GroupAccountTransactionsReply),
    GroupActiveProposalsRequest(GroupActiveProposalsRequest),
    GroupActiveProposalItemReply(GroupActiveProposalItemReply),
    GroupVoteHistoryRequest(GroupVoteHistoryRequest),
    GroupVoteHistoryItemReply(GroupVoteHistoryItemReply),
    StartGroupProposal(StartGroupProposal),
    GroupProposalBallot(GroupProposalBallot),
    TallyVotes(TallyVotes),
    GroupMembersRequest(GroupMembersRequest),
    GroupMembersReply(GroupMembersReply),
    ActivateGroup(ActivateGroup),
    SetGroupContribution(SetGroupContribution),
    SetGroupAcceptNotices(SetGroupAcceptNotices),
    GroupRoleDataRequest(GroupRoleDataRequest),
    GroupRoleDataReply(GroupRoleDataReply),
    GroupRoleMembersRequest(GroupRoleMembersRequest),
    GroupRoleMembersReply(GroupRoleMembersReply),
    GroupTitlesRequest(GroupTitlesRequest),
    GroupTitlesReply(GroupTitlesReply),
    GroupTitleUpdate(GroupTitleUpdate),
    GroupRoleUpdate(GroupRoleUpdate),
    LiveHelpGroupRequest(LiveHelpGroupRequest),
    LiveHelpGroupReply(LiveHelpGroupReply),
    AgentWearablesRequest(AgentWearablesRequest),
    AgentWearablesUpdate(AgentWearablesUpdate),
    AgentIsNowWearing(AgentIsNowWearing),
    AgentCachedTexture(AgentCachedTexture),
    AgentCachedTextureResponse(AgentCachedTextureResponse),
    AgentDataUpdateRequest(AgentDataUpdateRequest),
    AgentDataUpdate(AgentDataUpdate),
    GroupDataUpdate(GroupDataUpdate),
    AgentGroupDataUpdate(AgentGroupDataUpdate),
    AgentDropGroup(AgentDropGroup),
    LogTextMessage(LogTextMessage),
    ViewerEffect(ViewerEffect),
    CreateTrustedCircuit(CreateTrustedCircuit),
    DenyTrustedCircuit(DenyTrustedCircuit),
    RequestTrustedCircuit(RequestTrustedCircuit),
    RezSingleAttachmentFromInv(RezSingleAttachmentFromInv),
    RezMultipleAttachmentsFromInv(RezMultipleAttachmentsFromInv),
    DetachAttachmentIntoInv(DetachAttachmentIntoInv),
    CreateNewOutfitAttachments(CreateNewOutfitAttachments),
    UserInfoRequest(UserInfoRequest),
    UserInfoReply(UserInfoReply),
    UpdateUserInfo(UpdateUserInfo),
    ParcelRename(ParcelRename),
    InitiateDownload(InitiateDownload),
    SystemMessage(SystemMessage),
    MapLayerRequest(MapLayerRequest),
    MapLayerReply(MapLayerReply),
    MapBlockRequest(MapBlockRequest),
    MapNameRequest(MapNameRequest),
    MapBlockReply(MapBlockReply),
    MapItemRequest(MapItemRequest),
    MapItemReply(MapItemReply),
    SendPostcard(SendPostcard),
    RpcChannelRequest(RpcChannelRequest),
    RpcChannelReply(RpcChannelReply),
    RpcScriptRequestInbound(RpcScriptRequestInbound),
    RpcScriptRequestInboundForward(RpcScriptRequestInboundForward),
    RpcScriptReplyInbound(RpcScriptReplyInbound),
    ScriptMailRegistration(ScriptMailRegistration),
    ParcelMediaCommandMessage(ParcelMediaCommandMessage),
    ParcelMediaUpdate(ParcelMediaUpdate),
    LandStatRequest(LandStatRequest),
    LandStatReply(LandStatReply),
    Error(Error),
    ObjectIncludeInSearch(ObjectIncludeInSearch),
    RezRestoreToWorld(RezRestoreToWorld),
    LinkInventoryItem(LinkInventoryItem),
}


// Block IMPLEMENTATIONS



impl TestMessage_TestBlock1 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TestMessage_TestBlock1 { test1: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl TestMessage_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TestMessage_NeighborBlock {
            test0: try!(buffer.read_u32::<LittleEndian>()),
            test1: try!(buffer.read_u32::<LittleEndian>()),
            test2: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl PacketAck_Packets {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PacketAck_Packets { id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl OpenCircuit_CircuitInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(OpenCircuit_CircuitInfo {
            ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            port: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl StartPingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartPingCheck_PingID {
            ping_id: try!(buffer.read_u8()),
            oldest_unacked: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl CompletePingCheck_PingID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CompletePingCheck_PingID { ping_id: try!(buffer.read_u8()) })
    }
}

impl AddCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AddCircuitCode_CircuitCode {
            code: try!(buffer.read_u32::<LittleEndian>()),
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UseCircuitCode_CircuitCode {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UseCircuitCode_CircuitCode {
            code: try!(buffer.read_u32::<LittleEndian>()),
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl NeighborList_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NeighborList_NeighborBlock {
            ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            port: try!(buffer.read_u16::<LittleEndian>()),
            public_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            public_port: try!(buffer.read_u16::<LittleEndian>()),
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_access: try!(buffer.read_u8()),
        })
    }
}

impl AvatarTextureUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarTextureUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            textures_changed: try!(buffer.read_u8()) == 1,
        })
    }
}

impl AvatarTextureUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarTextureUpdate_WearableData {
            cache_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            texture_index: try!(buffer.read_u8()),
            host_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarTextureUpdate_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarTextureUpdate_TextureData {
            texture_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SimulatorMapUpdate_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorMapUpdate_MapData { flags: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl SimulatorSetMap_MapData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorSetMap_MapData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            type_: try!(buffer.read_i32::<LittleEndian>()),
            map_image: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SimulatorReady_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorReady_SimulatorBlock {
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_access: try!(buffer.read_u8()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            parent_estate_id: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SimulatorReady_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorReady_TelehubBlock {
            has_telehub: try!(buffer.read_u8()) == 1,
            telehub_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl TelehubInfo_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TelehubInfo_TelehubBlock {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            telehub_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>())),
            telehub_rot: Quaternion::from_parts(1.,
                                                Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                             try!(buffer.read_f32::<LittleEndian>()),
                                                             try!(buffer.read_f32::<LittleEndian>()))),
        })
    }
}

impl TelehubInfo_SpawnPointBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TelehubInfo_SpawnPointBlock {
            spawn_point_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                          try!(buffer.read_f32::<LittleEndian>()),
                                          try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorPresentAtLocation_SimulatorPublicHostBlock {
            port: try!(buffer.read_u16::<LittleEndian>()),
            simulator_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SimulatorPresentAtLocation_NeighborBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorPresentAtLocation_NeighborBlock {
            ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            port: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl SimulatorPresentAtLocation_SimulatorBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorPresentAtLocation_SimulatorBlock {
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_access: try!(buffer.read_u8()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            parent_estate_id: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SimulatorPresentAtLocation_TelehubBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorPresentAtLocation_TelehubBlock {
            has_telehub: try!(buffer.read_u8()) == 1,
            telehub_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl SimulatorLoad_SimulatorLoad {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorLoad_SimulatorLoad {
            time_dilation: try!(buffer.read_f32::<LittleEndian>()),
            agent_count: try!(buffer.read_i32::<LittleEndian>()),
            can_accept_agents: try!(buffer.read_u8()) == 1,
        })
    }
}

impl SimulatorLoad_AgentList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorLoad_AgentList {
            circuit_code: try!(buffer.read_u32::<LittleEndian>()),
            x: try!(buffer.read_u8()),
            y: try!(buffer.read_u8()),
        })
    }
}

impl RegionPresenceRequestByRegionID_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionPresenceRequestByRegionID_RegionData {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionPresenceRequestByHandle_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionPresenceRequestByHandle_RegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
        })
    }
}

impl RegionPresenceResponse_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionPresenceResponse_RegionData {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            internal_region_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            external_region_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            region_port: try!(buffer.read_u16::<LittleEndian>()),
            valid_until: try!(buffer.read_f64::<LittleEndian>()),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UpdateSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateSimulator_SimulatorInfo {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            sim_access: try!(buffer.read_u8()),
        })
    }
}

impl LogDwellTime_DwellInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogDwellTime_DwellInfo {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            duration: try!(buffer.read_f32::<LittleEndian>()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            region_x: try!(buffer.read_u32::<LittleEndian>()),
            region_y: try!(buffer.read_u32::<LittleEndian>()),
            avg_agents_in_view: try!(buffer.read_u8()),
            avg_viewer_fps: try!(buffer.read_u8()),
        })
    }
}

impl FeatureDisabled_FailureInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FeatureDisabled_FailureInfo {
            error_message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogFailedMoneyTransaction_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogFailedMoneyTransaction_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_time: try!(buffer.read_u32::<LittleEndian>()),
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u8()),
            amount: try!(buffer.read_i32::<LittleEndian>()),
            simulator_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
            failure_type: try!(buffer.read_u8()),
        })
    }
}

impl UserReportInternal_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserReportInternal_ReportData {
            report_type: try!(buffer.read_u8()),
            category: try!(buffer.read_u8()),
            reporter_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            viewer_position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                          try!(buffer.read_f32::<LittleEndian>()),
                                          try!(buffer.read_f32::<LittleEndian>())),
            agent_position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>())),
            screenshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            last_owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            abuser_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            abuse_region_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            abuse_region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            summary: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            details: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            version_string: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SetSimStatusInDatabase_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetSimStatusInDatabase_Data {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            host_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            x: try!(buffer.read_i32::<LittleEndian>()),
            y: try!(buffer.read_i32::<LittleEndian>()),
            pid: try!(buffer.read_i32::<LittleEndian>()),
            agent_count: try!(buffer.read_i32::<LittleEndian>()),
            time_to_live: try!(buffer.read_i32::<LittleEndian>()),
            status: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SetSimPresenceInDatabase_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetSimPresenceInDatabase_SimData {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            host_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
            pid: try!(buffer.read_i32::<LittleEndian>()),
            agent_count: try!(buffer.read_i32::<LittleEndian>()),
            time_to_live: try!(buffer.read_i32::<LittleEndian>()),
            status: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EconomyData_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EconomyData_Info {
            object_capacity: try!(buffer.read_i32::<LittleEndian>()),
            object_count: try!(buffer.read_i32::<LittleEndian>()),
            price_energy_unit: try!(buffer.read_i32::<LittleEndian>()),
            price_object_claim: try!(buffer.read_i32::<LittleEndian>()),
            price_public_object_decay: try!(buffer.read_i32::<LittleEndian>()),
            price_public_object_delete: try!(buffer.read_i32::<LittleEndian>()),
            price_parcel_claim: try!(buffer.read_i32::<LittleEndian>()),
            price_parcel_claim_factor: try!(buffer.read_f32::<LittleEndian>()),
            price_upload: try!(buffer.read_i32::<LittleEndian>()),
            price_rent_light: try!(buffer.read_i32::<LittleEndian>()),
            teleport_min_price: try!(buffer.read_i32::<LittleEndian>()),
            teleport_price_exponent: try!(buffer.read_f32::<LittleEndian>()),
            energy_efficiency: try!(buffer.read_f32::<LittleEndian>()),
            price_object_rent: try!(buffer.read_f32::<LittleEndian>()),
            price_object_scale_factor: try!(buffer.read_f32::<LittleEndian>()),
            price_parcel_rent: try!(buffer.read_i32::<LittleEndian>()),
            price_group_create: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AvatarPickerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPickerRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerRequest_Data {
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarPickerRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            god_level: try!(buffer.read_u8()),
        })
    }
}

impl AvatarPickerRequestBackend_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerRequestBackend_Data {
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarPickerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPickerReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPickerReply_Data {
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            first_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            last_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl PlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PlacesQuery_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesQuery_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesQuery_QueryData {
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_i8()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl PlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PlacesReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PlacesReply_QueryData {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
            billable_area: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u8()),
            global_x: try!(buffer.read_f32::<LittleEndian>()),
            global_y: try!(buffer.read_f32::<LittleEndian>()),
            global_z: try!(buffer.read_f32::<LittleEndian>()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dwell: try!(buffer.read_f32::<LittleEndian>()),
            price: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirFindQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirFindQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirFindQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirFindQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirFindQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirFindQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirFindQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirFindQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl DirPlacesQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPlacesQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_i8()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirPlacesQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPlacesQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_i8()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirPlacesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPlacesReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPlacesReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            for_sale: try!(buffer.read_u8()) == 1,
            auction: try!(buffer.read_u8()) == 1,
            dwell: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl DirPlacesReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPlacesReply_StatusData { status: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl DirPeopleReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPeopleReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPeopleReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPeopleReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPeopleReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPeopleReply_QueryReplies {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            first_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            last_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            group: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            online: try!(buffer.read_u8()) == 1,
            reputation: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirEventsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirEventsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirEventsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirEventsReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirEventsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirEventsReply_QueryReplies {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            event_id: try!(buffer.read_u32::<LittleEndian>()),
            date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            unix_time: try!(buffer.read_u32::<LittleEndian>()),
            event_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DirEventsReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirEventsReply_StatusData { status: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl DirGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirGroupsReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirGroupsReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirGroupsReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirGroupsReply_QueryReplies {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            members: try!(buffer.read_i32::<LittleEndian>()),
            search_order: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl DirClassifiedQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirClassifiedQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_u32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirClassifiedQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirClassifiedQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirClassifiedReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirClassifiedReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedReply_QueryReplies {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            classified_flags: try!(buffer.read_u8()),
            creation_date: try!(buffer.read_u32::<LittleEndian>()),
            expiration_date: try!(buffer.read_u32::<LittleEndian>()),
            price_for_listing: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirClassifiedReply_StatusData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirClassifiedReply_StatusData { status: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl AvatarClassifiedReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarClassifiedReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarClassifiedReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarClassifiedReply_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ClassifiedInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoRequest_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoReply_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creation_date: try!(buffer.read_u32::<LittleEndian>()),
            expiration_date: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_u32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_estate: try!(buffer.read_u32::<LittleEndian>()),
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            pos_global: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            parcel_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            classified_flags: try!(buffer.read_u8()),
            price_for_listing: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ClassifiedInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedInfoUpdate_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            category: try!(buffer.read_u32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_estate: try!(buffer.read_u32::<LittleEndian>()),
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pos_global: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            classified_flags: try!(buffer.read_u8()),
            price_for_listing: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ClassifiedDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedDelete_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ClassifiedGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClassifiedGodDelete_Data {
            classified_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirLandQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirLandQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            search_type: try!(buffer.read_u32::<LittleEndian>()),
            price: try!(buffer.read_i32::<LittleEndian>()),
            area: try!(buffer.read_i32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirLandQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirLandQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            search_type: try!(buffer.read_u32::<LittleEndian>()),
            price: try!(buffer.read_i32::<LittleEndian>()),
            area: try!(buffer.read_i32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl DirLandReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirLandReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirLandReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirLandReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            auction: try!(buffer.read_u8()) == 1,
            for_sale: try!(buffer.read_u8()) == 1,
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl DirPopularQuery_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularQuery_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPopularQuery_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularQuery_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DirPopularQueryBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularQueryBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPopularQueryBackend_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularQueryBackend_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl DirPopularReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPopularReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DirPopularReply_QueryReplies {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DirPopularReply_QueryReplies {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            dwell: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ParcelInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelInfoRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelInfoRequest_Data {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelInfoReply_Data {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
            billable_area: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u8()),
            global_x: try!(buffer.read_f32::<LittleEndian>()),
            global_y: try!(buffer.read_f32::<LittleEndian>()),
            global_z: try!(buffer.read_f32::<LittleEndian>()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dwell: try!(buffer.read_f32::<LittleEndian>()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            auction_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelObjectOwnersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelObjectOwnersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelObjectOwnersRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelObjectOwnersRequest_ParcelData { local_id: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl ParcelObjectOwnersReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelObjectOwnersReply_Data {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_group_owned: try!(buffer.read_u8()) == 1,
            count: try!(buffer.read_i32::<LittleEndian>()),
            online_status: try!(buffer.read_u8()) == 1,
        })
    }
}

impl GroupNoticesListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticesListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticesListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticesListRequest_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticesListReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticesListReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticesListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticesListReply_Data {
            notice_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            timestamp: try!(buffer.read_u32::<LittleEndian>()),
            from_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            subject: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            has_attachment: try!(buffer.read_u8()) == 1,
            asset_type: try!(buffer.read_u8()),
        })
    }
}

impl GroupNoticeRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticeRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticeRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticeRequest_Data {
            group_notice_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticeAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticeAdd_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupNoticeAdd_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupNoticeAdd_MessageBlock {
            to_group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dialog: try!(buffer.read_u8()),
            from_agent_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            binary_bucket: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl TeleportRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportRequest_Info {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl TeleportLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLocationRequest_Info {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl TeleportLocal_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLocal_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            location_id: try!(buffer.read_u32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            teleport_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl TeleportLandmarkRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLandmarkRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            landmark_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportProgress_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportProgress_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportProgress_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportProgress_Info {
            teleport_flags: try!(buffer.read_u32::<LittleEndian>()),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl DataHomeLocationRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DataHomeLocationRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            kicked_from_estate_id: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DataHomeLocationRequest_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DataHomeLocationRequest_AgentInfo {
            agent_effective_maturity: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DataHomeLocationReply_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DataHomeLocationReply_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl TeleportFinish_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportFinish_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            location_id: try!(buffer.read_u32::<LittleEndian>()),
            sim_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            sim_port: try!(buffer.read_u16::<LittleEndian>()),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            seed_capability: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_access: try!(buffer.read_u8()),
            teleport_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl StartLure_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartLure_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StartLure_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartLure_Info {
            lure_type: try!(buffer.read_u8()),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl StartLure_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartLure_TargetData {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportLureRequest_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLureRequest_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            lure_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            teleport_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl TeleportCancel_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportCancel_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TeleportStart_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportStart_Info { teleport_flags: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl TeleportFailed_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportFailed_Info {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            reason: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl TeleportFailed_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportFailed_AlertInfo {
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            extra_params: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl Undo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Undo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl Undo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Undo_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl Redo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Redo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl Redo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Redo_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UndoLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UndoLand_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentPause_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentPause_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentResume_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentResume_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            body_rotation: Quaternion::from_parts(1.,
                                                  Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()))),
            head_rotation: Quaternion::from_parts(1.,
                                                  Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()))),
            state: try!(buffer.read_u8()),
            camera_center: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            camera_at_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>())),
            camera_left_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>())),
            camera_up_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>()),
                                         try!(buffer.read_f32::<LittleEndian>())),
            far: try!(buffer.read_f32::<LittleEndian>()),
            control_flags: try!(buffer.read_u32::<LittleEndian>()),
            flags: try!(buffer.read_u8()),
        })
    }
}

impl ChatFromViewer_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChatFromViewer_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChatFromViewer_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChatFromViewer_ChatData {
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            type_: try!(buffer.read_u8()),
            channel: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AgentThrottle_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentThrottle_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            circuit_code: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentThrottle_Throttle {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentThrottle_Throttle {
            gen_counter: try!(buffer.read_u32::<LittleEndian>()),
            throttles: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentFOV_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentFOV_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            circuit_code: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentFOV_FOVBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentFOV_FOVBlock {
            gen_counter: try!(buffer.read_u32::<LittleEndian>()),
            vertical_angle: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl AgentHeightWidth_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentHeightWidth_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            circuit_code: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentHeightWidth_HeightWidthBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentHeightWidth_HeightWidthBlock {
            gen_counter: try!(buffer.read_u32::<LittleEndian>()),
            height: try!(buffer.read_u16::<LittleEndian>()),
            width: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl AgentSetAppearance_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentSetAppearance_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_u32::<LittleEndian>()),
            size: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl AgentSetAppearance_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentSetAppearance_WearableData {
            cache_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            texture_index: try!(buffer.read_u8()),
        })
    }
}

impl AgentSetAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentSetAppearance_ObjectData {
            texture_entry: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentSetAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentSetAppearance_VisualParam { param_value: try!(buffer.read_u8()) })
    }
}

impl AgentAnimation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentAnimation_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentAnimation_AnimationList {
            anim_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            start_anim: try!(buffer.read_u8()) == 1,
        })
    }
}

impl AgentAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentRequestSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentRequestSit_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentRequestSit_TargetObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentRequestSit_TargetObject {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            offset: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl AgentSit_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentSit_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentQuitCopy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentQuitCopy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentQuitCopy_FuseBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentQuitCopy_FuseBlock { viewer_circuit_code: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl RequestImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestImage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestImage_RequestImage {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestImage_RequestImage {
            image: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            discard_level: try!(buffer.read_i8()),
            download_priority: try!(buffer.read_f32::<LittleEndian>()),
            packet: try!(buffer.read_u32::<LittleEndian>()),
            type_: try!(buffer.read_u8()),
        })
    }
}

impl ImageNotInDatabase_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImageNotInDatabase_ImageID {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RebakeAvatarTextures_TextureData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RebakeAvatarTextures_TextureData {
            texture_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetAlwaysRun_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetAlwaysRun_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            always_run: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ObjectAdd_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectAdd_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectAdd_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectAdd_ObjectData {
            p_code: try!(buffer.read_u8()),
            material: try!(buffer.read_u8()),
            add_flags: try!(buffer.read_u32::<LittleEndian>()),
            path_curve: try!(buffer.read_u8()),
            profile_curve: try!(buffer.read_u8()),
            path_begin: try!(buffer.read_u16::<LittleEndian>()),
            path_end: try!(buffer.read_u16::<LittleEndian>()),
            path_scale_x: try!(buffer.read_u8()),
            path_scale_y: try!(buffer.read_u8()),
            path_shear_x: try!(buffer.read_u8()),
            path_shear_y: try!(buffer.read_u8()),
            path_twist: try!(buffer.read_i8()),
            path_twist_begin: try!(buffer.read_i8()),
            path_radius_offset: try!(buffer.read_i8()),
            path_taper_x: try!(buffer.read_i8()),
            path_taper_y: try!(buffer.read_i8()),
            path_revolutions: try!(buffer.read_u8()),
            path_skew: try!(buffer.read_i8()),
            profile_begin: try!(buffer.read_u16::<LittleEndian>()),
            profile_end: try!(buffer.read_u16::<LittleEndian>()),
            profile_hollow: try!(buffer.read_u16::<LittleEndian>()),
            bypass_raycast: try!(buffer.read_u8()),
            ray_start: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            ray_end: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            ray_target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            ray_end_is_intersection: try!(buffer.read_u8()),
            scale: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>())),
            rotation: Quaternion::from_parts(1.,
                                             Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()))),
            state: try!(buffer.read_u8()),
        })
    }
}

impl ObjectDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            force: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ObjectDelete_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDelete_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDuplicate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDuplicate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDuplicate_SharedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDuplicate_SharedData {
            offset: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            duplicate_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectDuplicate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDuplicate_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDuplicateOnRay_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDuplicateOnRay_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            ray_start: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            ray_end: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            bypass_raycast: try!(buffer.read_u8()) == 1,
            ray_end_is_intersection: try!(buffer.read_u8()) == 1,
            copy_centers: try!(buffer.read_u8()) == 1,
            copy_rotates: try!(buffer.read_u8()) == 1,
            ray_target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            duplicate_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectDuplicateOnRay_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDuplicateOnRay_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl MultipleObjectUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MultipleObjectUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MultipleObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MultipleObjectUpdate_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            type_: try!(buffer.read_u8()),
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RequestMultipleObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestMultipleObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestMultipleObjects_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestMultipleObjects_ObjectData {
            cache_miss_type: try!(buffer.read_u8()),
            id: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectPosition_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPosition_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectPosition_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPosition_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectScale_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectScale_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectScale_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectScale_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            scale: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectRotation_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectRotation_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectRotation_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectRotation_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            rotation: Quaternion::from_parts(1.,
                                             Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()))),
        })
    }
}

impl ObjectFlagUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectFlagUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            use_physics: try!(buffer.read_u8()) == 1,
            is_temporary: try!(buffer.read_u8()) == 1,
            is_phantom: try!(buffer.read_u8()) == 1,
            casts_shadows: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ObjectClickAction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectClickAction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectClickAction_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectClickAction_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            click_action: try!(buffer.read_u8()),
        })
    }
}

impl ObjectImage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectImage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectImage_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectImage_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            media_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            texture_entry: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectMaterial_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectMaterial_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectMaterial_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectMaterial_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            material: try!(buffer.read_u8()),
        })
    }
}

impl ObjectShape_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectShape_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectShape_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectShape_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            path_curve: try!(buffer.read_u8()),
            profile_curve: try!(buffer.read_u8()),
            path_begin: try!(buffer.read_u16::<LittleEndian>()),
            path_end: try!(buffer.read_u16::<LittleEndian>()),
            path_scale_x: try!(buffer.read_u8()),
            path_scale_y: try!(buffer.read_u8()),
            path_shear_x: try!(buffer.read_u8()),
            path_shear_y: try!(buffer.read_u8()),
            path_twist: try!(buffer.read_i8()),
            path_twist_begin: try!(buffer.read_i8()),
            path_radius_offset: try!(buffer.read_i8()),
            path_taper_x: try!(buffer.read_i8()),
            path_taper_y: try!(buffer.read_i8()),
            path_revolutions: try!(buffer.read_u8()),
            path_skew: try!(buffer.read_i8()),
            profile_begin: try!(buffer.read_u16::<LittleEndian>()),
            profile_end: try!(buffer.read_u16::<LittleEndian>()),
            profile_hollow: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ObjectExtraParams_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectExtraParams_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectExtraParams_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectExtraParams_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            param_type: try!(buffer.read_u16::<LittleEndian>()),
            param_in_use: try!(buffer.read_u8()) == 1,
            param_size: try!(buffer.read_u32::<LittleEndian>()),
            param_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectOwner_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectOwner_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectOwner_HeaderData {
            override_: try!(buffer.read_u8()) == 1,
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectOwner_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectOwner_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectGroup_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGroup_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectBuy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            category_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectBuy_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectBuy_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl BuyObjectInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(BuyObjectInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl BuyObjectInventory_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(BuyObjectInventory_Data {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DerezContainer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DerezContainer_Data {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            delete: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ObjectPermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPermissions_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectPermissions_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPermissions_HeaderData { override_: try!(buffer.read_u8()) == 1 })
    }
}

impl ObjectPermissions_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPermissions_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            field: try!(buffer.read_u8()),
            set: try!(buffer.read_u8()),
            mask: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectSaleInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSaleInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSaleInfo_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSaleInfo_ObjectData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ObjectName_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectName_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectName_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectName_ObjectData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectDescription_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDescription_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDescription_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDescription_ObjectData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectCategory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectCategory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectCategory_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectCategory_ObjectData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            category: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectSelect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSelect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSelect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSelect_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDeselect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDeselect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDeselect_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDeselect_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectAttach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectAttach_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            attachment_point: try!(buffer.read_u8()),
        })
    }
}

impl ObjectAttach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectAttach_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            rotation: Quaternion::from_parts(1.,
                                             Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()))),
        })
    }
}

impl ObjectDetach_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDetach_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDetach_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDetach_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDrop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDrop_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDrop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDrop_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectLink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectLink_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectLink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectLink_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDelink_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDelink_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDelink_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDelink_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrab_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrab_ObjectData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            grab_offset: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrab_SurfaceInfo {
            uv_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            st_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            face_index: try!(buffer.read_i32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            normal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            binormal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectGrabUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrabUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectGrabUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrabUpdate_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            grab_offset_initial: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                              try!(buffer.read_f32::<LittleEndian>()),
                                              try!(buffer.read_f32::<LittleEndian>())),
            grab_position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            time_since_last: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ObjectGrabUpdate_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectGrabUpdate_SurfaceInfo {
            uv_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            st_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            face_index: try!(buffer.read_i32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            normal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            binormal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectDeGrab_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDeGrab_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectDeGrab_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDeGrab_ObjectData { local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ObjectDeGrab_SurfaceInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectDeGrab_SurfaceInfo {
            uv_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            st_coord: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            face_index: try!(buffer.read_i32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            normal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            binormal: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectSpinStart_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinStart_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSpinStart_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinStart_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSpinUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSpinUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinUpdate_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            rotation: Quaternion::from_parts(1.,
                                             Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()))),
        })
    }
}

impl ObjectSpinStop_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinStop_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectSpinStop_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectSpinStop_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectExportSelected_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectExportSelected_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            volume_detail: try!(buffer.read_i16::<LittleEndian>()),
        })
    }
}

impl ObjectExportSelected_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectExportSelected_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ModifyLand_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ModifyLand_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ModifyLand_ModifyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ModifyLand_ModifyBlock {
            action: try!(buffer.read_u8()),
            brush_size: try!(buffer.read_u8()),
            seconds: try!(buffer.read_f32::<LittleEndian>()),
            height: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ModifyLand_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ModifyLand_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            west: try!(buffer.read_f32::<LittleEndian>()),
            south: try!(buffer.read_f32::<LittleEndian>()),
            east: try!(buffer.read_f32::<LittleEndian>()),
            north: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ModifyLand_ModifyBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ModifyLand_ModifyBlockExtended { brush_size: try!(buffer.read_f32::<LittleEndian>()) })
    }
}

impl VelocityInterpolateOn_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(VelocityInterpolateOn_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl VelocityInterpolateOff_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(VelocityInterpolateOff_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StateSave_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StateSave_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StateSave_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StateSave_DataBlock {
            filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ReportAutosaveCrash_AutosaveData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ReportAutosaveCrash_AutosaveData {
            pid: try!(buffer.read_i32::<LittleEndian>()),
            status: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl SimWideDeletes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimWideDeletes_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SimWideDeletes_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimWideDeletes_DataBlock {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RequestObjectPropertiesFamily_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestObjectPropertiesFamily_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestObjectPropertiesFamily_ObjectData {
            request_flags: try!(buffer.read_u32::<LittleEndian>()),
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TrackAgent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TrackAgent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TrackAgent_TargetData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TrackAgent_TargetData {
            prey_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ViewerStats_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStats_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            start_time: try!(buffer.read_u32::<LittleEndian>()),
            run_time: try!(buffer.read_f32::<LittleEndian>()),
            sim_fps: try!(buffer.read_f32::<LittleEndian>()),
            fps: try!(buffer.read_f32::<LittleEndian>()),
            agents_in_view: try!(buffer.read_u8()),
            ping: try!(buffer.read_f32::<LittleEndian>()),
            meters_traveled: try!(buffer.read_f64::<LittleEndian>()),
            regions_visited: try!(buffer.read_i32::<LittleEndian>()),
            sys_ram: try!(buffer.read_u32::<LittleEndian>()),
            sys_os: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sys_cpu: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sys_gpu: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ViewerStats_DownloadTotals {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStats_DownloadTotals {
            world: try!(buffer.read_u32::<LittleEndian>()),
            objects: try!(buffer.read_u32::<LittleEndian>()),
            textures: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ViewerStats_NetStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStats_NetStats {
            bytes: try!(buffer.read_u32::<LittleEndian>()),
            packets: try!(buffer.read_u32::<LittleEndian>()),
            compressed: try!(buffer.read_u32::<LittleEndian>()),
            savings: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ViewerStats_FailStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStats_FailStats {
            send_packet: try!(buffer.read_u32::<LittleEndian>()),
            dropped: try!(buffer.read_u32::<LittleEndian>()),
            resent: try!(buffer.read_u32::<LittleEndian>()),
            failed_resends: try!(buffer.read_u32::<LittleEndian>()),
            off_circuit: try!(buffer.read_u32::<LittleEndian>()),
            invalid: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ViewerStats_MiscStats {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStats_MiscStats {
            type_: try!(buffer.read_u32::<LittleEndian>()),
            value: try!(buffer.read_f64::<LittleEndian>()),
        })
    }
}

impl ScriptAnswerYes_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptAnswerYes_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptAnswerYes_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptAnswerYes_Data {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            questions: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl UserReport_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserReport_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UserReport_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserReport_ReportData {
            report_type: try!(buffer.read_u8()),
            category: try!(buffer.read_u8()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            check_flags: try!(buffer.read_u8()),
            screenshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            abuser_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            abuse_region_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            abuse_region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            summary: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            details: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            version_string: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AlertMessage_AlertData {
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AlertMessage_AlertInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AlertMessage_AlertInfo {
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            extra_params: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentAlertMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentAlertMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentAlertMessage_AlertData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentAlertMessage_AlertData {
            modal: try!(buffer.read_u8()) == 1,
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MeanCollisionAlert_MeanCollision {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MeanCollisionAlert_MeanCollision {
            victim: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            perp: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            time: try!(buffer.read_u32::<LittleEndian>()),
            mag: try!(buffer.read_f32::<LittleEndian>()),
            type_: try!(buffer.read_u8()),
        })
    }
}

impl ViewerFrozenMessage_FrozenData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerFrozenMessage_FrozenData { data: try!(buffer.read_u8()) == 1 })
    }
}

impl HealthMessage_HealthData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(HealthMessage_HealthData { health: try!(buffer.read_f32::<LittleEndian>()) })
    }
}

impl ChatFromSimulator_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChatFromSimulator_ChatData {
            from_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            source_type: try!(buffer.read_u8()),
            chat_type: try!(buffer.read_u8()),
            audible: try!(buffer.read_u8()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SimStats_Region {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimStats_Region {
            region_x: try!(buffer.read_u32::<LittleEndian>()),
            region_y: try!(buffer.read_u32::<LittleEndian>()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            object_capacity: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SimStats_Stat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimStats_Stat {
            stat_id: try!(buffer.read_u32::<LittleEndian>()),
            stat_value: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl SimStats_PidStat {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimStats_PidStat { pid: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl RequestRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionInfo_RegionInfo {
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            parent_estate_id: try!(buffer.read_u32::<LittleEndian>()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            sim_access: try!(buffer.read_u8()),
            max_agents: try!(buffer.read_u8()),
            billable_factor: try!(buffer.read_f32::<LittleEndian>()),
            object_bonus_factor: try!(buffer.read_f32::<LittleEndian>()),
            water_height: try!(buffer.read_f32::<LittleEndian>()),
            terrain_raise_limit: try!(buffer.read_f32::<LittleEndian>()),
            terrain_lower_limit: try!(buffer.read_f32::<LittleEndian>()),
            price_per_meter: try!(buffer.read_i32::<LittleEndian>()),
            redirect_grid_x: try!(buffer.read_i32::<LittleEndian>()),
            redirect_grid_y: try!(buffer.read_i32::<LittleEndian>()),
            use_estate_sun: try!(buffer.read_u8()) == 1,
            sun_hour: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl RegionInfo_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionInfo_RegionInfo2 {
            product_sku: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            product_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            max_agents32: try!(buffer.read_u32::<LittleEndian>()),
            hard_max_agents: try!(buffer.read_u32::<LittleEndian>()),
            hard_max_objects: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GodUpdateRegionInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodUpdateRegionInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GodUpdateRegionInfo_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodUpdateRegionInfo_RegionInfo {
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            parent_estate_id: try!(buffer.read_u32::<LittleEndian>()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            billable_factor: try!(buffer.read_f32::<LittleEndian>()),
            price_per_meter: try!(buffer.read_i32::<LittleEndian>()),
            redirect_grid_x: try!(buffer.read_i32::<LittleEndian>()),
            redirect_grid_y: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl NearestLandingRegionRequest_RequestingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NearestLandingRegionRequest_RequestingRegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
        })
    }
}

impl NearestLandingRegionReply_LandingRegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NearestLandingRegionReply_LandingRegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
        })
    }
}

impl NearestLandingRegionUpdated_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NearestLandingRegionUpdated_RegionData { region_handle: try!(buffer.read_u64::<LittleEndian>()) })
    }
}

impl TeleportLandingStatusChanged_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TeleportLandingStatusChanged_RegionData { region_handle: try!(buffer.read_u64::<LittleEndian>()) })
    }
}

impl RegionHandshake_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandshake_RegionInfo {
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            sim_access: try!(buffer.read_u8()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_owner: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_estate_manager: try!(buffer.read_u8()) == 1,
            water_height: try!(buffer.read_f32::<LittleEndian>()),
            billable_factor: try!(buffer.read_f32::<LittleEndian>()),
            cache_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_base0: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_base1: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_base2: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_base3: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_detail0: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_detail1: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_detail2: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_detail3: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terrain_start_height00: try!(buffer.read_f32::<LittleEndian>()),
            terrain_start_height01: try!(buffer.read_f32::<LittleEndian>()),
            terrain_start_height10: try!(buffer.read_f32::<LittleEndian>()),
            terrain_start_height11: try!(buffer.read_f32::<LittleEndian>()),
            terrain_height_range00: try!(buffer.read_f32::<LittleEndian>()),
            terrain_height_range01: try!(buffer.read_f32::<LittleEndian>()),
            terrain_height_range10: try!(buffer.read_f32::<LittleEndian>()),
            terrain_height_range11: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl RegionHandshake_RegionInfo2 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandshake_RegionInfo2 {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionHandshake_RegionInfo3 {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandshake_RegionInfo3 {
            cpu_class_id: try!(buffer.read_i32::<LittleEndian>()),
            cpu_ratio: try!(buffer.read_i32::<LittleEndian>()),
            colo_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            product_sku: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            product_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RegionHandshakeReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandshakeReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionHandshakeReply_RegionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandshakeReply_RegionInfo { flags: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl CoarseLocationUpdate_Location {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CoarseLocationUpdate_Location {
            x: try!(buffer.read_u8()),
            y: try!(buffer.read_u8()),
            z: try!(buffer.read_u8()),
        })
    }
}

impl CoarseLocationUpdate_Index {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CoarseLocationUpdate_Index {
            you: try!(buffer.read_i16::<LittleEndian>()),
            prey: try!(buffer.read_i16::<LittleEndian>()),
        })
    }
}

impl CoarseLocationUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CoarseLocationUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ImageData_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImageData_ImageID {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            codec: try!(buffer.read_u8()),
            size: try!(buffer.read_u32::<LittleEndian>()),
            packets: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ImageData_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImageData_ImageData {
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ImagePacket_ImageID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImagePacket_ImageID {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            packet: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ImagePacket_ImageData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImagePacket_ImageData {
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl LayerData_LayerID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LayerData_LayerID { type_: try!(buffer.read_u8()) })
    }
}

impl LayerData_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LayerData_LayerData {
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdate_RegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            time_dilation: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdate_ObjectData {
            id: try!(buffer.read_u32::<LittleEndian>()),
            state: try!(buffer.read_u8()),
            full_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            crc: try!(buffer.read_u32::<LittleEndian>()),
            p_code: try!(buffer.read_u8()),
            material: try!(buffer.read_u8()),
            click_action: try!(buffer.read_u8()),
            scale: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>())),
            object_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            parent_id: try!(buffer.read_u32::<LittleEndian>()),
            update_flags: try!(buffer.read_u32::<LittleEndian>()),
            path_curve: try!(buffer.read_u8()),
            profile_curve: try!(buffer.read_u8()),
            path_begin: try!(buffer.read_u16::<LittleEndian>()),
            path_end: try!(buffer.read_u16::<LittleEndian>()),
            path_scale_x: try!(buffer.read_u8()),
            path_scale_y: try!(buffer.read_u8()),
            path_shear_x: try!(buffer.read_u8()),
            path_shear_y: try!(buffer.read_u8()),
            path_twist: try!(buffer.read_i8()),
            path_twist_begin: try!(buffer.read_i8()),
            path_radius_offset: try!(buffer.read_i8()),
            path_taper_x: try!(buffer.read_i8()),
            path_taper_y: try!(buffer.read_i8()),
            path_revolutions: try!(buffer.read_u8()),
            path_skew: try!(buffer.read_i8()),
            profile_begin: try!(buffer.read_u16::<LittleEndian>()),
            profile_end: try!(buffer.read_u16::<LittleEndian>()),
            profile_hollow: try!(buffer.read_u16::<LittleEndian>()),
            texture_entry: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            texture_anim: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            name_value: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            text_color: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            ps_block: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            extra_params: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sound: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            gain: try!(buffer.read_f32::<LittleEndian>()),
            flags: try!(buffer.read_u8()),
            radius: try!(buffer.read_f32::<LittleEndian>()),
            joint_type: try!(buffer.read_u8()),
            joint_pivot: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>()),
                                      try!(buffer.read_f32::<LittleEndian>())),
            joint_axis_or_anchor: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                               try!(buffer.read_f32::<LittleEndian>()),
                                               try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectUpdateCompressed_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdateCompressed_RegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            time_dilation: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ObjectUpdateCompressed_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdateCompressed_ObjectData {
            update_flags: try!(buffer.read_u32::<LittleEndian>()),
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectUpdateCached_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdateCached_RegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            time_dilation: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ObjectUpdateCached_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectUpdateCached_ObjectData {
            id: try!(buffer.read_u32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
            update_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ImprovedTerseObjectUpdate_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImprovedTerseObjectUpdate_RegionData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            time_dilation: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ImprovedTerseObjectUpdate_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImprovedTerseObjectUpdate_ObjectData {
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            texture_entry: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl KillObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(KillObject_ObjectData { id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl CrossedRegion_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CrossedRegion_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CrossedRegion_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CrossedRegion_RegionData {
            sim_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            sim_port: try!(buffer.read_u16::<LittleEndian>()),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            seed_capability: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CrossedRegion_Info {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CrossedRegion_Info {
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl SimulatorViewerTimeMessage_TimeInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimulatorViewerTimeMessage_TimeInfo {
            usec_since_start: try!(buffer.read_u64::<LittleEndian>()),
            sec_per_day: try!(buffer.read_u32::<LittleEndian>()),
            sec_per_year: try!(buffer.read_u32::<LittleEndian>()),
            sun_direction: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            sun_phase: try!(buffer.read_f32::<LittleEndian>()),
            sun_ang_velocity: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl EnableSimulator_SimulatorInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EnableSimulator_SimulatorInfo {
            handle: try!(buffer.read_u64::<LittleEndian>()),
            ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            port: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl ConfirmEnableSimulator_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ConfirmEnableSimulator_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TransferRequest_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferRequest_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_type: try!(buffer.read_i32::<LittleEndian>()),
            source_type: try!(buffer.read_i32::<LittleEndian>()),
            priority: try!(buffer.read_f32::<LittleEndian>()),
            params: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl TransferInfo_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferInfo_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_type: try!(buffer.read_i32::<LittleEndian>()),
            target_type: try!(buffer.read_i32::<LittleEndian>()),
            status: try!(buffer.read_i32::<LittleEndian>()),
            size: try!(buffer.read_i32::<LittleEndian>()),
            params: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl TransferPacket_TransferData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferPacket_TransferData {
            transfer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_type: try!(buffer.read_i32::<LittleEndian>()),
            packet: try!(buffer.read_i32::<LittleEndian>()),
            status: try!(buffer.read_i32::<LittleEndian>()),
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl TransferAbort_TransferInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferAbort_TransferInfo {
            transfer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_type: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl RequestXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestXfer_XferID {
            id: try!(buffer.read_u64::<LittleEndian>()),
            filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            file_path: try!(buffer.read_u8()),
            delete_on_completion: try!(buffer.read_u8()) == 1,
            use_big_packets: try!(buffer.read_u8()) == 1,
            v_file_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            v_file_type: try!(buffer.read_i16::<LittleEndian>()),
        })
    }
}

impl SendXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SendXferPacket_XferID {
            id: try!(buffer.read_u64::<LittleEndian>()),
            packet: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SendXferPacket_DataPacket {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SendXferPacket_DataPacket {
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ConfirmXferPacket_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ConfirmXferPacket_XferID {
            id: try!(buffer.read_u64::<LittleEndian>()),
            packet: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AbortXfer_XferID {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AbortXfer_XferID {
            id: try!(buffer.read_u64::<LittleEndian>()),
            result: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AvatarAnimation_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAnimation_Sender {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarAnimation_AnimationList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAnimation_AnimationList {
            anim_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            anim_sequence_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AvatarAnimation_AnimationSourceList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAnimation_AnimationSourceList {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarAnimation_PhysicalAvatarEventList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAnimation_PhysicalAvatarEventList {
            type_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarAppearance_Sender {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAppearance_Sender {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_trial: try!(buffer.read_u8()) == 1,
        })
    }
}

impl AvatarAppearance_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAppearance_ObjectData {
            texture_entry: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarAppearance_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarAppearance_VisualParam { param_value: try!(buffer.read_u8()) })
    }
}

impl AvatarSitResponse_SitObject {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarSitResponse_SitObject {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarSitResponse_SitTransform {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarSitResponse_SitTransform {
            auto_pilot: try!(buffer.read_u8()) == 1,
            sit_position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            sit_rotation: Quaternion::from_parts(1.,
                                                 Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                              try!(buffer.read_f32::<LittleEndian>()),
                                                              try!(buffer.read_f32::<LittleEndian>()))),
            camera_eye_offset: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                            try!(buffer.read_f32::<LittleEndian>()),
                                            try!(buffer.read_f32::<LittleEndian>())),
            camera_at_offset: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>())),
            force_mouselook: try!(buffer.read_u8()) == 1,
        })
    }
}

impl SetFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetFollowCamProperties_CameraProperty {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetFollowCamProperties_CameraProperty {
            type_: try!(buffer.read_i32::<LittleEndian>()),
            value: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ClearFollowCamProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ClearFollowCamProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CameraConstraint_CameraCollidePlane {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CameraConstraint_CameraCollidePlane {
            plane: Vector4::new(try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>()),
                                try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ObjectProperties_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectProperties_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creation_date: try!(buffer.read_u64::<LittleEndian>()),
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            ownership_cost: try!(buffer.read_i32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            aggregate_perms: try!(buffer.read_u8()),
            aggregate_perm_textures: try!(buffer.read_u8()),
            aggregate_perm_textures_owner: try!(buffer.read_u8()),
            category: try!(buffer.read_u32::<LittleEndian>()),
            inventory_serial: try!(buffer.read_i16::<LittleEndian>()),
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            from_task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            last_owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            touch_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sit_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            texture_id: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectPropertiesFamily_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectPropertiesFamily_ObjectData {
            request_flags: try!(buffer.read_u32::<LittleEndian>()),
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            ownership_cost: try!(buffer.read_i32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            category: try!(buffer.read_u32::<LittleEndian>()),
            last_owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RequestPayPrice_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestPayPrice_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PayPriceReply_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PayPriceReply_ObjectData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            default_pay_price: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl PayPriceReply_ButtonData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PayPriceReply_ButtonData { pay_button: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl KickUser_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(KickUser_TargetBlock {
            target_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            target_port: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl KickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(KickUser_UserInfo {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            reason: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl KickUserAck_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(KickUserAck_UserInfo {
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GodKickUser_UserInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodKickUser_UserInfo {
            god_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            god_session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            kick_flags: try!(buffer.read_u32::<LittleEndian>()),
            reason: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SystemKickUser_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SystemKickUser_AgentInfo {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectUser_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectUser_Data {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl FreezeUser_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FreezeUser_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FreezeUser_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FreezeUser_Data {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AvatarPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPropertiesRequestBackend_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesRequestBackend_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            god_level: try!(buffer.read_u8()),
            web_profiles_disabled: try!(buffer.read_u8()) == 1,
        })
    }
}

impl AvatarPropertiesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPropertiesReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesReply_PropertiesData {
            image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            fl_image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            partner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            about_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            fl_about_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            born_on: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            profile_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            charter_member: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AvatarInterestsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarInterestsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarInterestsReply_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarInterestsReply_PropertiesData {
            want_to_mask: try!(buffer.read_u32::<LittleEndian>()),
            want_to_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            skills_mask: try!(buffer.read_u32::<LittleEndian>()),
            skills_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            languages_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarGroupsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarGroupsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            avatar_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarGroupsReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarGroupsReply_GroupData {
            group_powers: try!(buffer.read_u64::<LittleEndian>()),
            accept_notices: try!(buffer.read_u8()) == 1,
            group_title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            group_insignia_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarGroupsReply_NewGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarGroupsReply_NewGroupData { list_in_profile: try!(buffer.read_u8()) == 1 })
    }
}

impl AvatarPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPropertiesUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPropertiesUpdate_PropertiesData {
            image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            fl_image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            about_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            fl_about_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
            profile_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarInterestsUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarInterestsUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarInterestsUpdate_PropertiesData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarInterestsUpdate_PropertiesData {
            want_to_mask: try!(buffer.read_u32::<LittleEndian>()),
            want_to_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            skills_mask: try!(buffer.read_u32::<LittleEndian>()),
            skills_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            languages_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarNotesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarNotesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarNotesReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarNotesReply_Data {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            notes: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarNotesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarNotesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarNotesUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarNotesUpdate_Data {
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            notes: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AvatarPicksReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPicksReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AvatarPicksReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AvatarPicksReply_Data {
            pick_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pick_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EventInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventInfoRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventInfoRequest_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl EventInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventInfoReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventInfoReply_EventData {
            event_id: try!(buffer.read_u32::<LittleEndian>()),
            creator: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            category: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            date_utc: try!(buffer.read_u32::<LittleEndian>()),
            duration: try!(buffer.read_u32::<LittleEndian>()),
            cover: try!(buffer.read_u32::<LittleEndian>()),
            amount: try!(buffer.read_u32::<LittleEndian>()),
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            global_pos: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            event_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl EventNotificationAddRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventNotificationAddRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventNotificationAddRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventNotificationAddRequest_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl EventNotificationRemoveRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventNotificationRemoveRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventNotificationRemoveRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventNotificationRemoveRequest_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl EventGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventGodDelete_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventGodDelete_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl EventGodDelete_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventGodDelete_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            query_flags: try!(buffer.read_u32::<LittleEndian>()),
            query_start: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl PickInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PickInfoReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickInfoReply_Data {
            pick_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            top_pick: try!(buffer.read_u8()) == 1,
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            user: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            original_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            pos_global: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            sort_order: try!(buffer.read_i32::<LittleEndian>()),
            enabled: try!(buffer.read_u8()) == 1,
        })
    }
}

impl PickInfoUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickInfoUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PickInfoUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickInfoUpdate_Data {
            pick_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            top_pick: try!(buffer.read_u8()) == 1,
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pos_global: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            sort_order: try!(buffer.read_i32::<LittleEndian>()),
            enabled: try!(buffer.read_u8()) == 1,
        })
    }
}

impl PickDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PickDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickDelete_Data {
            pick_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PickGodDelete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickGodDelete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PickGodDelete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PickGodDelete_Data {
            pick_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptQuestion_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptQuestion_Data {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            object_owner: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            questions: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ScriptControlChange_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptControlChange_Data {
            take_controls: try!(buffer.read_u8()) == 1,
            controls: try!(buffer.read_u32::<LittleEndian>()),
            pass_to_agent: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ScriptDialog_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDialog_Data {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            first_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            last_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            object_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            chat_channel: try!(buffer.read_i32::<LittleEndian>()),
            image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptDialog_Buttons {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDialog_Buttons {
            button_label: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ScriptDialog_OwnerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDialog_OwnerData {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptDialogReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDialogReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptDialogReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDialogReply_Data {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            chat_channel: try!(buffer.read_i32::<LittleEndian>()),
            button_index: try!(buffer.read_i32::<LittleEndian>()),
            button_label: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ForceScriptControlRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ForceScriptControlRelease_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RevokePermissions_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RevokePermissions_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RevokePermissions_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RevokePermissions_Data {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_permissions: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl LoadURL_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LoadURL_Data {
            object_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_is_group: try!(buffer.read_u8()) == 1,
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ScriptTeleportRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptTeleportRequest_Data {
            object_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            sim_position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl ParcelOverlay_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelOverlay_ParcelData {
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ParcelPropertiesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelPropertiesRequest_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesRequest_ParcelData {
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            west: try!(buffer.read_f32::<LittleEndian>()),
            south: try!(buffer.read_f32::<LittleEndian>()),
            east: try!(buffer.read_f32::<LittleEndian>()),
            north: try!(buffer.read_f32::<LittleEndian>()),
            snap_selection: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ParcelPropertiesRequestByID_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesRequestByID_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelPropertiesRequestByID_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesRequestByID_ParcelData {
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelProperties_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelProperties_ParcelData {
            request_result: try!(buffer.read_i32::<LittleEndian>()),
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            snap_selection: try!(buffer.read_u8()) == 1,
            self_count: try!(buffer.read_i32::<LittleEndian>()),
            other_count: try!(buffer.read_i32::<LittleEndian>()),
            public_count: try!(buffer.read_i32::<LittleEndian>()),
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_group_owned: try!(buffer.read_u8()) == 1,
            auction_id: try!(buffer.read_u32::<LittleEndian>()),
            claim_date: try!(buffer.read_i32::<LittleEndian>()),
            claim_price: try!(buffer.read_i32::<LittleEndian>()),
            rent_price: try!(buffer.read_i32::<LittleEndian>()),
            aabb_min: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            aabb_max: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            bitmap: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            area: try!(buffer.read_i32::<LittleEndian>()),
            status: try!(buffer.read_u8()),
            sim_wide_max_prims: try!(buffer.read_i32::<LittleEndian>()),
            sim_wide_total_prims: try!(buffer.read_i32::<LittleEndian>()),
            max_prims: try!(buffer.read_i32::<LittleEndian>()),
            total_prims: try!(buffer.read_i32::<LittleEndian>()),
            owner_prims: try!(buffer.read_i32::<LittleEndian>()),
            group_prims: try!(buffer.read_i32::<LittleEndian>()),
            other_prims: try!(buffer.read_i32::<LittleEndian>()),
            selected_prims: try!(buffer.read_i32::<LittleEndian>()),
            parcel_prim_bonus: try!(buffer.read_f32::<LittleEndian>()),
            other_clean_time: try!(buffer.read_i32::<LittleEndian>()),
            parcel_flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            music_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            media_auto_scale: try!(buffer.read_u8()),
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pass_price: try!(buffer.read_i32::<LittleEndian>()),
            pass_hours: try!(buffer.read_f32::<LittleEndian>()),
            category: try!(buffer.read_u8()),
            auth_buyer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            user_location: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            user_look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            landing_type: try!(buffer.read_u8()),
            region_push_override: try!(buffer.read_u8()) == 1,
            region_deny_anonymous: try!(buffer.read_u8()) == 1,
            region_deny_identified: try!(buffer.read_u8()) == 1,
            region_deny_transacted: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ParcelProperties_AgeVerificationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelProperties_AgeVerificationBlock { region_deny_age_unverified: try!(buffer.read_u8()) == 1 })
    }
}

impl ParcelPropertiesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelPropertiesUpdate_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelPropertiesUpdate_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            parcel_flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            music_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            media_auto_scale: try!(buffer.read_u8()),
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pass_price: try!(buffer.read_i32::<LittleEndian>()),
            pass_hours: try!(buffer.read_f32::<LittleEndian>()),
            category: try!(buffer.read_u8()),
            auth_buyer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            user_location: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            user_look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            landing_type: try!(buffer.read_u8()),
        })
    }
}

impl ParcelReturnObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReturnObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelReturnObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReturnObjects_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            return_type: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelReturnObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReturnObjects_TaskIDs {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelReturnObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReturnObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelSetOtherCleanTime_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSetOtherCleanTime_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelSetOtherCleanTime_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSetOtherCleanTime_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            other_clean_time: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelDisableObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDisableObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDisableObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDisableObjects_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            return_type: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelDisableObjects_TaskIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDisableObjects_TaskIDs {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDisableObjects_OwnerIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDisableObjects_OwnerIDs {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelSelectObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSelectObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelSelectObjects_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSelectObjects_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            return_type: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelSelectObjects_ReturnIDs {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSelectObjects_ReturnIDs {
            return_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EstateCovenantRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EstateCovenantRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EstateCovenantReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EstateCovenantReply_Data {
            covenant_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            covenant_timestamp: try!(buffer.read_u32::<LittleEndian>()),
            estate_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            estate_owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ForceObjectSelect_Header {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ForceObjectSelect_Header { reset_list: try!(buffer.read_u8()) == 1 })
    }
}

impl ForceObjectSelect_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ForceObjectSelect_Data { local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ParcelBuyPass_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelBuyPass_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelBuyPass_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelBuyPass_ParcelData { local_id: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl ParcelDeedToGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDeedToGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDeedToGroup_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDeedToGroup_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelReclaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReclaim_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelReclaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelReclaim_Data { local_id: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl ParcelClaim_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelClaim_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelClaim_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelClaim_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_group_owned: try!(buffer.read_u8()) == 1,
            final_: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ParcelClaim_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelClaim_ParcelData {
            west: try!(buffer.read_f32::<LittleEndian>()),
            south: try!(buffer.read_f32::<LittleEndian>()),
            east: try!(buffer.read_f32::<LittleEndian>()),
            north: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ParcelJoin_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelJoin_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelJoin_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelJoin_ParcelData {
            west: try!(buffer.read_f32::<LittleEndian>()),
            south: try!(buffer.read_f32::<LittleEndian>()),
            east: try!(buffer.read_f32::<LittleEndian>()),
            north: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ParcelDivide_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDivide_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDivide_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDivide_ParcelData {
            west: try!(buffer.read_f32::<LittleEndian>()),
            south: try!(buffer.read_f32::<LittleEndian>()),
            east: try!(buffer.read_f32::<LittleEndian>()),
            north: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ParcelRelease_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelRelease_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelRelease_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelRelease_Data { local_id: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl ParcelBuy_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelBuy_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelBuy_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelBuy_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_group_owned: try!(buffer.read_u8()) == 1,
            remove_contribution: try!(buffer.read_u8()) == 1,
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            final_: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ParcelBuy_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelBuy_ParcelData {
            price: try!(buffer.read_i32::<LittleEndian>()),
            area: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelGodForceOwner_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelGodForceOwner_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelGodForceOwner_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelGodForceOwner_Data {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelAccessListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelAccessListRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListRequest_Data {
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelAccessListReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListReply_Data {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelAccessListReply_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListReply_List {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            time: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelAccessListUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelAccessListUpdate_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListUpdate_Data {
            flags: try!(buffer.read_u32::<LittleEndian>()),
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sequence_id: try!(buffer.read_i32::<LittleEndian>()),
            sections: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ParcelAccessListUpdate_List {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAccessListUpdate_List {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            time: try!(buffer.read_i32::<LittleEndian>()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelDwellRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDwellRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDwellRequest_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDwellRequest_Data {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDwellReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDwellReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelDwellReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelDwellReply_Data {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dwell: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl RequestParcelTransfer_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestParcelTransfer_Data {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_time: try!(buffer.read_u32::<LittleEndian>()),
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u8()),
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            amount: try!(buffer.read_i32::<LittleEndian>()),
            billable_area: try!(buffer.read_i32::<LittleEndian>()),
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
            final_: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RequestParcelTransfer_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestParcelTransfer_RegionData {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl UpdateParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateParcel_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_owned: try!(buffer.read_u8()) == 1,
            status: try!(buffer.read_u8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            music_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            region_x: try!(buffer.read_f32::<LittleEndian>()),
            region_y: try!(buffer.read_f32::<LittleEndian>()),
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
            billable_area: try!(buffer.read_i32::<LittleEndian>()),
            show_dir: try!(buffer.read_u8()) == 1,
            is_for_sale: try!(buffer.read_u8()) == 1,
            category: try!(buffer.read_u8()),
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            user_location: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>()),
                                        try!(buffer.read_f32::<LittleEndian>())),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            authorized_buyer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RemoveParcel_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveParcel_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MergeParcel_MasterParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MergeParcel_MasterParcelData {
            master_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MergeParcel_SlaveParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MergeParcel_SlaveParcelData {
            slave_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogParcelChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogParcelChanges_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogParcelChanges_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogParcelChanges_RegionData { region_handle: try!(buffer.read_u64::<LittleEndian>()) })
    }
}

impl LogParcelChanges_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogParcelChanges_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_owner_group: try!(buffer.read_u8()) == 1,
            actual_area: try!(buffer.read_i32::<LittleEndian>()),
            action: try!(buffer.read_i8()),
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CheckParcelSales_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CheckParcelSales_RegionData { region_handle: try!(buffer.read_u64::<LittleEndian>()) })
    }
}

impl ParcelSales_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelSales_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            buyer_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelGodMarkAsContent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelGodMarkAsContent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ParcelGodMarkAsContent_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelGodMarkAsContent_ParcelData { local_id: try!(buffer.read_i32::<LittleEndian>()) })
    }
}

impl ViewerStartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStartAuction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ViewerStartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerStartAuction_ParcelData {
            local_id: try!(buffer.read_i32::<LittleEndian>()),
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StartAuction_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartAuction_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StartAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            snapshot_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ConfirmAuctionStart_AuctionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ConfirmAuctionStart_AuctionData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            auction_id: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl CompleteAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CompleteAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CancelAuction_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CancelAuction_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CheckParcelAuctions_RegionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CheckParcelAuctions_RegionData { region_handle: try!(buffer.read_u64::<LittleEndian>()) })
    }
}

impl ParcelAuctions_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelAuctions_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            winner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UUIDNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UUIDNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UUIDNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UUIDNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            first_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            last_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UUIDGroupNameRequest_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UUIDGroupNameRequest_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UUIDGroupNameReply_UUIDNameBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UUIDGroupNameReply_UUIDNameBlock {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ChatPass_ChatData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChatPass_ChatData {
            channel: try!(buffer.read_i32::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            source_type: try!(buffer.read_u8()),
            type_: try!(buffer.read_u8()),
            radius: try!(buffer.read_f32::<LittleEndian>()),
            sim_access: try!(buffer.read_u8()),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EdgeDataPacket_EdgeData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EdgeDataPacket_EdgeData {
            layer_type: try!(buffer.read_u8()),
            direction: try!(buffer.read_u8()),
            layer_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SimStatus_SimStatus {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimStatus_SimStatus {
            can_accept_agents: try!(buffer.read_u8()) == 1,
            can_accept_tasks: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ChildAgentUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_AgentData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            viewer_circuit_code: try!(buffer.read_u32::<LittleEndian>()),
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            agent_vel: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            center: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            size: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>())),
            at_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            left_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            up_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            changed_grid: try!(buffer.read_u8()) == 1,
            far: try!(buffer.read_f32::<LittleEndian>()),
            aspect: try!(buffer.read_f32::<LittleEndian>()),
            throttles: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            locomotion_state: try!(buffer.read_u32::<LittleEndian>()),
            head_rotation: Quaternion::from_parts(1.,
                                                  Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()))),
            body_rotation: Quaternion::from_parts(1.,
                                                  Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()),
                                                               try!(buffer.read_f32::<LittleEndian>()))),
            control_flags: try!(buffer.read_u32::<LittleEndian>()),
            energy_level: try!(buffer.read_f32::<LittleEndian>()),
            god_level: try!(buffer.read_u8()),
            always_run: try!(buffer.read_u8()) == 1,
            prey_agent: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_access: try!(buffer.read_u8()),
            agent_textures: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            active_group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChildAgentUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_powers: try!(buffer.read_u64::<LittleEndian>()),
            accept_notices: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ChildAgentUpdate_AnimationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_AnimationData {
            animation: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChildAgentUpdate_GranterBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_GranterBlock {
            granter_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChildAgentUpdate_NVPairData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_NVPairData {
            nv_pairs: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ChildAgentUpdate_VisualParam {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_VisualParam { param_value: try!(buffer.read_u8()) })
    }
}

impl ChildAgentUpdate_AgentAccess {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_AgentAccess {
            agent_legacy_access: try!(buffer.read_u8()),
            agent_max_access: try!(buffer.read_u8()),
        })
    }
}

impl ChildAgentUpdate_AgentInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUpdate_AgentInfo { flags: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ChildAgentAlive_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentAlive_AgentData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            viewer_circuit_code: try!(buffer.read_u32::<LittleEndian>()),
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChildAgentPositionUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentPositionUpdate_AgentData {
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            viewer_circuit_code: try!(buffer.read_u32::<LittleEndian>()),
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            agent_vel: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            center: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>()),
                                 try!(buffer.read_f32::<LittleEndian>())),
            size: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>()),
                               try!(buffer.read_f32::<LittleEndian>())),
            at_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            left_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            up_axis: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            changed_grid: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ChildAgentDying_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentDying_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChildAgentUnknown_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChildAgentUnknown_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AtomicPassObject_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AtomicPassObject_TaskData {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            attachment_needs_save: try!(buffer.read_u8()) == 1,
        })
    }
}

impl KillChildAgents_IDBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(KillChildAgents_IDBlock {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GetScriptRunning_Script {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptRunningReply_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptRunningReply_Script {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            running: try!(buffer.read_u8()) == 1,
        })
    }
}

impl SetScriptRunning_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetScriptRunning_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetScriptRunning_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetScriptRunning_Script {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            running: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ScriptReset_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptReset_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptReset_Script {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptReset_Script {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptSensorRequest_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptSensorRequest_Requester {
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            search_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            search_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                     try!(buffer.read_f32::<LittleEndian>()),
                                     try!(buffer.read_f32::<LittleEndian>())),
            search_dir: Quaternion::from_parts(1.,
                                               Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                            try!(buffer.read_f32::<LittleEndian>()),
                                                            try!(buffer.read_f32::<LittleEndian>()))),
            search_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            type_: try!(buffer.read_i32::<LittleEndian>()),
            range: try!(buffer.read_f32::<LittleEndian>()),
            arc: try!(buffer.read_f32::<LittleEndian>()),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            search_regions: try!(buffer.read_u8()),
        })
    }
}

impl ScriptSensorReply_Requester {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptSensorReply_Requester {
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ScriptSensorReply_SensedData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptSensorReply_SensedData {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            velocity: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            rotation: Quaternion::from_parts(1.,
                                             Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()),
                                                          try!(buffer.read_f32::<LittleEndian>()))),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            type_: try!(buffer.read_i32::<LittleEndian>()),
            range: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl CompleteAgentMovement_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CompleteAgentMovement_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            circuit_code: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentMovementComplete_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentMovementComplete_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentMovementComplete_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentMovementComplete_Data {
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            timestamp: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentMovementComplete_SimData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentMovementComplete_SimData {
            channel_version: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl DataServerLogout_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DataServerLogout_UserData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            viewer_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            disconnect: try!(buffer.read_u8()) == 1,
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogoutRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogoutRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogoutReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogoutReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogoutReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogoutReply_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ImprovedInstantMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImprovedInstantMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ImprovedInstantMessage_MessageBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ImprovedInstantMessage_MessageBlock {
            from_group: try!(buffer.read_u8()) == 1,
            to_agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_estate_id: try!(buffer.read_u32::<LittleEndian>()),
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            offline: try!(buffer.read_u8()),
            dialog: try!(buffer.read_u8()),
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            timestamp: try!(buffer.read_u32::<LittleEndian>()),
            from_agent_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            binary_bucket: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RetrieveInstantMessages_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RetrieveInstantMessages_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FindAgent_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FindAgent_AgentBlock {
            hunter: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            prey: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            space_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
        })
    }
}

impl FindAgent_LocationBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FindAgent_LocationBlock {
            global_x: try!(buffer.read_f64::<LittleEndian>()),
            global_y: try!(buffer.read_f64::<LittleEndian>()),
        })
    }
}

impl RequestGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestGodlikePowers_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestGodlikePowers_RequestBlock {
            godlike: try!(buffer.read_u8()) == 1,
            token: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GrantGodlikePowers_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GrantGodlikePowers_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GrantGodlikePowers_GrantData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GrantGodlikePowers_GrantData {
            god_level: try!(buffer.read_u8()),
            token: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GodlikeMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodlikeMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GodlikeMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodlikeMessage_MethodData {
            method: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GodlikeMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GodlikeMessage_ParamList {
            parameter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EstateOwnerMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EstateOwnerMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EstateOwnerMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EstateOwnerMessage_MethodData {
            method: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EstateOwnerMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EstateOwnerMessage_ParamList {
            parameter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GenericMessage_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GenericMessage_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GenericMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GenericMessage_MethodData {
            method: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GenericMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GenericMessage_ParamList {
            parameter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MuteListRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MuteListRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MuteListRequest_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MuteListRequest_MuteData { mute_crc: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl UpdateMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            mute_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            mute_type: try!(buffer.read_i32::<LittleEndian>()),
            mute_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RemoveMuteListEntry_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveMuteListEntry_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveMuteListEntry_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveMuteListEntry_MuteData {
            mute_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            mute_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CopyInventoryFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CopyInventoryFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CopyInventoryFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CopyInventoryFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CopyInventoryFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CopyInventoryFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl UpdateCreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateCreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sim_approved: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateCreateInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateCreateInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl MoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            stamp: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            new_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CopyInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CopyInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CopyInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CopyInventoryItem_InventoryData {
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            old_agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            old_item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            new_folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            new_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RemoveInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveInventoryItem_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryItem_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChangeInventoryItemFlags_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChangeInventoryItemFlags_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChangeInventoryItemFlags_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChangeInventoryItemFlags_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SaveAssetIntoInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SaveAssetIntoInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SaveAssetIntoInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SaveAssetIntoInventory_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            new_asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UpdateInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            stamp: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MoveInventoryFolder_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveInventoryFolder_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveInventoryFolder_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryFolder_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveInventoryFolder_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryFolder_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FetchInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FetchInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sort_order: try!(buffer.read_i32::<LittleEndian>()),
            fetch_folders: try!(buffer.read_u8()) == 1,
            fetch_items: try!(buffer.read_u8()) == 1,
        })
    }
}

impl InventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            version: try!(buffer.read_i32::<LittleEndian>()),
            descendents: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl InventoryDescendents_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InventoryDescendents_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl InventoryDescendents_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InventoryDescendents_ItemData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl FetchInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FetchInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventory_InventoryData {
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FetchInventoryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventoryReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FetchInventoryReply_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FetchInventoryReply_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl BulkUpdateInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(BulkUpdateInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl BulkUpdateInventory_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(BulkUpdateInventory_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl BulkUpdateInventory_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(BulkUpdateInventory_ItemData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RequestInventoryAsset_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestInventoryAsset_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl InventoryAssetResponse_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InventoryAssetResponse_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_readable: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RemoveInventoryObjects_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryObjects_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveInventoryObjects_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryObjects_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveInventoryObjects_ItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveInventoryObjects_ItemData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PurgeInventoryDescendents_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PurgeInventoryDescendents_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl PurgeInventoryDescendents_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PurgeInventoryDescendents_InventoryData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateTaskInventory_UpdateData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateTaskInventory_UpdateData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            key: try!(buffer.read_u8()),
        })
    }
}

impl UpdateTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateTaskInventory_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RemoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveTaskInventory_InventoryData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MoveTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MoveTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoveTaskInventory_InventoryData {
            local_id: try!(buffer.read_u32::<LittleEndian>()),
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestTaskInventory_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestTaskInventory_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RequestTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RequestTaskInventory_InventoryData { local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl ReplyTaskInventory_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ReplyTaskInventory_InventoryData {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial: try!(buffer.read_i16::<LittleEndian>()),
            filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl DeRezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeRezObject_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DeRezObject_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeRezObject_AgentBlock {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            destination: try!(buffer.read_u8()),
            destination_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            packet_count: try!(buffer.read_u8()),
            packet_number: try!(buffer.read_u8()),
        })
    }
}

impl DeRezObject_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeRezObject_ObjectData { object_local_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl DeRezAck_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeRezAck_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            success: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RezObject_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObject_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezObject_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObject_RezData {
            from_task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            bypass_raycast: try!(buffer.read_u8()),
            ray_start: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            ray_end: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            ray_target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            ray_end_is_intersection: try!(buffer.read_u8()) == 1,
            rez_selected: try!(buffer.read_u8()) == 1,
            remove_item: try!(buffer.read_u8()) == 1,
            item_flags: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RezObject_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObject_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RezObjectFromNotecard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObjectFromNotecard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezObjectFromNotecard_RezData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObjectFromNotecard_RezData {
            from_task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            bypass_raycast: try!(buffer.read_u8()),
            ray_start: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>()),
                                    try!(buffer.read_f32::<LittleEndian>())),
            ray_end: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>()),
                                  try!(buffer.read_f32::<LittleEndian>())),
            ray_target_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            ray_end_is_intersection: try!(buffer.read_u8()) == 1,
            rez_selected: try!(buffer.read_u8()) == 1,
            remove_item: try!(buffer.read_u8()) == 1,
            item_flags: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RezObjectFromNotecard_NotecardData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObjectFromNotecard_NotecardData {
            notecard_item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezObjectFromNotecard_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezObjectFromNotecard_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TransferInventory_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferInventory_InfoBlock {
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TransferInventory_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferInventory_InventoryBlock {
            inventory_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
        })
    }
}

impl TransferInventoryAck_InfoBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TransferInventoryAck_InfoBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            inventory_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptFriendship_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptFriendship_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DeclineFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeclineFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DeclineFriendship_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeclineFriendship_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl FormFriendship_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(FormFriendship_AgentBlock {
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TerminateFriendship_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TerminateFriendship_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl TerminateFriendship_ExBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(TerminateFriendship_ExBlock {
            other_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl OfferCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(OfferCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl OfferCallingCard_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(OfferCallingCard_AgentBlock {
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AcceptCallingCard_FolderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AcceptCallingCard_FolderData {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DeclineCallingCard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeclineCallingCard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl DeclineCallingCard_TransactionBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeclineCallingCard_TransactionBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezScript_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezScript_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezScript_UpdateBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezScript_UpdateBlock {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            enabled: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RezScript_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezScript_InventoryBlock {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl CreateInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateInventoryItem_InventoryBlock {
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            wearable_type: try!(buffer.read_u8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CreateLandmarkForEvent_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateLandmarkForEvent_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateLandmarkForEvent_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateLandmarkForEvent_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl CreateLandmarkForEvent_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateLandmarkForEvent_InventoryBlock {
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EventLocationRequest_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventLocationRequest_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventLocationRequest_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventLocationRequest_EventData { event_id: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl EventLocationReply_QueryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventLocationReply_QueryData {
            query_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EventLocationReply_EventData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EventLocationReply_EventData {
            success: try!(buffer.read_u8()) == 1,
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                     try!(buffer.read_f32::<LittleEndian>()),
                                     try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl RegionHandleRequest_RequestBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionHandleRequest_RequestBlock {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RegionIDAndHandleReply_ReplyBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RegionIDAndHandleReply_ReplyBlock {
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
        })
    }
}

impl MoneyTransferRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyTransferRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MoneyTransferRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyTransferRequest_MoneyData {
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u8()),
            amount: try!(buffer.read_i32::<LittleEndian>()),
            aggregate_perm_next_owner: try!(buffer.read_u8()),
            aggregate_perm_inventory: try!(buffer.read_u8()),
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MoneyTransferBackend_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyTransferBackend_MoneyData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_time: try!(buffer.read_u32::<LittleEndian>()),
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u8()),
            amount: try!(buffer.read_i32::<LittleEndian>()),
            aggregate_perm_next_owner: try!(buffer.read_u8()),
            aggregate_perm_inventory: try!(buffer.read_u8()),
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MoneyBalanceRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyBalanceRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MoneyBalanceRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyBalanceRequest_MoneyData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_success: try!(buffer.read_u8()) == 1,
            money_balance: try!(buffer.read_i32::<LittleEndian>()),
            square_meters_credit: try!(buffer.read_i32::<LittleEndian>()),
            square_meters_committed: try!(buffer.read_i32::<LittleEndian>()),
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MoneyBalanceReply_TransactionInfo {
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_source_group: try!(buffer.read_u8()) == 1,
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_dest_group: try!(buffer.read_u8()) == 1,
            amount: try!(buffer.read_i32::<LittleEndian>()),
            item_description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RoutedMoneyBalanceReply_TargetBlock {
            target_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            target_port: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl RoutedMoneyBalanceReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RoutedMoneyBalanceReply_MoneyData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_success: try!(buffer.read_u8()) == 1,
            money_balance: try!(buffer.read_i32::<LittleEndian>()),
            square_meters_credit: try!(buffer.read_i32::<LittleEndian>()),
            square_meters_committed: try!(buffer.read_i32::<LittleEndian>()),
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RoutedMoneyBalanceReply_TransactionInfo {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RoutedMoneyBalanceReply_TransactionInfo {
            transaction_type: try!(buffer.read_i32::<LittleEndian>()),
            source_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_source_group: try!(buffer.read_u8()) == 1,
            dest_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            is_dest_group: try!(buffer.read_u8()) == 1,
            amount: try!(buffer.read_i32::<LittleEndian>()),
            item_description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ActivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ActivateGestures_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ActivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ActivateGestures_Data {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            gesture_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DeactivateGestures_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeactivateGestures_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl DeactivateGestures_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DeactivateGestures_Data {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            gesture_flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl MuteListUpdate_MuteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MuteListUpdate_MuteData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UseCachedMuteList_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UseCachedMuteList_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GrantUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GrantUserRights_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GrantUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GrantUserRights_Rights {
            agent_related: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            related_rights: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl ChangeUserRights_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChangeUserRights_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ChangeUserRights_Rights {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ChangeUserRights_Rights {
            agent_related: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            related_rights: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl OnlineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(OnlineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl OfflineNotification_AgentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(OfflineNotification_AgentBlock {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetStartLocationRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetStartLocationRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetStartLocationRequest_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetStartLocationRequest_StartLocationData {
            sim_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            location_id: try!(buffer.read_u32::<LittleEndian>()),
            location_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            location_look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl SetStartLocation_StartLocationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetStartLocation_StartLocationData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            region_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            location_id: try!(buffer.read_u32::<LittleEndian>()),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
            location_pos: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>()),
                                       try!(buffer.read_f32::<LittleEndian>())),
            location_look_at: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>()),
                                           try!(buffer.read_f32::<LittleEndian>())),
        })
    }
}

impl NetTest_NetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NetTest_NetBlock { port: try!(buffer.read_u16::<LittleEndian>()) })
    }
}

impl SetCPURatio_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetCPURatio_Data { ratio: try!(buffer.read_u8()) })
    }
}

impl SimCrashed_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimCrashed_Data {
            region_x: try!(buffer.read_u32::<LittleEndian>()),
            region_y: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl SimCrashed_Users {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SimCrashed_Users {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl NameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NameValuePair_TaskData {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl NameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(NameValuePair_NameValueData {
            nv_pair: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RemoveNameValuePair_TaskData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveNameValuePair_TaskData {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveNameValuePair_NameValueData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveNameValuePair_NameValueData {
            nv_pair: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UpdateAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateAttachment_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateAttachment_AttachmentBlock { attachment_point: try!(buffer.read_u8()) })
    }
}

impl UpdateAttachment_OperationData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateAttachment_OperationData {
            add_item: try!(buffer.read_u8()) == 1,
            use_existing_asset: try!(buffer.read_u8()) == 1,
        })
    }
}

impl UpdateAttachment_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateAttachment_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RemoveAttachment_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveAttachment_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RemoveAttachment_AttachmentBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RemoveAttachment_AttachmentBlock {
            attachment_point: try!(buffer.read_u8()),
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SoundTrigger_SoundData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SoundTrigger_SoundData {
            sound_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            parent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            handle: try!(buffer.read_u64::<LittleEndian>()),
            position: Vector3::new(try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>()),
                                   try!(buffer.read_f32::<LittleEndian>())),
            gain: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl AttachedSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AttachedSound_DataBlock {
            sound_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            gain: try!(buffer.read_f32::<LittleEndian>()),
            flags: try!(buffer.read_u8()),
        })
    }
}

impl AttachedSoundGainChange_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AttachedSoundGainChange_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            gain: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl PreloadSound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(PreloadSound_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            sound_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AssetUploadRequest_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AssetUploadRequest_AssetBlock {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            tempfile: try!(buffer.read_u8()) == 1,
            store_local: try!(buffer.read_u8()) == 1,
            asset_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AssetUploadComplete_AssetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AssetUploadComplete_AssetBlock {
            uuid: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            success: try!(buffer.read_u8()) == 1,
        })
    }
}

impl EmailMessageRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EmailMessageRequest_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            from_address: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            subject: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl EmailMessageReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EmailMessageReply_DataBlock {
            object_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            more: try!(buffer.read_u32::<LittleEndian>()),
            time: try!(buffer.read_u32::<LittleEndian>()),
            from_address: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            subject: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            mail_filter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl InternalScriptMail_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InternalScriptMail_DataBlock {
            from: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            to: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            subject: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            body: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ScriptDataRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDataRequest_DataBlock {
            hash: try!(buffer.read_u64::<LittleEndian>()),
            request_type: try!(buffer.read_i8()),
            request: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ScriptDataReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptDataReply_DataBlock {
            hash: try!(buffer.read_u64::<LittleEndian>()),
            reply: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CreateGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateGroupRequest_GroupData {
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            charter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            show_in_list: try!(buffer.read_u8()) == 1,
            insignia_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            membership_fee: try!(buffer.read_i32::<LittleEndian>()),
            open_enrollment: try!(buffer.read_u8()) == 1,
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
        })
    }
}

impl CreateGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateGroupReply_ReplyData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            success: try!(buffer.read_u8()) == 1,
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UpdateGroupInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateGroupInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateGroupInfo_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateGroupInfo_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            charter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            show_in_list: try!(buffer.read_u8()) == 1,
            insignia_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            membership_fee: try!(buffer.read_i32::<LittleEndian>()),
            open_enrollment: try!(buffer.read_u8()) == 1,
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
        })
    }
}

impl GroupRoleChanges_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleChanges_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleChanges_RoleChange {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleChanges_RoleChange {
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            member_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            change: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl JoinGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(JoinGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl JoinGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(JoinGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl JoinGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(JoinGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl JoinGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(JoinGroupReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            success: try!(buffer.read_u8()) == 1,
        })
    }
}

impl EjectGroupMemberRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectGroupMemberRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectGroupMemberRequest_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberRequest_EjectData {
            ejectee_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectGroupMemberReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectGroupMemberReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl EjectGroupMemberReply_EjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(EjectGroupMemberReply_EjectData { success: try!(buffer.read_u8()) == 1 })
    }
}

impl LeaveGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LeaveGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LeaveGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LeaveGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LeaveGroupReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LeaveGroupReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LeaveGroupReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LeaveGroupReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            success: try!(buffer.read_u8()) == 1,
        })
    }
}

impl InviteGroupRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InviteGroupRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl InviteGroupRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InviteGroupRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl InviteGroupRequest_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InviteGroupRequest_InviteData {
            invitee_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl InviteGroupResponse_InviteData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InviteGroupResponse_InviteData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            invitee_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            membership_fee: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupProfileRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProfileRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupProfileRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProfileRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupProfileReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProfileReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupProfileReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProfileReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            charter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            show_in_list: try!(buffer.read_u8()) == 1,
            member_title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            powers_mask: try!(buffer.read_u64::<LittleEndian>()),
            insignia_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            founder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            membership_fee: try!(buffer.read_i32::<LittleEndian>()),
            open_enrollment: try!(buffer.read_u8()) == 1,
            money: try!(buffer.read_i32::<LittleEndian>()),
            group_membership_count: try!(buffer.read_i32::<LittleEndian>()),
            group_roles_count: try!(buffer.read_i32::<LittleEndian>()),
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
            owner_role: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountSummaryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountSummaryRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountSummaryRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountSummaryRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupAccountSummaryReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountSummaryReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountSummaryReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountSummaryReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
            start_date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            balance: try!(buffer.read_i32::<LittleEndian>()),
            total_credits: try!(buffer.read_i32::<LittleEndian>()),
            total_debits: try!(buffer.read_i32::<LittleEndian>()),
            object_tax_current: try!(buffer.read_i32::<LittleEndian>()),
            light_tax_current: try!(buffer.read_i32::<LittleEndian>()),
            land_tax_current: try!(buffer.read_i32::<LittleEndian>()),
            group_tax_current: try!(buffer.read_i32::<LittleEndian>()),
            parcel_dir_fee_current: try!(buffer.read_i32::<LittleEndian>()),
            object_tax_estimate: try!(buffer.read_i32::<LittleEndian>()),
            light_tax_estimate: try!(buffer.read_i32::<LittleEndian>()),
            land_tax_estimate: try!(buffer.read_i32::<LittleEndian>()),
            group_tax_estimate: try!(buffer.read_i32::<LittleEndian>()),
            parcel_dir_fee_estimate: try!(buffer.read_i32::<LittleEndian>()),
            non_exempt_members: try!(buffer.read_i32::<LittleEndian>()),
            last_tax_date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            tax_date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupAccountDetailsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountDetailsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountDetailsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountDetailsRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupAccountDetailsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountDetailsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountDetailsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountDetailsReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
            start_date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupAccountDetailsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountDetailsReply_HistoryData {
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            amount: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupAccountTransactionsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountTransactionsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountTransactionsRequest_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountTransactionsRequest_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupAccountTransactionsReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountTransactionsReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupAccountTransactionsReply_MoneyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountTransactionsReply_MoneyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            interval_days: try!(buffer.read_i32::<LittleEndian>()),
            current_interval: try!(buffer.read_i32::<LittleEndian>()),
            start_date: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupAccountTransactionsReply_HistoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupAccountTransactionsReply_HistoryData {
            time: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            user: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            type_: try!(buffer.read_i32::<LittleEndian>()),
            item: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            amount: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupActiveProposalsRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalsRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupActiveProposalsRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalsRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupActiveProposalsRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalsRequest_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupActiveProposalItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupActiveProposalItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            total_num_items: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GroupActiveProposalItemReply_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupActiveProposalItemReply_ProposalData {
            vote_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            vote_initiator: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terse_date_id: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            start_date_time: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            end_date_time: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            already_voted: try!(buffer.read_u8()) == 1,
            vote_cast: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            majority: try!(buffer.read_f32::<LittleEndian>()),
            quorum: try!(buffer.read_i32::<LittleEndian>()),
            proposal_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupVoteHistoryRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupVoteHistoryRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupVoteHistoryRequest_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryRequest_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupVoteHistoryItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupVoteHistoryItemReply_TransactionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryItemReply_TransactionData {
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            total_num_items: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GroupVoteHistoryItemReply_HistoryItemData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryItemReply_HistoryItemData {
            vote_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            terse_date_id: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            start_date_time: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            end_date_time: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            vote_initiator: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            vote_type: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            vote_result: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            majority: try!(buffer.read_f32::<LittleEndian>()),
            quorum: try!(buffer.read_i32::<LittleEndian>()),
            proposal_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupVoteHistoryItemReply_VoteItem {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupVoteHistoryItemReply_VoteItem {
            candidate_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            vote_cast: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            num_votes: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl StartGroupProposal_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartGroupProposal_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl StartGroupProposal_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(StartGroupProposal_ProposalData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            quorum: try!(buffer.read_i32::<LittleEndian>()),
            majority: try!(buffer.read_f32::<LittleEndian>()),
            duration: try!(buffer.read_i32::<LittleEndian>()),
            proposal_text: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupProposalBallot_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProposalBallot_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupProposalBallot_ProposalData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupProposalBallot_ProposalData {
            proposal_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            vote_cast: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupMembersRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupMembersReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupMembersReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupMembersReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            member_count: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupMembersReply_MemberData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            contribution: try!(buffer.read_i32::<LittleEndian>()),
            online_status: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            agent_powers: try!(buffer.read_u64::<LittleEndian>()),
            title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            is_owner: try!(buffer.read_u8()) == 1,
        })
    }
}

impl ActivateGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ActivateGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetGroupContribution_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetGroupContribution_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetGroupContribution_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetGroupContribution_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            contribution: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl SetGroupAcceptNotices_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetGroupAcceptNotices_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl SetGroupAcceptNotices_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetGroupAcceptNotices_Data {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            accept_notices: try!(buffer.read_u8()) == 1,
        })
    }
}

impl SetGroupAcceptNotices_NewData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SetGroupAcceptNotices_NewData { list_in_profile: try!(buffer.read_u8()) == 1 })
    }
}

impl GroupRoleDataRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleDataRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleDataRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleDataRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleDataReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleDataReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleDataReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleDataReply_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            role_count: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl GroupRoleDataReply_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleDataReply_RoleData {
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            powers: try!(buffer.read_u64::<LittleEndian>()),
            members: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GroupRoleMembersRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleMembersRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleMembersRequest_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleMembersRequest_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleMembersReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleMembersReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            total_pairs: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl GroupRoleMembersReply_MemberData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleMembersReply_MemberData {
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            member_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupTitlesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupTitlesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupTitlesReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupTitlesReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupTitlesReply_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupTitlesReply_GroupData {
            title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            selected: try!(buffer.read_u8()) == 1,
        })
    }
}

impl GroupTitleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupTitleUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            title_role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl GroupRoleUpdate_RoleData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupRoleUpdate_RoleData {
            role_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            powers: try!(buffer.read_u64::<LittleEndian>()),
            update_type: try!(buffer.read_u8()),
        })
    }
}

impl LiveHelpGroupRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LiveHelpGroupRequest_RequestData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LiveHelpGroupReply_ReplyData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LiveHelpGroupReply_ReplyData {
            request_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            selection: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentWearablesRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentWearablesRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentWearablesUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentWearablesUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl AgentWearablesUpdate_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentWearablesUpdate_WearableData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            wearable_type: try!(buffer.read_u8()),
        })
    }
}

impl AgentIsNowWearing_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentIsNowWearing_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentIsNowWearing_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentIsNowWearing_WearableData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            wearable_type: try!(buffer.read_u8()),
        })
    }
}

impl AgentCachedTexture_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentCachedTexture_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AgentCachedTexture_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentCachedTexture_WearableData {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            texture_index: try!(buffer.read_u8()),
        })
    }
}

impl AgentCachedTextureResponse_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentCachedTextureResponse_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            serial_num: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl AgentCachedTextureResponse_WearableData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentCachedTextureResponse_WearableData {
            texture_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            texture_index: try!(buffer.read_u8()),
            host_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentDataUpdateRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentDataUpdateRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            first_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            last_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            group_title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            active_group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_powers: try!(buffer.read_u64::<LittleEndian>()),
            group_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl GroupDataUpdate_AgentGroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(GroupDataUpdate_AgentGroupData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_powers: try!(buffer.read_u64::<LittleEndian>()),
            group_title: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentGroupDataUpdate_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentGroupDataUpdate_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl AgentGroupDataUpdate_GroupData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentGroupDataUpdate_GroupData {
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_powers: try!(buffer.read_u64::<LittleEndian>()),
            accept_notices: try!(buffer.read_u8()) == 1,
            group_insignia_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            contribution: try!(buffer.read_i32::<LittleEndian>()),
            group_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl AgentDropGroup_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(AgentDropGroup_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LogTextMessage_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LogTextMessage_DataBlock {
            from_agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            to_agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            global_x: try!(buffer.read_f64::<LittleEndian>()),
            global_y: try!(buffer.read_f64::<LittleEndian>()),
            time: try!(buffer.read_u32::<LittleEndian>()),
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ViewerEffect_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerEffect_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ViewerEffect_Effect {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ViewerEffect_Effect {
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_u8()),
            duration: try!(buffer.read_f32::<LittleEndian>()),
            color: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            type_data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl CreateTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            digest: {
                let mut raw = [0; 32];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl DenyTrustedCircuit_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DenyTrustedCircuit_DataBlock {
            end_point_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezSingleAttachmentFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezSingleAttachmentFromInv_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezSingleAttachmentFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezSingleAttachmentFromInv_ObjectData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            attachment_pt: try!(buffer.read_u8()),
            item_flags: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RezMultipleAttachmentsFromInv_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezMultipleAttachmentsFromInv_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezMultipleAttachmentsFromInv_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezMultipleAttachmentsFromInv_HeaderData {
            compound_msg_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            total_objects: try!(buffer.read_u8()),
            first_detach_all: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RezMultipleAttachmentsFromInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezMultipleAttachmentsFromInv_ObjectData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            attachment_pt: try!(buffer.read_u8()),
            item_flags: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl DetachAttachmentIntoInv_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(DetachAttachmentIntoInv_ObjectData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateNewOutfitAttachments_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateNewOutfitAttachments_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateNewOutfitAttachments_HeaderData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateNewOutfitAttachments_HeaderData {
            new_folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl CreateNewOutfitAttachments_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(CreateNewOutfitAttachments_ObjectData {
            old_item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            old_folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UserInfoRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserInfoRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UserInfoReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserInfoReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UserInfoReply_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UserInfoReply_UserData {
            im_via_e_mail: try!(buffer.read_u8()) == 1,
            directory_visibility: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            e_mail: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl UpdateUserInfo_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateUserInfo_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl UpdateUserInfo_UserData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(UpdateUserInfo_UserData {
            im_via_e_mail: try!(buffer.read_u8()) == 1,
            directory_visibility: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ParcelRename_ParcelData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelRename_ParcelData {
            parcel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            new_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl InitiateDownload_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InitiateDownload_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl InitiateDownload_FileData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(InitiateDownload_FileData {
            sim_filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            viewer_filename: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SystemMessage_MethodData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SystemMessage_MethodData {
            method: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            invoice: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            digest: {
                let mut raw = [0; 32];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SystemMessage_ParamList {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SystemMessage_ParamList {
            parameter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MapLayerRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapLayerRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MapLayerReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapLayerReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl MapLayerReply_LayerData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapLayerReply_LayerData {
            left: try!(buffer.read_u32::<LittleEndian>()),
            right: try!(buffer.read_u32::<LittleEndian>()),
            top: try!(buffer.read_u32::<LittleEndian>()),
            bottom: try!(buffer.read_u32::<LittleEndian>()),
            image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MapBlockRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapBlockRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MapBlockRequest_PositionData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapBlockRequest_PositionData {
            min_x: try!(buffer.read_u16::<LittleEndian>()),
            max_x: try!(buffer.read_u16::<LittleEndian>()),
            min_y: try!(buffer.read_u16::<LittleEndian>()),
            max_y: try!(buffer.read_u16::<LittleEndian>()),
        })
    }
}

impl MapNameRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapNameRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MapNameRequest_NameData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapNameRequest_NameData {
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl MapBlockReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapBlockReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl MapBlockReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapBlockReply_Data {
            x: try!(buffer.read_u16::<LittleEndian>()),
            y: try!(buffer.read_u16::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            access: try!(buffer.read_u8()),
            region_flags: try!(buffer.read_u32::<LittleEndian>()),
            water_height: try!(buffer.read_u8()),
            agents: try!(buffer.read_u8()),
            map_image_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl MapItemRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapItemRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
            estate_id: try!(buffer.read_u32::<LittleEndian>()),
            godlike: try!(buffer.read_u8()) == 1,
        })
    }
}

impl MapItemRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapItemRequest_RequestData {
            item_type: try!(buffer.read_u32::<LittleEndian>()),
            region_handle: try!(buffer.read_u64::<LittleEndian>()),
        })
    }
}

impl MapItemReply_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapItemReply_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl MapItemReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapItemReply_RequestData { item_type: try!(buffer.read_u32::<LittleEndian>()) })
    }
}

impl MapItemReply_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(MapItemReply_Data {
            x: try!(buffer.read_u32::<LittleEndian>()),
            y: try!(buffer.read_u32::<LittleEndian>()),
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            extra: try!(buffer.read_i32::<LittleEndian>()),
            extra2: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl SendPostcard_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(SendPostcard_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            asset_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            pos_global: Vector3::new(try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>()),
                                     try!(buffer.read_f64::<LittleEndian>())),
            to: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            from: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            subject: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            msg: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            allow_publish: try!(buffer.read_u8()) == 1,
            mature_publish: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RpcChannelRequest_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcChannelRequest_DataBlock {
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RpcChannelReply_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcChannelReply_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RpcScriptRequestInbound_TargetBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcScriptRequestInbound_TargetBlock {
            grid_x: try!(buffer.read_u32::<LittleEndian>()),
            grid_y: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl RpcScriptRequestInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcScriptRequestInbound_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            int_value: try!(buffer.read_u32::<LittleEndian>()),
            string_value: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RpcScriptRequestInboundForward_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcScriptRequestInboundForward_DataBlock {
            rpc_server_ip: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                Ip4Addr::from(raw)
            },
            rpc_server_port: try!(buffer.read_u16::<LittleEndian>()),
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            int_value: try!(buffer.read_u32::<LittleEndian>()),
            string_value: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl RpcScriptReplyInbound_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RpcScriptReplyInbound_DataBlock {
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            channel_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            int_value: try!(buffer.read_u32::<LittleEndian>()),
            string_value: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ScriptMailRegistration_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ScriptMailRegistration_DataBlock {
            target_ip: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            target_port: try!(buffer.read_u16::<LittleEndian>()),
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            flags: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl ParcelMediaCommandMessage_CommandBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelMediaCommandMessage_CommandBlock {
            flags: try!(buffer.read_u32::<LittleEndian>()),
            command: try!(buffer.read_u32::<LittleEndian>()),
            time: try!(buffer.read_f32::<LittleEndian>()),
        })
    }
}

impl ParcelMediaUpdate_DataBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelMediaUpdate_DataBlock {
            media_url: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            media_auto_scale: try!(buffer.read_u8()),
        })
    }
}

impl ParcelMediaUpdate_DataBlockExtended {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ParcelMediaUpdate_DataBlockExtended {
            media_type: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_desc: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            media_width: try!(buffer.read_i32::<LittleEndian>()),
            media_height: try!(buffer.read_i32::<LittleEndian>()),
            media_loop: try!(buffer.read_u8()),
        })
    }
}

impl LandStatRequest_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LandStatRequest_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LandStatRequest_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LandStatRequest_RequestData {
            report_type: try!(buffer.read_u32::<LittleEndian>()),
            request_flags: try!(buffer.read_u32::<LittleEndian>()),
            filter: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            parcel_local_id: try!(buffer.read_i32::<LittleEndian>()),
        })
    }
}

impl LandStatReply_RequestData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LandStatReply_RequestData {
            report_type: try!(buffer.read_u32::<LittleEndian>()),
            request_flags: try!(buffer.read_u32::<LittleEndian>()),
            total_object_count: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl LandStatReply_ReportData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LandStatReply_ReportData {
            task_local_id: try!(buffer.read_u32::<LittleEndian>()),
            task_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            location_x: try!(buffer.read_f32::<LittleEndian>()),
            location_y: try!(buffer.read_f32::<LittleEndian>()),
            location_z: try!(buffer.read_f32::<LittleEndian>()),
            score: try!(buffer.read_f32::<LittleEndian>()),
            task_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            owner_name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl Error_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Error_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl Error_Data {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(Error_Data {
            code: try!(buffer.read_i32::<LittleEndian>()),
            token: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            system: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            message: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            data: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}

impl ObjectIncludeInSearch_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectIncludeInSearch_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl ObjectIncludeInSearch_ObjectData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(ObjectIncludeInSearch_ObjectData {
            object_local_id: try!(buffer.read_u32::<LittleEndian>()),
            include_in_search: try!(buffer.read_u8()) == 1,
        })
    }
}

impl RezRestoreToWorld_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezRestoreToWorld_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl RezRestoreToWorld_InventoryData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(RezRestoreToWorld_InventoryData {
            item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            creator_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            owner_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            group_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            base_mask: try!(buffer.read_u32::<LittleEndian>()),
            owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_mask: try!(buffer.read_u32::<LittleEndian>()),
            everyone_mask: try!(buffer.read_u32::<LittleEndian>()),
            next_owner_mask: try!(buffer.read_u32::<LittleEndian>()),
            group_owned: try!(buffer.read_u8()) == 1,
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            flags: try!(buffer.read_u32::<LittleEndian>()),
            sale_type: try!(buffer.read_u8()),
            sale_price: try!(buffer.read_i32::<LittleEndian>()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            creation_date: try!(buffer.read_i32::<LittleEndian>()),
            crc: try!(buffer.read_u32::<LittleEndian>()),
        })
    }
}

impl LinkInventoryItem_AgentData {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LinkInventoryItem_AgentData {
            agent_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            session_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
        })
    }
}

impl LinkInventoryItem_InventoryBlock {
    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<Self, ReadMessageError>
        where R: Read
    {
        Ok(LinkInventoryItem_InventoryBlock {
            callback_id: try!(buffer.read_u32::<LittleEndian>()),
            folder_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            transaction_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            old_item_id: {
                let mut raw = [0; 4];
                try!(buffer.read_exact(&mut raw));
                try!(Uuid::from_bytes(&raw))
            },
            type_: try!(buffer.read_i8()),
            inv_type: try!(buffer.read_i8()),
            name: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
            description: {
                let n = try!(buffer.read_u8()) as usize;
                let mut raw = vec![0; n];
                try!(buffer.read_exact(&mut raw));
                raw
            },
        })
    }
}



// Message IMPLEMENTATIONS



impl Message for TestMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x01]));
        // Block TestBlock1
        try!(buffer.write_u32::<LittleEndian>(self.test_block1.test1));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test0));
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test1));
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test2));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TestBlock1
        let test_block1 = try!(TestMessage_TestBlock1::read_from(buffer));
        // Block NeighborBlock
        let neighbor_block = [try!(TestMessage_NeighborBlock::read_from(buffer)),
                              try!(TestMessage_NeighborBlock::read_from(buffer)),
                              try!(TestMessage_NeighborBlock::read_from(buffer)),
                              try!(TestMessage_NeighborBlock::read_from(buffer))];
        Ok(MessageInstance::TestMessage(TestMessage {
            test_block1: test_block1,
            neighbor_block: neighbor_block,
        }))
    }
}

impl Message for PacketAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFB]));
        // Block Packets
        try!(buffer.write_u8(self.packets.len() as u8));
        for item in &self.packets {
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Packets
        let mut packets = Vec::new();
        let _packets_count = try!(buffer.read_u8());
        for _ in 0.._packets_count {
            packets.push(try!(PacketAck_Packets::read_from(buffer)));
        }
        Ok(MessageInstance::PacketAck(PacketAck { packets: packets }))
    }
}

impl Message for OpenCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFC]));
        // Block CircuitInfo
        try!(buffer.write(&self.circuit_info.ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.circuit_info.port));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block CircuitInfo
        let circuit_info = try!(OpenCircuit_CircuitInfo::read_from(buffer));
        Ok(MessageInstance::OpenCircuit(OpenCircuit { circuit_info: circuit_info }))
    }
}

impl Message for CloseCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFD]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::CloseCircuit(CloseCircuit {}))
    }
}

impl Message for StartPingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x01]));
        // Block PingID
        try!(buffer.write_u8(self.ping_id.ping_id));
        try!(buffer.write_u32::<LittleEndian>(self.ping_id.oldest_unacked));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block PingID
        let ping_id = try!(StartPingCheck_PingID::read_from(buffer));
        Ok(MessageInstance::StartPingCheck(StartPingCheck { ping_id: ping_id }))
    }
}

impl Message for CompletePingCheck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x02]));
        // Block PingID
        try!(buffer.write_u8(self.ping_id.ping_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block PingID
        let ping_id = try!(CompletePingCheck_PingID::read_from(buffer));
        Ok(MessageInstance::CompletePingCheck(CompletePingCheck { ping_id: ping_id }))
    }
}

impl Message for AddCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x02]));
        // Block CircuitCode
        try!(buffer.write_u32::<LittleEndian>(self.circuit_code.code));
        try!(buffer.write(self.circuit_code.session_id.as_bytes()));
        try!(buffer.write(self.circuit_code.agent_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block CircuitCode
        let circuit_code = try!(AddCircuitCode_CircuitCode::read_from(buffer));
        Ok(MessageInstance::AddCircuitCode(AddCircuitCode { circuit_code: circuit_code }))
    }
}

impl Message for UseCircuitCode {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x03]));
        // Block CircuitCode
        try!(buffer.write_u32::<LittleEndian>(self.circuit_code.code));
        try!(buffer.write(self.circuit_code.session_id.as_bytes()));
        try!(buffer.write(self.circuit_code.id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block CircuitCode
        let circuit_code = try!(UseCircuitCode_CircuitCode::read_from(buffer));
        Ok(MessageInstance::UseCircuitCode(UseCircuitCode { circuit_code: circuit_code }))
    }
}

impl Message for NeighborList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x03]));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write(&self.neighbor_block[i].ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port));
            try!(buffer.write(&self.neighbor_block[i].public_ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].public_port));
            try!(buffer.write(self.neighbor_block[i].region_id.as_bytes()));
            try!(buffer.write(&self.neighbor_block[i].name[..]));
            try!(buffer.write_u8(self.neighbor_block[i].sim_access));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block NeighborBlock
        let neighbor_block = [try!(NeighborList_NeighborBlock::read_from(buffer)),
                              try!(NeighborList_NeighborBlock::read_from(buffer)),
                              try!(NeighborList_NeighborBlock::read_from(buffer)),
                              try!(NeighborList_NeighborBlock::read_from(buffer))];
        Ok(MessageInstance::NeighborList(NeighborList { neighbor_block: neighbor_block }))
    }
}

impl Message for AvatarTextureUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.textures_changed as u8));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.cache_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
            try!(buffer.write(&item.host_name[..]));
        }
        // Block TextureData
        try!(buffer.write_u8(self.texture_data.len() as u8));
        for item in &self.texture_data {
            try!(buffer.write(item.texture_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarTextureUpdate_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AvatarTextureUpdate_WearableData::read_from(buffer)));
        }
        // Block TextureData
        let mut texture_data = Vec::new();
        let _texture_data_count = try!(buffer.read_u8());
        for _ in 0.._texture_data_count {
            texture_data.push(try!(AvatarTextureUpdate_TextureData::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarTextureUpdate(AvatarTextureUpdate {
            agent_data: agent_data,
            wearable_data: wearable_data,
            texture_data: texture_data,
        }))
    }
}

impl Message for SimulatorMapUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x05]));
        // Block MapData
        try!(buffer.write_u32::<LittleEndian>(self.map_data.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MapData
        let map_data = try!(SimulatorMapUpdate_MapData::read_from(buffer));
        Ok(MessageInstance::SimulatorMapUpdate(SimulatorMapUpdate { map_data: map_data }))
    }
}

impl Message for SimulatorSetMap {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x06]));
        // Block MapData
        try!(buffer.write_u64::<LittleEndian>(self.map_data.region_handle));
        try!(buffer.write_i32::<LittleEndian>(self.map_data.type_));
        try!(buffer.write(self.map_data.map_image.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MapData
        let map_data = try!(SimulatorSetMap_MapData::read_from(buffer));
        Ok(MessageInstance::SimulatorSetMap(SimulatorSetMap { map_data: map_data }))
    }
}

impl Message for SubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x07]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::SubscribeLoad(SubscribeLoad {}))
    }
}

impl Message for UnsubscribeLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x08]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::UnsubscribeLoad(UnsubscribeLoad {}))
    }
}

impl Message for SimulatorReady {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x09]));
        // Block SimulatorBlock
        try!(buffer.write(&self.simulator_block.sim_name[..]));
        try!(buffer.write_u8(self.simulator_block.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags));
        try!(buffer.write(self.simulator_block.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id));
        // Block TelehubBlock
        try!(buffer.write_u8(self.telehub_block.has_telehub as u8));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimulatorBlock
        let simulator_block = try!(SimulatorReady_SimulatorBlock::read_from(buffer));
        // Block TelehubBlock
        let telehub_block = try!(SimulatorReady_TelehubBlock::read_from(buffer));
        Ok(MessageInstance::SimulatorReady(SimulatorReady {
            simulator_block: simulator_block,
            telehub_block: telehub_block,
        }))
    }
}

impl Message for TelehubInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0a]));
        // Block TelehubBlock
        try!(buffer.write(self.telehub_block.object_id.as_bytes()));
        try!(buffer.write(&self.telehub_block.object_name[..]));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z));
        let normed_telehub_rot = UnitQuaternion::new(&self.telehub_block.telehub_rot).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.i));
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.j));
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.k));
        // Block SpawnPointBlock
        try!(buffer.write_u8(self.spawn_point_block.len() as u8));
        for item in &self.spawn_point_block {
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.x));
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.y));
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TelehubBlock
        let telehub_block = try!(TelehubInfo_TelehubBlock::read_from(buffer));
        // Block SpawnPointBlock
        let mut spawn_point_block = Vec::new();
        let _spawn_point_block_count = try!(buffer.read_u8());
        for _ in 0.._spawn_point_block_count {
            spawn_point_block.push(try!(TelehubInfo_SpawnPointBlock::read_from(buffer)));
        }
        Ok(MessageInstance::TelehubInfo(TelehubInfo {
            telehub_block: telehub_block,
            spawn_point_block: spawn_point_block,
        }))
    }
}

impl Message for SimulatorPresentAtLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0b]));
        // Block SimulatorPublicHostBlock
        try!(buffer.write_u16::<LittleEndian>(self.simulator_public_host_block.port));
        try!(buffer.write(&self.simulator_public_host_block.simulator_ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_y));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write(&self.neighbor_block[i].ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port));
        }
        // Block SimulatorBlock
        try!(buffer.write(&self.simulator_block.sim_name[..]));
        try!(buffer.write_u8(self.simulator_block.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags));
        try!(buffer.write(self.simulator_block.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id));
        // Block TelehubBlock
        try!(buffer.write_u8(self.telehub_block.len() as u8));
        for item in &self.telehub_block {
            try!(buffer.write_u8(item.has_telehub as u8));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.x));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.y));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimulatorPublicHostBlock
        let simulator_public_host_block =
            try!(SimulatorPresentAtLocation_SimulatorPublicHostBlock::read_from(buffer));
        // Block NeighborBlock
        let neighbor_block = [try!(SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)),
                              try!(SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)),
                              try!(SimulatorPresentAtLocation_NeighborBlock::read_from(buffer)),
                              try!(SimulatorPresentAtLocation_NeighborBlock::read_from(buffer))];
        // Block SimulatorBlock
        let simulator_block = try!(SimulatorPresentAtLocation_SimulatorBlock::read_from(buffer));
        // Block TelehubBlock
        let mut telehub_block = Vec::new();
        let _telehub_block_count = try!(buffer.read_u8());
        for _ in 0.._telehub_block_count {
            telehub_block.push(try!(SimulatorPresentAtLocation_TelehubBlock::read_from(buffer)));
        }
        Ok(MessageInstance::SimulatorPresentAtLocation(SimulatorPresentAtLocation {
            simulator_public_host_block: simulator_public_host_block,
            neighbor_block: neighbor_block,
            simulator_block: simulator_block,
            telehub_block: telehub_block,
        }))
    }
}

impl Message for SimulatorLoad {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0c]));
        // Block SimulatorLoad
        try!(buffer.write_f32::<LittleEndian>(self.simulator_load.time_dilation));
        try!(buffer.write_i32::<LittleEndian>(self.simulator_load.agent_count));
        try!(buffer.write_u8(self.simulator_load.can_accept_agents as u8));
        // Block AgentList
        try!(buffer.write_u8(self.agent_list.len() as u8));
        for item in &self.agent_list {
            try!(buffer.write_u32::<LittleEndian>(item.circuit_code));
            try!(buffer.write_u8(item.x));
            try!(buffer.write_u8(item.y));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimulatorLoad
        let simulator_load = try!(SimulatorLoad_SimulatorLoad::read_from(buffer));
        // Block AgentList
        let mut agent_list = Vec::new();
        let _agent_list_count = try!(buffer.read_u8());
        for _ in 0.._agent_list_count {
            agent_list.push(try!(SimulatorLoad_AgentList::read_from(buffer)));
        }
        Ok(MessageInstance::SimulatorLoad(SimulatorLoad {
            simulator_load: simulator_load,
            agent_list: agent_list,
        }))
    }
}

impl Message for SimulatorShutdownRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0d]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::SimulatorShutdownRequest(SimulatorShutdownRequest {}))
    }
}

impl Message for RegionPresenceRequestByRegionID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0e]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write(item.region_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = try!(buffer.read_u8());
        for _ in 0.._region_data_count {
            region_data.push(try!(RegionPresenceRequestByRegionID_RegionData::read_from(buffer)));
        }
        Ok(MessageInstance::RegionPresenceRequestByRegionID(RegionPresenceRequestByRegionID {
            region_data: region_data,
        }))
    }
}

impl Message for RegionPresenceRequestByHandle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0f]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = try!(buffer.read_u8());
        for _ in 0.._region_data_count {
            region_data.push(try!(RegionPresenceRequestByHandle_RegionData::read_from(buffer)));
        }
        Ok(MessageInstance::RegionPresenceRequestByHandle(RegionPresenceRequestByHandle {
            region_data: region_data,
        }))
    }
}

impl Message for RegionPresenceResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x10]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write(item.region_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
            try!(buffer.write(&item.internal_region_ip.octets()));
            try!(buffer.write(&item.external_region_ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(item.region_port));
            try!(buffer.write_f64::<LittleEndian>(item.valid_until));
            try!(buffer.write(&item.message[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = try!(buffer.read_u8());
        for _ in 0.._region_data_count {
            region_data.push(try!(RegionPresenceResponse_RegionData::read_from(buffer)));
        }
        Ok(MessageInstance::RegionPresenceResponse(RegionPresenceResponse { region_data: region_data }))
    }
}

impl Message for UpdateSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x11]));
        // Block SimulatorInfo
        try!(buffer.write(self.simulator_info.region_id.as_bytes()));
        try!(buffer.write(&self.simulator_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_info.estate_id));
        try!(buffer.write_u8(self.simulator_info.sim_access));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimulatorInfo
        let simulator_info = try!(UpdateSimulator_SimulatorInfo::read_from(buffer));
        Ok(MessageInstance::UpdateSimulator(UpdateSimulator { simulator_info: simulator_info }))
    }
}

impl Message for LogDwellTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x12]));
        // Block DwellInfo
        try!(buffer.write(self.dwell_info.agent_id.as_bytes()));
        try!(buffer.write(self.dwell_info.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.dwell_info.duration));
        try!(buffer.write(&self.dwell_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.dwell_info.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.dwell_info.region_y));
        try!(buffer.write_u8(self.dwell_info.avg_agents_in_view));
        try!(buffer.write_u8(self.dwell_info.avg_viewer_fps));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DwellInfo
        let dwell_info = try!(LogDwellTime_DwellInfo::read_from(buffer));
        Ok(MessageInstance::LogDwellTime(LogDwellTime { dwell_info: dwell_info }))
    }
}

impl Message for FeatureDisabled {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x13]));
        // Block FailureInfo
        try!(buffer.write(&self.failure_info.error_message[..]));
        try!(buffer.write(self.failure_info.agent_id.as_bytes()));
        try!(buffer.write(self.failure_info.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block FailureInfo
        let failure_info = try!(FeatureDisabled_FailureInfo::read_from(buffer));
        Ok(MessageInstance::FeatureDisabled(FeatureDisabled { failure_info: failure_info }))
    }
}

impl Message for LogFailedMoneyTransaction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x14]));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.transaction_time));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_data.transaction_type));
        try!(buffer.write(self.transaction_data.source_id.as_bytes()));
        try!(buffer.write(self.transaction_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_data.amount));
        try!(buffer.write(&self.transaction_data.simulator_ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.grid_y));
        try!(buffer.write_u8(self.transaction_data.failure_type));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransactionData
        let transaction_data = try!(LogFailedMoneyTransaction_TransactionData::read_from(buffer));
        Ok(MessageInstance::LogFailedMoneyTransaction(LogFailedMoneyTransaction {
            transaction_data: transaction_data,
        }))
    }
}

impl Message for UserReportInternal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x15]));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.report_type));
        try!(buffer.write_u8(self.report_data.category));
        try!(buffer.write(self.report_data.reporter_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.z));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.z));
        try!(buffer.write(self.report_data.screenshot_id.as_bytes()));
        try!(buffer.write(self.report_data.object_id.as_bytes()));
        try!(buffer.write(self.report_data.owner_id.as_bytes()));
        try!(buffer.write(self.report_data.last_owner_id.as_bytes()));
        try!(buffer.write(self.report_data.creator_id.as_bytes()));
        try!(buffer.write(self.report_data.region_id.as_bytes()));
        try!(buffer.write(self.report_data.abuser_id.as_bytes()));
        try!(buffer.write(&self.report_data.abuse_region_name[..]));
        try!(buffer.write(self.report_data.abuse_region_id.as_bytes()));
        try!(buffer.write(&self.report_data.summary[..]));
        try!(buffer.write(&self.report_data.details[..]));
        try!(buffer.write(&self.report_data.version_string[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ReportData
        let report_data = try!(UserReportInternal_ReportData::read_from(buffer));
        Ok(MessageInstance::UserReportInternal(UserReportInternal { report_data: report_data }))
    }
}

impl Message for SetSimStatusInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x16]));
        // Block Data
        try!(buffer.write(self.data.region_id.as_bytes()));
        try!(buffer.write(&self.data.host_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.x));
        try!(buffer.write_i32::<LittleEndian>(self.data.y));
        try!(buffer.write_i32::<LittleEndian>(self.data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.data.agent_count));
        try!(buffer.write_i32::<LittleEndian>(self.data.time_to_live));
        try!(buffer.write(&self.data.status[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(SetSimStatusInDatabase_Data::read_from(buffer));
        Ok(MessageInstance::SetSimStatusInDatabase(SetSimStatusInDatabase { data: data }))
    }
}

impl Message for SetSimPresenceInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x17]));
        // Block SimData
        try!(buffer.write(self.sim_data.region_id.as_bytes()));
        try!(buffer.write(&self.sim_data.host_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.sim_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.sim_data.grid_y));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.agent_count));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.time_to_live));
        try!(buffer.write(&self.sim_data.status[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimData
        let sim_data = try!(SetSimPresenceInDatabase_SimData::read_from(buffer));
        Ok(MessageInstance::SetSimPresenceInDatabase(SetSimPresenceInDatabase { sim_data: sim_data }))
    }
}

impl Message for EconomyDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x18]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::EconomyDataRequest(EconomyDataRequest {}))
    }
}

impl Message for EconomyData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x19]));
        // Block Info
        try!(buffer.write_i32::<LittleEndian>(self.info.object_capacity));
        try!(buffer.write_i32::<LittleEndian>(self.info.object_count));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_energy_unit));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_object_claim));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_public_object_decay));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_public_object_delete));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_parcel_claim));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_parcel_claim_factor));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_upload));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_rent_light));
        try!(buffer.write_i32::<LittleEndian>(self.info.teleport_min_price));
        try!(buffer.write_f32::<LittleEndian>(self.info.teleport_price_exponent));
        try!(buffer.write_f32::<LittleEndian>(self.info.energy_efficiency));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_object_rent));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_object_scale_factor));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_parcel_rent));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_group_create));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(EconomyData_Info::read_from(buffer));
        Ok(MessageInstance::EconomyData(EconomyData { info: info }))
    }
}

impl Message for AvatarPickerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block Data
        try!(buffer.write(&self.data.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPickerRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(AvatarPickerRequest_Data::read_from(buffer));
        Ok(MessageInstance::AvatarPickerRequest(AvatarPickerRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.god_level));
        // Block Data
        try!(buffer.write(&self.data.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPickerRequestBackend_AgentData::read_from(buffer));
        // Block Data
        let data = try!(AvatarPickerRequestBackend_Data::read_from(buffer));
        Ok(MessageInstance::AvatarPickerRequestBackend(AvatarPickerRequestBackend {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPickerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.avatar_id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPickerReply_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(AvatarPickerReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarPickerReply(AvatarPickerReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PlacesQuery_AgentData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(PlacesQuery_TransactionData::read_from(buffer));
        // Block QueryData
        let query_data = try!(PlacesQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::PlacesQuery(PlacesQuery {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for PlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        // Block QueryData
        try!(buffer.write_u8(self.query_data.len() as u8));
        for item in &self.query_data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.desc[..]));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
            try!(buffer.write_i32::<LittleEndian>(item.billable_area));
            try!(buffer.write_u8(item.flags));
            try!(buffer.write_f32::<LittleEndian>(item.global_x));
            try!(buffer.write_f32::<LittleEndian>(item.global_y));
            try!(buffer.write_f32::<LittleEndian>(item.global_z));
            try!(buffer.write(&item.sim_name[..]));
            try!(buffer.write(item.snapshot_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
            try!(buffer.write_i32::<LittleEndian>(item.price));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PlacesReply_AgentData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(PlacesReply_TransactionData::read_from(buffer));
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = try!(buffer.read_u8());
        for _ in 0.._query_data_count {
            query_data.push(try!(PlacesReply_QueryData::read_from(buffer)));
        }
        Ok(MessageInstance::PlacesReply(PlacesReply {
            agent_data: agent_data,
            transaction_data: transaction_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirFindQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirFindQuery_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirFindQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::DirFindQuery(DirFindQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirFindQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x20]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirFindQueryBackend_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirFindQueryBackend_QueryData::read_from(buffer));
        Ok(MessageInstance::DirFindQueryBackend(DirFindQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x21]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPlacesQuery_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPlacesQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::DirPlacesQuery(DirPlacesQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x22]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPlacesQueryBackend_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPlacesQueryBackend_QueryData::read_from(buffer));
        Ok(MessageInstance::DirPlacesQueryBackend(DirPlacesQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPlacesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x23]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write_u8(self.query_data.len() as u8));
        for item in &self.query_data {
            try!(buffer.write(item.query_id.as_bytes()));
        }
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.for_sale as u8));
            try!(buffer.write_u8(item.auction as u8));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPlacesReply_AgentData::read_from(buffer));
        // Block QueryData
        let mut query_data = Vec::new();
        let _query_data_count = try!(buffer.read_u8());
        for _ in 0.._query_data_count {
            query_data.push(try!(DirPlacesReply_QueryData::read_from(buffer)));
        }
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirPlacesReply_QueryReplies::read_from(buffer)));
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = try!(buffer.read_u8());
        for _ in 0.._status_data_count {
            status_data.push(try!(DirPlacesReply_StatusData::read_from(buffer)));
        }
        Ok(MessageInstance::DirPlacesReply(DirPlacesReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirPeopleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x24]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
            try!(buffer.write(&item.group[..]));
            try!(buffer.write_u8(item.online as u8));
            try!(buffer.write_i32::<LittleEndian>(item.reputation));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPeopleReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPeopleReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirPeopleReply_QueryReplies::read_from(buffer)));
        }
        Ok(MessageInstance::DirPeopleReply(DirPeopleReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirEventsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x25]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u32::<LittleEndian>(item.event_id));
            try!(buffer.write(&item.date[..]));
            try!(buffer.write_u32::<LittleEndian>(item.unix_time));
            try!(buffer.write_u32::<LittleEndian>(item.event_flags));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirEventsReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirEventsReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirEventsReply_QueryReplies::read_from(buffer)));
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = try!(buffer.read_u8());
        for _ in 0.._status_data_count {
            status_data.push(try!(DirEventsReply_StatusData::read_from(buffer)));
        }
        Ok(MessageInstance::DirEventsReply(DirEventsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for DirGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x26]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
            try!(buffer.write_i32::<LittleEndian>(item.members));
            try!(buffer.write_f32::<LittleEndian>(item.search_order));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirGroupsReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirGroupsReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirGroupsReply_QueryReplies::read_from(buffer)));
        }
        Ok(MessageInstance::DirGroupsReply(DirGroupsReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirClassifiedQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x27]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.category));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirClassifiedQuery_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirClassifiedQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::DirClassifiedQuery(DirClassifiedQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirClassifiedQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x28]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.category));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirClassifiedQueryBackend_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirClassifiedQueryBackend_QueryData::read_from(buffer));
        Ok(MessageInstance::DirClassifiedQueryBackend(DirClassifiedQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x29]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.classified_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.classified_flags));
            try!(buffer.write_u32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.expiration_date));
            try!(buffer.write_i32::<LittleEndian>(item.price_for_listing));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirClassifiedReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirClassifiedReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirClassifiedReply_QueryReplies::read_from(buffer)));
        }
        // Block StatusData
        let mut status_data = Vec::new();
        let _status_data_count = try!(buffer.read_u8());
        for _ in 0.._status_data_count {
            status_data.push(try!(DirClassifiedReply_StatusData::read_from(buffer)));
        }
        Ok(MessageInstance::DirClassifiedReply(DirClassifiedReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
            status_data: status_data,
        }))
    }
}

impl Message for AvatarClassifiedReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.target_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.classified_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarClassifiedReply_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(AvatarClassifiedReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarClassifiedReply(AvatarClassifiedReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ClassifiedInfoRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ClassifiedInfoRequest_Data::read_from(buffer));
        Ok(MessageInstance::ClassifiedInfoRequest(ClassifiedInfoRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.data.expiration_date));
        try!(buffer.write_u32::<LittleEndian>(self.data.category));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.parent_estate));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write(&self.data.parcel_name[..]));
        try!(buffer.write_u8(self.data.classified_flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.price_for_listing));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ClassifiedInfoReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ClassifiedInfoReply_Data::read_from(buffer));
        Ok(MessageInstance::ClassifiedInfoReply(ClassifiedInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.category));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.parent_estate));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_u8(self.data.classified_flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.price_for_listing));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ClassifiedInfoUpdate_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ClassifiedInfoUpdate_Data::read_from(buffer));
        Ok(MessageInstance::ClassifiedInfoUpdate(ClassifiedInfoUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ClassifiedDelete_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ClassifiedDelete_Data::read_from(buffer));
        Ok(MessageInstance::ClassifiedDelete(ClassifiedDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ClassifiedGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write(self.data.query_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ClassifiedGodDelete_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ClassifiedGodDelete_Data::read_from(buffer));
        Ok(MessageInstance::ClassifiedGodDelete(ClassifiedGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DirLandQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x30]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.search_type));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.area));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirLandQuery_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirLandQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::DirLandQuery(DirLandQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x31]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.search_type));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.area));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirLandQueryBackend_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirLandQueryBackend_QueryData::read_from(buffer));
        Ok(MessageInstance::DirLandQueryBackend(DirLandQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirLandReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x32]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.auction as u8));
            try!(buffer.write_u8(item.for_sale as u8));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirLandReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirLandReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirLandReply_QueryReplies::read_from(buffer)));
        }
        Ok(MessageInstance::DirLandReply(DirLandReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for DirPopularQuery {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x33]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPopularQuery_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPopularQuery_QueryData::read_from(buffer));
        Ok(MessageInstance::DirPopularQuery(DirPopularQuery {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPopularQueryBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x34]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPopularQueryBackend_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPopularQueryBackend_QueryData::read_from(buffer));
        Ok(MessageInstance::DirPopularQueryBackend(DirPopularQueryBackend {
            agent_data: agent_data,
            query_data: query_data,
        }))
    }
}

impl Message for DirPopularReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x35]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DirPopularReply_AgentData::read_from(buffer));
        // Block QueryData
        let query_data = try!(DirPopularReply_QueryData::read_from(buffer));
        // Block QueryReplies
        let mut query_replies = Vec::new();
        let _query_replies_count = try!(buffer.read_u8());
        for _ in 0.._query_replies_count {
            query_replies.push(try!(DirPopularReply_QueryReplies::read_from(buffer)));
        }
        Ok(MessageInstance::DirPopularReply(DirPopularReply {
            agent_data: agent_data,
            query_data: query_data,
            query_replies: query_replies,
        }))
    }
}

impl Message for ParcelInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x36]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelInfoRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelInfoRequest_Data::read_from(buffer));
        Ok(MessageInstance::ParcelInfoRequest(ParcelInfoRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x37]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.actual_area));
        try!(buffer.write_i32::<LittleEndian>(self.data.billable_area));
        try!(buffer.write_u8(self.data.flags));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_x));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_y));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_z));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data.dwell));
        try!(buffer.write_i32::<LittleEndian>(self.data.sale_price));
        try!(buffer.write_i32::<LittleEndian>(self.data.auction_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelInfoReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelInfoReply_Data::read_from(buffer));
        Ok(MessageInstance::ParcelInfoReply(ParcelInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelObjectOwnersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x38]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelObjectOwnersRequest_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelObjectOwnersRequest_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelObjectOwnersRequest(ParcelObjectOwnersRequest {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelObjectOwnersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x39]));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.is_group_owned as u8));
            try!(buffer.write_i32::<LittleEndian>(item.count));
            try!(buffer.write_u8(item.online_status as u8));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(ParcelObjectOwnersReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelObjectOwnersReply(ParcelObjectOwnersReply { data: data }))
    }
}

impl Message for GroupNoticesListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupNoticesListRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(GroupNoticesListRequest_Data::read_from(buffer));
        Ok(MessageInstance::GroupNoticesListRequest(GroupNoticesListRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GroupNoticesListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.notice_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.timestamp));
            try!(buffer.write(&item.from_name[..]));
            try!(buffer.write(&item.subject[..]));
            try!(buffer.write_u8(item.has_attachment as u8));
            try!(buffer.write_u8(item.asset_type));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupNoticesListReply_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(GroupNoticesListReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::GroupNoticesListReply(GroupNoticesListReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GroupNoticeRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_notice_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupNoticeRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(GroupNoticeRequest_Data::read_from(buffer));
        Ok(MessageInstance::GroupNoticeRequest(GroupNoticeRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for GroupNoticeAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block MessageBlock
        try!(buffer.write(self.message_block.to_group_id.as_bytes()));
        try!(buffer.write(self.message_block.id.as_bytes()));
        try!(buffer.write_u8(self.message_block.dialog));
        try!(buffer.write(&self.message_block.from_agent_name[..]));
        try!(buffer.write(&self.message_block.message[..]));
        try!(buffer.write(&self.message_block.binary_bucket[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupNoticeAdd_AgentData::read_from(buffer));
        // Block MessageBlock
        let message_block = try!(GroupNoticeAdd_MessageBlock::read_from(buffer));
        Ok(MessageInstance::GroupNoticeAdd(GroupNoticeAdd {
            agent_data: agent_data,
            message_block: message_block,
        }))
    }
}

impl Message for TeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write(self.info.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(TeleportRequest_AgentData::read_from(buffer));
        // Block Info
        let info = try!(TeleportRequest_Info::read_from(buffer));
        Ok(MessageInstance::TeleportRequest(TeleportRequest {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for TeleportLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(TeleportLocationRequest_AgentData::read_from(buffer));
        // Block Info
        let info = try!(TeleportLocationRequest_Info::read_from(buffer));
        Ok(MessageInstance::TeleportLocationRequest(TeleportLocationRequest {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for TeleportLocal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x40]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.location_id));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportLocal_Info::read_from(buffer));
        Ok(MessageInstance::TeleportLocal(TeleportLocal { info: info }))
    }
}

impl Message for TeleportLandmarkRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x41]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        try!(buffer.write(self.info.landmark_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportLandmarkRequest_Info::read_from(buffer));
        Ok(MessageInstance::TeleportLandmarkRequest(TeleportLandmarkRequest { info: info }))
    }
}

impl Message for TeleportProgress {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x42]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Info
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        try!(buffer.write(&self.info.message[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(TeleportProgress_AgentData::read_from(buffer));
        // Block Info
        let info = try!(TeleportProgress_Info::read_from(buffer));
        Ok(MessageInstance::TeleportProgress(TeleportProgress {
            agent_data: agent_data,
            info: info,
        }))
    }
}

impl Message for DataHomeLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x43]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.kicked_from_estate_id));
        // Block AgentInfo
        try!(buffer.write_u32::<LittleEndian>(self.agent_info.agent_effective_maturity));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(DataHomeLocationRequest_Info::read_from(buffer));
        // Block AgentInfo
        let agent_info = try!(DataHomeLocationRequest_AgentInfo::read_from(buffer));
        Ok(MessageInstance::DataHomeLocationRequest(DataHomeLocationRequest {
            info: info,
            agent_info: agent_info,
        }))
    }
}

impl Message for DataHomeLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x44]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(DataHomeLocationReply_Info::read_from(buffer));
        Ok(MessageInstance::DataHomeLocationReply(DataHomeLocationReply { info: info }))
    }
}

impl Message for TeleportFinish {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x45]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.location_id));
        try!(buffer.write(&self.info.sim_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.info.sim_port));
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write(&self.info.seed_capability[..]));
        try!(buffer.write_u8(self.info.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportFinish_Info::read_from(buffer));
        Ok(MessageInstance::TeleportFinish(TeleportFinish { info: info }))
    }
}

impl Message for StartLure {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x46]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write_u8(self.info.lure_type));
        try!(buffer.write(&self.info.message[..]));
        // Block TargetData
        try!(buffer.write_u8(self.target_data.len() as u8));
        for item in &self.target_data {
            try!(buffer.write(item.target_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(StartLure_AgentData::read_from(buffer));
        // Block Info
        let info = try!(StartLure_Info::read_from(buffer));
        // Block TargetData
        let mut target_data = Vec::new();
        let _target_data_count = try!(buffer.read_u8());
        for _ in 0.._target_data_count {
            target_data.push(try!(StartLure_TargetData::read_from(buffer)));
        }
        Ok(MessageInstance::StartLure(StartLure {
            agent_data: agent_data,
            info: info,
            target_data: target_data,
        }))
    }
}

impl Message for TeleportLureRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x47]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        try!(buffer.write(self.info.lure_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportLureRequest_Info::read_from(buffer));
        Ok(MessageInstance::TeleportLureRequest(TeleportLureRequest { info: info }))
    }
}

impl Message for TeleportCancel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x48]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportCancel_Info::read_from(buffer));
        Ok(MessageInstance::TeleportCancel(TeleportCancel { info: info }))
    }
}

impl Message for TeleportStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x49]));
        // Block Info
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportStart_Info::read_from(buffer));
        Ok(MessageInstance::TeleportStart(TeleportStart { info: info }))
    }
}

impl Message for TeleportFailed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4a]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(&self.info.reason[..]));
        // Block AlertInfo
        try!(buffer.write_u8(self.alert_info.len() as u8));
        for item in &self.alert_info {
            try!(buffer.write(&item.message[..]));
            try!(buffer.write(&item.extra_params[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Info
        let info = try!(TeleportFailed_Info::read_from(buffer));
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = try!(buffer.read_u8());
        for _ in 0.._alert_info_count {
            alert_info.push(try!(TeleportFailed_AlertInfo::read_from(buffer)));
        }
        Ok(MessageInstance::TeleportFailed(TeleportFailed {
            info: info,
            alert_info: alert_info,
        }))
    }
}

impl Message for Undo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(Undo_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(Undo_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::Undo(Undo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for Redo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(Redo_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(Redo_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::Redo(Redo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for UndoLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UndoLand_AgentData::read_from(buffer));
        Ok(MessageInstance::UndoLand(UndoLand { agent_data: agent_data }))
    }
}

impl Message for AgentPause {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentPause_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentPause(AgentPause { agent_data: agent_data }))
    }
}

impl Message for AgentResume {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentResume_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentResume(AgentResume { agent_data: agent_data }))
    }
}

impl Message for AgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.k));
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.k));
        try!(buffer.write_u8(self.agent_data.state));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.far));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.control_flags));
        try!(buffer.write_u8(self.agent_data.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentUpdate_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentUpdate(AgentUpdate { agent_data: agent_data }))
    }
}

impl Message for ChatFromViewer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x50]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ChatData
        try!(buffer.write(&self.chat_data.message[..]));
        try!(buffer.write_u8(self.chat_data.type_));
        try!(buffer.write_i32::<LittleEndian>(self.chat_data.channel));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChatFromViewer_AgentData::read_from(buffer));
        // Block ChatData
        let chat_data = try!(ChatFromViewer_ChatData::read_from(buffer));
        Ok(MessageInstance::ChatFromViewer(ChatFromViewer {
            agent_data: agent_data,
            chat_data: chat_data,
        }))
    }
}

impl Message for AgentThrottle {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x51]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block Throttle
        try!(buffer.write_u32::<LittleEndian>(self.throttle.gen_counter));
        try!(buffer.write(&self.throttle.throttles[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentThrottle_AgentData::read_from(buffer));
        // Block Throttle
        let throttle = try!(AgentThrottle_Throttle::read_from(buffer));
        Ok(MessageInstance::AgentThrottle(AgentThrottle {
            agent_data: agent_data,
            throttle: throttle,
        }))
    }
}

impl Message for AgentFOV {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x52]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block FOVBlock
        try!(buffer.write_u32::<LittleEndian>(self.fov_block.gen_counter));
        try!(buffer.write_f32::<LittleEndian>(self.fov_block.vertical_angle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentFOV_AgentData::read_from(buffer));
        // Block FOVBlock
        let fov_block = try!(AgentFOV_FOVBlock::read_from(buffer));
        Ok(MessageInstance::AgentFOV(AgentFOV {
            agent_data: agent_data,
            fov_block: fov_block,
        }))
    }
}

impl Message for AgentHeightWidth {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x53]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block HeightWidthBlock
        try!(buffer.write_u32::<LittleEndian>(self.height_width_block.gen_counter));
        try!(buffer.write_u16::<LittleEndian>(self.height_width_block.height));
        try!(buffer.write_u16::<LittleEndian>(self.height_width_block.width));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentHeightWidth_AgentData::read_from(buffer));
        // Block HeightWidthBlock
        let height_width_block = try!(AgentHeightWidth_HeightWidthBlock::read_from(buffer));
        Ok(MessageInstance::AgentHeightWidth(AgentHeightWidth {
            agent_data: agent_data,
            height_width_block: height_width_block,
        }))
    }
}

impl Message for AgentSetAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x54]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.cache_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
        }
        // Block ObjectData
        try!(buffer.write(&self.object_data.texture_entry[..]));
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentSetAppearance_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AgentSetAppearance_WearableData::read_from(buffer)));
        }
        // Block ObjectData
        let object_data = try!(AgentSetAppearance_ObjectData::read_from(buffer));
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = try!(buffer.read_u8());
        for _ in 0.._visual_param_count {
            visual_param.push(try!(AgentSetAppearance_VisualParam::read_from(buffer)));
        }
        Ok(MessageInstance::AgentSetAppearance(AgentSetAppearance {
            agent_data: agent_data,
            wearable_data: wearable_data,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AgentAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AnimationList
        try!(buffer.write_u8(self.animation_list.len() as u8));
        for item in &self.animation_list {
            try!(buffer.write(item.anim_id.as_bytes()));
            try!(buffer.write_u8(item.start_anim as u8));
        }
        // Block PhysicalAvatarEventList
        try!(buffer.write_u8(self.physical_avatar_event_list.len() as u8));
        for item in &self.physical_avatar_event_list {
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentAnimation_AgentData::read_from(buffer));
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = try!(buffer.read_u8());
        for _ in 0.._animation_list_count {
            animation_list.push(try!(AgentAnimation_AnimationList::read_from(buffer)));
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = try!(buffer.read_u8());
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list.push(try!(AgentAnimation_PhysicalAvatarEventList::read_from(buffer)));
        }
        Ok(MessageInstance::AgentAnimation(AgentAnimation {
            agent_data: agent_data,
            animation_list: animation_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AgentRequestSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x06]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TargetObject
        try!(buffer.write(self.target_object.target_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentRequestSit_AgentData::read_from(buffer));
        // Block TargetObject
        let target_object = try!(AgentRequestSit_TargetObject::read_from(buffer));
        Ok(MessageInstance::AgentRequestSit(AgentRequestSit {
            agent_data: agent_data,
            target_object: target_object,
        }))
    }
}

impl Message for AgentSit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentSit_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentSit(AgentSit { agent_data: agent_data }))
    }
}

impl Message for AgentQuitCopy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x55]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FuseBlock
        try!(buffer.write_u32::<LittleEndian>(self.fuse_block.viewer_circuit_code));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentQuitCopy_AgentData::read_from(buffer));
        // Block FuseBlock
        let fuse_block = try!(AgentQuitCopy_FuseBlock::read_from(buffer));
        Ok(MessageInstance::AgentQuitCopy(AgentQuitCopy {
            agent_data: agent_data,
            fuse_block: fuse_block,
        }))
    }
}

impl Message for RequestImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestImage
        try!(buffer.write_u8(self.request_image.len() as u8));
        for item in &self.request_image {
            try!(buffer.write(item.image.as_bytes()));
            try!(buffer.write_i8(item.discard_level));
            try!(buffer.write_f32::<LittleEndian>(item.download_priority));
            try!(buffer.write_u32::<LittleEndian>(item.packet));
            try!(buffer.write_u8(item.type_));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestImage_AgentData::read_from(buffer));
        // Block RequestImage
        let mut request_image = Vec::new();
        let _request_image_count = try!(buffer.read_u8());
        for _ in 0.._request_image_count {
            request_image.push(try!(RequestImage_RequestImage::read_from(buffer)));
        }
        Ok(MessageInstance::RequestImage(RequestImage {
            agent_data: agent_data,
            request_image: request_image,
        }))
    }
}

impl Message for ImageNotInDatabase {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x56]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ImageID
        let image_id = try!(ImageNotInDatabase_ImageID::read_from(buffer));
        Ok(MessageInstance::ImageNotInDatabase(ImageNotInDatabase { image_id: image_id }))
    }
}

impl Message for RebakeAvatarTextures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x57]));
        // Block TextureData
        try!(buffer.write(self.texture_data.texture_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TextureData
        let texture_data = try!(RebakeAvatarTextures_TextureData::read_from(buffer));
        Ok(MessageInstance::RebakeAvatarTextures(RebakeAvatarTextures { texture_data: texture_data }))
    }
}

impl Message for SetAlwaysRun {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x58]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.always_run as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SetAlwaysRun_AgentData::read_from(buffer));
        Ok(MessageInstance::SetAlwaysRun(SetAlwaysRun { agent_data: agent_data }))
    }
}

impl Message for ObjectAdd {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x01]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.p_code));
        try!(buffer.write_u8(self.object_data.material));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.add_flags));
        try!(buffer.write_u8(self.object_data.path_curve));
        try!(buffer.write_u8(self.object_data.profile_curve));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.path_begin));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.path_end));
        try!(buffer.write_u8(self.object_data.path_scale_x));
        try!(buffer.write_u8(self.object_data.path_scale_y));
        try!(buffer.write_u8(self.object_data.path_shear_x));
        try!(buffer.write_u8(self.object_data.path_shear_y));
        try!(buffer.write_i8(self.object_data.path_twist));
        try!(buffer.write_i8(self.object_data.path_twist_begin));
        try!(buffer.write_i8(self.object_data.path_radius_offset));
        try!(buffer.write_i8(self.object_data.path_taper_x));
        try!(buffer.write_i8(self.object_data.path_taper_y));
        try!(buffer.write_u8(self.object_data.path_revolutions));
        try!(buffer.write_i8(self.object_data.path_skew));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_begin));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_end));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_hollow));
        try!(buffer.write_u8(self.object_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.z));
        try!(buffer.write(self.object_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.object_data.ray_end_is_intersection));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.z));
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        try!(buffer.write_u8(self.object_data.state));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectAdd_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectAdd_ObjectData::read_from(buffer));
        Ok(MessageInstance::ObjectAdd(ObjectAdd {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x59]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.force as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDelete_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDelete_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDelete(ObjectDelete {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block SharedData
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.z));
        try!(buffer.write_u32::<LittleEndian>(self.shared_data.duplicate_flags));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDuplicate_AgentData::read_from(buffer));
        // Block SharedData
        let shared_data = try!(ObjectDuplicate_SharedData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDuplicate_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDuplicate(ObjectDuplicate {
            agent_data: agent_data,
            shared_data: shared_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDuplicateOnRay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.z));
        try!(buffer.write_u8(self.agent_data.bypass_raycast as u8));
        try!(buffer.write_u8(self.agent_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.agent_data.copy_centers as u8));
        try!(buffer.write_u8(self.agent_data.copy_rotates as u8));
        try!(buffer.write(self.agent_data.ray_target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.duplicate_flags));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDuplicateOnRay_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDuplicateOnRay_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDuplicateOnRay(ObjectDuplicateOnRay {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for MultipleObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x02]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.type_));
            try!(buffer.write(&item.data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MultipleObjectUpdate_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(MultipleObjectUpdate_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::MultipleObjectUpdate(MultipleObjectUpdate {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for RequestMultipleObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x03]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u8(item.cache_miss_type));
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestMultipleObjects_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(RequestMultipleObjects_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::RequestMultipleObjects(RequestMultipleObjects {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectPosition {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectPosition_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectPosition_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectPosition(ObjectPosition {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectScale {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_f32::<LittleEndian>(item.scale.x));
            try!(buffer.write_f32::<LittleEndian>(item.scale.y));
            try!(buffer.write_f32::<LittleEndian>(item.scale.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectScale_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectScale_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectScale(ObjectScale {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectRotation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectRotation_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectRotation_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectRotation(ObjectRotation {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectFlagUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.object_local_id));
        try!(buffer.write_u8(self.agent_data.use_physics as u8));
        try!(buffer.write_u8(self.agent_data.is_temporary as u8));
        try!(buffer.write_u8(self.agent_data.is_phantom as u8));
        try!(buffer.write_u8(self.agent_data.casts_shadows as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectFlagUpdate_AgentData::read_from(buffer));
        Ok(MessageInstance::ObjectFlagUpdate(ObjectFlagUpdate { agent_data: agent_data }))
    }
}

impl Message for ObjectClickAction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.click_action));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectClickAction_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectClickAction_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectClickAction(ObjectClickAction {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectImage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x60]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write(&item.media_url[..]));
            try!(buffer.write(&item.texture_entry[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectImage_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectImage_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectImage(ObjectImage {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectMaterial {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x61]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.material));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectMaterial_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectMaterial_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectMaterial(ObjectMaterial {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectShape {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x62]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.path_curve));
            try!(buffer.write_u8(item.profile_curve));
            try!(buffer.write_u16::<LittleEndian>(item.path_begin));
            try!(buffer.write_u16::<LittleEndian>(item.path_end));
            try!(buffer.write_u8(item.path_scale_x));
            try!(buffer.write_u8(item.path_scale_y));
            try!(buffer.write_u8(item.path_shear_x));
            try!(buffer.write_u8(item.path_shear_y));
            try!(buffer.write_i8(item.path_twist));
            try!(buffer.write_i8(item.path_twist_begin));
            try!(buffer.write_i8(item.path_radius_offset));
            try!(buffer.write_i8(item.path_taper_x));
            try!(buffer.write_i8(item.path_taper_y));
            try!(buffer.write_u8(item.path_revolutions));
            try!(buffer.write_i8(item.path_skew));
            try!(buffer.write_u16::<LittleEndian>(item.profile_begin));
            try!(buffer.write_u16::<LittleEndian>(item.profile_end));
            try!(buffer.write_u16::<LittleEndian>(item.profile_hollow));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectShape_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectShape_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectShape(ObjectShape {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectExtraParams {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x63]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u16::<LittleEndian>(item.param_type));
            try!(buffer.write_u8(item.param_in_use as u8));
            try!(buffer.write_u32::<LittleEndian>(item.param_size));
            try!(buffer.write(&item.param_data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectExtraParams_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectExtraParams_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectExtraParams(ObjectExtraParams {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x64]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write_u8(self.header_data.override_ as u8));
        try!(buffer.write(self.header_data.owner_id.as_bytes()));
        try!(buffer.write(self.header_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectOwner_AgentData::read_from(buffer));
        // Block HeaderData
        let header_data = try!(ObjectOwner_HeaderData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectOwner_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectOwner(ObjectOwner {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x65]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectGroup_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectGroup_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectGroup(ObjectGroup {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x66]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.category_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectBuy_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectBuy_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectBuy(ObjectBuy {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for BuyObjectInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x67]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write(self.data.folder_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(BuyObjectInventory_AgentData::read_from(buffer));
        // Block Data
        let data = try!(BuyObjectInventory_Data::read_from(buffer));
        Ok(MessageInstance::BuyObjectInventory(BuyObjectInventory {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DerezContainer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x68]));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_u8(self.data.delete as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(DerezContainer_Data::read_from(buffer));
        Ok(MessageInstance::DerezContainer(DerezContainer { data: data }))
    }
}

impl Message for ObjectPermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x69]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write_u8(self.header_data.override_ as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.field));
            try!(buffer.write_u8(item.set));
            try!(buffer.write_u32::<LittleEndian>(item.mask));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectPermissions_AgentData::read_from(buffer));
        // Block HeaderData
        let header_data = try!(ObjectPermissions_HeaderData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectPermissions_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectPermissions(ObjectPermissions {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSaleInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectSaleInfo_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectSaleInfo_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectSaleInfo(ObjectSaleInfo {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectName {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectName_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectName_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectName(ObjectName {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDescription {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write(&item.description[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDescription_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDescription_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDescription(ObjectDescription {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectCategory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write_u32::<LittleEndian>(item.category));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectCategory_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectCategory_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectCategory(ObjectCategory {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectSelect_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectSelect_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectSelect(ObjectSelect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDeselect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDeselect_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDeselect_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDeselect(ObjectDeselect {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectAttach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x70]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.attachment_point));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectAttach_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectAttach_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectAttach(ObjectAttach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDetach {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x71]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDetach_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDetach_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDetach(ObjectDetach {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDrop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x72]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDrop_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDrop_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDrop(ObjectDrop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectLink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x73]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectLink_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectLink_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectLink(ObjectLink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectDelink {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x74]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDelink_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectDelink_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDelink(ObjectDelink {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x75]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.local_id));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.z));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectGrab_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectGrab_ObjectData::read_from(buffer));
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = try!(buffer.read_u8());
        for _ in 0.._surface_info_count {
            surface_info.push(try!(ObjectGrab_SurfaceInfo::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectGrab(ObjectGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectGrabUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x76]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.z));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.z));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.time_since_last));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectGrabUpdate_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectGrabUpdate_ObjectData::read_from(buffer));
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = try!(buffer.read_u8());
        for _ in 0.._surface_info_count {
            surface_info.push(try!(ObjectGrabUpdate_SurfaceInfo::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectGrabUpdate(ObjectGrabUpdate {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectDeGrab {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x77]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.local_id));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectDeGrab_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectDeGrab_ObjectData::read_from(buffer));
        // Block SurfaceInfo
        let mut surface_info = Vec::new();
        let _surface_info_count = try!(buffer.read_u8());
        for _ in 0.._surface_info_count {
            surface_info.push(try!(ObjectDeGrab_SurfaceInfo::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectDeGrab(ObjectDeGrab {
            agent_data: agent_data,
            object_data: object_data,
            surface_info: surface_info,
        }))
    }
}

impl Message for ObjectSpinStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x78]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectSpinStart_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectSpinStart_ObjectData::read_from(buffer));
        Ok(MessageInstance::ObjectSpinStart(ObjectSpinStart {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x79]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectSpinUpdate_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectSpinUpdate_ObjectData::read_from(buffer));
        Ok(MessageInstance::ObjectSpinUpdate(ObjectSpinUpdate {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectSpinStop {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectSpinStop_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(ObjectSpinStop_ObjectData::read_from(buffer));
        Ok(MessageInstance::ObjectSpinStop(ObjectSpinStop {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectExportSelected {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.agent_data.volume_detail));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectExportSelected_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectExportSelected_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectExportSelected(ObjectExportSelected {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for ModifyLand {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ModifyBlock
        try!(buffer.write_u8(self.modify_block.action));
        try!(buffer.write_u8(self.modify_block.brush_size));
        try!(buffer.write_f32::<LittleEndian>(self.modify_block.seconds));
        try!(buffer.write_f32::<LittleEndian>(self.modify_block.height));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write_i32::<LittleEndian>(item.local_id));
            try!(buffer.write_f32::<LittleEndian>(item.west));
            try!(buffer.write_f32::<LittleEndian>(item.south));
            try!(buffer.write_f32::<LittleEndian>(item.east));
            try!(buffer.write_f32::<LittleEndian>(item.north));
        }
        // Block ModifyBlockExtended
        try!(buffer.write_u8(self.modify_block_extended.len() as u8));
        for item in &self.modify_block_extended {
            try!(buffer.write_f32::<LittleEndian>(item.brush_size));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ModifyLand_AgentData::read_from(buffer));
        // Block ModifyBlock
        let modify_block = try!(ModifyLand_ModifyBlock::read_from(buffer));
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(ModifyLand_ParcelData::read_from(buffer)));
        }
        // Block ModifyBlockExtended
        let mut modify_block_extended = Vec::new();
        let _modify_block_extended_count = try!(buffer.read_u8());
        for _ in 0.._modify_block_extended_count {
            modify_block_extended.push(try!(ModifyLand_ModifyBlockExtended::read_from(buffer)));
        }
        Ok(MessageInstance::ModifyLand(ModifyLand {
            agent_data: agent_data,
            modify_block: modify_block,
            parcel_data: parcel_data,
            modify_block_extended: modify_block_extended,
        }))
    }
}

impl Message for VelocityInterpolateOn {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(VelocityInterpolateOn_AgentData::read_from(buffer));
        Ok(MessageInstance::VelocityInterpolateOn(VelocityInterpolateOn { agent_data: agent_data }))
    }
}

impl Message for VelocityInterpolateOff {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(VelocityInterpolateOff_AgentData::read_from(buffer));
        Ok(MessageInstance::VelocityInterpolateOff(VelocityInterpolateOff { agent_data: agent_data }))
    }
}

impl Message for StateSave {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block DataBlock
        try!(buffer.write(&self.data_block.filename[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(StateSave_AgentData::read_from(buffer));
        // Block DataBlock
        let data_block = try!(StateSave_DataBlock::read_from(buffer));
        Ok(MessageInstance::StateSave(StateSave {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for ReportAutosaveCrash {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x80]));
        // Block AutosaveData
        try!(buffer.write_i32::<LittleEndian>(self.autosave_data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.autosave_data.status));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AutosaveData
        let autosave_data = try!(ReportAutosaveCrash_AutosaveData::read_from(buffer));
        Ok(MessageInstance::ReportAutosaveCrash(ReportAutosaveCrash { autosave_data: autosave_data }))
    }
}

impl Message for SimWideDeletes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x81]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block DataBlock
        try!(buffer.write(self.data_block.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SimWideDeletes_AgentData::read_from(buffer));
        // Block DataBlock
        let data_block = try!(SimWideDeletes_DataBlock::read_from(buffer));
        Ok(MessageInstance::SimWideDeletes(SimWideDeletes {
            agent_data: agent_data,
            data_block: data_block,
        }))
    }
}

impl Message for RequestObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.request_flags));
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestObjectPropertiesFamily_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(RequestObjectPropertiesFamily_ObjectData::read_from(buffer));
        Ok(MessageInstance::RequestObjectPropertiesFamily(RequestObjectPropertiesFamily {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for TrackAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x82]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TargetData
        try!(buffer.write(self.target_data.prey_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(TrackAgent_AgentData::read_from(buffer));
        // Block TargetData
        let target_data = try!(TrackAgent_TargetData::read_from(buffer));
        Ok(MessageInstance::TrackAgent(TrackAgent {
            agent_data: agent_data,
            target_data: target_data,
        }))
    }
}

impl Message for ViewerStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x83]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(&self.agent_data.ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.start_time));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.run_time));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.sim_fps));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.fps));
        try!(buffer.write_u8(self.agent_data.agents_in_view));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ping));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.meters_traveled));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.regions_visited));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.sys_ram));
        try!(buffer.write(&self.agent_data.sys_os[..]));
        try!(buffer.write(&self.agent_data.sys_cpu[..]));
        try!(buffer.write(&self.agent_data.sys_gpu[..]));
        // Block DownloadTotals
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.world));
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.objects));
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.textures));
        // Block NetStats
        for i in 0..2 {
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].bytes));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].packets));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].compressed));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].savings));
        }
        // Block FailStats
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.send_packet));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.dropped));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.resent));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.failed_resends));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.off_circuit));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.invalid));
        // Block MiscStats
        try!(buffer.write_u8(self.misc_stats.len() as u8));
        for item in &self.misc_stats {
            try!(buffer.write_u32::<LittleEndian>(item.type_));
            try!(buffer.write_f64::<LittleEndian>(item.value));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ViewerStats_AgentData::read_from(buffer));
        // Block DownloadTotals
        let download_totals = try!(ViewerStats_DownloadTotals::read_from(buffer));
        // Block NetStats
        let net_stats = [try!(ViewerStats_NetStats::read_from(buffer)),
                         try!(ViewerStats_NetStats::read_from(buffer))];
        // Block FailStats
        let fail_stats = try!(ViewerStats_FailStats::read_from(buffer));
        // Block MiscStats
        let mut misc_stats = Vec::new();
        let _misc_stats_count = try!(buffer.read_u8());
        for _ in 0.._misc_stats_count {
            misc_stats.push(try!(ViewerStats_MiscStats::read_from(buffer)));
        }
        Ok(MessageInstance::ViewerStats(ViewerStats {
            agent_data: agent_data,
            download_totals: download_totals,
            net_stats: net_stats,
            fail_stats: fail_stats,
            misc_stats: misc_stats,
        }))
    }
}

impl Message for ScriptAnswerYes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x84]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.task_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.questions));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ScriptAnswerYes_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ScriptAnswerYes_Data::read_from(buffer));
        Ok(MessageInstance::ScriptAnswerYes(ScriptAnswerYes {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for UserReport {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x85]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.report_type));
        try!(buffer.write_u8(self.report_data.category));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.z));
        try!(buffer.write_u8(self.report_data.check_flags));
        try!(buffer.write(self.report_data.screenshot_id.as_bytes()));
        try!(buffer.write(self.report_data.object_id.as_bytes()));
        try!(buffer.write(self.report_data.abuser_id.as_bytes()));
        try!(buffer.write(&self.report_data.abuse_region_name[..]));
        try!(buffer.write(self.report_data.abuse_region_id.as_bytes()));
        try!(buffer.write(&self.report_data.summary[..]));
        try!(buffer.write(&self.report_data.details[..]));
        try!(buffer.write(&self.report_data.version_string[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UserReport_AgentData::read_from(buffer));
        // Block ReportData
        let report_data = try!(UserReport_ReportData::read_from(buffer));
        Ok(MessageInstance::UserReport(UserReport {
            agent_data: agent_data,
            report_data: report_data,
        }))
    }
}

impl Message for AlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x86]));
        // Block AlertData
        try!(buffer.write(&self.alert_data.message[..]));
        // Block AlertInfo
        try!(buffer.write_u8(self.alert_info.len() as u8));
        for item in &self.alert_info {
            try!(buffer.write(&item.message[..]));
            try!(buffer.write(&item.extra_params[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AlertData
        let alert_data = try!(AlertMessage_AlertData::read_from(buffer));
        // Block AlertInfo
        let mut alert_info = Vec::new();
        let _alert_info_count = try!(buffer.read_u8());
        for _ in 0.._alert_info_count {
            alert_info.push(try!(AlertMessage_AlertInfo::read_from(buffer)));
        }
        Ok(MessageInstance::AlertMessage(AlertMessage {
            alert_data: alert_data,
            alert_info: alert_info,
        }))
    }
}

impl Message for AgentAlertMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x87]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block AlertData
        try!(buffer.write_u8(self.alert_data.modal as u8));
        try!(buffer.write(&self.alert_data.message[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentAlertMessage_AgentData::read_from(buffer));
        // Block AlertData
        let alert_data = try!(AgentAlertMessage_AlertData::read_from(buffer));
        Ok(MessageInstance::AgentAlertMessage(AgentAlertMessage {
            agent_data: agent_data,
            alert_data: alert_data,
        }))
    }
}

impl Message for MeanCollisionAlert {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x88]));
        // Block MeanCollision
        try!(buffer.write_u8(self.mean_collision.len() as u8));
        for item in &self.mean_collision {
            try!(buffer.write(item.victim.as_bytes()));
            try!(buffer.write(item.perp.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.time));
            try!(buffer.write_f32::<LittleEndian>(item.mag));
            try!(buffer.write_u8(item.type_));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MeanCollision
        let mut mean_collision = Vec::new();
        let _mean_collision_count = try!(buffer.read_u8());
        for _ in 0.._mean_collision_count {
            mean_collision.push(try!(MeanCollisionAlert_MeanCollision::read_from(buffer)));
        }
        Ok(MessageInstance::MeanCollisionAlert(MeanCollisionAlert { mean_collision: mean_collision }))
    }
}

impl Message for ViewerFrozenMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x89]));
        // Block FrozenData
        try!(buffer.write_u8(self.frozen_data.data as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block FrozenData
        let frozen_data = try!(ViewerFrozenMessage_FrozenData::read_from(buffer));
        Ok(MessageInstance::ViewerFrozenMessage(ViewerFrozenMessage { frozen_data: frozen_data }))
    }
}

impl Message for HealthMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8a]));
        // Block HealthData
        try!(buffer.write_f32::<LittleEndian>(self.health_data.health));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block HealthData
        let health_data = try!(HealthMessage_HealthData::read_from(buffer));
        Ok(MessageInstance::HealthMessage(HealthMessage { health_data: health_data }))
    }
}

impl Message for ChatFromSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8b]));
        // Block ChatData
        try!(buffer.write(&self.chat_data.from_name[..]));
        try!(buffer.write(self.chat_data.source_id.as_bytes()));
        try!(buffer.write(self.chat_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.chat_data.source_type));
        try!(buffer.write_u8(self.chat_data.chat_type));
        try!(buffer.write_u8(self.chat_data.audible));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.z));
        try!(buffer.write(&self.chat_data.message[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ChatData
        let chat_data = try!(ChatFromSimulator_ChatData::read_from(buffer));
        Ok(MessageInstance::ChatFromSimulator(ChatFromSimulator { chat_data: chat_data }))
    }
}

impl Message for SimStats {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8c]));
        // Block Region
        try!(buffer.write_u32::<LittleEndian>(self.region.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.region.region_y));
        try!(buffer.write_u32::<LittleEndian>(self.region.region_flags));
        try!(buffer.write_u32::<LittleEndian>(self.region.object_capacity));
        // Block Stat
        try!(buffer.write_u8(self.stat.len() as u8));
        for item in &self.stat {
            try!(buffer.write_u32::<LittleEndian>(item.stat_id));
            try!(buffer.write_f32::<LittleEndian>(item.stat_value));
        }
        // Block PidStat
        try!(buffer.write_i32::<LittleEndian>(self.pid_stat.pid));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Region
        let region = try!(SimStats_Region::read_from(buffer));
        // Block Stat
        let mut stat = Vec::new();
        let _stat_count = try!(buffer.read_u8());
        for _ in 0.._stat_count {
            stat.push(try!(SimStats_Stat::read_from(buffer)));
        }
        // Block PidStat
        let pid_stat = try!(SimStats_PidStat::read_from(buffer));
        Ok(MessageInstance::SimStats(SimStats {
            region: region,
            stat: stat,
            pid_stat: pid_stat,
        }))
    }
}

impl Message for RequestRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestRegionInfo_AgentData::read_from(buffer));
        Ok(MessageInstance::RequestRegionInfo(RequestRegionInfo { agent_data: agent_data }))
    }
}

impl Message for RegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_u8(self.region_info.sim_access));
        try!(buffer.write_u8(self.region_info.max_agents));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.object_bonus_factor));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.water_height));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_raise_limit));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_lower_limit));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y));
        try!(buffer.write_u8(self.region_info.use_estate_sun as u8));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.sun_hour));
        // Block RegionInfo2
        try!(buffer.write(&self.region_info2.product_sku[..]));
        try!(buffer.write(&self.region_info2.product_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.max_agents32));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_agents));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_objects));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RegionInfo_AgentData::read_from(buffer));
        // Block RegionInfo
        let region_info = try!(RegionInfo_RegionInfo::read_from(buffer));
        // Block RegionInfo2
        let region_info2 = try!(RegionInfo_RegionInfo2::read_from(buffer));
        Ok(MessageInstance::RegionInfo(RegionInfo {
            agent_data: agent_data,
            region_info: region_info,
            region_info2: region_info2,
        }))
    }
}

impl Message for GodUpdateRegionInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GodUpdateRegionInfo_AgentData::read_from(buffer));
        // Block RegionInfo
        let region_info = try!(GodUpdateRegionInfo_RegionInfo::read_from(buffer));
        Ok(MessageInstance::GodUpdateRegionInfo(GodUpdateRegionInfo {
            agent_data: agent_data,
            region_info: region_info,
        }))
    }
}

impl Message for NearestLandingRegionRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x90]));
        // Block RequestingRegionData
        try!(buffer.write_u64::<LittleEndian>(self.requesting_region_data.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RequestingRegionData
        let requesting_region_data =
            try!(NearestLandingRegionRequest_RequestingRegionData::read_from(buffer));
        Ok(MessageInstance::NearestLandingRegionRequest(NearestLandingRegionRequest {
            requesting_region_data: requesting_region_data,
        }))
    }
}

impl Message for NearestLandingRegionReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x91]));
        // Block LandingRegionData
        try!(buffer.write_u64::<LittleEndian>(self.landing_region_data.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block LandingRegionData
        let landing_region_data = try!(NearestLandingRegionReply_LandingRegionData::read_from(buffer));
        Ok(MessageInstance::NearestLandingRegionReply(NearestLandingRegionReply {
            landing_region_data: landing_region_data,
        }))
    }
}

impl Message for NearestLandingRegionUpdated {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x92]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(NearestLandingRegionUpdated_RegionData::read_from(buffer));
        Ok(MessageInstance::NearestLandingRegionUpdated(NearestLandingRegionUpdated {
            region_data: region_data,
        }))
    }
}

impl Message for TeleportLandingStatusChanged {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x93]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(TeleportLandingStatusChanged_RegionData::read_from(buffer));
        Ok(MessageInstance::TeleportLandingStatusChanged(TeleportLandingStatusChanged {
            region_data: region_data,
        }))
    }
}

impl Message for RegionHandshake {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x94]));
        // Block RegionInfo
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_u8(self.region_info.sim_access));
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write(self.region_info.sim_owner.as_bytes()));
        try!(buffer.write_u8(self.region_info.is_estate_manager as u8));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.water_height));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write(self.region_info.cache_id.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base0.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base1.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base2.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base3.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail0.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail1.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail2.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail3.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height00));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height01));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height10));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height11));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range00));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range01));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range10));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range11));
        // Block RegionInfo2
        try!(buffer.write(self.region_info2.region_id.as_bytes()));
        // Block RegionInfo3
        try!(buffer.write_i32::<LittleEndian>(self.region_info3.cpu_class_id));
        try!(buffer.write_i32::<LittleEndian>(self.region_info3.cpu_ratio));
        try!(buffer.write(&self.region_info3.colo_name[..]));
        try!(buffer.write(&self.region_info3.product_sku[..]));
        try!(buffer.write(&self.region_info3.product_name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionInfo
        let region_info = try!(RegionHandshake_RegionInfo::read_from(buffer));
        // Block RegionInfo2
        let region_info2 = try!(RegionHandshake_RegionInfo2::read_from(buffer));
        // Block RegionInfo3
        let region_info3 = try!(RegionHandshake_RegionInfo3::read_from(buffer));
        Ok(MessageInstance::RegionHandshake(RegionHandshake {
            region_info: region_info,
            region_info2: region_info2,
            region_info3: region_info3,
        }))
    }
}

impl Message for RegionHandshakeReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x95]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write_u32::<LittleEndian>(self.region_info.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RegionHandshakeReply_AgentData::read_from(buffer));
        // Block RegionInfo
        let region_info = try!(RegionHandshakeReply_RegionInfo::read_from(buffer));
        Ok(MessageInstance::RegionHandshakeReply(RegionHandshakeReply {
            agent_data: agent_data,
            region_info: region_info,
        }))
    }
}

impl Message for CoarseLocationUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x06]));
        // Block Location
        try!(buffer.write_u8(self.location.len() as u8));
        for item in &self.location {
            try!(buffer.write_u8(item.x));
            try!(buffer.write_u8(item.y));
            try!(buffer.write_u8(item.z));
        }
        // Block Index
        try!(buffer.write_i16::<LittleEndian>(self.index.you));
        try!(buffer.write_i16::<LittleEndian>(self.index.prey));
        // Block AgentData
        try!(buffer.write_u8(self.agent_data.len() as u8));
        for item in &self.agent_data {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Location
        let mut location = Vec::new();
        let _location_count = try!(buffer.read_u8());
        for _ in 0.._location_count {
            location.push(try!(CoarseLocationUpdate_Location::read_from(buffer)));
        }
        // Block Index
        let index = try!(CoarseLocationUpdate_Index::read_from(buffer));
        // Block AgentData
        let mut agent_data = Vec::new();
        let _agent_data_count = try!(buffer.read_u8());
        for _ in 0.._agent_data_count {
            agent_data.push(try!(CoarseLocationUpdate_AgentData::read_from(buffer)));
        }
        Ok(MessageInstance::CoarseLocationUpdate(CoarseLocationUpdate {
            location: location,
            index: index,
            agent_data: agent_data,
        }))
    }
}

impl Message for ImageData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x09]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        try!(buffer.write_u8(self.image_id.codec));
        try!(buffer.write_u32::<LittleEndian>(self.image_id.size));
        try!(buffer.write_u16::<LittleEndian>(self.image_id.packets));
        // Block ImageData
        try!(buffer.write(&self.image_data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ImageID
        let image_id = try!(ImageData_ImageID::read_from(buffer));
        // Block ImageData
        let image_data = try!(ImageData_ImageData::read_from(buffer));
        Ok(MessageInstance::ImageData(ImageData {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for ImagePacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0a]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        try!(buffer.write_u16::<LittleEndian>(self.image_id.packet));
        // Block ImageData
        try!(buffer.write(&self.image_data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ImageID
        let image_id = try!(ImagePacket_ImageID::read_from(buffer));
        // Block ImageData
        let image_data = try!(ImagePacket_ImageData::read_from(buffer));
        Ok(MessageInstance::ImagePacket(ImagePacket {
            image_id: image_id,
            image_data: image_data,
        }))
    }
}

impl Message for LayerData {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0b]));
        // Block LayerID
        try!(buffer.write_u8(self.layer_id.type_));
        // Block LayerData
        try!(buffer.write(&self.layer_data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block LayerID
        let layer_id = try!(LayerData_LayerID::read_from(buffer));
        // Block LayerData
        let layer_data = try!(LayerData_LayerData::read_from(buffer));
        Ok(MessageInstance::LayerData(LayerData {
            layer_id: layer_id,
            layer_data: layer_data,
        }))
    }
}

impl Message for ObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0c]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
            try!(buffer.write_u8(item.state));
            try!(buffer.write(item.full_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
            try!(buffer.write_u8(item.p_code));
            try!(buffer.write_u8(item.material));
            try!(buffer.write_u8(item.click_action));
            try!(buffer.write_f32::<LittleEndian>(item.scale.x));
            try!(buffer.write_f32::<LittleEndian>(item.scale.y));
            try!(buffer.write_f32::<LittleEndian>(item.scale.z));
            try!(buffer.write(&item.object_data[..]));
            try!(buffer.write_u32::<LittleEndian>(item.parent_id));
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
            try!(buffer.write_u8(item.path_curve));
            try!(buffer.write_u8(item.profile_curve));
            try!(buffer.write_u16::<LittleEndian>(item.path_begin));
            try!(buffer.write_u16::<LittleEndian>(item.path_end));
            try!(buffer.write_u8(item.path_scale_x));
            try!(buffer.write_u8(item.path_scale_y));
            try!(buffer.write_u8(item.path_shear_x));
            try!(buffer.write_u8(item.path_shear_y));
            try!(buffer.write_i8(item.path_twist));
            try!(buffer.write_i8(item.path_twist_begin));
            try!(buffer.write_i8(item.path_radius_offset));
            try!(buffer.write_i8(item.path_taper_x));
            try!(buffer.write_i8(item.path_taper_y));
            try!(buffer.write_u8(item.path_revolutions));
            try!(buffer.write_i8(item.path_skew));
            try!(buffer.write_u16::<LittleEndian>(item.profile_begin));
            try!(buffer.write_u16::<LittleEndian>(item.profile_end));
            try!(buffer.write_u16::<LittleEndian>(item.profile_hollow));
            try!(buffer.write(&item.texture_entry[..]));
            try!(buffer.write(&item.texture_anim[..]));
            try!(buffer.write(&item.name_value[..]));
            try!(buffer.write(&item.data[..]));
            try!(buffer.write(&item.text[..]));
            try!(buffer.write(&item.text_color));
            try!(buffer.write(&item.media_url[..]));
            try!(buffer.write(&item.ps_block[..]));
            try!(buffer.write(&item.extra_params[..]));
            try!(buffer.write(item.sound.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.gain));
            try!(buffer.write_u8(item.flags));
            try!(buffer.write_f32::<LittleEndian>(item.radius));
            try!(buffer.write_u8(item.joint_type));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.x));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.y));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.z));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.x));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.y));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.z));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(ObjectUpdate_RegionData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectUpdate_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectUpdate(ObjectUpdate {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdateCompressed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0d]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
            try!(buffer.write(&item.data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(ObjectUpdateCompressed_RegionData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectUpdateCompressed_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectUpdateCompressed(ObjectUpdateCompressed {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ObjectUpdateCached {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0e]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(ObjectUpdateCached_RegionData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectUpdateCached_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectUpdateCached(ObjectUpdateCached {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for ImprovedTerseObjectUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x0f]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(&item.data[..]));
            try!(buffer.write(&item.texture_entry[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let region_data = try!(ImprovedTerseObjectUpdate_RegionData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ImprovedTerseObjectUpdate_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ImprovedTerseObjectUpdate(ImprovedTerseObjectUpdate {
            region_data: region_data,
            object_data: object_data,
        }))
    }
}

impl Message for KillObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x10]));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(KillObject_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::KillObject(KillObject { object_data: object_data }))
    }
}

impl Message for CrossedRegion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionData
        try!(buffer.write(&self.region_data.sim_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.sim_port));
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write(&self.region_data.seed_capability[..]));
        // Block Info
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CrossedRegion_AgentData::read_from(buffer));
        // Block RegionData
        let region_data = try!(CrossedRegion_RegionData::read_from(buffer));
        // Block Info
        let info = try!(CrossedRegion_Info::read_from(buffer));
        Ok(MessageInstance::CrossedRegion(CrossedRegion {
            agent_data: agent_data,
            region_data: region_data,
            info: info,
        }))
    }
}

impl Message for SimulatorViewerTimeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x96]));
        // Block TimeInfo
        try!(buffer.write_u64::<LittleEndian>(self.time_info.usec_since_start));
        try!(buffer.write_u32::<LittleEndian>(self.time_info.sec_per_day));
        try!(buffer.write_u32::<LittleEndian>(self.time_info.sec_per_year));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.x));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.y));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.z));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_phase));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.x));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.y));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TimeInfo
        let time_info = try!(SimulatorViewerTimeMessage_TimeInfo::read_from(buffer));
        Ok(MessageInstance::SimulatorViewerTimeMessage(SimulatorViewerTimeMessage { time_info: time_info }))
    }
}

impl Message for EnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x97]));
        // Block SimulatorInfo
        try!(buffer.write_u64::<LittleEndian>(self.simulator_info.handle));
        try!(buffer.write(&self.simulator_info.ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.simulator_info.port));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimulatorInfo
        let simulator_info = try!(EnableSimulator_SimulatorInfo::read_from(buffer));
        Ok(MessageInstance::EnableSimulator(EnableSimulator { simulator_info: simulator_info }))
    }
}

impl Message for DisableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x98]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::DisableSimulator(DisableSimulator {}))
    }
}

impl Message for ConfirmEnableSimulator {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ConfirmEnableSimulator_AgentData::read_from(buffer));
        Ok(MessageInstance::ConfirmEnableSimulator(ConfirmEnableSimulator { agent_data: agent_data }))
    }
}

impl Message for TransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x99]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.source_type));
        try!(buffer.write_f32::<LittleEndian>(self.transfer_info.priority));
        try!(buffer.write(&self.transfer_info.params[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransferInfo
        let transfer_info = try!(TransferRequest_TransferInfo::read_from(buffer));
        Ok(MessageInstance::TransferRequest(TransferRequest { transfer_info: transfer_info }))
    }
}

impl Message for TransferInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9a]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.target_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.status));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.size));
        try!(buffer.write(&self.transfer_info.params[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransferInfo
        let transfer_info = try!(TransferInfo_TransferInfo::read_from(buffer));
        Ok(MessageInstance::TransferInfo(TransferInfo { transfer_info: transfer_info }))
    }
}

impl Message for TransferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x11]));
        // Block TransferData
        try!(buffer.write(self.transfer_data.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.packet));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.status));
        try!(buffer.write(&self.transfer_data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransferData
        let transfer_data = try!(TransferPacket_TransferData::read_from(buffer));
        Ok(MessageInstance::TransferPacket(TransferPacket { transfer_data: transfer_data }))
    }
}

impl Message for TransferAbort {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9b]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransferInfo
        let transfer_info = try!(TransferAbort_TransferInfo::read_from(buffer));
        Ok(MessageInstance::TransferAbort(TransferAbort { transfer_info: transfer_info }))
    }
}

impl Message for RequestXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9c]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write(&self.xfer_id.filename[..]));
        try!(buffer.write_u8(self.xfer_id.file_path));
        try!(buffer.write_u8(self.xfer_id.delete_on_completion as u8));
        try!(buffer.write_u8(self.xfer_id.use_big_packets as u8));
        try!(buffer.write(self.xfer_id.v_file_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.xfer_id.v_file_type));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block XferID
        let xfer_id = try!(RequestXfer_XferID::read_from(buffer));
        Ok(MessageInstance::RequestXfer(RequestXfer { xfer_id: xfer_id }))
    }
}

impl Message for SendXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x12]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_u32::<LittleEndian>(self.xfer_id.packet));
        // Block DataPacket
        try!(buffer.write(&self.data_packet.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block XferID
        let xfer_id = try!(SendXferPacket_XferID::read_from(buffer));
        // Block DataPacket
        let data_packet = try!(SendXferPacket_DataPacket::read_from(buffer));
        Ok(MessageInstance::SendXferPacket(SendXferPacket {
            xfer_id: xfer_id,
            data_packet: data_packet,
        }))
    }
}

impl Message for ConfirmXferPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x13]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_u32::<LittleEndian>(self.xfer_id.packet));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block XferID
        let xfer_id = try!(ConfirmXferPacket_XferID::read_from(buffer));
        Ok(MessageInstance::ConfirmXferPacket(ConfirmXferPacket { xfer_id: xfer_id }))
    }
}

impl Message for AbortXfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9d]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_i32::<LittleEndian>(self.xfer_id.result));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block XferID
        let xfer_id = try!(AbortXfer_XferID::read_from(buffer));
        Ok(MessageInstance::AbortXfer(AbortXfer { xfer_id: xfer_id }))
    }
}

impl Message for AvatarAnimation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x14]));
        // Block Sender
        try!(buffer.write(self.sender.id.as_bytes()));
        // Block AnimationList
        try!(buffer.write_u8(self.animation_list.len() as u8));
        for item in &self.animation_list {
            try!(buffer.write(item.anim_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.anim_sequence_id));
        }
        // Block AnimationSourceList
        try!(buffer.write_u8(self.animation_source_list.len() as u8));
        for item in &self.animation_source_list {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        // Block PhysicalAvatarEventList
        try!(buffer.write_u8(self.physical_avatar_event_list.len() as u8));
        for item in &self.physical_avatar_event_list {
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Sender
        let sender = try!(AvatarAnimation_Sender::read_from(buffer));
        // Block AnimationList
        let mut animation_list = Vec::new();
        let _animation_list_count = try!(buffer.read_u8());
        for _ in 0.._animation_list_count {
            animation_list.push(try!(AvatarAnimation_AnimationList::read_from(buffer)));
        }
        // Block AnimationSourceList
        let mut animation_source_list = Vec::new();
        let _animation_source_list_count = try!(buffer.read_u8());
        for _ in 0.._animation_source_list_count {
            animation_source_list.push(try!(AvatarAnimation_AnimationSourceList::read_from(buffer)));
        }
        // Block PhysicalAvatarEventList
        let mut physical_avatar_event_list = Vec::new();
        let _physical_avatar_event_list_count = try!(buffer.read_u8());
        for _ in 0.._physical_avatar_event_list_count {
            physical_avatar_event_list.push(try!(AvatarAnimation_PhysicalAvatarEventList::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarAnimation(AvatarAnimation {
            sender: sender,
            animation_list: animation_list,
            animation_source_list: animation_source_list,
            physical_avatar_event_list: physical_avatar_event_list,
        }))
    }
}

impl Message for AvatarAppearance {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9e]));
        // Block Sender
        try!(buffer.write(self.sender.id.as_bytes()));
        try!(buffer.write_u8(self.sender.is_trial as u8));
        // Block ObjectData
        try!(buffer.write(&self.object_data.texture_entry[..]));
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Sender
        let sender = try!(AvatarAppearance_Sender::read_from(buffer));
        // Block ObjectData
        let object_data = try!(AvatarAppearance_ObjectData::read_from(buffer));
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = try!(buffer.read_u8());
        for _ in 0.._visual_param_count {
            visual_param.push(try!(AvatarAppearance_VisualParam::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarAppearance(AvatarAppearance {
            sender: sender,
            object_data: object_data,
            visual_param: visual_param,
        }))
    }
}

impl Message for AvatarSitResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x15]));
        // Block SitObject
        try!(buffer.write(self.sit_object.id.as_bytes()));
        // Block SitTransform
        try!(buffer.write_u8(self.sit_transform.auto_pilot as u8));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.z));
        let normed_sit_rotation = UnitQuaternion::new(&self.sit_transform.sit_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.k));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.z));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.z));
        try!(buffer.write_u8(self.sit_transform.force_mouselook as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SitObject
        let sit_object = try!(AvatarSitResponse_SitObject::read_from(buffer));
        // Block SitTransform
        let sit_transform = try!(AvatarSitResponse_SitTransform::read_from(buffer));
        Ok(MessageInstance::AvatarSitResponse(AvatarSitResponse {
            sit_object: sit_object,
            sit_transform: sit_transform,
        }))
    }
}

impl Message for SetFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9f]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        // Block CameraProperty
        try!(buffer.write_u8(self.camera_property.len() as u8));
        for item in &self.camera_property {
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.value));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(SetFollowCamProperties_ObjectData::read_from(buffer));
        // Block CameraProperty
        let mut camera_property = Vec::new();
        let _camera_property_count = try!(buffer.read_u8());
        for _ in 0.._camera_property_count {
            camera_property.push(try!(SetFollowCamProperties_CameraProperty::read_from(buffer)));
        }
        Ok(MessageInstance::SetFollowCamProperties(SetFollowCamProperties {
            object_data: object_data,
            camera_property: camera_property,
        }))
    }
}

impl Message for ClearFollowCamProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa0]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(ClearFollowCamProperties_ObjectData::read_from(buffer));
        Ok(MessageInstance::ClearFollowCamProperties(ClearFollowCamProperties { object_data: object_data }))
    }
}

impl Message for CameraConstraint {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x16]));
        // Block CameraCollidePlane
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.x));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.y));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.z));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.w));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block CameraCollidePlane
        let camera_collide_plane = try!(CameraConstraint_CameraCollidePlane::read_from(buffer));
        Ok(MessageInstance::CameraConstraint(CameraConstraint { camera_collide_plane: camera_collide_plane }))
    }
}

impl Message for ObjectProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x09]));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_i32::<LittleEndian>(item.ownership_cost));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write_u8(item.aggregate_perms));
            try!(buffer.write_u8(item.aggregate_perm_textures));
            try!(buffer.write_u8(item.aggregate_perm_textures_owner));
            try!(buffer.write_u32::<LittleEndian>(item.category));
            try!(buffer.write_i16::<LittleEndian>(item.inventory_serial));
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.from_task_id.as_bytes()));
            try!(buffer.write(item.last_owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write(&item.touch_name[..]));
            try!(buffer.write(&item.sit_name[..]));
            try!(buffer.write(&item.texture_id[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectProperties_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectProperties(ObjectProperties { object_data: object_data }))
    }
}

impl Message for ObjectPropertiesFamily {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0a]));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.request_flags));
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write(self.object_data.owner_id.as_bytes()));
        try!(buffer.write(self.object_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.ownership_cost));
        try!(buffer.write_u8(self.object_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.sale_price));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.category));
        try!(buffer.write(self.object_data.last_owner_id.as_bytes()));
        try!(buffer.write(&self.object_data.name[..]));
        try!(buffer.write(&self.object_data.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(ObjectPropertiesFamily_ObjectData::read_from(buffer));
        Ok(MessageInstance::ObjectPropertiesFamily(ObjectPropertiesFamily { object_data: object_data }))
    }
}

impl Message for RequestPayPrice {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa1]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(RequestPayPrice_ObjectData::read_from(buffer));
        Ok(MessageInstance::RequestPayPrice(RequestPayPrice { object_data: object_data }))
    }
}

impl Message for PayPriceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa2]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.default_pay_price));
        // Block ButtonData
        try!(buffer.write_u8(self.button_data.len() as u8));
        for item in &self.button_data {
            try!(buffer.write_i32::<LittleEndian>(item.pay_button));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(PayPriceReply_ObjectData::read_from(buffer));
        // Block ButtonData
        let mut button_data = Vec::new();
        let _button_data_count = try!(buffer.read_u8());
        for _ in 0.._button_data_count {
            button_data.push(try!(PayPriceReply_ButtonData::read_from(buffer)));
        }
        Ok(MessageInstance::PayPriceReply(PayPriceReply {
            object_data: object_data,
            button_data: button_data,
        }))
    }
}

impl Message for KickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa3]));
        // Block TargetBlock
        try!(buffer.write(&self.target_block.target_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.target_block.target_port));
        // Block UserInfo
        try!(buffer.write(self.user_info.agent_id.as_bytes()));
        try!(buffer.write(self.user_info.session_id.as_bytes()));
        try!(buffer.write(&self.user_info.reason[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TargetBlock
        let target_block = try!(KickUser_TargetBlock::read_from(buffer));
        // Block UserInfo
        let user_info = try!(KickUser_UserInfo::read_from(buffer));
        Ok(MessageInstance::KickUser(KickUser {
            target_block: target_block,
            user_info: user_info,
        }))
    }
}

impl Message for KickUserAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa4]));
        // Block UserInfo
        try!(buffer.write(self.user_info.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.user_info.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UserInfo
        let user_info = try!(KickUserAck_UserInfo::read_from(buffer));
        Ok(MessageInstance::KickUserAck(KickUserAck { user_info: user_info }))
    }
}

impl Message for GodKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa5]));
        // Block UserInfo
        try!(buffer.write(self.user_info.god_id.as_bytes()));
        try!(buffer.write(self.user_info.god_session_id.as_bytes()));
        try!(buffer.write(self.user_info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.user_info.kick_flags));
        try!(buffer.write(&self.user_info.reason[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UserInfo
        let user_info = try!(GodKickUser_UserInfo::read_from(buffer));
        Ok(MessageInstance::GodKickUser(GodKickUser { user_info: user_info }))
    }
}

impl Message for SystemKickUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa6]));
        // Block AgentInfo
        try!(buffer.write_u8(self.agent_info.len() as u8));
        for item in &self.agent_info {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = try!(buffer.read_u8());
        for _ in 0.._agent_info_count {
            agent_info.push(try!(SystemKickUser_AgentInfo::read_from(buffer)));
        }
        Ok(MessageInstance::SystemKickUser(SystemKickUser { agent_info: agent_info }))
    }
}

impl Message for EjectUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EjectUser_AgentData::read_from(buffer));
        // Block Data
        let data = try!(EjectUser_Data::read_from(buffer));
        Ok(MessageInstance::EjectUser(EjectUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for FreezeUser {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(FreezeUser_AgentData::read_from(buffer));
        // Block Data
        let data = try!(FreezeUser_Data::read_from(buffer));
        Ok(MessageInstance::FreezeUser(FreezeUser {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPropertiesRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::AvatarPropertiesRequest(AvatarPropertiesRequest { agent_data: agent_data }))
    }
}

impl Message for AvatarPropertiesRequestBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xaa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.god_level));
        try!(buffer.write_u8(self.agent_data.web_profiles_disabled as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPropertiesRequestBackend_AgentData::read_from(buffer));
        Ok(MessageInstance::AvatarPropertiesRequestBackend(AvatarPropertiesRequestBackend {
            agent_data: agent_data,
        }))
    }
}

impl Message for AvatarPropertiesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xab]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write(self.properties_data.image_id.as_bytes()));
        try!(buffer.write(self.properties_data.fl_image_id.as_bytes()));
        try!(buffer.write(self.properties_data.partner_id.as_bytes()));
        try!(buffer.write(&self.properties_data.about_text[..]));
        try!(buffer.write(&self.properties_data.fl_about_text[..]));
        try!(buffer.write(&self.properties_data.born_on[..]));
        try!(buffer.write(&self.properties_data.profile_url[..]));
        try!(buffer.write(&self.properties_data.charter_member[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPropertiesReply_AgentData::read_from(buffer));
        // Block PropertiesData
        let properties_data = try!(AvatarPropertiesReply_PropertiesData::read_from(buffer));
        Ok(MessageInstance::AvatarPropertiesReply(AvatarPropertiesReply {
            agent_data: agent_data,
            properties_data: properties_data,
        }))
    }
}

impl Message for AvatarInterestsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xac]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask));
        try!(buffer.write(&self.properties_data.want_to_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask));
        try!(buffer.write(&self.properties_data.skills_text[..]));
        try!(buffer.write(&self.properties_data.languages_text[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarInterestsReply_AgentData::read_from(buffer));
        // Block PropertiesData
        let properties_data = try!(AvatarInterestsReply_PropertiesData::read_from(buffer));
        Ok(MessageInstance::AvatarInterestsReply(AvatarInterestsReply {
            agent_data: agent_data,
            properties_data: properties_data,
        }))
    }
}

impl Message for AvatarGroupsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xad]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
            try!(buffer.write(&item.group_title[..]));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
            try!(buffer.write(item.group_insignia_id.as_bytes()));
        }
        // Block NewGroupData
        try!(buffer.write_u8(self.new_group_data.list_in_profile as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarGroupsReply_AgentData::read_from(buffer));
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = try!(buffer.read_u8());
        for _ in 0.._group_data_count {
            group_data.push(try!(AvatarGroupsReply_GroupData::read_from(buffer)));
        }
        // Block NewGroupData
        let new_group_data = try!(AvatarGroupsReply_NewGroupData::read_from(buffer));
        Ok(MessageInstance::AvatarGroupsReply(AvatarGroupsReply {
            agent_data: agent_data,
            group_data: group_data,
            new_group_data: new_group_data,
        }))
    }
}

impl Message for AvatarPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xae]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write(self.properties_data.image_id.as_bytes()));
        try!(buffer.write(self.properties_data.fl_image_id.as_bytes()));
        try!(buffer.write(&self.properties_data.about_text[..]));
        try!(buffer.write(&self.properties_data.fl_about_text[..]));
        try!(buffer.write_u8(self.properties_data.allow_publish as u8));
        try!(buffer.write_u8(self.properties_data.mature_publish as u8));
        try!(buffer.write(&self.properties_data.profile_url[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPropertiesUpdate_AgentData::read_from(buffer));
        // Block PropertiesData
        let properties_data = try!(AvatarPropertiesUpdate_PropertiesData::read_from(buffer));
        Ok(MessageInstance::AvatarPropertiesUpdate(AvatarPropertiesUpdate {
            agent_data: agent_data,
            properties_data: properties_data,
        }))
    }
}

impl Message for AvatarInterestsUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xaf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask));
        try!(buffer.write(&self.properties_data.want_to_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask));
        try!(buffer.write(&self.properties_data.skills_text[..]));
        try!(buffer.write(&self.properties_data.languages_text[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarInterestsUpdate_AgentData::read_from(buffer));
        // Block PropertiesData
        let properties_data = try!(AvatarInterestsUpdate_PropertiesData::read_from(buffer));
        Ok(MessageInstance::AvatarInterestsUpdate(AvatarInterestsUpdate {
            agent_data: agent_data,
            properties_data: properties_data,
        }))
    }
}

impl Message for AvatarNotesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write(&self.data.notes[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarNotesReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(AvatarNotesReply_Data::read_from(buffer));
        Ok(MessageInstance::AvatarNotesReply(AvatarNotesReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarNotesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write(&self.data.notes[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarNotesUpdate_AgentData::read_from(buffer));
        // Block Data
        let data = try!(AvatarNotesUpdate_Data::read_from(buffer));
        Ok(MessageInstance::AvatarNotesUpdate(AvatarNotesUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for AvatarPicksReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb2]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.target_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.pick_id.as_bytes()));
            try!(buffer.write(&item.pick_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AvatarPicksReply_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(AvatarPicksReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::AvatarPicksReply(AvatarPicksReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for EventInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EventInfoRequest_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventInfoRequest_EventData::read_from(buffer));
        Ok(MessageInstance::EventInfoRequest(EventInfoRequest {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        try!(buffer.write(&self.event_data.creator[..]));
        try!(buffer.write(&self.event_data.name[..]));
        try!(buffer.write(&self.event_data.category[..]));
        try!(buffer.write(&self.event_data.desc[..]));
        try!(buffer.write(&self.event_data.date[..]));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.date_utc));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.duration));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.cover));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.amount));
        try!(buffer.write(&self.event_data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.x));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.y));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.z));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EventInfoReply_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventInfoReply_EventData::read_from(buffer));
        Ok(MessageInstance::EventInfoReply(EventInfoReply {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventNotificationAddRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EventNotificationAddRequest_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventNotificationAddRequest_EventData::read_from(buffer));
        Ok(MessageInstance::EventNotificationAddRequest(EventNotificationAddRequest {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventNotificationRemoveRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EventNotificationRemoveRequest_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventNotificationRemoveRequest_EventData::read_from(buffer));
        Ok(MessageInstance::EventNotificationRemoveRequest(EventNotificationRemoveRequest {
            agent_data: agent_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EventGodDelete_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventGodDelete_EventData::read_from(buffer));
        // Block QueryData
        let query_data = try!(EventGodDelete_QueryData::read_from(buffer));
        Ok(MessageInstance::EventGodDelete(EventGodDelete {
            agent_data: agent_data,
            event_data: event_data,
            query_data: query_data,
        }))
    }
}

impl Message for PickInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u8(self.data.top_pick as u8));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.data.user[..]));
        try!(buffer.write(&self.data.original_name[..]));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_i32::<LittleEndian>(self.data.sort_order));
        try!(buffer.write_u8(self.data.enabled as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PickInfoReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(PickInfoReply_Data::read_from(buffer));
        Ok(MessageInstance::PickInfoReply(PickInfoReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickInfoUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u8(self.data.top_pick as u8));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_i32::<LittleEndian>(self.data.sort_order));
        try!(buffer.write_u8(self.data.enabled as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PickInfoUpdate_AgentData::read_from(buffer));
        // Block Data
        let data = try!(PickInfoUpdate_Data::read_from(buffer));
        Ok(MessageInstance::PickInfoUpdate(PickInfoUpdate {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xba]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PickDelete_AgentData::read_from(buffer));
        // Block Data
        let data = try!(PickDelete_Data::read_from(buffer));
        Ok(MessageInstance::PickDelete(PickDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for PickGodDelete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.query_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PickGodDelete_AgentData::read_from(buffer));
        // Block Data
        let data = try!(PickGodDelete_Data::read_from(buffer));
        Ok(MessageInstance::PickGodDelete(PickGodDelete {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ScriptQuestion {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbc]));
        // Block Data
        try!(buffer.write(self.data.task_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.object_owner[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.questions));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(ScriptQuestion_Data::read_from(buffer));
        Ok(MessageInstance::ScriptQuestion(ScriptQuestion { data: data }))
    }
}

impl Message for ScriptControlChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbd]));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u8(item.take_controls as u8));
            try!(buffer.write_u32::<LittleEndian>(item.controls));
            try!(buffer.write_u8(item.pass_to_agent as u8));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(ScriptControlChange_Data::read_from(buffer)));
        }
        Ok(MessageInstance::ScriptControlChange(ScriptControlChange { data: data }))
    }
}

impl Message for ScriptDialog {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbe]));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(&self.data.first_name[..]));
        try!(buffer.write(&self.data.last_name[..]));
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.chat_channel));
        try!(buffer.write(self.data.image_id.as_bytes()));
        // Block Buttons
        try!(buffer.write_u8(self.buttons.len() as u8));
        for item in &self.buttons {
            try!(buffer.write(&item.button_label[..]));
        }
        // Block OwnerData
        try!(buffer.write_u8(self.owner_data.len() as u8));
        for item in &self.owner_data {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(ScriptDialog_Data::read_from(buffer));
        // Block Buttons
        let mut buttons = Vec::new();
        let _buttons_count = try!(buffer.read_u8());
        for _ in 0.._buttons_count {
            buttons.push(try!(ScriptDialog_Buttons::read_from(buffer)));
        }
        // Block OwnerData
        let mut owner_data = Vec::new();
        let _owner_data_count = try!(buffer.read_u8());
        for _ in 0.._owner_data_count {
            owner_data.push(try!(ScriptDialog_OwnerData::read_from(buffer)));
        }
        Ok(MessageInstance::ScriptDialog(ScriptDialog {
            data: data,
            buttons: buttons,
            owner_data: owner_data,
        }))
    }
}

impl Message for ScriptDialogReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.chat_channel));
        try!(buffer.write_i32::<LittleEndian>(self.data.button_index));
        try!(buffer.write(&self.data.button_label[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ScriptDialogReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ScriptDialogReply_Data::read_from(buffer));
        Ok(MessageInstance::ScriptDialogReply(ScriptDialogReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ForceScriptControlRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ForceScriptControlRelease_AgentData::read_from(buffer));
        Ok(MessageInstance::ForceScriptControlRelease(ForceScriptControlRelease { agent_data: agent_data }))
    }
}

impl Message for RevokePermissions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.object_permissions));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RevokePermissions_AgentData::read_from(buffer));
        // Block Data
        let data = try!(RevokePermissions_Data::read_from(buffer));
        Ok(MessageInstance::RevokePermissions(RevokePermissions {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for LoadURL {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc2]));
        // Block Data
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.data.owner_is_group as u8));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write(&self.data.url[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(LoadURL_Data::read_from(buffer));
        Ok(MessageInstance::LoadURL(LoadURL { data: data }))
    }
}

impl Message for ScriptTeleportRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc3]));
        // Block Data
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.z));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(ScriptTeleportRequest_Data::read_from(buffer));
        Ok(MessageInstance::ScriptTeleportRequest(ScriptTeleportRequest { data: data }))
    }
}

impl Message for ParcelOverlay {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc4]));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write(&self.parcel_data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let parcel_data = try!(ParcelOverlay_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelOverlay(ParcelOverlay { parcel_data: parcel_data }))
    }
}

impl Message for ParcelPropertiesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        try!(buffer.write_u8(self.parcel_data.snap_selection as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelPropertiesRequest_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelPropertiesRequest_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelPropertiesRequest(ParcelPropertiesRequest {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelPropertiesRequestByID {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelPropertiesRequestByID_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelPropertiesRequestByID_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelPropertiesRequestByID(ParcelPropertiesRequestByID {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelProperties {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x17]));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.request_result));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_u8(self.parcel_data.snap_selection as u8));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.self_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.public_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write(self.parcel_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.is_group_owned as u8));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.auction_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.claim_date));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.claim_price));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.rent_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.z));
        try!(buffer.write(&self.parcel_data.bitmap[..]));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.area));
        try!(buffer.write_u8(self.parcel_data.status));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_max_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_total_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.max_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.total_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.owner_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.group_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.selected_prims));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.parcel_prim_bonus));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.desc[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write(&self.parcel_data.media_url[..]));
        try!(buffer.write(self.parcel_data.media_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.media_auto_scale));
        try!(buffer.write(self.parcel_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.auth_buyer_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z));
        try!(buffer.write_u8(self.parcel_data.landing_type));
        try!(buffer.write_u8(self.parcel_data.region_push_override as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_anonymous as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_identified as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_transacted as u8));
        // Block AgeVerificationBlock
        try!(buffer.write_u8(self.age_verification_block.region_deny_age_unverified as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let parcel_data = try!(ParcelProperties_ParcelData::read_from(buffer));
        // Block AgeVerificationBlock
        let age_verification_block = try!(ParcelProperties_AgeVerificationBlock::read_from(buffer));
        Ok(MessageInstance::ParcelProperties(ParcelProperties {
            parcel_data: parcel_data,
            age_verification_block: age_verification_block,
        }))
    }
}

impl Message for ParcelPropertiesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.desc[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write(&self.parcel_data.media_url[..]));
        try!(buffer.write(self.parcel_data.media_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.media_auto_scale));
        try!(buffer.write(self.parcel_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.auth_buyer_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z));
        try!(buffer.write_u8(self.parcel_data.landing_type));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelPropertiesUpdate_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelPropertiesUpdate_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelPropertiesUpdate(ParcelPropertiesUpdate {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelReturnObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block TaskIDs
        try!(buffer.write_u8(self.task_i_ds.len() as u8));
        for item in &self.task_i_ds {
            try!(buffer.write(item.task_id.as_bytes()));
        }
        // Block OwnerIDs
        try!(buffer.write_u8(self.owner_i_ds.len() as u8));
        for item in &self.owner_i_ds {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelReturnObjects_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelReturnObjects_ParcelData::read_from(buffer));
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = try!(buffer.read_u8());
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(try!(ParcelReturnObjects_TaskIDs::read_from(buffer)));
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = try!(buffer.read_u8());
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(try!(ParcelReturnObjects_OwnerIDs::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelReturnObjects(ParcelReturnObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            task_i_ds: task_i_ds,
            owner_i_ds: owner_i_ds,
        }))
    }
}

impl Message for ParcelSetOtherCleanTime {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelSetOtherCleanTime_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelSetOtherCleanTime_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelSetOtherCleanTime(ParcelSetOtherCleanTime {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDisableObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block TaskIDs
        try!(buffer.write_u8(self.task_i_ds.len() as u8));
        for item in &self.task_i_ds {
            try!(buffer.write(item.task_id.as_bytes()));
        }
        // Block OwnerIDs
        try!(buffer.write_u8(self.owner_i_ds.len() as u8));
        for item in &self.owner_i_ds {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelDisableObjects_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelDisableObjects_ParcelData::read_from(buffer));
        // Block TaskIDs
        let mut task_i_ds = Vec::new();
        let _task_i_ds_count = try!(buffer.read_u8());
        for _ in 0.._task_i_ds_count {
            task_i_ds.push(try!(ParcelDisableObjects_TaskIDs::read_from(buffer)));
        }
        // Block OwnerIDs
        let mut owner_i_ds = Vec::new();
        let _owner_i_ds_count = try!(buffer.read_u8());
        for _ in 0.._owner_i_ds_count {
            owner_i_ds.push(try!(ParcelDisableObjects_OwnerIDs::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelDisableObjects(ParcelDisableObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            task_i_ds: task_i_ds,
            owner_i_ds: owner_i_ds,
        }))
    }
}

impl Message for ParcelSelectObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xca]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block ReturnIDs
        try!(buffer.write_u8(self.return_i_ds.len() as u8));
        for item in &self.return_i_ds {
            try!(buffer.write(item.return_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelSelectObjects_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelSelectObjects_ParcelData::read_from(buffer));
        // Block ReturnIDs
        let mut return_i_ds = Vec::new();
        let _return_i_ds_count = try!(buffer.read_u8());
        for _ in 0.._return_i_ds_count {
            return_i_ds.push(try!(ParcelSelectObjects_ReturnIDs::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelSelectObjects(ParcelSelectObjects {
            agent_data: agent_data,
            parcel_data: parcel_data,
            return_i_ds: return_i_ds,
        }))
    }
}

impl Message for EstateCovenantRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EstateCovenantRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::EstateCovenantRequest(EstateCovenantRequest { agent_data: agent_data }))
    }
}

impl Message for EstateCovenantReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcc]));
        // Block Data
        try!(buffer.write(self.data.covenant_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.covenant_timestamp));
        try!(buffer.write(&self.data.estate_name[..]));
        try!(buffer.write(self.data.estate_owner_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(EstateCovenantReply_Data::read_from(buffer));
        Ok(MessageInstance::EstateCovenantReply(EstateCovenantReply { data: data }))
    }
}

impl Message for ForceObjectSelect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcd]));
        // Block Header
        try!(buffer.write_u8(self.header.reset_list as u8));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Header
        let header = try!(ForceObjectSelect_Header::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(ForceObjectSelect_Data::read_from(buffer)));
        }
        Ok(MessageInstance::ForceObjectSelect(ForceObjectSelect {
            header: header,
            data: data,
        }))
    }
}

impl Message for ParcelBuyPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xce]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelBuyPass_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelBuyPass_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelBuyPass(ParcelBuyPass {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDeedToGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelDeedToGroup_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelDeedToGroup_Data::read_from(buffer));
        Ok(MessageInstance::ParcelDeedToGroup(ParcelDeedToGroup {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelReclaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelReclaim_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelReclaim_Data::read_from(buffer));
        Ok(MessageInstance::ParcelReclaim(ParcelReclaim {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelClaim {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.is_group_owned as u8));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write_f32::<LittleEndian>(item.west));
            try!(buffer.write_f32::<LittleEndian>(item.south));
            try!(buffer.write_f32::<LittleEndian>(item.east));
            try!(buffer.write_f32::<LittleEndian>(item.north));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelClaim_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelClaim_Data::read_from(buffer));
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(ParcelClaim_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelClaim(ParcelClaim {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelJoin {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd2]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelJoin_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelJoin_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelJoin(ParcelJoin {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelDivide {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelDivide_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelDivide_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelDivide(ParcelDivide {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelRelease {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelRelease_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelRelease_Data::read_from(buffer));
        Ok(MessageInstance::ParcelRelease(ParcelRelease {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelBuy {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.is_group_owned as u8));
        try!(buffer.write_u8(self.data.remove_contribution as u8));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.area));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelBuy_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelBuy_Data::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelBuy_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelBuy(ParcelBuy {
            agent_data: agent_data,
            data: data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ParcelGodForceOwner {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelGodForceOwner_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelGodForceOwner_Data::read_from(buffer));
        Ok(MessageInstance::ParcelGodForceOwner(ParcelGodForceOwner {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelAccessListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelAccessListRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelAccessListRequest_Data::read_from(buffer));
        Ok(MessageInstance::ParcelAccessListRequest(ParcelAccessListRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelAccessListReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd8]));
        // Block Data
        try!(buffer.write(self.data.agent_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        // Block List
        try!(buffer.write_u8(self.list.len() as u8));
        for item in &self.list {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.time));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(ParcelAccessListReply_Data::read_from(buffer));
        // Block List
        let mut list = Vec::new();
        let _list_count = try!(buffer.read_u8());
        for _ in 0.._list_count {
            list.push(try!(ParcelAccessListReply_List::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelAccessListReply(ParcelAccessListReply {
            data: data,
            list: list,
        }))
    }
}

impl Message for ParcelAccessListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.transaction_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_i32::<LittleEndian>(self.data.sections));
        // Block List
        try!(buffer.write_u8(self.list.len() as u8));
        for item in &self.list {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.time));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelAccessListUpdate_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelAccessListUpdate_Data::read_from(buffer));
        // Block List
        let mut list = Vec::new();
        let _list_count = try!(buffer.read_u8());
        for _ in 0.._list_count {
            list.push(try!(ParcelAccessListUpdate_List::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelAccessListUpdate(ParcelAccessListUpdate {
            agent_data: agent_data,
            data: data,
            list: list,
        }))
    }
}

impl Message for ParcelDwellRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xda]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelDwellRequest_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelDwellRequest_Data::read_from(buffer));
        Ok(MessageInstance::ParcelDwellRequest(ParcelDwellRequest {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ParcelDwellReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data.dwell));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelDwellReply_AgentData::read_from(buffer));
        // Block Data
        let data = try!(ParcelDwellReply_Data::read_from(buffer));
        Ok(MessageInstance::ParcelDwellReply(ParcelDwellReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for RequestParcelTransfer {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdc]));
        // Block Data
        try!(buffer.write(self.data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.transaction_time));
        try!(buffer.write(self.data.source_id.as_bytes()));
        try!(buffer.write(self.data.dest_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.transaction_type));
        try!(buffer.write_i32::<LittleEndian>(self.data.amount));
        try!(buffer.write_i32::<LittleEndian>(self.data.billable_area));
        try!(buffer.write_i32::<LittleEndian>(self.data.actual_area));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block RegionData
        try!(buffer.write(self.region_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.region_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.region_data.grid_y));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(RequestParcelTransfer_Data::read_from(buffer));
        // Block RegionData
        let region_data = try!(RequestParcelTransfer_RegionData::read_from(buffer));
        Ok(MessageInstance::RequestParcelTransfer(RequestParcelTransfer {
            data: data,
            region_data: region_data,
        }))
    }
}

impl Message for UpdateParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdd]));
        // Block ParcelData
        try!(buffer.write(self.parcel_data.parcel_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.parcel_data.region_handle));
        try!(buffer.write(self.parcel_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.group_owned as u8));
        try!(buffer.write_u8(self.parcel_data.status));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.description[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.region_x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.region_y));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.actual_area));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.billable_area));
        try!(buffer.write_u8(self.parcel_data.show_dir as u8));
        try!(buffer.write_u8(self.parcel_data.is_for_sale as u8));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(self.parcel_data.authorized_buyer_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.allow_publish as u8));
        try!(buffer.write_u8(self.parcel_data.mature_publish as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let parcel_data = try!(UpdateParcel_ParcelData::read_from(buffer));
        Ok(MessageInstance::UpdateParcel(UpdateParcel { parcel_data: parcel_data }))
    }
}

impl Message for RemoveParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xde]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(RemoveParcel_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::RemoveParcel(RemoveParcel { parcel_data: parcel_data }))
    }
}

impl Message for MergeParcel {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdf]));
        // Block MasterParcelData
        try!(buffer.write(self.master_parcel_data.master_id.as_bytes()));
        // Block SlaveParcelData
        try!(buffer.write_u8(self.slave_parcel_data.len() as u8));
        for item in &self.slave_parcel_data {
            try!(buffer.write(item.slave_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MasterParcelData
        let master_parcel_data = try!(MergeParcel_MasterParcelData::read_from(buffer));
        // Block SlaveParcelData
        let mut slave_parcel_data = Vec::new();
        let _slave_parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._slave_parcel_data_count {
            slave_parcel_data.push(try!(MergeParcel_SlaveParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::MergeParcel(MergeParcel {
            master_parcel_data: master_parcel_data,
            slave_parcel_data: slave_parcel_data,
        }))
    }
}

impl Message for LogParcelChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.is_owner_group as u8));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
            try!(buffer.write_i8(item.action));
            try!(buffer.write(item.transaction_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LogParcelChanges_AgentData::read_from(buffer));
        // Block RegionData
        let region_data = try!(LogParcelChanges_RegionData::read_from(buffer));
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(LogParcelChanges_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::LogParcelChanges(LogParcelChanges {
            agent_data: agent_data,
            region_data: region_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for CheckParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe1]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = try!(buffer.read_u8());
        for _ in 0.._region_data_count {
            region_data.push(try!(CheckParcelSales_RegionData::read_from(buffer)));
        }
        Ok(MessageInstance::CheckParcelSales(CheckParcelSales { region_data: region_data }))
    }
}

impl Message for ParcelSales {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe2]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.buyer_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(ParcelSales_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelSales(ParcelSales { parcel_data: parcel_data }))
    }
}

impl Message for ParcelGodMarkAsContent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ParcelGodMarkAsContent_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ParcelGodMarkAsContent_ParcelData::read_from(buffer));
        Ok(MessageInstance::ParcelGodMarkAsContent(ParcelGodMarkAsContent {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ViewerStartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ViewerStartAuction_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(ViewerStartAuction_ParcelData::read_from(buffer));
        Ok(MessageInstance::ViewerStartAuction(ViewerStartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for StartAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write(self.parcel_data.parcel_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.parcel_data.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(StartAuction_AgentData::read_from(buffer));
        // Block ParcelData
        let parcel_data = try!(StartAuction_ParcelData::read_from(buffer));
        Ok(MessageInstance::StartAuction(StartAuction {
            agent_data: agent_data,
            parcel_data: parcel_data,
        }))
    }
}

impl Message for ConfirmAuctionStart {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe6]));
        // Block AuctionData
        try!(buffer.write(self.auction_data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.auction_data.auction_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AuctionData
        let auction_data = try!(ConfirmAuctionStart_AuctionData::read_from(buffer));
        Ok(MessageInstance::ConfirmAuctionStart(ConfirmAuctionStart { auction_data: auction_data }))
    }
}

impl Message for CompleteAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe7]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(CompleteAuction_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::CompleteAuction(CompleteAuction { parcel_data: parcel_data }))
    }
}

impl Message for CancelAuction {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe8]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(CancelAuction_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::CancelAuction(CancelAuction { parcel_data: parcel_data }))
    }
}

impl Message for CheckParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe9]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RegionData
        let mut region_data = Vec::new();
        let _region_data_count = try!(buffer.read_u8());
        for _ in 0.._region_data_count {
            region_data.push(try!(CheckParcelAuctions_RegionData::read_from(buffer)));
        }
        Ok(MessageInstance::CheckParcelAuctions(CheckParcelAuctions { region_data: region_data }))
    }
}

impl Message for ParcelAuctions {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xea]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.winner_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(ParcelAuctions_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelAuctions(ParcelAuctions { parcel_data: parcel_data }))
    }
}

impl Message for UUIDNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xeb]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = try!(buffer.read_u8());
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(try!(UUIDNameRequest_UUIDNameBlock::read_from(buffer)));
        }
        Ok(MessageInstance::UUIDNameRequest(UUIDNameRequest { uuid_name_block: uuid_name_block }))
    }
}

impl Message for UUIDNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xec]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = try!(buffer.read_u8());
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(try!(UUIDNameReply_UUIDNameBlock::read_from(buffer)));
        }
        Ok(MessageInstance::UUIDNameReply(UUIDNameReply { uuid_name_block: uuid_name_block }))
    }
}

impl Message for UUIDGroupNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xed]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = try!(buffer.read_u8());
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(try!(UUIDGroupNameRequest_UUIDNameBlock::read_from(buffer)));
        }
        Ok(MessageInstance::UUIDGroupNameRequest(UUIDGroupNameRequest { uuid_name_block: uuid_name_block }))
    }
}

impl Message for UUIDGroupNameReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xee]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UUIDNameBlock
        let mut uuid_name_block = Vec::new();
        let _uuid_name_block_count = try!(buffer.read_u8());
        for _ in 0.._uuid_name_block_count {
            uuid_name_block.push(try!(UUIDGroupNameReply_UUIDNameBlock::read_from(buffer)));
        }
        Ok(MessageInstance::UUIDGroupNameReply(UUIDGroupNameReply { uuid_name_block: uuid_name_block }))
    }
}

impl Message for ChatPass {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xef]));
        // Block ChatData
        try!(buffer.write_i32::<LittleEndian>(self.chat_data.channel));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.z));
        try!(buffer.write(self.chat_data.id.as_bytes()));
        try!(buffer.write(self.chat_data.owner_id.as_bytes()));
        try!(buffer.write(&self.chat_data.name[..]));
        try!(buffer.write_u8(self.chat_data.source_type));
        try!(buffer.write_u8(self.chat_data.type_));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.radius));
        try!(buffer.write_u8(self.chat_data.sim_access));
        try!(buffer.write(&self.chat_data.message[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ChatData
        let chat_data = try!(ChatPass_ChatData::read_from(buffer));
        Ok(MessageInstance::ChatPass(ChatPass { chat_data: chat_data }))
    }
}

impl Message for EdgeDataPacket {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x18]));
        // Block EdgeData
        try!(buffer.write_u8(self.edge_data.layer_type));
        try!(buffer.write_u8(self.edge_data.direction));
        try!(buffer.write(&self.edge_data.layer_data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block EdgeData
        let edge_data = try!(EdgeDataPacket_EdgeData::read_from(buffer));
        Ok(MessageInstance::EdgeDataPacket(EdgeDataPacket { edge_data: edge_data }))
    }
}

impl Message for SimStatus {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0c]));
        // Block SimStatus
        try!(buffer.write_u8(self.sim_status.can_accept_agents as u8));
        try!(buffer.write_u8(self.sim_status.can_accept_tasks as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SimStatus
        let sim_status = try!(SimStatus_SimStatus::read_from(buffer));
        Ok(MessageInstance::SimStatus(SimStatus { sim_status: sim_status }))
    }
}

impl Message for ChildAgentUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x19]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z));
        try!(buffer.write_u8(self.agent_data.changed_grid as u8));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.far));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.aspect));
        try!(buffer.write(&self.agent_data.throttles[..]));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.locomotion_state));
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.k));
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.k));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.control_flags));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.energy_level));
        try!(buffer.write_u8(self.agent_data.god_level));
        try!(buffer.write_u8(self.agent_data.always_run as u8));
        try!(buffer.write(self.agent_data.prey_agent.as_bytes()));
        try!(buffer.write_u8(self.agent_data.agent_access));
        try!(buffer.write(&self.agent_data.agent_textures[..]));
        try!(buffer.write(self.agent_data.active_group_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
        }
        // Block AnimationData
        try!(buffer.write_u8(self.animation_data.len() as u8));
        for item in &self.animation_data {
            try!(buffer.write(item.animation.as_bytes()));
            try!(buffer.write(item.object_id.as_bytes()));
        }
        // Block GranterBlock
        try!(buffer.write_u8(self.granter_block.len() as u8));
        for item in &self.granter_block {
            try!(buffer.write(item.granter_id.as_bytes()));
        }
        // Block NVPairData
        try!(buffer.write_u8(self.nv_pair_data.len() as u8));
        for item in &self.nv_pair_data {
            try!(buffer.write(&item.nv_pairs[..]));
        }
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        // Block AgentAccess
        try!(buffer.write_u8(self.agent_access.len() as u8));
        for item in &self.agent_access {
            try!(buffer.write_u8(item.agent_legacy_access));
            try!(buffer.write_u8(item.agent_max_access));
        }
        // Block AgentInfo
        try!(buffer.write_u8(self.agent_info.len() as u8));
        for item in &self.agent_info {
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChildAgentUpdate_AgentData::read_from(buffer));
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = try!(buffer.read_u8());
        for _ in 0.._group_data_count {
            group_data.push(try!(ChildAgentUpdate_GroupData::read_from(buffer)));
        }
        // Block AnimationData
        let mut animation_data = Vec::new();
        let _animation_data_count = try!(buffer.read_u8());
        for _ in 0.._animation_data_count {
            animation_data.push(try!(ChildAgentUpdate_AnimationData::read_from(buffer)));
        }
        // Block GranterBlock
        let mut granter_block = Vec::new();
        let _granter_block_count = try!(buffer.read_u8());
        for _ in 0.._granter_block_count {
            granter_block.push(try!(ChildAgentUpdate_GranterBlock::read_from(buffer)));
        }
        // Block NVPairData
        let mut nv_pair_data = Vec::new();
        let _nv_pair_data_count = try!(buffer.read_u8());
        for _ in 0.._nv_pair_data_count {
            nv_pair_data.push(try!(ChildAgentUpdate_NVPairData::read_from(buffer)));
        }
        // Block VisualParam
        let mut visual_param = Vec::new();
        let _visual_param_count = try!(buffer.read_u8());
        for _ in 0.._visual_param_count {
            visual_param.push(try!(ChildAgentUpdate_VisualParam::read_from(buffer)));
        }
        // Block AgentAccess
        let mut agent_access = Vec::new();
        let _agent_access_count = try!(buffer.read_u8());
        for _ in 0.._agent_access_count {
            agent_access.push(try!(ChildAgentUpdate_AgentAccess::read_from(buffer)));
        }
        // Block AgentInfo
        let mut agent_info = Vec::new();
        let _agent_info_count = try!(buffer.read_u8());
        for _ in 0.._agent_info_count {
            agent_info.push(try!(ChildAgentUpdate_AgentInfo::read_from(buffer)));
        }
        Ok(MessageInstance::ChildAgentUpdate(ChildAgentUpdate {
            agent_data: agent_data,
            group_data: group_data,
            animation_data: animation_data,
            granter_block: granter_block,
            nv_pair_data: nv_pair_data,
            visual_param: visual_param,
            agent_access: agent_access,
            agent_info: agent_info,
        }))
    }
}

impl Message for ChildAgentAlive {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x1a]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChildAgentAlive_AgentData::read_from(buffer));
        Ok(MessageInstance::ChildAgentAlive(ChildAgentAlive { agent_data: agent_data }))
    }
}

impl Message for ChildAgentPositionUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x1b]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z));
        try!(buffer.write_u8(self.agent_data.changed_grid as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChildAgentPositionUpdate_AgentData::read_from(buffer));
        Ok(MessageInstance::ChildAgentPositionUpdate(ChildAgentPositionUpdate { agent_data: agent_data }))
    }
}

impl Message for ChildAgentDying {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChildAgentDying_AgentData::read_from(buffer));
        Ok(MessageInstance::ChildAgentDying(ChildAgentDying { agent_data: agent_data }))
    }
}

impl Message for ChildAgentUnknown {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChildAgentUnknown_AgentData::read_from(buffer));
        Ok(MessageInstance::ChildAgentUnknown(ChildAgentUnknown { agent_data: agent_data }))
    }
}

impl Message for AtomicPassObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x1c]));
        // Block TaskData
        try!(buffer.write(self.task_data.task_id.as_bytes()));
        try!(buffer.write_u8(self.task_data.attachment_needs_save as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TaskData
        let task_data = try!(AtomicPassObject_TaskData::read_from(buffer));
        Ok(MessageInstance::AtomicPassObject(AtomicPassObject { task_data: task_data }))
    }
}

impl Message for KillChildAgents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf2]));
        // Block IDBlock
        try!(buffer.write(self.id_block.agent_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block IDBlock
        let id_block = try!(KillChildAgents_IDBlock::read_from(buffer));
        Ok(MessageInstance::KillChildAgents(KillChildAgents { id_block: id_block }))
    }
}

impl Message for GetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf3]));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Script
        let script = try!(GetScriptRunning_Script::read_from(buffer));
        Ok(MessageInstance::GetScriptRunning(GetScriptRunning { script: script }))
    }
}

impl Message for ScriptRunningReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf4]));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        try!(buffer.write_u8(self.script.running as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Script
        let script = try!(ScriptRunningReply_Script::read_from(buffer));
        Ok(MessageInstance::ScriptRunningReply(ScriptRunningReply { script: script }))
    }
}

impl Message for SetScriptRunning {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        try!(buffer.write_u8(self.script.running as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SetScriptRunning_AgentData::read_from(buffer));
        // Block Script
        let script = try!(SetScriptRunning_Script::read_from(buffer));
        Ok(MessageInstance::SetScriptRunning(SetScriptRunning {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for ScriptReset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ScriptReset_AgentData::read_from(buffer));
        // Block Script
        let script = try!(ScriptReset_Script::read_from(buffer));
        Ok(MessageInstance::ScriptReset(ScriptReset {
            agent_data: agent_data,
            script: script,
        }))
    }
}

impl Message for ScriptSensorRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf7]));
        // Block Requester
        try!(buffer.write(self.requester.source_id.as_bytes()));
        try!(buffer.write(self.requester.request_id.as_bytes()));
        try!(buffer.write(self.requester.search_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.z));
        let normed_search_dir = UnitQuaternion::new(&self.requester.search_dir).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.i));
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.j));
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.k));
        try!(buffer.write(&self.requester.search_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.requester.type_));
        try!(buffer.write_f32::<LittleEndian>(self.requester.range));
        try!(buffer.write_f32::<LittleEndian>(self.requester.arc));
        try!(buffer.write_u64::<LittleEndian>(self.requester.region_handle));
        try!(buffer.write_u8(self.requester.search_regions));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Requester
        let requester = try!(ScriptSensorRequest_Requester::read_from(buffer));
        Ok(MessageInstance::ScriptSensorRequest(ScriptSensorRequest { requester: requester }))
    }
}

impl Message for ScriptSensorReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf8]));
        // Block Requester
        try!(buffer.write(self.requester.source_id.as_bytes()));
        // Block SensedData
        try!(buffer.write_u8(self.sensed_data.len() as u8));
        for item in &self.sensed_data {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.x));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.y));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.z));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.range));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Requester
        let requester = try!(ScriptSensorReply_Requester::read_from(buffer));
        // Block SensedData
        let mut sensed_data = Vec::new();
        let _sensed_data_count = try!(buffer.read_u8());
        for _ in 0.._sensed_data_count {
            sensed_data.push(try!(ScriptSensorReply_SensedData::read_from(buffer)));
        }
        Ok(MessageInstance::ScriptSensorReply(ScriptSensorReply {
            requester: requester,
            sensed_data: sensed_data,
        }))
    }
}

impl Message for CompleteAgentMovement {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CompleteAgentMovement_AgentData::read_from(buffer));
        Ok(MessageInstance::CompleteAgentMovement(CompleteAgentMovement { agent_data: agent_data }))
    }
}

impl Message for AgentMovementComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_f32::<LittleEndian>(self.data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.z));
        try!(buffer.write_u64::<LittleEndian>(self.data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.data.timestamp));
        // Block SimData
        try!(buffer.write(&self.sim_data.channel_version[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentMovementComplete_AgentData::read_from(buffer));
        // Block Data
        let data = try!(AgentMovementComplete_Data::read_from(buffer));
        // Block SimData
        let sim_data = try!(AgentMovementComplete_SimData::read_from(buffer));
        Ok(MessageInstance::AgentMovementComplete(AgentMovementComplete {
            agent_data: agent_data,
            data: data,
            sim_data: sim_data,
        }))
    }
}

impl Message for DataServerLogout {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfb]));
        // Block UserData
        try!(buffer.write(self.user_data.agent_id.as_bytes()));
        try!(buffer.write(&self.user_data.viewer_ip.octets()));
        try!(buffer.write_u8(self.user_data.disconnect as u8));
        try!(buffer.write(self.user_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block UserData
        let user_data = try!(DataServerLogout_UserData::read_from(buffer));
        Ok(MessageInstance::DataServerLogout(DataServerLogout { user_data: user_data }))
    }
}

impl Message for LogoutRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfc]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LogoutRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::LogoutRequest(LogoutRequest { agent_data: agent_data }))
    }
}

impl Message for LogoutReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfd]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LogoutReply_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(LogoutReply_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::LogoutReply(LogoutReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ImprovedInstantMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfe]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MessageBlock
        try!(buffer.write_u8(self.message_block.from_group as u8));
        try!(buffer.write(self.message_block.to_agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.message_block.parent_estate_id));
        try!(buffer.write(self.message_block.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.z));
        try!(buffer.write_u8(self.message_block.offline));
        try!(buffer.write_u8(self.message_block.dialog));
        try!(buffer.write(self.message_block.id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.message_block.timestamp));
        try!(buffer.write(&self.message_block.from_agent_name[..]));
        try!(buffer.write(&self.message_block.message[..]));
        try!(buffer.write(&self.message_block.binary_bucket[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ImprovedInstantMessage_AgentData::read_from(buffer));
        // Block MessageBlock
        let message_block = try!(ImprovedInstantMessage_MessageBlock::read_from(buffer));
        Ok(MessageInstance::ImprovedInstantMessage(ImprovedInstantMessage {
            agent_data: agent_data,
            message_block: message_block,
        }))
    }
}

impl Message for RetrieveInstantMessages {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xff]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RetrieveInstantMessages_AgentData::read_from(buffer));
        Ok(MessageInstance::RetrieveInstantMessages(RetrieveInstantMessages { agent_data: agent_data }))
    }
}

impl Message for FindAgent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x00]));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.hunter.as_bytes()));
        try!(buffer.write(self.agent_block.prey.as_bytes()));
        try!(buffer.write(&self.agent_block.space_ip.octets()));
        // Block LocationBlock
        try!(buffer.write_u8(self.location_block.len() as u8));
        for item in &self.location_block {
            try!(buffer.write_f64::<LittleEndian>(item.global_x));
            try!(buffer.write_f64::<LittleEndian>(item.global_y));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentBlock
        let agent_block = try!(FindAgent_AgentBlock::read_from(buffer));
        // Block LocationBlock
        let mut location_block = Vec::new();
        let _location_block_count = try!(buffer.read_u8());
        for _ in 0.._location_block_count {
            location_block.push(try!(FindAgent_LocationBlock::read_from(buffer)));
        }
        Ok(MessageInstance::FindAgent(FindAgent {
            agent_block: agent_block,
            location_block: location_block,
        }))
    }
}

impl Message for RequestGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x01]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestBlock
        try!(buffer.write_u8(self.request_block.godlike as u8));
        try!(buffer.write(self.request_block.token.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestGodlikePowers_AgentData::read_from(buffer));
        // Block RequestBlock
        let request_block = try!(RequestGodlikePowers_RequestBlock::read_from(buffer));
        Ok(MessageInstance::RequestGodlikePowers(RequestGodlikePowers {
            agent_data: agent_data,
            request_block: request_block,
        }))
    }
}

impl Message for GrantGodlikePowers {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x02]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GrantData
        try!(buffer.write_u8(self.grant_data.god_level));
        try!(buffer.write(self.grant_data.token.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GrantGodlikePowers_AgentData::read_from(buffer));
        // Block GrantData
        let grant_data = try!(GrantGodlikePowers_GrantData::read_from(buffer));
        Ok(MessageInstance::GrantGodlikePowers(GrantGodlikePowers {
            agent_data: agent_data,
            grant_data: grant_data,
        }))
    }
}

impl Message for GodlikeMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x03]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GodlikeMessage_AgentData::read_from(buffer));
        // Block MethodData
        let method_data = try!(GodlikeMessage_MethodData::read_from(buffer));
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = try!(buffer.read_u8());
        for _ in 0.._param_list_count {
            param_list.push(try!(GodlikeMessage_ParamList::read_from(buffer)));
        }
        Ok(MessageInstance::GodlikeMessage(GodlikeMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for EstateOwnerMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EstateOwnerMessage_AgentData::read_from(buffer));
        // Block MethodData
        let method_data = try!(EstateOwnerMessage_MethodData::read_from(buffer));
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = try!(buffer.read_u8());
        for _ in 0.._param_list_count {
            param_list.push(try!(EstateOwnerMessage_ParamList::read_from(buffer)));
        }
        Ok(MessageInstance::EstateOwnerMessage(EstateOwnerMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for GenericMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GenericMessage_AgentData::read_from(buffer));
        // Block MethodData
        let method_data = try!(GenericMessage_MethodData::read_from(buffer));
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = try!(buffer.read_u8());
        for _ in 0.._param_list_count {
            param_list.push(try!(GenericMessage_ParamList::read_from(buffer)));
        }
        Ok(MessageInstance::GenericMessage(GenericMessage {
            agent_data: agent_data,
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for MuteListRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x06]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write_u32::<LittleEndian>(self.mute_data.mute_crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MuteListRequest_AgentData::read_from(buffer));
        // Block MuteData
        let mute_data = try!(MuteListRequest_MuteData::read_from(buffer));
        Ok(MessageInstance::MuteListRequest(MuteListRequest {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for UpdateMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write(self.mute_data.mute_id.as_bytes()));
        try!(buffer.write(&self.mute_data.mute_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.mute_data.mute_type));
        try!(buffer.write_u32::<LittleEndian>(self.mute_data.mute_flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateMuteListEntry_AgentData::read_from(buffer));
        // Block MuteData
        let mute_data = try!(UpdateMuteListEntry_MuteData::read_from(buffer));
        Ok(MessageInstance::UpdateMuteListEntry(UpdateMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for RemoveMuteListEntry {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write(self.mute_data.mute_id.as_bytes()));
        try!(buffer.write(&self.mute_data.mute_name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveMuteListEntry_AgentData::read_from(buffer));
        // Block MuteData
        let mute_data = try!(RemoveMuteListEntry_MuteData::read_from(buffer));
        Ok(MessageInstance::RemoveMuteListEntry(RemoveMuteListEntry {
            agent_data: agent_data,
            mute_data: mute_data,
        }))
    }
}

impl Message for CopyInventoryFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x09]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block NotecardData
        try!(buffer.write(self.notecard_data.notecard_item_id.as_bytes()));
        try!(buffer.write(self.notecard_data.object_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CopyInventoryFromNotecard_AgentData::read_from(buffer));
        // Block NotecardData
        let notecard_data = try!(CopyInventoryFromNotecard_NotecardData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(CopyInventoryFromNotecard_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::CopyInventoryFromNotecard(CopyInventoryFromNotecard {
            agent_data: agent_data,
            notecard_data: notecard_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.transaction_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateInventoryItem_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(UpdateInventoryItem_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::UpdateInventoryItem(UpdateInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateCreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.sim_approved as u8));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateCreateInventoryItem_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(UpdateCreateInventoryItem_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::UpdateCreateInventoryItem(UpdateCreateInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.stamp as u8));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MoveInventoryItem_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(MoveInventoryItem_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::MoveInventoryItem(MoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for CopyInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.old_agent_id.as_bytes()));
            try!(buffer.write(item.old_item_id.as_bytes()));
            try!(buffer.write(item.new_folder_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CopyInventoryItem_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(CopyInventoryItem_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::CopyInventoryItem(CopyInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveInventoryItem_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(RemoveInventoryItem_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::RemoveInventoryItem(RemoveInventoryItem {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ChangeInventoryItemFlags {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChangeInventoryItemFlags_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(ChangeInventoryItemFlags_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::ChangeInventoryItemFlags(ChangeInventoryItemFlags {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for SaveAssetIntoInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x10]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.new_asset_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SaveAssetIntoInventory_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(SaveAssetIntoInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::SaveAssetIntoInventory(SaveAssetIntoInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for CreateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x11]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write(self.folder_data.folder_id.as_bytes()));
        try!(buffer.write(self.folder_data.parent_id.as_bytes()));
        try!(buffer.write_i8(self.folder_data.type_));
        try!(buffer.write(&self.folder_data.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateInventoryFolder_AgentData::read_from(buffer));
        // Block FolderData
        let folder_data = try!(CreateInventoryFolder_FolderData::read_from(buffer));
        Ok(MessageInstance::CreateInventoryFolder(CreateInventoryFolder {
            agent_data: agent_data,
            folder_data: folder_data,
        }))
    }
}

impl Message for UpdateInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x12]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateInventoryFolder_AgentData::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(UpdateInventoryFolder_FolderData::read_from(buffer)));
        }
        Ok(MessageInstance::UpdateInventoryFolder(UpdateInventoryFolder {
            agent_data: agent_data,
            folder_data: folder_data,
        }))
    }
}

impl Message for MoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x13]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.stamp as u8));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MoveInventoryFolder_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(MoveInventoryFolder_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::MoveInventoryFolder(MoveInventoryFolder {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveInventoryFolder {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x14]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveInventoryFolder_AgentData::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(RemoveInventoryFolder_FolderData::read_from(buffer)));
        }
        Ok(MessageInstance::RemoveInventoryFolder(RemoveInventoryFolder {
            agent_data: agent_data,
            folder_data: folder_data,
        }))
    }
}

impl Message for FetchInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x15]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sort_order));
        try!(buffer.write_u8(self.inventory_data.fetch_folders as u8));
        try!(buffer.write_u8(self.inventory_data.fetch_items as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(FetchInventoryDescendents_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(FetchInventoryDescendents_InventoryData::read_from(buffer));
        Ok(MessageInstance::FetchInventoryDescendents(FetchInventoryDescendents {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for InventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x16]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.folder_id.as_bytes()));
        try!(buffer.write(self.agent_data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.version));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.descendents));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(InventoryDescendents_AgentData::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(InventoryDescendents_FolderData::read_from(buffer)));
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = try!(buffer.read_u8());
        for _ in 0.._item_data_count {
            item_data.push(try!(InventoryDescendents_ItemData::read_from(buffer)));
        }
        Ok(MessageInstance::InventoryDescendents(InventoryDescendents {
            agent_data: agent_data,
            folder_data: folder_data,
            item_data: item_data,
        }))
    }
}

impl Message for FetchInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x17]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(FetchInventory_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(FetchInventory_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::FetchInventory(FetchInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for FetchInventoryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x18]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(FetchInventoryReply_AgentData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(FetchInventoryReply_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::FetchInventoryReply(FetchInventoryReply {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for BulkUpdateInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x19]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(BulkUpdateInventory_AgentData::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(BulkUpdateInventory_FolderData::read_from(buffer)));
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = try!(buffer.read_u8());
        for _ in 0.._item_data_count {
            item_data.push(try!(BulkUpdateInventory_ItemData::read_from(buffer)));
        }
        Ok(MessageInstance::BulkUpdateInventory(BulkUpdateInventory {
            agent_data: agent_data,
            folder_data: folder_data,
            item_data: item_data,
        }))
    }
}

impl Message for RequestInventoryAsset {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1a]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(self.query_data.agent_id.as_bytes()));
        try!(buffer.write(self.query_data.owner_id.as_bytes()));
        try!(buffer.write(self.query_data.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block QueryData
        let query_data = try!(RequestInventoryAsset_QueryData::read_from(buffer));
        Ok(MessageInstance::RequestInventoryAsset(RequestInventoryAsset { query_data: query_data }))
    }
}

impl Message for InventoryAssetResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1b]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(self.query_data.asset_id.as_bytes()));
        try!(buffer.write_u8(self.query_data.is_readable as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block QueryData
        let query_data = try!(InventoryAssetResponse_QueryData::read_from(buffer));
        Ok(MessageInstance::InventoryAssetResponse(InventoryAssetResponse { query_data: query_data }))
    }
}

impl Message for RemoveInventoryObjects {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveInventoryObjects_AgentData::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(RemoveInventoryObjects_FolderData::read_from(buffer)));
        }
        // Block ItemData
        let mut item_data = Vec::new();
        let _item_data_count = try!(buffer.read_u8());
        for _ in 0.._item_data_count {
            item_data.push(try!(RemoveInventoryObjects_ItemData::read_from(buffer)));
        }
        Ok(MessageInstance::RemoveInventoryObjects(RemoveInventoryObjects {
            agent_data: agent_data,
            folder_data: folder_data,
            item_data: item_data,
        }))
    }
}

impl Message for PurgeInventoryDescendents {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(PurgeInventoryDescendents_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(PurgeInventoryDescendents_InventoryData::read_from(buffer));
        Ok(MessageInstance::PurgeInventoryDescendents(PurgeInventoryDescendents {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for UpdateTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block UpdateData
        try!(buffer.write_u32::<LittleEndian>(self.update_data.local_id));
        try!(buffer.write_u8(self.update_data.key));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateTaskInventory_AgentData::read_from(buffer));
        // Block UpdateData
        let update_data = try!(UpdateTaskInventory_UpdateData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(UpdateTaskInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::UpdateTaskInventory(UpdateTaskInventory {
            agent_data: agent_data,
            update_data: update_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveTaskInventory_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(RemoveTaskInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::RemoveTaskInventory(RemoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for MoveTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x20]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.folder_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MoveTaskInventory_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(MoveTaskInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::MoveTaskInventory(MoveTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RequestTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x21]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RequestTaskInventory_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(RequestTaskInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::RequestTaskInventory(RequestTaskInventory {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for ReplyTaskInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x22]));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.task_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.inventory_data.serial));
        try!(buffer.write(&self.inventory_data.filename[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block InventoryData
        let inventory_data = try!(ReplyTaskInventory_InventoryData::read_from(buffer));
        Ok(MessageInstance::ReplyTaskInventory(ReplyTaskInventory { inventory_data: inventory_data }))
    }
}

impl Message for DeRezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x23]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.group_id.as_bytes()));
        try!(buffer.write_u8(self.agent_block.destination));
        try!(buffer.write(self.agent_block.destination_id.as_bytes()));
        try!(buffer.write(self.agent_block.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.agent_block.packet_count));
        try!(buffer.write_u8(self.agent_block.packet_number));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DeRezObject_AgentData::read_from(buffer));
        // Block AgentBlock
        let agent_block = try!(DeRezObject_AgentBlock::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(DeRezObject_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::DeRezObject(DeRezObject {
            agent_data: agent_data,
            agent_block: agent_block,
            object_data: object_data,
        }))
    }
}

impl Message for DeRezAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x24]));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_data.success as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TransactionData
        let transaction_data = try!(DeRezAck_TransactionData::read_from(buffer));
        Ok(MessageInstance::DeRezAck(DeRezAck { transaction_data: transaction_data }))
    }
}

impl Message for RezObject {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x25]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RezData
        try!(buffer.write(self.rez_data.from_task_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z));
        try!(buffer.write(self.rez_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.rez_data.rez_selected as u8));
        try!(buffer.write_u8(self.rez_data.remove_item as u8));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezObject_AgentData::read_from(buffer));
        // Block RezData
        let rez_data = try!(RezObject_RezData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(RezObject_InventoryData::read_from(buffer));
        Ok(MessageInstance::RezObject(RezObject {
            agent_data: agent_data,
            rez_data: rez_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RezObjectFromNotecard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x26]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RezData
        try!(buffer.write(self.rez_data.from_task_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z));
        try!(buffer.write(self.rez_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.rez_data.rez_selected as u8));
        try!(buffer.write_u8(self.rez_data.remove_item as u8));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask));
        // Block NotecardData
        try!(buffer.write(self.notecard_data.notecard_item_id.as_bytes()));
        try!(buffer.write(self.notecard_data.object_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezObjectFromNotecard_AgentData::read_from(buffer));
        // Block RezData
        let rez_data = try!(RezObjectFromNotecard_RezData::read_from(buffer));
        // Block NotecardData
        let notecard_data = try!(RezObjectFromNotecard_NotecardData::read_from(buffer));
        // Block InventoryData
        let mut inventory_data = Vec::new();
        let _inventory_data_count = try!(buffer.read_u8());
        for _ in 0.._inventory_data_count {
            inventory_data.push(try!(RezObjectFromNotecard_InventoryData::read_from(buffer)));
        }
        Ok(MessageInstance::RezObjectFromNotecard(RezObjectFromNotecard {
            agent_data: agent_data,
            rez_data: rez_data,
            notecard_data: notecard_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for TransferInventory {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x27]));
        // Block InfoBlock
        try!(buffer.write(self.info_block.source_id.as_bytes()));
        try!(buffer.write(self.info_block.dest_id.as_bytes()));
        try!(buffer.write(self.info_block.transaction_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u8(self.inventory_block.len() as u8));
        for item in &self.inventory_block {
            try!(buffer.write(item.inventory_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block InfoBlock
        let info_block = try!(TransferInventory_InfoBlock::read_from(buffer));
        // Block InventoryBlock
        let mut inventory_block = Vec::new();
        let _inventory_block_count = try!(buffer.read_u8());
        for _ in 0.._inventory_block_count {
            inventory_block.push(try!(TransferInventory_InventoryBlock::read_from(buffer)));
        }
        Ok(MessageInstance::TransferInventory(TransferInventory {
            info_block: info_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for TransferInventoryAck {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x28]));
        // Block InfoBlock
        try!(buffer.write(self.info_block.transaction_id.as_bytes()));
        try!(buffer.write(self.info_block.inventory_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block InfoBlock
        let info_block = try!(TransferInventoryAck_InfoBlock::read_from(buffer));
        Ok(MessageInstance::TransferInventoryAck(TransferInventoryAck { info_block: info_block }))
    }
}

impl Message for AcceptFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x29]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AcceptFriendship_AgentData::read_from(buffer));
        // Block TransactionBlock
        let transaction_block = try!(AcceptFriendship_TransactionBlock::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(AcceptFriendship_FolderData::read_from(buffer)));
        }
        Ok(MessageInstance::AcceptFriendship(AcceptFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for DeclineFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DeclineFriendship_AgentData::read_from(buffer));
        // Block TransactionBlock
        let transaction_block = try!(DeclineFriendship_TransactionBlock::read_from(buffer));
        Ok(MessageInstance::DeclineFriendship(DeclineFriendship {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for FormFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2b]));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.source_id.as_bytes()));
        try!(buffer.write(self.agent_block.dest_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentBlock
        let agent_block = try!(FormFriendship_AgentBlock::read_from(buffer));
        Ok(MessageInstance::FormFriendship(FormFriendship { agent_block: agent_block }))
    }
}

impl Message for TerminateFriendship {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ExBlock
        try!(buffer.write(self.ex_block.other_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(TerminateFriendship_AgentData::read_from(buffer));
        // Block ExBlock
        let ex_block = try!(TerminateFriendship_ExBlock::read_from(buffer));
        Ok(MessageInstance::TerminateFriendship(TerminateFriendship {
            agent_data: agent_data,
            ex_block: ex_block,
        }))
    }
}

impl Message for OfferCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.dest_id.as_bytes()));
        try!(buffer.write(self.agent_block.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(OfferCallingCard_AgentData::read_from(buffer));
        // Block AgentBlock
        let agent_block = try!(OfferCallingCard_AgentBlock::read_from(buffer));
        Ok(MessageInstance::OfferCallingCard(OfferCallingCard {
            agent_data: agent_data,
            agent_block: agent_block,
        }))
    }
}

impl Message for AcceptCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AcceptCallingCard_AgentData::read_from(buffer));
        // Block TransactionBlock
        let transaction_block = try!(AcceptCallingCard_TransactionBlock::read_from(buffer));
        // Block FolderData
        let mut folder_data = Vec::new();
        let _folder_data_count = try!(buffer.read_u8());
        for _ in 0.._folder_data_count {
            folder_data.push(try!(AcceptCallingCard_FolderData::read_from(buffer)));
        }
        Ok(MessageInstance::AcceptCallingCard(AcceptCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
            folder_data: folder_data,
        }))
    }
}

impl Message for DeclineCallingCard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DeclineCallingCard_AgentData::read_from(buffer));
        // Block TransactionBlock
        let transaction_block = try!(DeclineCallingCard_TransactionBlock::read_from(buffer));
        Ok(MessageInstance::DeclineCallingCard(DeclineCallingCard {
            agent_data: agent_data,
            transaction_block: transaction_block,
        }))
    }
}

impl Message for RezScript {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x30]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block UpdateBlock
        try!(buffer.write_u32::<LittleEndian>(self.update_block.object_local_id));
        try!(buffer.write_u8(self.update_block.enabled as u8));
        // Block InventoryBlock
        try!(buffer.write(self.inventory_block.item_id.as_bytes()));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_block.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_block.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask));
        try!(buffer.write_u8(self.inventory_block.group_owned as u8));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.flags));
        try!(buffer.write_u8(self.inventory_block.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_block.sale_price));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_block.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezScript_AgentData::read_from(buffer));
        // Block UpdateBlock
        let update_block = try!(RezScript_UpdateBlock::read_from(buffer));
        // Block InventoryBlock
        let inventory_block = try!(RezScript_InventoryBlock::read_from(buffer));
        Ok(MessageInstance::RezScript(RezScript {
            agent_data: agent_data,
            update_block: update_block,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for CreateInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x31]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write_u8(self.inventory_block.wearable_type));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateInventoryItem_AgentData::read_from(buffer));
        // Block InventoryBlock
        let inventory_block = try!(CreateInventoryItem_InventoryBlock::read_from(buffer));
        Ok(MessageInstance::CreateInventoryItem(CreateInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for CreateLandmarkForEvent {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x32]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        // Block InventoryBlock
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(&self.inventory_block.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateLandmarkForEvent_AgentData::read_from(buffer));
        // Block EventData
        let event_data = try!(CreateLandmarkForEvent_EventData::read_from(buffer));
        // Block InventoryBlock
        let inventory_block = try!(CreateLandmarkForEvent_InventoryBlock::read_from(buffer));
        Ok(MessageInstance::CreateLandmarkForEvent(CreateLandmarkForEvent {
            agent_data: agent_data,
            event_data: event_data,
            inventory_block: inventory_block,
        }))
    }
}

impl Message for EventLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x33]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block QueryData
        let query_data = try!(EventLocationRequest_QueryData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventLocationRequest_EventData::read_from(buffer));
        Ok(MessageInstance::EventLocationRequest(EventLocationRequest {
            query_data: query_data,
            event_data: event_data,
        }))
    }
}

impl Message for EventLocationReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x34]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u8(self.event_data.success as u8));
        try!(buffer.write(self.event_data.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block QueryData
        let query_data = try!(EventLocationReply_QueryData::read_from(buffer));
        // Block EventData
        let event_data = try!(EventLocationReply_EventData::read_from(buffer));
        Ok(MessageInstance::EventLocationReply(EventLocationReply {
            query_data: query_data,
            event_data: event_data,
        }))
    }
}

impl Message for RegionHandleRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x35]));
        // Block RequestBlock
        try!(buffer.write(self.request_block.region_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RequestBlock
        let request_block = try!(RegionHandleRequest_RequestBlock::read_from(buffer));
        Ok(MessageInstance::RegionHandleRequest(RegionHandleRequest { request_block: request_block }))
    }
}

impl Message for RegionIDAndHandleReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x36]));
        // Block ReplyBlock
        try!(buffer.write(self.reply_block.region_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.reply_block.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ReplyBlock
        let reply_block = try!(RegionIDAndHandleReply_ReplyBlock::read_from(buffer));
        Ok(MessageInstance::RegionIDAndHandleReply(RegionIDAndHandleReply { reply_block: reply_block }))
    }
}

impl Message for MoneyTransferRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x37]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.source_id.as_bytes()));
        try!(buffer.write(self.money_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.amount));
        try!(buffer.write_u8(self.money_data.aggregate_perm_next_owner));
        try!(buffer.write_u8(self.money_data.aggregate_perm_inventory));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.transaction_type));
        try!(buffer.write(&self.money_data.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MoneyTransferRequest_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(MoneyTransferRequest_MoneyData::read_from(buffer));
        Ok(MessageInstance::MoneyTransferRequest(MoneyTransferRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for MoneyTransferBackend {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x38]));
        // Block MoneyData
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.transaction_time));
        try!(buffer.write(self.money_data.source_id.as_bytes()));
        try!(buffer.write(self.money_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.amount));
        try!(buffer.write_u8(self.money_data.aggregate_perm_next_owner));
        try!(buffer.write_u8(self.money_data.aggregate_perm_inventory));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.transaction_type));
        try!(buffer.write(self.money_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.grid_y));
        try!(buffer.write(&self.money_data.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MoneyData
        let money_data = try!(MoneyTransferBackend_MoneyData::read_from(buffer));
        Ok(MessageInstance::MoneyTransferBackend(MoneyTransferBackend { money_data: money_data }))
    }
}

impl Message for MoneyBalanceRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x39]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MoneyBalanceRequest_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(MoneyBalanceRequest_MoneyData::read_from(buffer));
        Ok(MessageInstance::MoneyBalanceRequest(MoneyBalanceRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for MoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3a]));
        // Block MoneyData
        try!(buffer.write(self.money_data.agent_id.as_bytes()));
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.transaction_success as u8));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.money_balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed));
        try!(buffer.write(&self.money_data.description[..]));
        // Block TransactionInfo
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type));
        try!(buffer.write(self.transaction_info.source_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_source_group as u8));
        try!(buffer.write(self.transaction_info.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_dest_group as u8));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.amount));
        try!(buffer.write(&self.transaction_info.item_description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MoneyData
        let money_data = try!(MoneyBalanceReply_MoneyData::read_from(buffer));
        // Block TransactionInfo
        let transaction_info = try!(MoneyBalanceReply_TransactionInfo::read_from(buffer));
        Ok(MessageInstance::MoneyBalanceReply(MoneyBalanceReply {
            money_data: money_data,
            transaction_info: transaction_info,
        }))
    }
}

impl Message for RoutedMoneyBalanceReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3b]));
        // Block TargetBlock
        try!(buffer.write(&self.target_block.target_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.target_block.target_port));
        // Block MoneyData
        try!(buffer.write(self.money_data.agent_id.as_bytes()));
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.transaction_success as u8));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.money_balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed));
        try!(buffer.write(&self.money_data.description[..]));
        // Block TransactionInfo
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type));
        try!(buffer.write(self.transaction_info.source_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_source_group as u8));
        try!(buffer.write(self.transaction_info.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_dest_group as u8));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.amount));
        try!(buffer.write(&self.transaction_info.item_description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TargetBlock
        let target_block = try!(RoutedMoneyBalanceReply_TargetBlock::read_from(buffer));
        // Block MoneyData
        let money_data = try!(RoutedMoneyBalanceReply_MoneyData::read_from(buffer));
        // Block TransactionInfo
        let transaction_info = try!(RoutedMoneyBalanceReply_TransactionInfo::read_from(buffer));
        Ok(MessageInstance::RoutedMoneyBalanceReply(RoutedMoneyBalanceReply {
            target_block: target_block,
            money_data: money_data,
            transaction_info: transaction_info,
        }))
    }
}

impl Message for ActivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.gesture_flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ActivateGestures_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(ActivateGestures_Data::read_from(buffer)));
        }
        Ok(MessageInstance::ActivateGestures(ActivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for DeactivateGestures {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.gesture_flags));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(DeactivateGestures_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(DeactivateGestures_Data::read_from(buffer)));
        }
        Ok(MessageInstance::DeactivateGestures(DeactivateGestures {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for MuteListUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3e]));
        // Block MuteData
        try!(buffer.write(self.mute_data.agent_id.as_bytes()));
        try!(buffer.write(&self.mute_data.filename[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MuteData
        let mute_data = try!(MuteListUpdate_MuteData::read_from(buffer));
        Ok(MessageInstance::MuteListUpdate(MuteListUpdate { mute_data: mute_data }))
    }
}

impl Message for UseCachedMuteList {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UseCachedMuteList_AgentData::read_from(buffer));
        Ok(MessageInstance::UseCachedMuteList(UseCachedMuteList { agent_data: agent_data }))
    }
}

impl Message for GrantUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x40]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Rights
        try!(buffer.write_u8(self.rights.len() as u8));
        for item in &self.rights {
            try!(buffer.write(item.agent_related.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.related_rights));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GrantUserRights_AgentData::read_from(buffer));
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = try!(buffer.read_u8());
        for _ in 0.._rights_count {
            rights.push(try!(GrantUserRights_Rights::read_from(buffer)));
        }
        Ok(MessageInstance::GrantUserRights(GrantUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for ChangeUserRights {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x41]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Rights
        try!(buffer.write_u8(self.rights.len() as u8));
        for item in &self.rights {
            try!(buffer.write(item.agent_related.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.related_rights));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ChangeUserRights_AgentData::read_from(buffer));
        // Block Rights
        let mut rights = Vec::new();
        let _rights_count = try!(buffer.read_u8());
        for _ in 0.._rights_count {
            rights.push(try!(ChangeUserRights_Rights::read_from(buffer)));
        }
        Ok(MessageInstance::ChangeUserRights(ChangeUserRights {
            agent_data: agent_data,
            rights: rights,
        }))
    }
}

impl Message for OnlineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x42]));
        // Block AgentBlock
        try!(buffer.write_u8(self.agent_block.len() as u8));
        for item in &self.agent_block {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = try!(buffer.read_u8());
        for _ in 0.._agent_block_count {
            agent_block.push(try!(OnlineNotification_AgentBlock::read_from(buffer)));
        }
        Ok(MessageInstance::OnlineNotification(OnlineNotification { agent_block: agent_block }))
    }
}

impl Message for OfflineNotification {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x43]));
        // Block AgentBlock
        try!(buffer.write_u8(self.agent_block.len() as u8));
        for item in &self.agent_block {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentBlock
        let mut agent_block = Vec::new();
        let _agent_block_count = try!(buffer.read_u8());
        for _ in 0.._agent_block_count {
            agent_block.push(try!(OfflineNotification_AgentBlock::read_from(buffer)));
        }
        Ok(MessageInstance::OfflineNotification(OfflineNotification { agent_block: agent_block }))
    }
}

impl Message for SetStartLocationRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x44]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block StartLocationData
        try!(buffer.write(&self.start_location_data.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.start_location_data.location_id));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SetStartLocationRequest_AgentData::read_from(buffer));
        // Block StartLocationData
        let start_location_data = try!(SetStartLocationRequest_StartLocationData::read_from(buffer));
        Ok(MessageInstance::SetStartLocationRequest(SetStartLocationRequest {
            agent_data: agent_data,
            start_location_data: start_location_data,
        }))
    }
}

impl Message for SetStartLocation {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x45]));
        // Block StartLocationData
        try!(buffer.write(self.start_location_data.agent_id.as_bytes()));
        try!(buffer.write(self.start_location_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.start_location_data.location_id));
        try!(buffer.write_u64::<LittleEndian>(self.start_location_data.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block StartLocationData
        let start_location_data = try!(SetStartLocation_StartLocationData::read_from(buffer));
        Ok(MessageInstance::SetStartLocation(SetStartLocation { start_location_data: start_location_data }))
    }
}

impl Message for NetTest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x46]));
        // Block NetBlock
        try!(buffer.write_u16::<LittleEndian>(self.net_block.port));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block NetBlock
        let net_block = try!(NetTest_NetBlock::read_from(buffer));
        Ok(MessageInstance::NetTest(NetTest { net_block: net_block }))
    }
}

impl Message for SetCPURatio {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x47]));
        // Block Data
        try!(buffer.write_u8(self.data.ratio));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(SetCPURatio_Data::read_from(buffer));
        Ok(MessageInstance::SetCPURatio(SetCPURatio { data: data }))
    }
}

impl Message for SimCrashed {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x48]));
        // Block Data
        try!(buffer.write_u32::<LittleEndian>(self.data.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.data.region_y));
        // Block Users
        try!(buffer.write_u8(self.users.len() as u8));
        for item in &self.users {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block Data
        let data = try!(SimCrashed_Data::read_from(buffer));
        // Block Users
        let mut users = Vec::new();
        let _users_count = try!(buffer.read_u8());
        for _ in 0.._users_count {
            users.push(try!(SimCrashed_Users::read_from(buffer)));
        }
        Ok(MessageInstance::SimCrashed(SimCrashed {
            data: data,
            users: users,
        }))
    }
}

impl Message for NameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x49]));
        // Block TaskData
        try!(buffer.write(self.task_data.id.as_bytes()));
        // Block NameValueData
        try!(buffer.write_u8(self.name_value_data.len() as u8));
        for item in &self.name_value_data {
            try!(buffer.write(&item.nv_pair[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TaskData
        let task_data = try!(NameValuePair_TaskData::read_from(buffer));
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = try!(buffer.read_u8());
        for _ in 0.._name_value_data_count {
            name_value_data.push(try!(NameValuePair_NameValueData::read_from(buffer)));
        }
        Ok(MessageInstance::NameValuePair(NameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for RemoveNameValuePair {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4a]));
        // Block TaskData
        try!(buffer.write(self.task_data.id.as_bytes()));
        // Block NameValueData
        try!(buffer.write_u8(self.name_value_data.len() as u8));
        for item in &self.name_value_data {
            try!(buffer.write(&item.nv_pair[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TaskData
        let task_data = try!(RemoveNameValuePair_TaskData::read_from(buffer));
        // Block NameValueData
        let mut name_value_data = Vec::new();
        let _name_value_data_count = try!(buffer.read_u8());
        for _ in 0.._name_value_data_count {
            name_value_data.push(try!(RemoveNameValuePair_NameValueData::read_from(buffer)));
        }
        Ok(MessageInstance::RemoveNameValuePair(RemoveNameValuePair {
            task_data: task_data,
            name_value_data: name_value_data,
        }))
    }
}

impl Message for UpdateAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AttachmentBlock
        try!(buffer.write_u8(self.attachment_block.attachment_point));
        // Block OperationData
        try!(buffer.write_u8(self.operation_data.add_item as u8));
        try!(buffer.write_u8(self.operation_data.use_existing_asset as u8));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.asset_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateAttachment_AgentData::read_from(buffer));
        // Block AttachmentBlock
        let attachment_block = try!(UpdateAttachment_AttachmentBlock::read_from(buffer));
        // Block OperationData
        let operation_data = try!(UpdateAttachment_OperationData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(UpdateAttachment_InventoryData::read_from(buffer));
        Ok(MessageInstance::UpdateAttachment(UpdateAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
            operation_data: operation_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for RemoveAttachment {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AttachmentBlock
        try!(buffer.write_u8(self.attachment_block.attachment_point));
        try!(buffer.write(self.attachment_block.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RemoveAttachment_AgentData::read_from(buffer));
        // Block AttachmentBlock
        let attachment_block = try!(RemoveAttachment_AttachmentBlock::read_from(buffer));
        Ok(MessageInstance::RemoveAttachment(RemoveAttachment {
            agent_data: agent_data,
            attachment_block: attachment_block,
        }))
    }
}

impl Message for SoundTrigger {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0x1d]));
        // Block SoundData
        try!(buffer.write(self.sound_data.sound_id.as_bytes()));
        try!(buffer.write(self.sound_data.owner_id.as_bytes()));
        try!(buffer.write(self.sound_data.object_id.as_bytes()));
        try!(buffer.write(self.sound_data.parent_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.sound_data.handle));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.gain));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block SoundData
        let sound_data = try!(SoundTrigger_SoundData::read_from(buffer));
        Ok(MessageInstance::SoundTrigger(SoundTrigger { sound_data: sound_data }))
    }
}

impl Message for AttachedSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0d]));
        // Block DataBlock
        try!(buffer.write(self.data_block.sound_id.as_bytes()));
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write(self.data_block.owner_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data_block.gain));
        try!(buffer.write_u8(self.data_block.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(AttachedSound_DataBlock::read_from(buffer));
        Ok(MessageInstance::AttachedSound(AttachedSound { data_block: data_block }))
    }
}

impl Message for AttachedSoundGainChange {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0e]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data_block.gain));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(AttachedSoundGainChange_DataBlock::read_from(buffer));
        Ok(MessageInstance::AttachedSoundGainChange(AttachedSoundGainChange { data_block: data_block }))
    }
}

impl Message for PreloadSound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0f]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.sound_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = try!(buffer.read_u8());
        for _ in 0.._data_block_count {
            data_block.push(try!(PreloadSound_DataBlock::read_from(buffer)));
        }
        Ok(MessageInstance::PreloadSound(PreloadSound { data_block: data_block }))
    }
}

impl Message for AssetUploadRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4d]));
        // Block AssetBlock
        try!(buffer.write(self.asset_block.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.asset_block.type_));
        try!(buffer.write_u8(self.asset_block.tempfile as u8));
        try!(buffer.write_u8(self.asset_block.store_local as u8));
        try!(buffer.write(&self.asset_block.asset_data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AssetBlock
        let asset_block = try!(AssetUploadRequest_AssetBlock::read_from(buffer));
        Ok(MessageInstance::AssetUploadRequest(AssetUploadRequest { asset_block: asset_block }))
    }
}

impl Message for AssetUploadComplete {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4e]));
        // Block AssetBlock
        try!(buffer.write(self.asset_block.uuid.as_bytes()));
        try!(buffer.write_i8(self.asset_block.type_));
        try!(buffer.write_u8(self.asset_block.success as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AssetBlock
        let asset_block = try!(AssetUploadComplete_AssetBlock::read_from(buffer));
        Ok(MessageInstance::AssetUploadComplete(AssetUploadComplete { asset_block: asset_block }))
    }
}

impl Message for EmailMessageRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4f]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write(&self.data_block.from_address[..]));
        try!(buffer.write(&self.data_block.subject[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(EmailMessageRequest_DataBlock::read_from(buffer));
        Ok(MessageInstance::EmailMessageRequest(EmailMessageRequest { data_block: data_block }))
    }
}

impl Message for EmailMessageReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x50]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.more));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.time));
        try!(buffer.write(&self.data_block.from_address[..]));
        try!(buffer.write(&self.data_block.subject[..]));
        try!(buffer.write(&self.data_block.data[..]));
        try!(buffer.write(&self.data_block.mail_filter[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(EmailMessageReply_DataBlock::read_from(buffer));
        Ok(MessageInstance::EmailMessageReply(EmailMessageReply { data_block: data_block }))
    }
}

impl Message for InternalScriptMail {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x10]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.from[..]));
        try!(buffer.write(self.data_block.to.as_bytes()));
        try!(buffer.write(&self.data_block.subject[..]));
        try!(buffer.write(&self.data_block.body[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(InternalScriptMail_DataBlock::read_from(buffer));
        Ok(MessageInstance::InternalScriptMail(InternalScriptMail { data_block: data_block }))
    }
}

impl Message for ScriptDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x51]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write_u64::<LittleEndian>(item.hash));
            try!(buffer.write_i8(item.request_type));
            try!(buffer.write(&item.request[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = try!(buffer.read_u8());
        for _ in 0.._data_block_count {
            data_block.push(try!(ScriptDataRequest_DataBlock::read_from(buffer)));
        }
        Ok(MessageInstance::ScriptDataRequest(ScriptDataRequest { data_block: data_block }))
    }
}

impl Message for ScriptDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x52]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write_u64::<LittleEndian>(item.hash));
            try!(buffer.write(&item.reply[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = try!(buffer.read_u8());
        for _ in 0.._data_block_count {
            data_block.push(try!(ScriptDataReply_DataBlock::read_from(buffer)));
        }
        Ok(MessageInstance::ScriptDataReply(ScriptDataReply { data_block: data_block }))
    }
}

impl Message for CreateGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x53]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(&self.group_data.name[..]));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateGroupRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(CreateGroupRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::CreateGroupRequest(CreateGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for CreateGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x54]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block ReplyData
        try!(buffer.write(self.reply_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.reply_data.success as u8));
        try!(buffer.write(&self.reply_data.message[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateGroupReply_AgentData::read_from(buffer));
        // Block ReplyData
        let reply_data = try!(CreateGroupReply_ReplyData::read_from(buffer));
        Ok(MessageInstance::CreateGroupReply(CreateGroupReply {
            agent_data: agent_data,
            reply_data: reply_data,
        }))
    }
}

impl Message for UpdateGroupInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x55]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateGroupInfo_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(UpdateGroupInfo_GroupData::read_from(buffer));
        Ok(MessageInstance::UpdateGroupInfo(UpdateGroupInfo {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupRoleChanges {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x56]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RoleChange
        try!(buffer.write_u8(self.role_change.len() as u8));
        for item in &self.role_change {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(item.member_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.change));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleChanges_AgentData::read_from(buffer));
        // Block RoleChange
        let mut role_change = Vec::new();
        let _role_change_count = try!(buffer.read_u8());
        for _ in 0.._role_change_count {
            role_change.push(try!(GroupRoleChanges_RoleChange::read_from(buffer)));
        }
        Ok(MessageInstance::GroupRoleChanges(GroupRoleChanges {
            agent_data: agent_data,
            role_change: role_change,
        }))
    }
}

impl Message for JoinGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x57]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(JoinGroupRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(JoinGroupRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::JoinGroupRequest(JoinGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for JoinGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x58]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.group_data.success as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(JoinGroupReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(JoinGroupReply_GroupData::read_from(buffer));
        Ok(MessageInstance::JoinGroupReply(JoinGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for EjectGroupMemberRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x59]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block EjectData
        try!(buffer.write_u8(self.eject_data.len() as u8));
        for item in &self.eject_data {
            try!(buffer.write(item.ejectee_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EjectGroupMemberRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(EjectGroupMemberRequest_GroupData::read_from(buffer));
        // Block EjectData
        let mut eject_data = Vec::new();
        let _eject_data_count = try!(buffer.read_u8());
        for _ in 0.._eject_data_count {
            eject_data.push(try!(EjectGroupMemberRequest_EjectData::read_from(buffer)));
        }
        Ok(MessageInstance::EjectGroupMemberRequest(EjectGroupMemberRequest {
            agent_data: agent_data,
            group_data: group_data,
            eject_data: eject_data,
        }))
    }
}

impl Message for EjectGroupMemberReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block EjectData
        try!(buffer.write_u8(self.eject_data.success as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(EjectGroupMemberReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(EjectGroupMemberReply_GroupData::read_from(buffer));
        // Block EjectData
        let eject_data = try!(EjectGroupMemberReply_EjectData::read_from(buffer));
        Ok(MessageInstance::EjectGroupMemberReply(EjectGroupMemberReply {
            agent_data: agent_data,
            group_data: group_data,
            eject_data: eject_data,
        }))
    }
}

impl Message for LeaveGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LeaveGroupRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(LeaveGroupRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::LeaveGroupRequest(LeaveGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for LeaveGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.group_data.success as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LeaveGroupReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(LeaveGroupReply_GroupData::read_from(buffer));
        Ok(MessageInstance::LeaveGroupReply(LeaveGroupReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for InviteGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block InviteData
        try!(buffer.write_u8(self.invite_data.len() as u8));
        for item in &self.invite_data {
            try!(buffer.write(item.invitee_id.as_bytes()));
            try!(buffer.write(item.role_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(InviteGroupRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(InviteGroupRequest_GroupData::read_from(buffer));
        // Block InviteData
        let mut invite_data = Vec::new();
        let _invite_data_count = try!(buffer.read_u8());
        for _ in 0.._invite_data_count {
            invite_data.push(try!(InviteGroupRequest_InviteData::read_from(buffer)));
        }
        Ok(MessageInstance::InviteGroupRequest(InviteGroupRequest {
            agent_data: agent_data,
            group_data: group_data,
            invite_data: invite_data,
        }))
    }
}

impl Message for InviteGroupResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5e]));
        // Block InviteData
        try!(buffer.write(self.invite_data.agent_id.as_bytes()));
        try!(buffer.write(self.invite_data.invitee_id.as_bytes()));
        try!(buffer.write(self.invite_data.group_id.as_bytes()));
        try!(buffer.write(self.invite_data.role_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.invite_data.membership_fee));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block InviteData
        let invite_data = try!(InviteGroupResponse_InviteData::read_from(buffer));
        Ok(MessageInstance::InviteGroupResponse(InviteGroupResponse { invite_data: invite_data }))
    }
}

impl Message for GroupProfileRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupProfileRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupProfileRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::GroupProfileRequest(GroupProfileRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupProfileReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x60]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(&self.group_data.name[..]));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(&self.group_data.member_title[..]));
        try!(buffer.write_u64::<LittleEndian>(self.group_data.powers_mask));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write(self.group_data.founder_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.money));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.group_membership_count));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.group_roles_count));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        try!(buffer.write(self.group_data.owner_role.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupProfileReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupProfileReply_GroupData::read_from(buffer));
        Ok(MessageInstance::GroupProfileReply(GroupProfileReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupAccountSummaryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x61]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountSummaryRequest_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountSummaryRequest_MoneyData::read_from(buffer));
        Ok(MessageInstance::GroupAccountSummaryRequest(GroupAccountSummaryRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for GroupAccountSummaryReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x62]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.total_credits));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.total_debits));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.object_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.light_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.land_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.group_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.object_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.light_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.land_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.group_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.non_exempt_members));
        try!(buffer.write(&self.money_data.last_tax_date[..]));
        try!(buffer.write(&self.money_data.tax_date[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountSummaryReply_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountSummaryReply_MoneyData::read_from(buffer));
        Ok(MessageInstance::GroupAccountSummaryReply(GroupAccountSummaryReply {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for GroupAccountDetailsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x63]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountDetailsRequest_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountDetailsRequest_MoneyData::read_from(buffer));
        Ok(MessageInstance::GroupAccountDetailsRequest(GroupAccountDetailsRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for GroupAccountDetailsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x64]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        // Block HistoryData
        try!(buffer.write_u8(self.history_data.len() as u8));
        for item in &self.history_data {
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.amount));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountDetailsReply_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountDetailsReply_MoneyData::read_from(buffer));
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = try!(buffer.read_u8());
        for _ in 0.._history_data_count {
            history_data.push(try!(GroupAccountDetailsReply_HistoryData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupAccountDetailsReply(GroupAccountDetailsReply {
            agent_data: agent_data,
            money_data: money_data,
            history_data: history_data,
        }))
    }
}

impl Message for GroupAccountTransactionsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x65]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountTransactionsRequest_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountTransactionsRequest_MoneyData::read_from(buffer));
        Ok(MessageInstance::GroupAccountTransactionsRequest(GroupAccountTransactionsRequest {
            agent_data: agent_data,
            money_data: money_data,
        }))
    }
}

impl Message for GroupAccountTransactionsReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x66]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        // Block HistoryData
        try!(buffer.write_u8(self.history_data.len() as u8));
        for item in &self.history_data {
            try!(buffer.write(&item.time[..]));
            try!(buffer.write(&item.user[..]));
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write(&item.item[..]));
            try!(buffer.write_i32::<LittleEndian>(item.amount));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupAccountTransactionsReply_AgentData::read_from(buffer));
        // Block MoneyData
        let money_data = try!(GroupAccountTransactionsReply_MoneyData::read_from(buffer));
        // Block HistoryData
        let mut history_data = Vec::new();
        let _history_data_count = try!(buffer.read_u8());
        for _ in 0.._history_data_count {
            history_data.push(try!(GroupAccountTransactionsReply_HistoryData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupAccountTransactionsReply(GroupAccountTransactionsReply {
            agent_data: agent_data,
            money_data: money_data,
            history_data: history_data,
        }))
    }
}

impl Message for GroupActiveProposalsRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x67]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupActiveProposalsRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupActiveProposalsRequest_GroupData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(GroupActiveProposalsRequest_TransactionData::read_from(buffer));
        Ok(MessageInstance::GroupActiveProposalsRequest(GroupActiveProposalsRequest {
            agent_data: agent_data,
            group_data: group_data,
            transaction_data: transaction_data,
        }))
    }
}

impl Message for GroupActiveProposalItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x68]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items));
        // Block ProposalData
        try!(buffer.write_u8(self.proposal_data.len() as u8));
        for item in &self.proposal_data {
            try!(buffer.write(item.vote_id.as_bytes()));
            try!(buffer.write(item.vote_initiator.as_bytes()));
            try!(buffer.write(&item.terse_date_id[..]));
            try!(buffer.write(&item.start_date_time[..]));
            try!(buffer.write(&item.end_date_time[..]));
            try!(buffer.write_u8(item.already_voted as u8));
            try!(buffer.write(&item.vote_cast[..]));
            try!(buffer.write_f32::<LittleEndian>(item.majority));
            try!(buffer.write_i32::<LittleEndian>(item.quorum));
            try!(buffer.write(&item.proposal_text[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupActiveProposalItemReply_AgentData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(GroupActiveProposalItemReply_TransactionData::read_from(buffer));
        // Block ProposalData
        let mut proposal_data = Vec::new();
        let _proposal_data_count = try!(buffer.read_u8());
        for _ in 0.._proposal_data_count {
            proposal_data.push(try!(GroupActiveProposalItemReply_ProposalData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupActiveProposalItemReply(GroupActiveProposalItemReply {
            agent_data: agent_data,
            transaction_data: transaction_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for GroupVoteHistoryRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x69]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupVoteHistoryRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupVoteHistoryRequest_GroupData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(GroupVoteHistoryRequest_TransactionData::read_from(buffer));
        Ok(MessageInstance::GroupVoteHistoryRequest(GroupVoteHistoryRequest {
            agent_data: agent_data,
            group_data: group_data,
            transaction_data: transaction_data,
        }))
    }
}

impl Message for GroupVoteHistoryItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items));
        // Block HistoryItemData
        try!(buffer.write(self.history_item_data.vote_id.as_bytes()));
        try!(buffer.write(&self.history_item_data.terse_date_id[..]));
        try!(buffer.write(&self.history_item_data.start_date_time[..]));
        try!(buffer.write(&self.history_item_data.end_date_time[..]));
        try!(buffer.write(self.history_item_data.vote_initiator.as_bytes()));
        try!(buffer.write(&self.history_item_data.vote_type[..]));
        try!(buffer.write(&self.history_item_data.vote_result[..]));
        try!(buffer.write_f32::<LittleEndian>(self.history_item_data.majority));
        try!(buffer.write_i32::<LittleEndian>(self.history_item_data.quorum));
        try!(buffer.write(&self.history_item_data.proposal_text[..]));
        // Block VoteItem
        try!(buffer.write_u8(self.vote_item.len() as u8));
        for item in &self.vote_item {
            try!(buffer.write(item.candidate_id.as_bytes()));
            try!(buffer.write(&item.vote_cast[..]));
            try!(buffer.write_i32::<LittleEndian>(item.num_votes));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupVoteHistoryItemReply_AgentData::read_from(buffer));
        // Block TransactionData
        let transaction_data = try!(GroupVoteHistoryItemReply_TransactionData::read_from(buffer));
        // Block HistoryItemData
        let history_item_data = try!(GroupVoteHistoryItemReply_HistoryItemData::read_from(buffer));
        // Block VoteItem
        let mut vote_item = Vec::new();
        let _vote_item_count = try!(buffer.read_u8());
        for _ in 0.._vote_item_count {
            vote_item.push(try!(GroupVoteHistoryItemReply_VoteItem::read_from(buffer)));
        }
        Ok(MessageInstance::GroupVoteHistoryItemReply(GroupVoteHistoryItemReply {
            agent_data: agent_data,
            transaction_data: transaction_data,
            history_item_data: history_item_data,
            vote_item: vote_item,
        }))
    }
}

impl Message for StartGroupProposal {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ProposalData
        try!(buffer.write(self.proposal_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.proposal_data.quorum));
        try!(buffer.write_f32::<LittleEndian>(self.proposal_data.majority));
        try!(buffer.write_i32::<LittleEndian>(self.proposal_data.duration));
        try!(buffer.write(&self.proposal_data.proposal_text[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(StartGroupProposal_AgentData::read_from(buffer));
        // Block ProposalData
        let proposal_data = try!(StartGroupProposal_ProposalData::read_from(buffer));
        Ok(MessageInstance::StartGroupProposal(StartGroupProposal {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for GroupProposalBallot {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ProposalData
        try!(buffer.write(self.proposal_data.proposal_id.as_bytes()));
        try!(buffer.write(self.proposal_data.group_id.as_bytes()));
        try!(buffer.write(&self.proposal_data.vote_cast[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupProposalBallot_AgentData::read_from(buffer));
        // Block ProposalData
        let proposal_data = try!(GroupProposalBallot_ProposalData::read_from(buffer));
        Ok(MessageInstance::GroupProposalBallot(GroupProposalBallot {
            agent_data: agent_data,
            proposal_data: proposal_data,
        }))
    }
}

impl Message for TallyVotes {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6d]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::TallyVotes(TallyVotes {}))
    }
}

impl Message for GroupMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupMembersRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupMembersRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::GroupMembersRequest(GroupMembersRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.member_count));
        // Block MemberData
        try!(buffer.write_u8(self.member_data.len() as u8));
        for item in &self.member_data {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.contribution));
            try!(buffer.write(&item.online_status[..]));
            try!(buffer.write_u64::<LittleEndian>(item.agent_powers));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write_u8(item.is_owner as u8));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupMembersReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupMembersReply_GroupData::read_from(buffer));
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = try!(buffer.read_u8());
        for _ in 0.._member_data_count {
            member_data.push(try!(GroupMembersReply_MemberData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupMembersReply(GroupMembersReply {
            agent_data: agent_data,
            group_data: group_data,
            member_data: member_data,
        }))
    }
}

impl Message for ActivateGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x70]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ActivateGroup_AgentData::read_from(buffer));
        Ok(MessageInstance::ActivateGroup(ActivateGroup { agent_data: agent_data }))
    }
}

impl Message for SetGroupContribution {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x71]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.contribution));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SetGroupContribution_AgentData::read_from(buffer));
        // Block Data
        let data = try!(SetGroupContribution_Data::read_from(buffer));
        Ok(MessageInstance::SetGroupContribution(SetGroupContribution {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for SetGroupAcceptNotices {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x72]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.accept_notices as u8));
        // Block NewData
        try!(buffer.write_u8(self.new_data.list_in_profile as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SetGroupAcceptNotices_AgentData::read_from(buffer));
        // Block Data
        let data = try!(SetGroupAcceptNotices_Data::read_from(buffer));
        // Block NewData
        let new_data = try!(SetGroupAcceptNotices_NewData::read_from(buffer));
        Ok(MessageInstance::SetGroupAcceptNotices(SetGroupAcceptNotices {
            agent_data: agent_data,
            data: data,
            new_data: new_data,
        }))
    }
}

impl Message for GroupRoleDataRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x73]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleDataRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupRoleDataRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::GroupRoleDataRequest(GroupRoleDataRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupRoleDataReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x74]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.role_count));
        // Block RoleData
        try!(buffer.write_u8(self.role_data.len() as u8));
        for item in &self.role_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_u64::<LittleEndian>(item.powers));
            try!(buffer.write_u32::<LittleEndian>(item.members));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleDataReply_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupRoleDataReply_GroupData::read_from(buffer));
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = try!(buffer.read_u8());
        for _ in 0.._role_data_count {
            role_data.push(try!(GroupRoleDataReply_RoleData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupRoleDataReply(GroupRoleDataReply {
            agent_data: agent_data,
            group_data: group_data,
            role_data: role_data,
        }))
    }
}

impl Message for GroupRoleMembersRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x75]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleMembersRequest_AgentData::read_from(buffer));
        // Block GroupData
        let group_data = try!(GroupRoleMembersRequest_GroupData::read_from(buffer));
        Ok(MessageInstance::GroupRoleMembersRequest(GroupRoleMembersRequest {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupRoleMembersReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x76]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.total_pairs));
        // Block MemberData
        try!(buffer.write_u8(self.member_data.len() as u8));
        for item in &self.member_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(item.member_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleMembersReply_AgentData::read_from(buffer));
        // Block MemberData
        let mut member_data = Vec::new();
        let _member_data_count = try!(buffer.read_u8());
        for _ in 0.._member_data_count {
            member_data.push(try!(GroupRoleMembersReply_MemberData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupRoleMembersReply(GroupRoleMembersReply {
            agent_data: agent_data,
            member_data: member_data,
        }))
    }
}

impl Message for GroupTitlesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x77]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupTitlesRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::GroupTitlesRequest(GroupTitlesRequest { agent_data: agent_data }))
    }
}

impl Message for GroupTitlesReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x78]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(&item.title[..]));
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write_u8(item.selected as u8));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupTitlesReply_AgentData::read_from(buffer));
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = try!(buffer.read_u8());
        for _ in 0.._group_data_count {
            group_data.push(try!(GroupTitlesReply_GroupData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupTitlesReply(GroupTitlesReply {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for GroupTitleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x79]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.title_role_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupTitleUpdate_AgentData::read_from(buffer));
        Ok(MessageInstance::GroupTitleUpdate(GroupTitleUpdate { agent_data: agent_data }))
    }
}

impl Message for GroupRoleUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RoleData
        try!(buffer.write_u8(self.role_data.len() as u8));
        for item in &self.role_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write_u64::<LittleEndian>(item.powers));
            try!(buffer.write_u8(item.update_type));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(GroupRoleUpdate_AgentData::read_from(buffer));
        // Block RoleData
        let mut role_data = Vec::new();
        let _role_data_count = try!(buffer.read_u8());
        for _ in 0.._role_data_count {
            role_data.push(try!(GroupRoleUpdate_RoleData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupRoleUpdate(GroupRoleUpdate {
            agent_data: agent_data,
            role_data: role_data,
        }))
    }
}

impl Message for LiveHelpGroupRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7b]));
        // Block RequestData
        try!(buffer.write(self.request_data.request_id.as_bytes()));
        try!(buffer.write(self.request_data.agent_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RequestData
        let request_data = try!(LiveHelpGroupRequest_RequestData::read_from(buffer));
        Ok(MessageInstance::LiveHelpGroupRequest(LiveHelpGroupRequest { request_data: request_data }))
    }
}

impl Message for LiveHelpGroupReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7c]));
        // Block ReplyData
        try!(buffer.write(self.reply_data.request_id.as_bytes()));
        try!(buffer.write(self.reply_data.group_id.as_bytes()));
        try!(buffer.write(&self.reply_data.selection[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ReplyData
        let reply_data = try!(LiveHelpGroupReply_ReplyData::read_from(buffer));
        Ok(MessageInstance::LiveHelpGroupReply(LiveHelpGroupReply { reply_data: reply_data }))
    }
}

impl Message for AgentWearablesRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentWearablesRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentWearablesRequest(AgentWearablesRequest { agent_data: agent_data }))
    }
}

impl Message for AgentWearablesUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_u8(item.wearable_type));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentWearablesUpdate_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AgentWearablesUpdate_WearableData::read_from(buffer)));
        }
        Ok(MessageInstance::AgentWearablesUpdate(AgentWearablesUpdate {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentIsNowWearing {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u8(item.wearable_type));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentIsNowWearing_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AgentIsNowWearing_WearableData::read_from(buffer)));
        }
        Ok(MessageInstance::AgentIsNowWearing(AgentIsNowWearing {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentCachedTexture {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x80]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentCachedTexture_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AgentCachedTexture_WearableData::read_from(buffer)));
        }
        Ok(MessageInstance::AgentCachedTexture(AgentCachedTexture {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentCachedTextureResponse {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x81]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.texture_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
            try!(buffer.write(&item.host_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentCachedTextureResponse_AgentData::read_from(buffer));
        // Block WearableData
        let mut wearable_data = Vec::new();
        let _wearable_data_count = try!(buffer.read_u8());
        for _ in 0.._wearable_data_count {
            wearable_data.push(try!(AgentCachedTextureResponse_WearableData::read_from(buffer)));
        }
        Ok(MessageInstance::AgentCachedTextureResponse(AgentCachedTextureResponse {
            agent_data: agent_data,
            wearable_data: wearable_data,
        }))
    }
}

impl Message for AgentDataUpdateRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x82]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentDataUpdateRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentDataUpdateRequest(AgentDataUpdateRequest { agent_data: agent_data }))
    }
}

impl Message for AgentDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x83]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(&self.agent_data.first_name[..]));
        try!(buffer.write(&self.agent_data.last_name[..]));
        try!(buffer.write(&self.agent_data.group_title[..]));
        try!(buffer.write(self.agent_data.active_group_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.group_powers));
        try!(buffer.write(&self.agent_data.group_name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentDataUpdate_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentDataUpdate(AgentDataUpdate { agent_data: agent_data }))
    }
}

impl Message for GroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x84]));
        // Block AgentGroupData
        try!(buffer.write_u8(self.agent_group_data.len() as u8));
        for item in &self.agent_group_data {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.agent_powers));
            try!(buffer.write(&item.group_title[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentGroupData
        let mut agent_group_data = Vec::new();
        let _agent_group_data_count = try!(buffer.read_u8());
        for _ in 0.._agent_group_data_count {
            agent_group_data.push(try!(GroupDataUpdate_AgentGroupData::read_from(buffer)));
        }
        Ok(MessageInstance::GroupDataUpdate(GroupDataUpdate { agent_group_data: agent_group_data }))
    }
}

impl Message for AgentGroupDataUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x85]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
            try!(buffer.write(item.group_insignia_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.contribution));
            try!(buffer.write(&item.group_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentGroupDataUpdate_AgentData::read_from(buffer));
        // Block GroupData
        let mut group_data = Vec::new();
        let _group_data_count = try!(buffer.read_u8());
        for _ in 0.._group_data_count {
            group_data.push(try!(AgentGroupDataUpdate_GroupData::read_from(buffer)));
        }
        Ok(MessageInstance::AgentGroupDataUpdate(AgentGroupDataUpdate {
            agent_data: agent_data,
            group_data: group_data,
        }))
    }
}

impl Message for AgentDropGroup {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x86]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(AgentDropGroup_AgentData::read_from(buffer));
        Ok(MessageInstance::AgentDropGroup(AgentDropGroup { agent_data: agent_data }))
    }
}

impl Message for LogTextMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x87]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write(item.from_agent_id.as_bytes()));
            try!(buffer.write(item.to_agent_id.as_bytes()));
            try!(buffer.write_f64::<LittleEndian>(item.global_x));
            try!(buffer.write_f64::<LittleEndian>(item.global_y));
            try!(buffer.write_u32::<LittleEndian>(item.time));
            try!(buffer.write(&item.message[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let mut data_block = Vec::new();
        let _data_block_count = try!(buffer.read_u8());
        for _ in 0.._data_block_count {
            data_block.push(try!(LogTextMessage_DataBlock::read_from(buffer)));
        }
        Ok(MessageInstance::LogTextMessage(LogTextMessage { data_block: data_block }))
    }
}

impl Message for ViewerEffect {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x11]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Effect
        try!(buffer.write_u8(self.effect.len() as u8));
        for item in &self.effect {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write_u8(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.duration));
            try!(buffer.write(&item.color));
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ViewerEffect_AgentData::read_from(buffer));
        // Block Effect
        let mut effect = Vec::new();
        let _effect_count = try!(buffer.read_u8());
        for _ in 0.._effect_count {
            effect.push(try!(ViewerEffect_Effect::read_from(buffer)));
        }
        Ok(MessageInstance::ViewerEffect(ViewerEffect {
            agent_data: agent_data,
            effect: effect,
        }))
    }
}

impl Message for CreateTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x88]));
        // Block DataBlock
        try!(buffer.write(self.data_block.end_point_id.as_bytes()));
        try!(buffer.write(&self.data_block.digest));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(CreateTrustedCircuit_DataBlock::read_from(buffer));
        Ok(MessageInstance::CreateTrustedCircuit(CreateTrustedCircuit { data_block: data_block }))
    }
}

impl Message for DenyTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x89]));
        // Block DataBlock
        try!(buffer.write(self.data_block.end_point_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(DenyTrustedCircuit_DataBlock::read_from(buffer));
        Ok(MessageInstance::DenyTrustedCircuit(DenyTrustedCircuit { data_block: data_block }))
    }
}

impl Message for RequestTrustedCircuit {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8a]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        Ok(MessageInstance::RequestTrustedCircuit(RequestTrustedCircuit {}))
    }
}

impl Message for RezSingleAttachmentFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.item_id.as_bytes()));
        try!(buffer.write(self.object_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.object_data.attachment_pt));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask));
        try!(buffer.write(&self.object_data.name[..]));
        try!(buffer.write(&self.object_data.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezSingleAttachmentFromInv_AgentData::read_from(buffer));
        // Block ObjectData
        let object_data = try!(RezSingleAttachmentFromInv_ObjectData::read_from(buffer));
        Ok(MessageInstance::RezSingleAttachmentFromInv(RezSingleAttachmentFromInv {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for RezMultipleAttachmentsFromInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write(self.header_data.compound_msg_id.as_bytes()));
        try!(buffer.write_u8(self.header_data.total_objects));
        try!(buffer.write_u8(self.header_data.first_detach_all as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.attachment_pt));
            try!(buffer.write_u32::<LittleEndian>(item.item_flags));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezMultipleAttachmentsFromInv_AgentData::read_from(buffer));
        // Block HeaderData
        let header_data = try!(RezMultipleAttachmentsFromInv_HeaderData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(RezMultipleAttachmentsFromInv_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::RezMultipleAttachmentsFromInv(RezMultipleAttachmentsFromInv {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for DetachAttachmentIntoInv {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8d]));
        // Block ObjectData
        try!(buffer.write(self.object_data.agent_id.as_bytes()));
        try!(buffer.write(self.object_data.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ObjectData
        let object_data = try!(DetachAttachmentIntoInv_ObjectData::read_from(buffer));
        Ok(MessageInstance::DetachAttachmentIntoInv(DetachAttachmentIntoInv { object_data: object_data }))
    }
}

impl Message for CreateNewOutfitAttachments {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write(self.header_data.new_folder_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.old_item_id.as_bytes()));
            try!(buffer.write(item.old_folder_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(CreateNewOutfitAttachments_AgentData::read_from(buffer));
        // Block HeaderData
        let header_data = try!(CreateNewOutfitAttachments_HeaderData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(CreateNewOutfitAttachments_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::CreateNewOutfitAttachments(CreateNewOutfitAttachments {
            agent_data: agent_data,
            header_data: header_data,
            object_data: object_data,
        }))
    }
}

impl Message for UserInfoRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UserInfoRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::UserInfoRequest(UserInfoRequest { agent_data: agent_data }))
    }
}

impl Message for UserInfoReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x90]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block UserData
        try!(buffer.write_u8(self.user_data.im_via_e_mail as u8));
        try!(buffer.write(&self.user_data.directory_visibility[..]));
        try!(buffer.write(&self.user_data.e_mail[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UserInfoReply_AgentData::read_from(buffer));
        // Block UserData
        let user_data = try!(UserInfoReply_UserData::read_from(buffer));
        Ok(MessageInstance::UserInfoReply(UserInfoReply {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for UpdateUserInfo {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x91]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block UserData
        try!(buffer.write_u8(self.user_data.im_via_e_mail as u8));
        try!(buffer.write(&self.user_data.directory_visibility[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(UpdateUserInfo_AgentData::read_from(buffer));
        // Block UserData
        let user_data = try!(UpdateUserInfo_UserData::read_from(buffer));
        Ok(MessageInstance::UpdateUserInfo(UpdateUserInfo {
            agent_data: agent_data,
            user_data: user_data,
        }))
    }
}

impl Message for ParcelRename {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x92]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block ParcelData
        let mut parcel_data = Vec::new();
        let _parcel_data_count = try!(buffer.read_u8());
        for _ in 0.._parcel_data_count {
            parcel_data.push(try!(ParcelRename_ParcelData::read_from(buffer)));
        }
        Ok(MessageInstance::ParcelRename(ParcelRename { parcel_data: parcel_data }))
    }
}

impl Message for InitiateDownload {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x93]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block FileData
        try!(buffer.write(&self.file_data.sim_filename[..]));
        try!(buffer.write(&self.file_data.viewer_filename[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(InitiateDownload_AgentData::read_from(buffer));
        // Block FileData
        let file_data = try!(InitiateDownload_FileData::read_from(buffer));
        Ok(MessageInstance::InitiateDownload(InitiateDownload {
            agent_data: agent_data,
            file_data: file_data,
        }))
    }
}

impl Message for SystemMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x94]));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        try!(buffer.write(&self.method_data.digest));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block MethodData
        let method_data = try!(SystemMessage_MethodData::read_from(buffer));
        // Block ParamList
        let mut param_list = Vec::new();
        let _param_list_count = try!(buffer.read_u8());
        for _ in 0.._param_list_count {
            param_list.push(try!(SystemMessage_ParamList::read_from(buffer)));
        }
        Ok(MessageInstance::SystemMessage(SystemMessage {
            method_data: method_data,
            param_list: param_list,
        }))
    }
}

impl Message for MapLayerRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x95]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapLayerRequest_AgentData::read_from(buffer));
        Ok(MessageInstance::MapLayerRequest(MapLayerRequest { agent_data: agent_data }))
    }
}

impl Message for MapLayerReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x96]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block LayerData
        try!(buffer.write_u8(self.layer_data.len() as u8));
        for item in &self.layer_data {
            try!(buffer.write_u32::<LittleEndian>(item.left));
            try!(buffer.write_u32::<LittleEndian>(item.right));
            try!(buffer.write_u32::<LittleEndian>(item.top));
            try!(buffer.write_u32::<LittleEndian>(item.bottom));
            try!(buffer.write(item.image_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapLayerReply_AgentData::read_from(buffer));
        // Block LayerData
        let mut layer_data = Vec::new();
        let _layer_data_count = try!(buffer.read_u8());
        for _ in 0.._layer_data_count {
            layer_data.push(try!(MapLayerReply_LayerData::read_from(buffer)));
        }
        Ok(MessageInstance::MapLayerReply(MapLayerReply {
            agent_data: agent_data,
            layer_data: layer_data,
        }))
    }
}

impl Message for MapBlockRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x97]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block PositionData
        try!(buffer.write_u16::<LittleEndian>(self.position_data.min_x));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.max_x));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.min_y));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.max_y));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapBlockRequest_AgentData::read_from(buffer));
        // Block PositionData
        let position_data = try!(MapBlockRequest_PositionData::read_from(buffer));
        Ok(MessageInstance::MapBlockRequest(MapBlockRequest {
            agent_data: agent_data,
            position_data: position_data,
        }))
    }
}

impl Message for MapNameRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x98]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block NameData
        try!(buffer.write(&self.name_data.name[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapNameRequest_AgentData::read_from(buffer));
        // Block NameData
        let name_data = try!(MapNameRequest_NameData::read_from(buffer));
        Ok(MessageInstance::MapNameRequest(MapNameRequest {
            agent_data: agent_data,
            name_data: name_data,
        }))
    }
}

impl Message for MapBlockReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x99]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u16::<LittleEndian>(item.x));
            try!(buffer.write_u16::<LittleEndian>(item.y));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.access));
            try!(buffer.write_u32::<LittleEndian>(item.region_flags));
            try!(buffer.write_u8(item.water_height));
            try!(buffer.write_u8(item.agents));
            try!(buffer.write(item.map_image_id.as_bytes()));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapBlockReply_AgentData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(MapBlockReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::MapBlockReply(MapBlockReply {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for MapItemRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.item_type));
        try!(buffer.write_u64::<LittleEndian>(self.request_data.region_handle));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapItemRequest_AgentData::read_from(buffer));
        // Block RequestData
        let request_data = try!(MapItemRequest_RequestData::read_from(buffer));
        Ok(MessageInstance::MapItemRequest(MapItemRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for MapItemReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.item_type));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u32::<LittleEndian>(item.x));
            try!(buffer.write_u32::<LittleEndian>(item.y));
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.extra));
            try!(buffer.write_i32::<LittleEndian>(item.extra2));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(MapItemReply_AgentData::read_from(buffer));
        // Block RequestData
        let request_data = try!(MapItemReply_RequestData::read_from(buffer));
        // Block Data
        let mut data = Vec::new();
        let _data_count = try!(buffer.read_u8());
        for _ in 0.._data_count {
            data.push(try!(MapItemReply_Data::read_from(buffer)));
        }
        Ok(MessageInstance::MapItemReply(MapItemReply {
            agent_data: agent_data,
            request_data: request_data,
            data: data,
        }))
    }
}

impl Message for SendPostcard {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.asset_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.z));
        try!(buffer.write(&self.agent_data.to[..]));
        try!(buffer.write(&self.agent_data.from[..]));
        try!(buffer.write(&self.agent_data.name[..]));
        try!(buffer.write(&self.agent_data.subject[..]));
        try!(buffer.write(&self.agent_data.msg[..]));
        try!(buffer.write_u8(self.agent_data.allow_publish as u8));
        try!(buffer.write_u8(self.agent_data.mature_publish as u8));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(SendPostcard_AgentData::read_from(buffer));
        Ok(MessageInstance::SendPostcard(SendPostcard { agent_data: agent_data }))
    }
}

impl Message for RpcChannelRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9d]));
        // Block DataBlock
        try!(buffer.write_u32::<LittleEndian>(self.data_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.grid_y));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(RpcChannelRequest_DataBlock::read_from(buffer));
        Ok(MessageInstance::RpcChannelRequest(RpcChannelRequest { data_block: data_block }))
    }
}

impl Message for RpcChannelReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9e]));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(RpcChannelReply_DataBlock::read_from(buffer));
        Ok(MessageInstance::RpcChannelReply(RpcChannelReply { data_block: data_block }))
    }
}

impl Message for RpcScriptRequestInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9f]));
        // Block TargetBlock
        try!(buffer.write_u32::<LittleEndian>(self.target_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.target_block.grid_y));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block TargetBlock
        let target_block = try!(RpcScriptRequestInbound_TargetBlock::read_from(buffer));
        // Block DataBlock
        let data_block = try!(RpcScriptRequestInbound_DataBlock::read_from(buffer));
        Ok(MessageInstance::RpcScriptRequestInbound(RpcScriptRequestInbound {
            target_block: target_block,
            data_block: data_block,
        }))
    }
}

impl Message for RpcScriptRequestInboundForward {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa0]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.rpc_server_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.data_block.rpc_server_port));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(RpcScriptRequestInboundForward_DataBlock::read_from(buffer));
        Ok(MessageInstance::RpcScriptRequestInboundForward(RpcScriptRequestInboundForward {
            data_block: data_block,
        }))
    }
}

impl Message for RpcScriptReplyInbound {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa1]));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(RpcScriptReplyInbound_DataBlock::read_from(buffer));
        Ok(MessageInstance::RpcScriptReplyInbound(RpcScriptReplyInbound { data_block: data_block }))
    }
}

impl Message for ScriptMailRegistration {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa2]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.target_ip[..]));
        try!(buffer.write_u16::<LittleEndian>(self.data_block.target_port));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.flags));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(ScriptMailRegistration_DataBlock::read_from(buffer));
        Ok(MessageInstance::ScriptMailRegistration(ScriptMailRegistration { data_block: data_block }))
    }
}

impl Message for ParcelMediaCommandMessage {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa3]));
        // Block CommandBlock
        try!(buffer.write_u32::<LittleEndian>(self.command_block.flags));
        try!(buffer.write_u32::<LittleEndian>(self.command_block.command));
        try!(buffer.write_f32::<LittleEndian>(self.command_block.time));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block CommandBlock
        let command_block = try!(ParcelMediaCommandMessage_CommandBlock::read_from(buffer));
        Ok(MessageInstance::ParcelMediaCommandMessage(ParcelMediaCommandMessage {
            command_block: command_block,
        }))
    }
}

impl Message for ParcelMediaUpdate {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa4]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.media_url[..]));
        try!(buffer.write(self.data_block.media_id.as_bytes()));
        try!(buffer.write_u8(self.data_block.media_auto_scale));
        // Block DataBlockExtended
        try!(buffer.write(&self.data_block_extended.media_type[..]));
        try!(buffer.write(&self.data_block_extended.media_desc[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data_block_extended.media_width));
        try!(buffer.write_i32::<LittleEndian>(self.data_block_extended.media_height));
        try!(buffer.write_u8(self.data_block_extended.media_loop));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block DataBlock
        let data_block = try!(ParcelMediaUpdate_DataBlock::read_from(buffer));
        // Block DataBlockExtended
        let data_block_extended = try!(ParcelMediaUpdate_DataBlockExtended::read_from(buffer));
        Ok(MessageInstance::ParcelMediaUpdate(ParcelMediaUpdate {
            data_block: data_block,
            data_block_extended: data_block_extended,
        }))
    }
}

impl Message for LandStatRequest {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.report_type));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.request_flags));
        try!(buffer.write(&self.request_data.filter[..]));
        try!(buffer.write_i32::<LittleEndian>(self.request_data.parcel_local_id));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LandStatRequest_AgentData::read_from(buffer));
        // Block RequestData
        let request_data = try!(LandStatRequest_RequestData::read_from(buffer));
        Ok(MessageInstance::LandStatRequest(LandStatRequest {
            agent_data: agent_data,
            request_data: request_data,
        }))
    }
}

impl Message for LandStatReply {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa6]));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.report_type));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.request_flags));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.total_object_count));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.len() as u8));
        for item in &self.report_data {
            try!(buffer.write_u32::<LittleEndian>(item.task_local_id));
            try!(buffer.write(item.task_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.location_x));
            try!(buffer.write_f32::<LittleEndian>(item.location_y));
            try!(buffer.write_f32::<LittleEndian>(item.location_z));
            try!(buffer.write_f32::<LittleEndian>(item.score));
            try!(buffer.write(&item.task_name[..]));
            try!(buffer.write(&item.owner_name[..]));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block RequestData
        let request_data = try!(LandStatReply_RequestData::read_from(buffer));
        // Block ReportData
        let mut report_data = Vec::new();
        let _report_data_count = try!(buffer.read_u8());
        for _ in 0.._report_data_count {
            report_data.push(try!(LandStatReply_ReportData::read_from(buffer)));
        }
        Ok(MessageInstance::LandStatReply(LandStatReply {
            request_data: request_data,
            report_data: report_data,
        }))
    }
}

impl Message for Error {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.code));
        try!(buffer.write(&self.data.token[..]));
        try!(buffer.write(self.data.id.as_bytes()));
        try!(buffer.write(&self.data.system[..]));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write(&self.data.data[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(Error_AgentData::read_from(buffer));
        // Block Data
        let data = try!(Error_Data::read_from(buffer));
        Ok(MessageInstance::Error(Error {
            agent_data: agent_data,
            data: data,
        }))
    }
}

impl Message for ObjectIncludeInSearch {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.include_in_search as u8));
        }
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(ObjectIncludeInSearch_AgentData::read_from(buffer));
        // Block ObjectData
        let mut object_data = Vec::new();
        let _object_data_count = try!(buffer.read_u8());
        for _ in 0.._object_data_count {
            object_data.push(try!(ObjectIncludeInSearch_ObjectData::read_from(buffer)));
        }
        Ok(MessageInstance::ObjectIncludeInSearch(ObjectIncludeInSearch {
            agent_data: agent_data,
            object_data: object_data,
        }))
    }
}

impl Message for RezRestoreToWorld {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(RezRestoreToWorld_AgentData::read_from(buffer));
        // Block InventoryData
        let inventory_data = try!(RezRestoreToWorld_InventoryData::read_from(buffer));
        Ok(MessageInstance::RezRestoreToWorld(RezRestoreToWorld {
            agent_data: agent_data,
            inventory_data: inventory_data,
        }))
    }
}

impl Message for LinkInventoryItem {
    fn write_to<W: ?Sized>(&self, buffer: &mut W) -> WriteMessageResult
        where W: Write
    {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xaa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write(self.inventory_block.old_item_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        Ok(())
    }

    fn read_from<R: ?Sized>(buffer: &mut R) -> Result<MessageInstance, ReadMessageError>
        where R: Read
    {
        // Block AgentData
        let agent_data = try!(LinkInventoryItem_AgentData::read_from(buffer));
        // Block InventoryBlock
        let inventory_block = try!(LinkInventoryItem_InventoryBlock::read_from(buffer));
        Ok(MessageInstance::LinkInventoryItem(LinkInventoryItem {
            agent_data: agent_data,
            inventory_block: inventory_block,
        }))
    }
}
