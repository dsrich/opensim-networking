use {Vector3, Vector4, Quaternion, UnitQuaternion, Ip4Addr, Ip4Port, Uuid};
use std::io::Write;
use byteorder::{LittleEndian, BigEndian, WriteBytesExt};

pub enum WriteMessageError {
    IoError(::std::io::Error),
}

impl From<::std::io::Error> for WriteMessageError {
    fn from(e: ::std::io::Error) -> WriteMessageError {
        WriteMessageError::IoError(e)
    }
}

pub type WriteMessageResult = Result<(), WriteMessageError>;
pub trait Message {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult;
}

// Don't edit this file manually, it is generated by a script and might be overwritten in the
// future.

pub struct TestMessage_TestBlock1 {
    pub test1: u32,
}

pub struct TestMessage_NeighborBlock {
    pub test0: u32,
    pub test1: u32,
    pub test2: u32,
}

pub struct TestMessage {
    pub test_block1: TestMessage_TestBlock1,
    pub neighbor_block: [TestMessage_NeighborBlock; 4],
}


pub struct PacketAck_Packets {
    pub id: u32,
}

pub struct PacketAck {
    pub packets: Vec<PacketAck_Packets>,
}


pub struct OpenCircuit_CircuitInfo {
    pub ip: Ip4Addr,
    pub port: Ip4Port,
}

pub struct OpenCircuit {
    pub circuit_info: OpenCircuit_CircuitInfo,
}


pub struct CloseCircuit {
}


pub struct StartPingCheck_PingID {
    pub ping_id: u8,
    pub oldest_unacked: u32,
}

pub struct StartPingCheck {
    pub ping_id: StartPingCheck_PingID,
}


pub struct CompletePingCheck_PingID {
    pub ping_id: u8,
}

pub struct CompletePingCheck {
    pub ping_id: CompletePingCheck_PingID,
}


pub struct AddCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub agent_id: Uuid,
}

pub struct AddCircuitCode {
    pub circuit_code: AddCircuitCode_CircuitCode,
}


pub struct UseCircuitCode_CircuitCode {
    pub code: u32,
    pub session_id: Uuid,
    pub id: Uuid,
}

pub struct UseCircuitCode {
    pub circuit_code: UseCircuitCode_CircuitCode,
}


pub struct NeighborList_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: Ip4Port,
    pub public_ip: Ip4Addr,
    pub public_port: Ip4Port,
    pub region_id: Uuid,
    pub name: Vec<u8>,
    pub sim_access: u8,
}

pub struct NeighborList {
    pub neighbor_block: [NeighborList_NeighborBlock; 4],
}


pub struct AvatarTextureUpdate_AgentData {
    pub agent_id: Uuid,
    pub textures_changed: bool,
}

pub struct AvatarTextureUpdate_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

pub struct AvatarTextureUpdate_TextureData {
    pub texture_id: Uuid,
}

pub struct AvatarTextureUpdate {
    pub agent_data: AvatarTextureUpdate_AgentData,
    pub wearable_data: Vec<AvatarTextureUpdate_WearableData>,
    pub texture_data: Vec<AvatarTextureUpdate_TextureData>,
}


pub struct SimulatorMapUpdate_MapData {
    pub flags: u32,
}

pub struct SimulatorMapUpdate {
    pub map_data: SimulatorMapUpdate_MapData,
}


pub struct SimulatorSetMap_MapData {
    pub region_handle: u64,
    pub type_: i32,
    pub map_image: Uuid,
}

pub struct SimulatorSetMap {
    pub map_data: SimulatorSetMap_MapData,
}


pub struct SubscribeLoad {
}


pub struct UnsubscribeLoad {
}


pub struct SimulatorReady_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

pub struct SimulatorReady_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

pub struct SimulatorReady {
    pub simulator_block: SimulatorReady_SimulatorBlock,
    pub telehub_block: SimulatorReady_TelehubBlock,
}


pub struct TelehubInfo_TelehubBlock {
    pub object_id: Uuid,
    pub object_name: Vec<u8>,
    pub telehub_pos: Vector3<f32>,
    pub telehub_rot: Quaternion<f32>,
}

pub struct TelehubInfo_SpawnPointBlock {
    pub spawn_point_pos: Vector3<f32>,
}

pub struct TelehubInfo {
    pub telehub_block: TelehubInfo_TelehubBlock,
    pub spawn_point_block: Vec<TelehubInfo_SpawnPointBlock>,
}


pub struct SimulatorPresentAtLocation_SimulatorPublicHostBlock {
    pub port: Ip4Port,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
}

pub struct SimulatorPresentAtLocation_NeighborBlock {
    pub ip: Ip4Addr,
    pub port: Ip4Port,
}

pub struct SimulatorPresentAtLocation_SimulatorBlock {
    pub sim_name: Vec<u8>,
    pub sim_access: u8,
    pub region_flags: u32,
    pub region_id: Uuid,
    pub estate_id: u32,
    pub parent_estate_id: u32,
}

pub struct SimulatorPresentAtLocation_TelehubBlock {
    pub has_telehub: bool,
    pub telehub_pos: Vector3<f32>,
}

pub struct SimulatorPresentAtLocation {
    pub simulator_public_host_block: SimulatorPresentAtLocation_SimulatorPublicHostBlock,
    pub neighbor_block: [SimulatorPresentAtLocation_NeighborBlock; 4],
    pub simulator_block: SimulatorPresentAtLocation_SimulatorBlock,
    pub telehub_block: Vec<SimulatorPresentAtLocation_TelehubBlock>,
}


pub struct SimulatorLoad_SimulatorLoad {
    pub time_dilation: f32,
    pub agent_count: i32,
    pub can_accept_agents: bool,
}

pub struct SimulatorLoad_AgentList {
    pub circuit_code: u32,
    pub x: u8,
    pub y: u8,
}

pub struct SimulatorLoad {
    pub simulator_load: SimulatorLoad_SimulatorLoad,
    pub agent_list: Vec<SimulatorLoad_AgentList>,
}


pub struct SimulatorShutdownRequest {
}


pub struct RegionPresenceRequestByRegionID_RegionData {
    pub region_id: Uuid,
}

pub struct RegionPresenceRequestByRegionID {
    pub region_data: Vec<RegionPresenceRequestByRegionID_RegionData>,
}


pub struct RegionPresenceRequestByHandle_RegionData {
    pub region_handle: u64,
}

pub struct RegionPresenceRequestByHandle {
    pub region_data: Vec<RegionPresenceRequestByHandle_RegionData>,
}


pub struct RegionPresenceResponse_RegionData {
    pub region_id: Uuid,
    pub region_handle: u64,
    pub internal_region_ip: Ip4Addr,
    pub external_region_ip: Ip4Addr,
    pub region_port: Ip4Port,
    pub valid_until: f64,
    pub message: Vec<u8>,
}

pub struct RegionPresenceResponse {
    pub region_data: Vec<RegionPresenceResponse_RegionData>,
}


pub struct UpdateSimulator_SimulatorInfo {
    pub region_id: Uuid,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub sim_access: u8,
}

pub struct UpdateSimulator {
    pub simulator_info: UpdateSimulator_SimulatorInfo,
}


pub struct LogDwellTime_DwellInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub duration: f32,
    pub sim_name: Vec<u8>,
    pub region_x: u32,
    pub region_y: u32,
    pub avg_agents_in_view: u8,
    pub avg_viewer_fps: u8,
}

pub struct LogDwellTime {
    pub dwell_info: LogDwellTime_DwellInfo,
}


pub struct FeatureDisabled_FailureInfo {
    pub error_message: Vec<u8>,
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct FeatureDisabled {
    pub failure_info: FeatureDisabled_FailureInfo,
}


pub struct LogFailedMoneyTransaction_TransactionData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub simulator_ip: Ip4Addr,
    pub grid_x: u32,
    pub grid_y: u32,
    pub failure_type: u8,
}

pub struct LogFailedMoneyTransaction {
    pub transaction_data: LogFailedMoneyTransaction_TransactionData,
}


pub struct UserReportInternal_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub reporter_id: Uuid,
    pub viewer_position: Vector3<f32>,
    pub agent_position: Vector3<f32>,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub last_owner_id: Uuid,
    pub creator_id: Uuid,
    pub region_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

pub struct UserReportInternal {
    pub report_data: UserReportInternal_ReportData,
}


pub struct SetSimStatusInDatabase_Data {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub x: i32,
    pub y: i32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

pub struct SetSimStatusInDatabase {
    pub data: SetSimStatusInDatabase_Data,
}


pub struct SetSimPresenceInDatabase_SimData {
    pub region_id: Uuid,
    pub host_name: Vec<u8>,
    pub grid_x: u32,
    pub grid_y: u32,
    pub pid: i32,
    pub agent_count: i32,
    pub time_to_live: i32,
    pub status: Vec<u8>,
}

pub struct SetSimPresenceInDatabase {
    pub sim_data: SetSimPresenceInDatabase_SimData,
}


pub struct EconomyDataRequest {
}


pub struct EconomyData_Info {
    pub object_capacity: i32,
    pub object_count: i32,
    pub price_energy_unit: i32,
    pub price_object_claim: i32,
    pub price_public_object_decay: i32,
    pub price_public_object_delete: i32,
    pub price_parcel_claim: i32,
    pub price_parcel_claim_factor: f32,
    pub price_upload: i32,
    pub price_rent_light: i32,
    pub teleport_min_price: i32,
    pub teleport_price_exponent: f32,
    pub energy_efficiency: f32,
    pub price_object_rent: f32,
    pub price_object_scale_factor: f32,
    pub price_parcel_rent: i32,
    pub price_group_create: i32,
}

pub struct EconomyData {
    pub info: EconomyData_Info,
}


pub struct AvatarPickerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

pub struct AvatarPickerRequest_Data {
    pub name: Vec<u8>,
}

pub struct AvatarPickerRequest {
    pub agent_data: AvatarPickerRequest_AgentData,
    pub data: AvatarPickerRequest_Data,
}


pub struct AvatarPickerRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
    pub god_level: u8,
}

pub struct AvatarPickerRequestBackend_Data {
    pub name: Vec<u8>,
}

pub struct AvatarPickerRequestBackend {
    pub agent_data: AvatarPickerRequestBackend_AgentData,
    pub data: AvatarPickerRequestBackend_Data,
}


pub struct AvatarPickerReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

pub struct AvatarPickerReply_Data {
    pub avatar_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

pub struct AvatarPickerReply {
    pub agent_data: AvatarPickerReply_AgentData,
    pub data: Vec<AvatarPickerReply_Data>,
}


pub struct PlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub query_id: Uuid,
}

pub struct PlacesQuery_TransactionData {
    pub transaction_id: Uuid,
}

pub struct PlacesQuery_QueryData {
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
}

pub struct PlacesQuery {
    pub agent_data: PlacesQuery_AgentData,
    pub transaction_data: PlacesQuery_TransactionData,
    pub query_data: PlacesQuery_QueryData,
}


pub struct PlacesReply_AgentData {
    pub agent_id: Uuid,
    pub query_id: Uuid,
}

pub struct PlacesReply_TransactionData {
    pub transaction_id: Uuid,
}

pub struct PlacesReply_QueryData {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub price: i32,
}

pub struct PlacesReply {
    pub agent_data: PlacesReply_AgentData,
    pub transaction_data: PlacesReply_TransactionData,
    pub query_data: Vec<PlacesReply_QueryData>,
}


pub struct DirFindQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DirFindQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

pub struct DirFindQuery {
    pub agent_data: DirFindQuery_AgentData,
    pub query_data: DirFindQuery_QueryData,
}


pub struct DirFindQueryBackend_AgentData {
    pub agent_id: Uuid,
}

pub struct DirFindQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct DirFindQueryBackend {
    pub agent_data: DirFindQueryBackend_AgentData,
    pub query_data: DirFindQueryBackend_QueryData,
}


pub struct DirPlacesQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DirPlacesQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub query_start: i32,
}

pub struct DirPlacesQuery {
    pub agent_data: DirPlacesQuery_AgentData,
    pub query_data: DirPlacesQuery_QueryData,
}


pub struct DirPlacesQueryBackend_AgentData {
    pub agent_id: Uuid,
}

pub struct DirPlacesQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: i8,
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

pub struct DirPlacesQueryBackend {
    pub agent_data: DirPlacesQueryBackend_AgentData,
    pub query_data: DirPlacesQueryBackend_QueryData,
}


pub struct DirPlacesReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirPlacesReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirPlacesReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub for_sale: bool,
    pub auction: bool,
    pub dwell: f32,
}

pub struct DirPlacesReply_StatusData {
    pub status: u32,
}

pub struct DirPlacesReply {
    pub agent_data: DirPlacesReply_AgentData,
    pub query_data: Vec<DirPlacesReply_QueryData>,
    pub query_replies: Vec<DirPlacesReply_QueryReplies>,
    pub status_data: Vec<DirPlacesReply_StatusData>,
}


pub struct DirPeopleReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirPeopleReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirPeopleReply_QueryReplies {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group: Vec<u8>,
    pub online: bool,
    pub reputation: i32,
}

pub struct DirPeopleReply {
    pub agent_data: DirPeopleReply_AgentData,
    pub query_data: DirPeopleReply_QueryData,
    pub query_replies: Vec<DirPeopleReply_QueryReplies>,
}


pub struct DirEventsReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirEventsReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirEventsReply_QueryReplies {
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub event_id: u32,
    pub date: Vec<u8>,
    pub unix_time: u32,
    pub event_flags: u32,
}

pub struct DirEventsReply_StatusData {
    pub status: u32,
}

pub struct DirEventsReply {
    pub agent_data: DirEventsReply_AgentData,
    pub query_data: DirEventsReply_QueryData,
    pub query_replies: Vec<DirEventsReply_QueryReplies>,
    pub status_data: Vec<DirEventsReply_StatusData>,
}


pub struct DirGroupsReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirGroupsReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirGroupsReply_QueryReplies {
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub members: i32,
    pub search_order: f32,
}

pub struct DirGroupsReply {
    pub agent_data: DirGroupsReply_AgentData,
    pub query_data: DirGroupsReply_QueryData,
    pub query_replies: Vec<DirGroupsReply_QueryReplies>,
}


pub struct DirClassifiedQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DirClassifiedQuery_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub query_start: i32,
}

pub struct DirClassifiedQuery {
    pub agent_data: DirClassifiedQuery_AgentData,
    pub query_data: DirClassifiedQuery_QueryData,
}


pub struct DirClassifiedQueryBackend_AgentData {
    pub agent_id: Uuid,
}

pub struct DirClassifiedQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub category: u32,
    pub estate_id: u32,
    pub godlike: bool,
    pub query_start: i32,
}

pub struct DirClassifiedQueryBackend {
    pub agent_data: DirClassifiedQueryBackend_AgentData,
    pub query_data: DirClassifiedQueryBackend_QueryData,
}


pub struct DirClassifiedReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirClassifiedReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirClassifiedReply_QueryReplies {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
    pub classified_flags: u8,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub price_for_listing: i32,
}

pub struct DirClassifiedReply_StatusData {
    pub status: u32,
}

pub struct DirClassifiedReply {
    pub agent_data: DirClassifiedReply_AgentData,
    pub query_data: DirClassifiedReply_QueryData,
    pub query_replies: Vec<DirClassifiedReply_QueryReplies>,
    pub status_data: Vec<DirClassifiedReply_StatusData>,
}


pub struct AvatarClassifiedReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

pub struct AvatarClassifiedReply_Data {
    pub classified_id: Uuid,
    pub name: Vec<u8>,
}

pub struct AvatarClassifiedReply {
    pub agent_data: AvatarClassifiedReply_AgentData,
    pub data: Vec<AvatarClassifiedReply_Data>,
}


pub struct ClassifiedInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ClassifiedInfoRequest_Data {
    pub classified_id: Uuid,
}

pub struct ClassifiedInfoRequest {
    pub agent_data: ClassifiedInfoRequest_AgentData,
    pub data: ClassifiedInfoRequest_Data,
}


pub struct ClassifiedInfoReply_AgentData {
    pub agent_id: Uuid,
}

pub struct ClassifiedInfoReply_Data {
    pub classified_id: Uuid,
    pub creator_id: Uuid,
    pub creation_date: u32,
    pub expiration_date: u32,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub parcel_name: Vec<u8>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

pub struct ClassifiedInfoReply {
    pub agent_data: ClassifiedInfoReply_AgentData,
    pub data: ClassifiedInfoReply_Data,
}


pub struct ClassifiedInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ClassifiedInfoUpdate_Data {
    pub classified_id: Uuid,
    pub category: u32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub parcel_id: Uuid,
    pub parent_estate: u32,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub classified_flags: u8,
    pub price_for_listing: i32,
}

pub struct ClassifiedInfoUpdate {
    pub agent_data: ClassifiedInfoUpdate_AgentData,
    pub data: ClassifiedInfoUpdate_Data,
}


pub struct ClassifiedDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ClassifiedDelete_Data {
    pub classified_id: Uuid,
}

pub struct ClassifiedDelete {
    pub agent_data: ClassifiedDelete_AgentData,
    pub data: ClassifiedDelete_Data,
}


pub struct ClassifiedGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ClassifiedGodDelete_Data {
    pub classified_id: Uuid,
    pub query_id: Uuid,
}

pub struct ClassifiedGodDelete {
    pub agent_data: ClassifiedGodDelete_AgentData,
    pub data: ClassifiedGodDelete_Data,
}


pub struct DirLandQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DirLandQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
}

pub struct DirLandQuery {
    pub agent_data: DirLandQuery_AgentData,
    pub query_data: DirLandQuery_QueryData,
}


pub struct DirLandQueryBackend_AgentData {
    pub agent_id: Uuid,
}

pub struct DirLandQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub search_type: u32,
    pub price: i32,
    pub area: i32,
    pub query_start: i32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct DirLandQueryBackend {
    pub agent_data: DirLandQueryBackend_AgentData,
    pub query_data: DirLandQueryBackend_QueryData,
}


pub struct DirLandReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirLandReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirLandReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub auction: bool,
    pub for_sale: bool,
    pub sale_price: i32,
    pub actual_area: i32,
}

pub struct DirLandReply {
    pub agent_data: DirLandReply_AgentData,
    pub query_data: DirLandReply_QueryData,
    pub query_replies: Vec<DirLandReply_QueryReplies>,
}


pub struct DirPopularQuery_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DirPopularQuery_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
}

pub struct DirPopularQuery {
    pub agent_data: DirPopularQuery_AgentData,
    pub query_data: DirPopularQuery_QueryData,
}


pub struct DirPopularQueryBackend_AgentData {
    pub agent_id: Uuid,
}

pub struct DirPopularQueryBackend_QueryData {
    pub query_id: Uuid,
    pub query_flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct DirPopularQueryBackend {
    pub agent_data: DirPopularQueryBackend_AgentData,
    pub query_data: DirPopularQueryBackend_QueryData,
}


pub struct DirPopularReply_AgentData {
    pub agent_id: Uuid,
}

pub struct DirPopularReply_QueryData {
    pub query_id: Uuid,
}

pub struct DirPopularReply_QueryReplies {
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub dwell: f32,
}

pub struct DirPopularReply {
    pub agent_data: DirPopularReply_AgentData,
    pub query_data: DirPopularReply_QueryData,
    pub query_replies: Vec<DirPopularReply_QueryReplies>,
}


pub struct ParcelInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelInfoRequest_Data {
    pub parcel_id: Uuid,
}

pub struct ParcelInfoRequest {
    pub agent_data: ParcelInfoRequest_AgentData,
    pub data: ParcelInfoRequest_Data,
}


pub struct ParcelInfoReply_AgentData {
    pub agent_id: Uuid,
}

pub struct ParcelInfoReply_Data {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub actual_area: i32,
    pub billable_area: i32,
    pub flags: u8,
    pub global_x: f32,
    pub global_y: f32,
    pub global_z: f32,
    pub sim_name: Vec<u8>,
    pub snapshot_id: Uuid,
    pub dwell: f32,
    pub sale_price: i32,
    pub auction_id: i32,
}

pub struct ParcelInfoReply {
    pub agent_data: ParcelInfoReply_AgentData,
    pub data: ParcelInfoReply_Data,
}


pub struct ParcelObjectOwnersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelObjectOwnersRequest_ParcelData {
    pub local_id: i32,
}

pub struct ParcelObjectOwnersRequest {
    pub agent_data: ParcelObjectOwnersRequest_AgentData,
    pub parcel_data: ParcelObjectOwnersRequest_ParcelData,
}


pub struct ParcelObjectOwnersReply_Data {
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub count: i32,
    pub online_status: bool,
}

pub struct ParcelObjectOwnersReply {
    pub data: Vec<ParcelObjectOwnersReply_Data>,
}


pub struct GroupNoticesListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupNoticesListRequest_Data {
    pub group_id: Uuid,
}

pub struct GroupNoticesListRequest {
    pub agent_data: GroupNoticesListRequest_AgentData,
    pub data: GroupNoticesListRequest_Data,
}


pub struct GroupNoticesListReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupNoticesListReply_Data {
    pub notice_id: Uuid,
    pub timestamp: u32,
    pub from_name: Vec<u8>,
    pub subject: Vec<u8>,
    pub has_attachment: bool,
    pub asset_type: u8,
}

pub struct GroupNoticesListReply {
    pub agent_data: GroupNoticesListReply_AgentData,
    pub data: Vec<GroupNoticesListReply_Data>,
}


pub struct GroupNoticeRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupNoticeRequest_Data {
    pub group_notice_id: Uuid,
}

pub struct GroupNoticeRequest {
    pub agent_data: GroupNoticeRequest_AgentData,
    pub data: GroupNoticeRequest_Data,
}


pub struct GroupNoticeAdd_AgentData {
    pub agent_id: Uuid,
}

pub struct GroupNoticeAdd_MessageBlock {
    pub to_group_id: Uuid,
    pub id: Uuid,
    pub dialog: u8,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

pub struct GroupNoticeAdd {
    pub agent_data: GroupNoticeAdd_AgentData,
    pub message_block: GroupNoticeAdd_MessageBlock,
}


pub struct TeleportRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct TeleportRequest_Info {
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

pub struct TeleportRequest {
    pub agent_data: TeleportRequest_AgentData,
    pub info: TeleportRequest_Info,
}


pub struct TeleportLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct TeleportLocationRequest_Info {
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

pub struct TeleportLocationRequest {
    pub agent_data: TeleportLocationRequest_AgentData,
    pub info: TeleportLocationRequest_Info,
}


pub struct TeleportLocal_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub teleport_flags: u32,
}

pub struct TeleportLocal {
    pub info: TeleportLocal_Info,
}


pub struct TeleportLandmarkRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub landmark_id: Uuid,
}

pub struct TeleportLandmarkRequest {
    pub info: TeleportLandmarkRequest_Info,
}


pub struct TeleportProgress_AgentData {
    pub agent_id: Uuid,
}

pub struct TeleportProgress_Info {
    pub teleport_flags: u32,
    pub message: Vec<u8>,
}

pub struct TeleportProgress {
    pub agent_data: TeleportProgress_AgentData,
    pub info: TeleportProgress_Info,
}


pub struct DataHomeLocationRequest_Info {
    pub agent_id: Uuid,
    pub kicked_from_estate_id: u32,
}

pub struct DataHomeLocationRequest_AgentInfo {
    pub agent_effective_maturity: u32,
}

pub struct DataHomeLocationRequest {
    pub info: DataHomeLocationRequest_Info,
    pub agent_info: DataHomeLocationRequest_AgentInfo,
}


pub struct DataHomeLocationReply_Info {
    pub agent_id: Uuid,
    pub region_handle: u64,
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

pub struct DataHomeLocationReply {
    pub info: DataHomeLocationReply_Info,
}


pub struct TeleportFinish_Info {
    pub agent_id: Uuid,
    pub location_id: u32,
    pub sim_ip: Ip4Addr,
    pub sim_port: Ip4Port,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
    pub sim_access: u8,
    pub teleport_flags: u32,
}

pub struct TeleportFinish {
    pub info: TeleportFinish_Info,
}


pub struct StartLure_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct StartLure_Info {
    pub lure_type: u8,
    pub message: Vec<u8>,
}

pub struct StartLure_TargetData {
    pub target_id: Uuid,
}

pub struct StartLure {
    pub agent_data: StartLure_AgentData,
    pub info: StartLure_Info,
    pub target_data: Vec<StartLure_TargetData>,
}


pub struct TeleportLureRequest_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub lure_id: Uuid,
    pub teleport_flags: u32,
}

pub struct TeleportLureRequest {
    pub info: TeleportLureRequest_Info,
}


pub struct TeleportCancel_Info {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct TeleportCancel {
    pub info: TeleportCancel_Info,
}


pub struct TeleportStart_Info {
    pub teleport_flags: u32,
}

pub struct TeleportStart {
    pub info: TeleportStart_Info,
}


pub struct TeleportFailed_Info {
    pub agent_id: Uuid,
    pub reason: Vec<u8>,
}

pub struct TeleportFailed_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

pub struct TeleportFailed {
    pub info: TeleportFailed_Info,
    pub alert_info: Vec<TeleportFailed_AlertInfo>,
}


pub struct Undo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct Undo_ObjectData {
    pub object_id: Uuid,
}

pub struct Undo {
    pub agent_data: Undo_AgentData,
    pub object_data: Vec<Undo_ObjectData>,
}


pub struct Redo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct Redo_ObjectData {
    pub object_id: Uuid,
}

pub struct Redo {
    pub agent_data: Redo_AgentData,
    pub object_data: Vec<Redo_ObjectData>,
}


pub struct UndoLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UndoLand {
    pub agent_data: UndoLand_AgentData,
}


pub struct AgentPause_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

pub struct AgentPause {
    pub agent_data: AgentPause_AgentData,
}


pub struct AgentResume_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

pub struct AgentResume {
    pub agent_data: AgentResume_AgentData,
}


pub struct AgentUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub body_rotation: Quaternion<f32>,
    pub head_rotation: Quaternion<f32>,
    pub state: u8,
    pub camera_center: Vector3<f32>,
    pub camera_at_axis: Vector3<f32>,
    pub camera_left_axis: Vector3<f32>,
    pub camera_up_axis: Vector3<f32>,
    pub far: f32,
    pub control_flags: u32,
    pub flags: u8,
}

pub struct AgentUpdate {
    pub agent_data: AgentUpdate_AgentData,
}


pub struct ChatFromViewer_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ChatFromViewer_ChatData {
    pub message: Vec<u8>,
    pub type_: u8,
    pub channel: i32,
}

pub struct ChatFromViewer {
    pub agent_data: ChatFromViewer_AgentData,
    pub chat_data: ChatFromViewer_ChatData,
}


pub struct AgentThrottle_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

pub struct AgentThrottle_Throttle {
    pub gen_counter: u32,
    pub throttles: Vec<u8>,
}

pub struct AgentThrottle {
    pub agent_data: AgentThrottle_AgentData,
    pub throttle: AgentThrottle_Throttle,
}


pub struct AgentFOV_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

pub struct AgentFOV_FOVBlock {
    pub gen_counter: u32,
    pub vertical_angle: f32,
}

pub struct AgentFOV {
    pub agent_data: AgentFOV_AgentData,
    pub fov_block: AgentFOV_FOVBlock,
}


pub struct AgentHeightWidth_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

pub struct AgentHeightWidth_HeightWidthBlock {
    pub gen_counter: u32,
    pub height: u16,
    pub width: u16,
}

pub struct AgentHeightWidth {
    pub agent_data: AgentHeightWidth_AgentData,
    pub height_width_block: AgentHeightWidth_HeightWidthBlock,
}


pub struct AgentSetAppearance_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
    pub size: Vector3<f32>,
}

pub struct AgentSetAppearance_WearableData {
    pub cache_id: Uuid,
    pub texture_index: u8,
}

pub struct AgentSetAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

pub struct AgentSetAppearance_VisualParam {
    pub param_value: u8,
}

pub struct AgentSetAppearance {
    pub agent_data: AgentSetAppearance_AgentData,
    pub wearable_data: Vec<AgentSetAppearance_WearableData>,
    pub object_data: AgentSetAppearance_ObjectData,
    pub visual_param: Vec<AgentSetAppearance_VisualParam>,
}


pub struct AgentAnimation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentAnimation_AnimationList {
    pub anim_id: Uuid,
    pub start_anim: bool,
}

pub struct AgentAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}

pub struct AgentAnimation {
    pub agent_data: AgentAnimation_AgentData,
    pub animation_list: Vec<AgentAnimation_AnimationList>,
    pub physical_avatar_event_list: Vec<AgentAnimation_PhysicalAvatarEventList>,
}


pub struct AgentRequestSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentRequestSit_TargetObject {
    pub target_id: Uuid,
    pub offset: Vector3<f32>,
}

pub struct AgentRequestSit {
    pub agent_data: AgentRequestSit_AgentData,
    pub target_object: AgentRequestSit_TargetObject,
}


pub struct AgentSit_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentSit {
    pub agent_data: AgentSit_AgentData,
}


pub struct AgentQuitCopy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentQuitCopy_FuseBlock {
    pub viewer_circuit_code: u32,
}

pub struct AgentQuitCopy {
    pub agent_data: AgentQuitCopy_AgentData,
    pub fuse_block: AgentQuitCopy_FuseBlock,
}


pub struct RequestImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestImage_RequestImage {
    pub image: Uuid,
    pub discard_level: i8,
    pub download_priority: f32,
    pub packet: u32,
    pub type_: u8,
}

pub struct RequestImage {
    pub agent_data: RequestImage_AgentData,
    pub request_image: Vec<RequestImage_RequestImage>,
}


pub struct ImageNotInDatabase_ImageID {
    pub id: Uuid,
}

pub struct ImageNotInDatabase {
    pub image_id: ImageNotInDatabase_ImageID,
}


pub struct RebakeAvatarTextures_TextureData {
    pub texture_id: Uuid,
}

pub struct RebakeAvatarTextures {
    pub texture_data: RebakeAvatarTextures_TextureData,
}


pub struct SetAlwaysRun_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub always_run: bool,
}

pub struct SetAlwaysRun {
    pub agent_data: SetAlwaysRun_AgentData,
}


pub struct ObjectAdd_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct ObjectAdd_ObjectData {
    pub p_code: u8,
    pub material: u8,
    pub add_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: u8,
    pub scale: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub state: u8,
}

pub struct ObjectAdd {
    pub agent_data: ObjectAdd_AgentData,
    pub object_data: ObjectAdd_ObjectData,
}


pub struct ObjectDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub force: bool,
}

pub struct ObjectDelete_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDelete {
    pub agent_data: ObjectDelete_AgentData,
    pub object_data: Vec<ObjectDelete_ObjectData>,
}


pub struct ObjectDuplicate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct ObjectDuplicate_SharedData {
    pub offset: Vector3<f32>,
    pub duplicate_flags: u32,
}

pub struct ObjectDuplicate_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDuplicate {
    pub agent_data: ObjectDuplicate_AgentData,
    pub shared_data: ObjectDuplicate_SharedData,
    pub object_data: Vec<ObjectDuplicate_ObjectData>,
}


pub struct ObjectDuplicateOnRay_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub bypass_raycast: bool,
    pub ray_end_is_intersection: bool,
    pub copy_centers: bool,
    pub copy_rotates: bool,
    pub ray_target_id: Uuid,
    pub duplicate_flags: u32,
}

pub struct ObjectDuplicateOnRay_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDuplicateOnRay {
    pub agent_data: ObjectDuplicateOnRay_AgentData,
    pub object_data: Vec<ObjectDuplicateOnRay_ObjectData>,
}


pub struct MultipleObjectUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct MultipleObjectUpdate_ObjectData {
    pub object_local_id: u32,
    pub type_: u8,
    pub data: Vec<u8>,
}

pub struct MultipleObjectUpdate {
    pub agent_data: MultipleObjectUpdate_AgentData,
    pub object_data: Vec<MultipleObjectUpdate_ObjectData>,
}


pub struct RequestMultipleObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestMultipleObjects_ObjectData {
    pub cache_miss_type: u8,
    pub id: u32,
}

pub struct RequestMultipleObjects {
    pub agent_data: RequestMultipleObjects_AgentData,
    pub object_data: Vec<RequestMultipleObjects_ObjectData>,
}


pub struct ObjectPosition_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectPosition_ObjectData {
    pub object_local_id: u32,
    pub position: Vector3<f32>,
}

pub struct ObjectPosition {
    pub agent_data: ObjectPosition_AgentData,
    pub object_data: Vec<ObjectPosition_ObjectData>,
}


pub struct ObjectScale_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectScale_ObjectData {
    pub object_local_id: u32,
    pub scale: Vector3<f32>,
}

pub struct ObjectScale {
    pub agent_data: ObjectScale_AgentData,
    pub object_data: Vec<ObjectScale_ObjectData>,
}


pub struct ObjectRotation_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectRotation_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

pub struct ObjectRotation {
    pub agent_data: ObjectRotation_AgentData,
    pub object_data: Vec<ObjectRotation_ObjectData>,
}


pub struct ObjectFlagUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub object_local_id: u32,
    pub use_physics: bool,
    pub is_temporary: bool,
    pub is_phantom: bool,
    pub casts_shadows: bool,
}

pub struct ObjectFlagUpdate {
    pub agent_data: ObjectFlagUpdate_AgentData,
}


pub struct ObjectClickAction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectClickAction_ObjectData {
    pub object_local_id: u32,
    pub click_action: u8,
}

pub struct ObjectClickAction {
    pub agent_data: ObjectClickAction_AgentData,
    pub object_data: Vec<ObjectClickAction_ObjectData>,
}


pub struct ObjectImage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectImage_ObjectData {
    pub object_local_id: u32,
    pub media_url: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

pub struct ObjectImage {
    pub agent_data: ObjectImage_AgentData,
    pub object_data: Vec<ObjectImage_ObjectData>,
}


pub struct ObjectMaterial_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectMaterial_ObjectData {
    pub object_local_id: u32,
    pub material: u8,
}

pub struct ObjectMaterial {
    pub agent_data: ObjectMaterial_AgentData,
    pub object_data: Vec<ObjectMaterial_ObjectData>,
}


pub struct ObjectShape_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectShape_ObjectData {
    pub object_local_id: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
}

pub struct ObjectShape {
    pub agent_data: ObjectShape_AgentData,
    pub object_data: Vec<ObjectShape_ObjectData>,
}


pub struct ObjectExtraParams_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectExtraParams_ObjectData {
    pub object_local_id: u32,
    pub param_type: u16,
    pub param_in_use: bool,
    pub param_size: u32,
    pub param_data: Vec<u8>,
}

pub struct ObjectExtraParams {
    pub agent_data: ObjectExtraParams_AgentData,
    pub object_data: Vec<ObjectExtraParams_ObjectData>,
}


pub struct ObjectOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectOwner_HeaderData {
    pub override_: bool,
    pub owner_id: Uuid,
    pub group_id: Uuid,
}

pub struct ObjectOwner_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectOwner {
    pub agent_data: ObjectOwner_AgentData,
    pub header_data: ObjectOwner_HeaderData,
    pub object_data: Vec<ObjectOwner_ObjectData>,
}


pub struct ObjectGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct ObjectGroup_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectGroup {
    pub agent_data: ObjectGroup_AgentData,
    pub object_data: Vec<ObjectGroup_ObjectData>,
}


pub struct ObjectBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub category_id: Uuid,
}

pub struct ObjectBuy_ObjectData {
    pub object_local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

pub struct ObjectBuy {
    pub agent_data: ObjectBuy_AgentData,
    pub object_data: Vec<ObjectBuy_ObjectData>,
}


pub struct BuyObjectInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct BuyObjectInventory_Data {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub folder_id: Uuid,
}

pub struct BuyObjectInventory {
    pub agent_data: BuyObjectInventory_AgentData,
    pub data: BuyObjectInventory_Data,
}


pub struct DerezContainer_Data {
    pub object_id: Uuid,
    pub delete: bool,
}

pub struct DerezContainer {
    pub data: DerezContainer_Data,
}


pub struct ObjectPermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectPermissions_HeaderData {
    pub override_: bool,
}

pub struct ObjectPermissions_ObjectData {
    pub object_local_id: u32,
    pub field: u8,
    pub set: u8,
    pub mask: u32,
}

pub struct ObjectPermissions {
    pub agent_data: ObjectPermissions_AgentData,
    pub header_data: ObjectPermissions_HeaderData,
    pub object_data: Vec<ObjectPermissions_ObjectData>,
}


pub struct ObjectSaleInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectSaleInfo_ObjectData {
    pub local_id: u32,
    pub sale_type: u8,
    pub sale_price: i32,
}

pub struct ObjectSaleInfo {
    pub agent_data: ObjectSaleInfo_AgentData,
    pub object_data: Vec<ObjectSaleInfo_ObjectData>,
}


pub struct ObjectName_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectName_ObjectData {
    pub local_id: u32,
    pub name: Vec<u8>,
}

pub struct ObjectName {
    pub agent_data: ObjectName_AgentData,
    pub object_data: Vec<ObjectName_ObjectData>,
}


pub struct ObjectDescription_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDescription_ObjectData {
    pub local_id: u32,
    pub description: Vec<u8>,
}

pub struct ObjectDescription {
    pub agent_data: ObjectDescription_AgentData,
    pub object_data: Vec<ObjectDescription_ObjectData>,
}


pub struct ObjectCategory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectCategory_ObjectData {
    pub local_id: u32,
    pub category: u32,
}

pub struct ObjectCategory {
    pub agent_data: ObjectCategory_AgentData,
    pub object_data: Vec<ObjectCategory_ObjectData>,
}


pub struct ObjectSelect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectSelect_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectSelect {
    pub agent_data: ObjectSelect_AgentData,
    pub object_data: Vec<ObjectSelect_ObjectData>,
}


pub struct ObjectDeselect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDeselect_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDeselect {
    pub agent_data: ObjectDeselect_AgentData,
    pub object_data: Vec<ObjectDeselect_ObjectData>,
}


pub struct ObjectAttach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub attachment_point: u8,
}

pub struct ObjectAttach_ObjectData {
    pub object_local_id: u32,
    pub rotation: Quaternion<f32>,
}

pub struct ObjectAttach {
    pub agent_data: ObjectAttach_AgentData,
    pub object_data: Vec<ObjectAttach_ObjectData>,
}


pub struct ObjectDetach_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDetach_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDetach {
    pub agent_data: ObjectDetach_AgentData,
    pub object_data: Vec<ObjectDetach_ObjectData>,
}


pub struct ObjectDrop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDrop_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDrop {
    pub agent_data: ObjectDrop_AgentData,
    pub object_data: Vec<ObjectDrop_ObjectData>,
}


pub struct ObjectLink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectLink_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectLink {
    pub agent_data: ObjectLink_AgentData,
    pub object_data: Vec<ObjectLink_ObjectData>,
}


pub struct ObjectDelink_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDelink_ObjectData {
    pub object_local_id: u32,
}

pub struct ObjectDelink {
    pub agent_data: ObjectDelink_AgentData,
    pub object_data: Vec<ObjectDelink_ObjectData>,
}


pub struct ObjectGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectGrab_ObjectData {
    pub local_id: u32,
    pub grab_offset: Vector3<f32>,
}

pub struct ObjectGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

pub struct ObjectGrab {
    pub agent_data: ObjectGrab_AgentData,
    pub object_data: ObjectGrab_ObjectData,
    pub surface_info: Vec<ObjectGrab_SurfaceInfo>,
}


pub struct ObjectGrabUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectGrabUpdate_ObjectData {
    pub object_id: Uuid,
    pub grab_offset_initial: Vector3<f32>,
    pub grab_position: Vector3<f32>,
    pub time_since_last: u32,
}

pub struct ObjectGrabUpdate_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

pub struct ObjectGrabUpdate {
    pub agent_data: ObjectGrabUpdate_AgentData,
    pub object_data: ObjectGrabUpdate_ObjectData,
    pub surface_info: Vec<ObjectGrabUpdate_SurfaceInfo>,
}


pub struct ObjectDeGrab_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectDeGrab_ObjectData {
    pub local_id: u32,
}

pub struct ObjectDeGrab_SurfaceInfo {
    pub uv_coord: Vector3<f32>,
    pub st_coord: Vector3<f32>,
    pub face_index: i32,
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub binormal: Vector3<f32>,
}

pub struct ObjectDeGrab {
    pub agent_data: ObjectDeGrab_AgentData,
    pub object_data: ObjectDeGrab_ObjectData,
    pub surface_info: Vec<ObjectDeGrab_SurfaceInfo>,
}


pub struct ObjectSpinStart_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectSpinStart_ObjectData {
    pub object_id: Uuid,
}

pub struct ObjectSpinStart {
    pub agent_data: ObjectSpinStart_AgentData,
    pub object_data: ObjectSpinStart_ObjectData,
}


pub struct ObjectSpinUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectSpinUpdate_ObjectData {
    pub object_id: Uuid,
    pub rotation: Quaternion<f32>,
}

pub struct ObjectSpinUpdate {
    pub agent_data: ObjectSpinUpdate_AgentData,
    pub object_data: ObjectSpinUpdate_ObjectData,
}


pub struct ObjectSpinStop_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectSpinStop_ObjectData {
    pub object_id: Uuid,
}

pub struct ObjectSpinStop {
    pub agent_data: ObjectSpinStop_AgentData,
    pub object_data: ObjectSpinStop_ObjectData,
}


pub struct ObjectExportSelected_AgentData {
    pub agent_id: Uuid,
    pub request_id: Uuid,
    pub volume_detail: i16,
}

pub struct ObjectExportSelected_ObjectData {
    pub object_id: Uuid,
}

pub struct ObjectExportSelected {
    pub agent_data: ObjectExportSelected_AgentData,
    pub object_data: Vec<ObjectExportSelected_ObjectData>,
}


pub struct ModifyLand_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ModifyLand_ModifyBlock {
    pub action: u8,
    pub brush_size: u8,
    pub seconds: f32,
    pub height: f32,
}

pub struct ModifyLand_ParcelData {
    pub local_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

pub struct ModifyLand_ModifyBlockExtended {
    pub brush_size: f32,
}

pub struct ModifyLand {
    pub agent_data: ModifyLand_AgentData,
    pub modify_block: ModifyLand_ModifyBlock,
    pub parcel_data: Vec<ModifyLand_ParcelData>,
    pub modify_block_extended: Vec<ModifyLand_ModifyBlockExtended>,
}


pub struct VelocityInterpolateOn_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct VelocityInterpolateOn {
    pub agent_data: VelocityInterpolateOn_AgentData,
}


pub struct VelocityInterpolateOff_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct VelocityInterpolateOff {
    pub agent_data: VelocityInterpolateOff_AgentData,
}


pub struct StateSave_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct StateSave_DataBlock {
    pub filename: Vec<u8>,
}

pub struct StateSave {
    pub agent_data: StateSave_AgentData,
    pub data_block: StateSave_DataBlock,
}


pub struct ReportAutosaveCrash_AutosaveData {
    pub pid: i32,
    pub status: i32,
}

pub struct ReportAutosaveCrash {
    pub autosave_data: ReportAutosaveCrash_AutosaveData,
}


pub struct SimWideDeletes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct SimWideDeletes_DataBlock {
    pub target_id: Uuid,
    pub flags: u32,
}

pub struct SimWideDeletes {
    pub agent_data: SimWideDeletes_AgentData,
    pub data_block: SimWideDeletes_DataBlock,
}


pub struct RequestObjectPropertiesFamily_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
}

pub struct RequestObjectPropertiesFamily {
    pub agent_data: RequestObjectPropertiesFamily_AgentData,
    pub object_data: RequestObjectPropertiesFamily_ObjectData,
}


pub struct TrackAgent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct TrackAgent_TargetData {
    pub prey_id: Uuid,
}

pub struct TrackAgent {
    pub agent_data: TrackAgent_AgentData,
    pub target_data: TrackAgent_TargetData,
}


pub struct ViewerStats_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub ip: Ip4Addr,
    pub start_time: u32,
    pub run_time: f32,
    pub sim_fps: f32,
    pub fps: f32,
    pub agents_in_view: u8,
    pub ping: f32,
    pub meters_traveled: f64,
    pub regions_visited: i32,
    pub sys_ram: u32,
    pub sys_os: Vec<u8>,
    pub sys_cpu: Vec<u8>,
    pub sys_gpu: Vec<u8>,
}

pub struct ViewerStats_DownloadTotals {
    pub world: u32,
    pub objects: u32,
    pub textures: u32,
}

pub struct ViewerStats_NetStats {
    pub bytes: u32,
    pub packets: u32,
    pub compressed: u32,
    pub savings: u32,
}

pub struct ViewerStats_FailStats {
    pub send_packet: u32,
    pub dropped: u32,
    pub resent: u32,
    pub failed_resends: u32,
    pub off_circuit: u32,
    pub invalid: u32,
}

pub struct ViewerStats_MiscStats {
    pub type_: u32,
    pub value: f64,
}

pub struct ViewerStats {
    pub agent_data: ViewerStats_AgentData,
    pub download_totals: ViewerStats_DownloadTotals,
    pub net_stats: [ViewerStats_NetStats; 2],
    pub fail_stats: ViewerStats_FailStats,
    pub misc_stats: Vec<ViewerStats_MiscStats>,
}


pub struct ScriptAnswerYes_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ScriptAnswerYes_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub questions: i32,
}

pub struct ScriptAnswerYes {
    pub agent_data: ScriptAnswerYes_AgentData,
    pub data: ScriptAnswerYes_Data,
}


pub struct UserReport_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UserReport_ReportData {
    pub report_type: u8,
    pub category: u8,
    pub position: Vector3<f32>,
    pub check_flags: u8,
    pub screenshot_id: Uuid,
    pub object_id: Uuid,
    pub abuser_id: Uuid,
    pub abuse_region_name: Vec<u8>,
    pub abuse_region_id: Uuid,
    pub summary: Vec<u8>,
    pub details: Vec<u8>,
    pub version_string: Vec<u8>,
}

pub struct UserReport {
    pub agent_data: UserReport_AgentData,
    pub report_data: UserReport_ReportData,
}


pub struct AlertMessage_AlertData {
    pub message: Vec<u8>,
}

pub struct AlertMessage_AlertInfo {
    pub message: Vec<u8>,
    pub extra_params: Vec<u8>,
}

pub struct AlertMessage {
    pub alert_data: AlertMessage_AlertData,
    pub alert_info: Vec<AlertMessage_AlertInfo>,
}


pub struct AgentAlertMessage_AgentData {
    pub agent_id: Uuid,
}

pub struct AgentAlertMessage_AlertData {
    pub modal: bool,
    pub message: Vec<u8>,
}

pub struct AgentAlertMessage {
    pub agent_data: AgentAlertMessage_AgentData,
    pub alert_data: AgentAlertMessage_AlertData,
}


pub struct MeanCollisionAlert_MeanCollision {
    pub victim: Uuid,
    pub perp: Uuid,
    pub time: u32,
    pub mag: f32,
    pub type_: u8,
}

pub struct MeanCollisionAlert {
    pub mean_collision: Vec<MeanCollisionAlert_MeanCollision>,
}


pub struct ViewerFrozenMessage_FrozenData {
    pub data: bool,
}

pub struct ViewerFrozenMessage {
    pub frozen_data: ViewerFrozenMessage_FrozenData,
}


pub struct HealthMessage_HealthData {
    pub health: f32,
}

pub struct HealthMessage {
    pub health_data: HealthMessage_HealthData,
}


pub struct ChatFromSimulator_ChatData {
    pub from_name: Vec<u8>,
    pub source_id: Uuid,
    pub owner_id: Uuid,
    pub source_type: u8,
    pub chat_type: u8,
    pub audible: u8,
    pub position: Vector3<f32>,
    pub message: Vec<u8>,
}

pub struct ChatFromSimulator {
    pub chat_data: ChatFromSimulator_ChatData,
}


pub struct SimStats_Region {
    pub region_x: u32,
    pub region_y: u32,
    pub region_flags: u32,
    pub object_capacity: u32,
}

pub struct SimStats_Stat {
    pub stat_id: u32,
    pub stat_value: f32,
}

pub struct SimStats_PidStat {
    pub pid: i32,
}

pub struct SimStats {
    pub region: SimStats_Region,
    pub stat: Vec<SimStats_Stat>,
    pub pid_stat: SimStats_PidStat,
}


pub struct RequestRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestRegionInfo {
    pub agent_data: RequestRegionInfo_AgentData,
}


pub struct RegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub sim_access: u8,
    pub max_agents: u8,
    pub billable_factor: f32,
    pub object_bonus_factor: f32,
    pub water_height: f32,
    pub terrain_raise_limit: f32,
    pub terrain_lower_limit: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
    pub use_estate_sun: bool,
    pub sun_hour: f32,
}

pub struct RegionInfo_RegionInfo2 {
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
    pub max_agents32: u32,
    pub hard_max_agents: u32,
    pub hard_max_objects: u32,
}

pub struct RegionInfo {
    pub agent_data: RegionInfo_AgentData,
    pub region_info: RegionInfo_RegionInfo,
    pub region_info2: RegionInfo_RegionInfo2,
}


pub struct GodUpdateRegionInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GodUpdateRegionInfo_RegionInfo {
    pub sim_name: Vec<u8>,
    pub estate_id: u32,
    pub parent_estate_id: u32,
    pub region_flags: u32,
    pub billable_factor: f32,
    pub price_per_meter: i32,
    pub redirect_grid_x: i32,
    pub redirect_grid_y: i32,
}

pub struct GodUpdateRegionInfo {
    pub agent_data: GodUpdateRegionInfo_AgentData,
    pub region_info: GodUpdateRegionInfo_RegionInfo,
}


pub struct NearestLandingRegionRequest_RequestingRegionData {
    pub region_handle: u64,
}

pub struct NearestLandingRegionRequest {
    pub requesting_region_data: NearestLandingRegionRequest_RequestingRegionData,
}


pub struct NearestLandingRegionReply_LandingRegionData {
    pub region_handle: u64,
}

pub struct NearestLandingRegionReply {
    pub landing_region_data: NearestLandingRegionReply_LandingRegionData,
}


pub struct NearestLandingRegionUpdated_RegionData {
    pub region_handle: u64,
}

pub struct NearestLandingRegionUpdated {
    pub region_data: NearestLandingRegionUpdated_RegionData,
}


pub struct TeleportLandingStatusChanged_RegionData {
    pub region_handle: u64,
}

pub struct TeleportLandingStatusChanged {
    pub region_data: TeleportLandingStatusChanged_RegionData,
}


pub struct RegionHandshake_RegionInfo {
    pub region_flags: u32,
    pub sim_access: u8,
    pub sim_name: Vec<u8>,
    pub sim_owner: Uuid,
    pub is_estate_manager: bool,
    pub water_height: f32,
    pub billable_factor: f32,
    pub cache_id: Uuid,
    pub terrain_base0: Uuid,
    pub terrain_base1: Uuid,
    pub terrain_base2: Uuid,
    pub terrain_base3: Uuid,
    pub terrain_detail0: Uuid,
    pub terrain_detail1: Uuid,
    pub terrain_detail2: Uuid,
    pub terrain_detail3: Uuid,
    pub terrain_start_height00: f32,
    pub terrain_start_height01: f32,
    pub terrain_start_height10: f32,
    pub terrain_start_height11: f32,
    pub terrain_height_range00: f32,
    pub terrain_height_range01: f32,
    pub terrain_height_range10: f32,
    pub terrain_height_range11: f32,
}

pub struct RegionHandshake_RegionInfo2 {
    pub region_id: Uuid,
}

pub struct RegionHandshake_RegionInfo3 {
    pub cpu_class_id: i32,
    pub cpu_ratio: i32,
    pub colo_name: Vec<u8>,
    pub product_sku: Vec<u8>,
    pub product_name: Vec<u8>,
}

pub struct RegionHandshake {
    pub region_info: RegionHandshake_RegionInfo,
    pub region_info2: RegionHandshake_RegionInfo2,
    pub region_info3: RegionHandshake_RegionInfo3,
}


pub struct RegionHandshakeReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RegionHandshakeReply_RegionInfo {
    pub flags: u32,
}

pub struct RegionHandshakeReply {
    pub agent_data: RegionHandshakeReply_AgentData,
    pub region_info: RegionHandshakeReply_RegionInfo,
}


pub struct CoarseLocationUpdate_Location {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}

pub struct CoarseLocationUpdate_Index {
    pub you: i16,
    pub prey: i16,
}

pub struct CoarseLocationUpdate_AgentData {
    pub agent_id: Uuid,
}

pub struct CoarseLocationUpdate {
    pub location: Vec<CoarseLocationUpdate_Location>,
    pub index: CoarseLocationUpdate_Index,
    pub agent_data: Vec<CoarseLocationUpdate_AgentData>,
}


pub struct ImageData_ImageID {
    pub id: Uuid,
    pub codec: u8,
    pub size: u32,
    pub packets: u16,
}

pub struct ImageData_ImageData {
    pub data: Vec<u8>,
}

pub struct ImageData {
    pub image_id: ImageData_ImageID,
    pub image_data: ImageData_ImageData,
}


pub struct ImagePacket_ImageID {
    pub id: Uuid,
    pub packet: u16,
}

pub struct ImagePacket_ImageData {
    pub data: Vec<u8>,
}

pub struct ImagePacket {
    pub image_id: ImagePacket_ImageID,
    pub image_data: ImagePacket_ImageData,
}


pub struct LayerData_LayerID {
    pub type_: u8,
}

pub struct LayerData_LayerData {
    pub data: Vec<u8>,
}

pub struct LayerData {
    pub layer_id: LayerData_LayerID,
    pub layer_data: LayerData_LayerData,
}


pub struct ObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

pub struct ObjectUpdate_ObjectData {
    pub id: u32,
    pub state: u8,
    pub full_id: Uuid,
    pub crc: u32,
    pub p_code: u8,
    pub material: u8,
    pub click_action: u8,
    pub scale: Vector3<f32>,
    pub object_data: Vec<u8>,
    pub parent_id: u32,
    pub update_flags: u32,
    pub path_curve: u8,
    pub profile_curve: u8,
    pub path_begin: u16,
    pub path_end: u16,
    pub path_scale_x: u8,
    pub path_scale_y: u8,
    pub path_shear_x: u8,
    pub path_shear_y: u8,
    pub path_twist: i8,
    pub path_twist_begin: i8,
    pub path_radius_offset: i8,
    pub path_taper_x: i8,
    pub path_taper_y: i8,
    pub path_revolutions: u8,
    pub path_skew: i8,
    pub profile_begin: u16,
    pub profile_end: u16,
    pub profile_hollow: u16,
    pub texture_entry: Vec<u8>,
    pub texture_anim: Vec<u8>,
    pub name_value: Vec<u8>,
    pub data: Vec<u8>,
    pub text: Vec<u8>,
    pub text_color: [u8; 4],
    pub media_url: Vec<u8>,
    pub ps_block: Vec<u8>,
    pub extra_params: Vec<u8>,
    pub sound: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
    pub radius: f32,
    pub joint_type: u8,
    pub joint_pivot: Vector3<f32>,
    pub joint_axis_or_anchor: Vector3<f32>,
}

pub struct ObjectUpdate {
    pub region_data: ObjectUpdate_RegionData,
    pub object_data: Vec<ObjectUpdate_ObjectData>,
}


pub struct ObjectUpdateCompressed_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

pub struct ObjectUpdateCompressed_ObjectData {
    pub update_flags: u32,
    pub data: Vec<u8>,
}

pub struct ObjectUpdateCompressed {
    pub region_data: ObjectUpdateCompressed_RegionData,
    pub object_data: Vec<ObjectUpdateCompressed_ObjectData>,
}


pub struct ObjectUpdateCached_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

pub struct ObjectUpdateCached_ObjectData {
    pub id: u32,
    pub crc: u32,
    pub update_flags: u32,
}

pub struct ObjectUpdateCached {
    pub region_data: ObjectUpdateCached_RegionData,
    pub object_data: Vec<ObjectUpdateCached_ObjectData>,
}


pub struct ImprovedTerseObjectUpdate_RegionData {
    pub region_handle: u64,
    pub time_dilation: u16,
}

pub struct ImprovedTerseObjectUpdate_ObjectData {
    pub data: Vec<u8>,
    pub texture_entry: Vec<u8>,
}

pub struct ImprovedTerseObjectUpdate {
    pub region_data: ImprovedTerseObjectUpdate_RegionData,
    pub object_data: Vec<ImprovedTerseObjectUpdate_ObjectData>,
}


pub struct KillObject_ObjectData {
    pub id: u32,
}

pub struct KillObject {
    pub object_data: Vec<KillObject_ObjectData>,
}


pub struct CrossedRegion_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CrossedRegion_RegionData {
    pub sim_ip: Ip4Addr,
    pub sim_port: Ip4Port,
    pub region_handle: u64,
    pub seed_capability: Vec<u8>,
}

pub struct CrossedRegion_Info {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

pub struct CrossedRegion {
    pub agent_data: CrossedRegion_AgentData,
    pub region_data: CrossedRegion_RegionData,
    pub info: CrossedRegion_Info,
}


pub struct SimulatorViewerTimeMessage_TimeInfo {
    pub usec_since_start: u64,
    pub sec_per_day: u32,
    pub sec_per_year: u32,
    pub sun_direction: Vector3<f32>,
    pub sun_phase: f32,
    pub sun_ang_velocity: Vector3<f32>,
}

pub struct SimulatorViewerTimeMessage {
    pub time_info: SimulatorViewerTimeMessage_TimeInfo,
}


pub struct EnableSimulator_SimulatorInfo {
    pub handle: u64,
    pub ip: Ip4Addr,
    pub port: Ip4Port,
}

pub struct EnableSimulator {
    pub simulator_info: EnableSimulator_SimulatorInfo,
}


pub struct DisableSimulator {
}


pub struct ConfirmEnableSimulator_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ConfirmEnableSimulator {
    pub agent_data: ConfirmEnableSimulator_AgentData,
}


pub struct TransferRequest_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub source_type: i32,
    pub priority: f32,
    pub params: Vec<u8>,
}

pub struct TransferRequest {
    pub transfer_info: TransferRequest_TransferInfo,
}


pub struct TransferInfo_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub target_type: i32,
    pub status: i32,
    pub size: i32,
    pub params: Vec<u8>,
}

pub struct TransferInfo {
    pub transfer_info: TransferInfo_TransferInfo,
}


pub struct TransferPacket_TransferData {
    pub transfer_id: Uuid,
    pub channel_type: i32,
    pub packet: i32,
    pub status: i32,
    pub data: Vec<u8>,
}

pub struct TransferPacket {
    pub transfer_data: TransferPacket_TransferData,
}


pub struct TransferAbort_TransferInfo {
    pub transfer_id: Uuid,
    pub channel_type: i32,
}

pub struct TransferAbort {
    pub transfer_info: TransferAbort_TransferInfo,
}


pub struct RequestXfer_XferID {
    pub id: u64,
    pub filename: Vec<u8>,
    pub file_path: u8,
    pub delete_on_completion: bool,
    pub use_big_packets: bool,
    pub v_file_id: Uuid,
    pub v_file_type: i16,
}

pub struct RequestXfer {
    pub xfer_id: RequestXfer_XferID,
}


pub struct SendXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

pub struct SendXferPacket_DataPacket {
    pub data: Vec<u8>,
}

pub struct SendXferPacket {
    pub xfer_id: SendXferPacket_XferID,
    pub data_packet: SendXferPacket_DataPacket,
}


pub struct ConfirmXferPacket_XferID {
    pub id: u64,
    pub packet: u32,
}

pub struct ConfirmXferPacket {
    pub xfer_id: ConfirmXferPacket_XferID,
}


pub struct AbortXfer_XferID {
    pub id: u64,
    pub result: i32,
}

pub struct AbortXfer {
    pub xfer_id: AbortXfer_XferID,
}


pub struct AvatarAnimation_Sender {
    pub id: Uuid,
}

pub struct AvatarAnimation_AnimationList {
    pub anim_id: Uuid,
    pub anim_sequence_id: i32,
}

pub struct AvatarAnimation_AnimationSourceList {
    pub object_id: Uuid,
}

pub struct AvatarAnimation_PhysicalAvatarEventList {
    pub type_data: Vec<u8>,
}

pub struct AvatarAnimation {
    pub sender: AvatarAnimation_Sender,
    pub animation_list: Vec<AvatarAnimation_AnimationList>,
    pub animation_source_list: Vec<AvatarAnimation_AnimationSourceList>,
    pub physical_avatar_event_list: Vec<AvatarAnimation_PhysicalAvatarEventList>,
}


pub struct AvatarAppearance_Sender {
    pub id: Uuid,
    pub is_trial: bool,
}

pub struct AvatarAppearance_ObjectData {
    pub texture_entry: Vec<u8>,
}

pub struct AvatarAppearance_VisualParam {
    pub param_value: u8,
}

pub struct AvatarAppearance {
    pub sender: AvatarAppearance_Sender,
    pub object_data: AvatarAppearance_ObjectData,
    pub visual_param: Vec<AvatarAppearance_VisualParam>,
}


pub struct AvatarSitResponse_SitObject {
    pub id: Uuid,
}

pub struct AvatarSitResponse_SitTransform {
    pub auto_pilot: bool,
    pub sit_position: Vector3<f32>,
    pub sit_rotation: Quaternion<f32>,
    pub camera_eye_offset: Vector3<f32>,
    pub camera_at_offset: Vector3<f32>,
    pub force_mouselook: bool,
}

pub struct AvatarSitResponse {
    pub sit_object: AvatarSitResponse_SitObject,
    pub sit_transform: AvatarSitResponse_SitTransform,
}


pub struct SetFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

pub struct SetFollowCamProperties_CameraProperty {
    pub type_: i32,
    pub value: f32,
}

pub struct SetFollowCamProperties {
    pub object_data: SetFollowCamProperties_ObjectData,
    pub camera_property: Vec<SetFollowCamProperties_CameraProperty>,
}


pub struct ClearFollowCamProperties_ObjectData {
    pub object_id: Uuid,
}

pub struct ClearFollowCamProperties {
    pub object_data: ClearFollowCamProperties_ObjectData,
}


pub struct CameraConstraint_CameraCollidePlane {
    pub plane: Vector4<f32>,
}

pub struct CameraConstraint {
    pub camera_collide_plane: CameraConstraint_CameraCollidePlane,
}


pub struct ObjectProperties_ObjectData {
    pub object_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub creation_date: u64,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub aggregate_perms: u8,
    pub aggregate_perm_textures: u8,
    pub aggregate_perm_textures_owner: u8,
    pub category: u32,
    pub inventory_serial: i16,
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub from_task_id: Uuid,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub touch_name: Vec<u8>,
    pub sit_name: Vec<u8>,
    pub texture_id: Vec<u8>,
}

pub struct ObjectProperties {
    pub object_data: Vec<ObjectProperties_ObjectData>,
}


pub struct ObjectPropertiesFamily_ObjectData {
    pub request_flags: u32,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub ownership_cost: i32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub category: u32,
    pub last_owner_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

pub struct ObjectPropertiesFamily {
    pub object_data: ObjectPropertiesFamily_ObjectData,
}


pub struct RequestPayPrice_ObjectData {
    pub object_id: Uuid,
}

pub struct RequestPayPrice {
    pub object_data: RequestPayPrice_ObjectData,
}


pub struct PayPriceReply_ObjectData {
    pub object_id: Uuid,
    pub default_pay_price: i32,
}

pub struct PayPriceReply_ButtonData {
    pub pay_button: i32,
}

pub struct PayPriceReply {
    pub object_data: PayPriceReply_ObjectData,
    pub button_data: Vec<PayPriceReply_ButtonData>,
}


pub struct KickUser_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: Ip4Port,
}

pub struct KickUser_UserInfo {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub reason: Vec<u8>,
}

pub struct KickUser {
    pub target_block: KickUser_TargetBlock,
    pub user_info: KickUser_UserInfo,
}


pub struct KickUserAck_UserInfo {
    pub session_id: Uuid,
    pub flags: u32,
}

pub struct KickUserAck {
    pub user_info: KickUserAck_UserInfo,
}


pub struct GodKickUser_UserInfo {
    pub god_id: Uuid,
    pub god_session_id: Uuid,
    pub agent_id: Uuid,
    pub kick_flags: u32,
    pub reason: Vec<u8>,
}

pub struct GodKickUser {
    pub user_info: GodKickUser_UserInfo,
}


pub struct SystemKickUser_AgentInfo {
    pub agent_id: Uuid,
}

pub struct SystemKickUser {
    pub agent_info: Vec<SystemKickUser_AgentInfo>,
}


pub struct EjectUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EjectUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

pub struct EjectUser {
    pub agent_data: EjectUser_AgentData,
    pub data: EjectUser_Data,
}


pub struct FreezeUser_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct FreezeUser_Data {
    pub target_id: Uuid,
    pub flags: u32,
}

pub struct FreezeUser {
    pub agent_data: FreezeUser_AgentData,
    pub data: FreezeUser_Data,
}


pub struct AvatarPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub avatar_id: Uuid,
}

pub struct AvatarPropertiesRequest {
    pub agent_data: AvatarPropertiesRequest_AgentData,
}


pub struct AvatarPropertiesRequestBackend_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
    pub god_level: u8,
    pub web_profiles_disabled: bool,
}

pub struct AvatarPropertiesRequestBackend {
    pub agent_data: AvatarPropertiesRequestBackend_AgentData,
}


pub struct AvatarPropertiesReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

pub struct AvatarPropertiesReply_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub partner_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub born_on: Vec<u8>,
    pub profile_url: Vec<u8>,
    pub charter_member: Vec<u8>,
    pub flags: u32,
}

pub struct AvatarPropertiesReply {
    pub agent_data: AvatarPropertiesReply_AgentData,
    pub properties_data: AvatarPropertiesReply_PropertiesData,
}


pub struct AvatarInterestsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

pub struct AvatarInterestsReply_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}

pub struct AvatarInterestsReply {
    pub agent_data: AvatarInterestsReply_AgentData,
    pub properties_data: AvatarInterestsReply_PropertiesData,
}


pub struct AvatarGroupsReply_AgentData {
    pub agent_id: Uuid,
    pub avatar_id: Uuid,
}

pub struct AvatarGroupsReply_GroupData {
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_title: Vec<u8>,
    pub group_id: Uuid,
    pub group_name: Vec<u8>,
    pub group_insignia_id: Uuid,
}

pub struct AvatarGroupsReply_NewGroupData {
    pub list_in_profile: bool,
}

pub struct AvatarGroupsReply {
    pub agent_data: AvatarGroupsReply_AgentData,
    pub group_data: Vec<AvatarGroupsReply_GroupData>,
    pub new_group_data: AvatarGroupsReply_NewGroupData,
}


pub struct AvatarPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AvatarPropertiesUpdate_PropertiesData {
    pub image_id: Uuid,
    pub fl_image_id: Uuid,
    pub about_text: Vec<u8>,
    pub fl_about_text: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub profile_url: Vec<u8>,
}

pub struct AvatarPropertiesUpdate {
    pub agent_data: AvatarPropertiesUpdate_AgentData,
    pub properties_data: AvatarPropertiesUpdate_PropertiesData,
}


pub struct AvatarInterestsUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AvatarInterestsUpdate_PropertiesData {
    pub want_to_mask: u32,
    pub want_to_text: Vec<u8>,
    pub skills_mask: u32,
    pub skills_text: Vec<u8>,
    pub languages_text: Vec<u8>,
}

pub struct AvatarInterestsUpdate {
    pub agent_data: AvatarInterestsUpdate_AgentData,
    pub properties_data: AvatarInterestsUpdate_PropertiesData,
}


pub struct AvatarNotesReply_AgentData {
    pub agent_id: Uuid,
}

pub struct AvatarNotesReply_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

pub struct AvatarNotesReply {
    pub agent_data: AvatarNotesReply_AgentData,
    pub data: AvatarNotesReply_Data,
}


pub struct AvatarNotesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AvatarNotesUpdate_Data {
    pub target_id: Uuid,
    pub notes: Vec<u8>,
}

pub struct AvatarNotesUpdate {
    pub agent_data: AvatarNotesUpdate_AgentData,
    pub data: AvatarNotesUpdate_Data,
}


pub struct AvatarPicksReply_AgentData {
    pub agent_id: Uuid,
    pub target_id: Uuid,
}

pub struct AvatarPicksReply_Data {
    pub pick_id: Uuid,
    pub pick_name: Vec<u8>,
}

pub struct AvatarPicksReply {
    pub agent_data: AvatarPicksReply_AgentData,
    pub data: Vec<AvatarPicksReply_Data>,
}


pub struct EventInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EventInfoRequest_EventData {
    pub event_id: u32,
}

pub struct EventInfoRequest {
    pub agent_data: EventInfoRequest_AgentData,
    pub event_data: EventInfoRequest_EventData,
}


pub struct EventInfoReply_AgentData {
    pub agent_id: Uuid,
}

pub struct EventInfoReply_EventData {
    pub event_id: u32,
    pub creator: Vec<u8>,
    pub name: Vec<u8>,
    pub category: Vec<u8>,
    pub desc: Vec<u8>,
    pub date: Vec<u8>,
    pub date_utc: u32,
    pub duration: u32,
    pub cover: u32,
    pub amount: u32,
    pub sim_name: Vec<u8>,
    pub global_pos: Vector3<f64>,
    pub event_flags: u32,
}

pub struct EventInfoReply {
    pub agent_data: EventInfoReply_AgentData,
    pub event_data: EventInfoReply_EventData,
}


pub struct EventNotificationAddRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EventNotificationAddRequest_EventData {
    pub event_id: u32,
}

pub struct EventNotificationAddRequest {
    pub agent_data: EventNotificationAddRequest_AgentData,
    pub event_data: EventNotificationAddRequest_EventData,
}


pub struct EventNotificationRemoveRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EventNotificationRemoveRequest_EventData {
    pub event_id: u32,
}

pub struct EventNotificationRemoveRequest {
    pub agent_data: EventNotificationRemoveRequest_AgentData,
    pub event_data: EventNotificationRemoveRequest_EventData,
}


pub struct EventGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EventGodDelete_EventData {
    pub event_id: u32,
}

pub struct EventGodDelete_QueryData {
    pub query_id: Uuid,
    pub query_text: Vec<u8>,
    pub query_flags: u32,
    pub query_start: i32,
}

pub struct EventGodDelete {
    pub agent_data: EventGodDelete_AgentData,
    pub event_data: EventGodDelete_EventData,
    pub query_data: EventGodDelete_QueryData,
}


pub struct PickInfoReply_AgentData {
    pub agent_id: Uuid,
}

pub struct PickInfoReply_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub user: Vec<u8>,
    pub original_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

pub struct PickInfoReply {
    pub agent_data: PickInfoReply_AgentData,
    pub data: PickInfoReply_Data,
}


pub struct PickInfoUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct PickInfoUpdate_Data {
    pub pick_id: Uuid,
    pub creator_id: Uuid,
    pub top_pick: bool,
    pub parcel_id: Uuid,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub snapshot_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub sort_order: i32,
    pub enabled: bool,
}

pub struct PickInfoUpdate {
    pub agent_data: PickInfoUpdate_AgentData,
    pub data: PickInfoUpdate_Data,
}


pub struct PickDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct PickDelete_Data {
    pub pick_id: Uuid,
}

pub struct PickDelete {
    pub agent_data: PickDelete_AgentData,
    pub data: PickDelete_Data,
}


pub struct PickGodDelete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct PickGodDelete_Data {
    pub pick_id: Uuid,
    pub query_id: Uuid,
}

pub struct PickGodDelete {
    pub agent_data: PickGodDelete_AgentData,
    pub data: PickGodDelete_Data,
}


pub struct ScriptQuestion_Data {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub object_name: Vec<u8>,
    pub object_owner: Vec<u8>,
    pub questions: i32,
}

pub struct ScriptQuestion {
    pub data: ScriptQuestion_Data,
}


pub struct ScriptControlChange_Data {
    pub take_controls: bool,
    pub controls: u32,
    pub pass_to_agent: bool,
}

pub struct ScriptControlChange {
    pub data: Vec<ScriptControlChange_Data>,
}


pub struct ScriptDialog_Data {
    pub object_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub object_name: Vec<u8>,
    pub message: Vec<u8>,
    pub chat_channel: i32,
    pub image_id: Uuid,
}

pub struct ScriptDialog_Buttons {
    pub button_label: Vec<u8>,
}

pub struct ScriptDialog_OwnerData {
    pub owner_id: Uuid,
}

pub struct ScriptDialog {
    pub data: ScriptDialog_Data,
    pub buttons: Vec<ScriptDialog_Buttons>,
    pub owner_data: Vec<ScriptDialog_OwnerData>,
}


pub struct ScriptDialogReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ScriptDialogReply_Data {
    pub object_id: Uuid,
    pub chat_channel: i32,
    pub button_index: i32,
    pub button_label: Vec<u8>,
}

pub struct ScriptDialogReply {
    pub agent_data: ScriptDialogReply_AgentData,
    pub data: ScriptDialogReply_Data,
}


pub struct ForceScriptControlRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ForceScriptControlRelease {
    pub agent_data: ForceScriptControlRelease_AgentData,
}


pub struct RevokePermissions_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RevokePermissions_Data {
    pub object_id: Uuid,
    pub object_permissions: u32,
}

pub struct RevokePermissions {
    pub agent_data: RevokePermissions_AgentData,
    pub data: RevokePermissions_Data,
}


pub struct LoadURL_Data {
    pub object_name: Vec<u8>,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub owner_is_group: bool,
    pub message: Vec<u8>,
    pub url: Vec<u8>,
}

pub struct LoadURL {
    pub data: LoadURL_Data,
}


pub struct ScriptTeleportRequest_Data {
    pub object_name: Vec<u8>,
    pub sim_name: Vec<u8>,
    pub sim_position: Vector3<f32>,
    pub look_at: Vector3<f32>,
}

pub struct ScriptTeleportRequest {
    pub data: ScriptTeleportRequest_Data,
}


pub struct ParcelOverlay_ParcelData {
    pub sequence_id: i32,
    pub data: Vec<u8>,
}

pub struct ParcelOverlay {
    pub parcel_data: ParcelOverlay_ParcelData,
}


pub struct ParcelPropertiesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelPropertiesRequest_ParcelData {
    pub sequence_id: i32,
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
    pub snap_selection: bool,
}

pub struct ParcelPropertiesRequest {
    pub agent_data: ParcelPropertiesRequest_AgentData,
    pub parcel_data: ParcelPropertiesRequest_ParcelData,
}


pub struct ParcelPropertiesRequestByID_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelPropertiesRequestByID_ParcelData {
    pub sequence_id: i32,
    pub local_id: i32,
}

pub struct ParcelPropertiesRequestByID {
    pub agent_data: ParcelPropertiesRequestByID_AgentData,
    pub parcel_data: ParcelPropertiesRequestByID_ParcelData,
}


pub struct ParcelProperties_ParcelData {
    pub request_result: i32,
    pub sequence_id: i32,
    pub snap_selection: bool,
    pub self_count: i32,
    pub other_count: i32,
    pub public_count: i32,
    pub local_id: i32,
    pub owner_id: Uuid,
    pub is_group_owned: bool,
    pub auction_id: u32,
    pub claim_date: i32,
    pub claim_price: i32,
    pub rent_price: i32,
    pub aabb_min: Vector3<f32>,
    pub aabb_max: Vector3<f32>,
    pub bitmap: Vec<u8>,
    pub area: i32,
    pub status: u8,
    pub sim_wide_max_prims: i32,
    pub sim_wide_total_prims: i32,
    pub max_prims: i32,
    pub total_prims: i32,
    pub owner_prims: i32,
    pub group_prims: i32,
    pub other_prims: i32,
    pub selected_prims: i32,
    pub parcel_prim_bonus: f32,
    pub other_clean_time: i32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
    pub region_push_override: bool,
    pub region_deny_anonymous: bool,
    pub region_deny_identified: bool,
    pub region_deny_transacted: bool,
}

pub struct ParcelProperties_AgeVerificationBlock {
    pub region_deny_age_unverified: bool,
}

pub struct ParcelProperties {
    pub parcel_data: ParcelProperties_ParcelData,
    pub age_verification_block: ParcelProperties_AgeVerificationBlock,
}


pub struct ParcelPropertiesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelPropertiesUpdate_ParcelData {
    pub local_id: i32,
    pub flags: u32,
    pub parcel_flags: u32,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub desc: Vec<u8>,
    pub music_url: Vec<u8>,
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
    pub group_id: Uuid,
    pub pass_price: i32,
    pub pass_hours: f32,
    pub category: u8,
    pub auth_buyer_id: Uuid,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub user_look_at: Vector3<f32>,
    pub landing_type: u8,
}

pub struct ParcelPropertiesUpdate {
    pub agent_data: ParcelPropertiesUpdate_AgentData,
    pub parcel_data: ParcelPropertiesUpdate_ParcelData,
}


pub struct ParcelReturnObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelReturnObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

pub struct ParcelReturnObjects_TaskIDs {
    pub task_id: Uuid,
}

pub struct ParcelReturnObjects_OwnerIDs {
    pub owner_id: Uuid,
}

pub struct ParcelReturnObjects {
    pub agent_data: ParcelReturnObjects_AgentData,
    pub parcel_data: ParcelReturnObjects_ParcelData,
    pub task_i_ds: Vec<ParcelReturnObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelReturnObjects_OwnerIDs>,
}


pub struct ParcelSetOtherCleanTime_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelSetOtherCleanTime_ParcelData {
    pub local_id: i32,
    pub other_clean_time: i32,
}

pub struct ParcelSetOtherCleanTime {
    pub agent_data: ParcelSetOtherCleanTime_AgentData,
    pub parcel_data: ParcelSetOtherCleanTime_ParcelData,
}


pub struct ParcelDisableObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelDisableObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

pub struct ParcelDisableObjects_TaskIDs {
    pub task_id: Uuid,
}

pub struct ParcelDisableObjects_OwnerIDs {
    pub owner_id: Uuid,
}

pub struct ParcelDisableObjects {
    pub agent_data: ParcelDisableObjects_AgentData,
    pub parcel_data: ParcelDisableObjects_ParcelData,
    pub task_i_ds: Vec<ParcelDisableObjects_TaskIDs>,
    pub owner_i_ds: Vec<ParcelDisableObjects_OwnerIDs>,
}


pub struct ParcelSelectObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelSelectObjects_ParcelData {
    pub local_id: i32,
    pub return_type: u32,
}

pub struct ParcelSelectObjects_ReturnIDs {
    pub return_id: Uuid,
}

pub struct ParcelSelectObjects {
    pub agent_data: ParcelSelectObjects_AgentData,
    pub parcel_data: ParcelSelectObjects_ParcelData,
    pub return_i_ds: Vec<ParcelSelectObjects_ReturnIDs>,
}


pub struct EstateCovenantRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EstateCovenantRequest {
    pub agent_data: EstateCovenantRequest_AgentData,
}


pub struct EstateCovenantReply_Data {
    pub covenant_id: Uuid,
    pub covenant_timestamp: u32,
    pub estate_name: Vec<u8>,
    pub estate_owner_id: Uuid,
}

pub struct EstateCovenantReply {
    pub data: EstateCovenantReply_Data,
}


pub struct ForceObjectSelect_Header {
    pub reset_list: bool,
}

pub struct ForceObjectSelect_Data {
    pub local_id: u32,
}

pub struct ForceObjectSelect {
    pub header: ForceObjectSelect_Header,
    pub data: Vec<ForceObjectSelect_Data>,
}


pub struct ParcelBuyPass_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelBuyPass_ParcelData {
    pub local_id: i32,
}

pub struct ParcelBuyPass {
    pub agent_data: ParcelBuyPass_AgentData,
    pub parcel_data: ParcelBuyPass_ParcelData,
}


pub struct ParcelDeedToGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelDeedToGroup_Data {
    pub group_id: Uuid,
    pub local_id: i32,
}

pub struct ParcelDeedToGroup {
    pub agent_data: ParcelDeedToGroup_AgentData,
    pub data: ParcelDeedToGroup_Data,
}


pub struct ParcelReclaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelReclaim_Data {
    pub local_id: i32,
}

pub struct ParcelReclaim {
    pub agent_data: ParcelReclaim_AgentData,
    pub data: ParcelReclaim_Data,
}


pub struct ParcelClaim_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelClaim_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub final_: bool,
}

pub struct ParcelClaim_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

pub struct ParcelClaim {
    pub agent_data: ParcelClaim_AgentData,
    pub data: ParcelClaim_Data,
    pub parcel_data: Vec<ParcelClaim_ParcelData>,
}


pub struct ParcelJoin_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelJoin_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

pub struct ParcelJoin {
    pub agent_data: ParcelJoin_AgentData,
    pub parcel_data: ParcelJoin_ParcelData,
}


pub struct ParcelDivide_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelDivide_ParcelData {
    pub west: f32,
    pub south: f32,
    pub east: f32,
    pub north: f32,
}

pub struct ParcelDivide {
    pub agent_data: ParcelDivide_AgentData,
    pub parcel_data: ParcelDivide_ParcelData,
}


pub struct ParcelRelease_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelRelease_Data {
    pub local_id: i32,
}

pub struct ParcelRelease {
    pub agent_data: ParcelRelease_AgentData,
    pub data: ParcelRelease_Data,
}


pub struct ParcelBuy_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelBuy_Data {
    pub group_id: Uuid,
    pub is_group_owned: bool,
    pub remove_contribution: bool,
    pub local_id: i32,
    pub final_: bool,
}

pub struct ParcelBuy_ParcelData {
    pub price: i32,
    pub area: i32,
}

pub struct ParcelBuy {
    pub agent_data: ParcelBuy_AgentData,
    pub data: ParcelBuy_Data,
    pub parcel_data: ParcelBuy_ParcelData,
}


pub struct ParcelGodForceOwner_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelGodForceOwner_Data {
    pub owner_id: Uuid,
    pub local_id: i32,
}

pub struct ParcelGodForceOwner {
    pub agent_data: ParcelGodForceOwner_AgentData,
    pub data: ParcelGodForceOwner_Data,
}


pub struct ParcelAccessListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelAccessListRequest_Data {
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

pub struct ParcelAccessListRequest {
    pub agent_data: ParcelAccessListRequest_AgentData,
    pub data: ParcelAccessListRequest_Data,
}


pub struct ParcelAccessListReply_Data {
    pub agent_id: Uuid,
    pub sequence_id: i32,
    pub flags: u32,
    pub local_id: i32,
}

pub struct ParcelAccessListReply_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

pub struct ParcelAccessListReply {
    pub data: ParcelAccessListReply_Data,
    pub list: Vec<ParcelAccessListReply_List>,
}


pub struct ParcelAccessListUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelAccessListUpdate_Data {
    pub flags: u32,
    pub local_id: i32,
    pub transaction_id: Uuid,
    pub sequence_id: i32,
    pub sections: i32,
}

pub struct ParcelAccessListUpdate_List {
    pub id: Uuid,
    pub time: i32,
    pub flags: u32,
}

pub struct ParcelAccessListUpdate {
    pub agent_data: ParcelAccessListUpdate_AgentData,
    pub data: ParcelAccessListUpdate_Data,
    pub list: Vec<ParcelAccessListUpdate_List>,
}


pub struct ParcelDwellRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelDwellRequest_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
}

pub struct ParcelDwellRequest {
    pub agent_data: ParcelDwellRequest_AgentData,
    pub data: ParcelDwellRequest_Data,
}


pub struct ParcelDwellReply_AgentData {
    pub agent_id: Uuid,
}

pub struct ParcelDwellReply_Data {
    pub local_id: i32,
    pub parcel_id: Uuid,
    pub dwell: f32,
}

pub struct ParcelDwellReply {
    pub agent_data: ParcelDwellReply_AgentData,
    pub data: ParcelDwellReply_Data,
}


pub struct RequestParcelTransfer_Data {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub owner_id: Uuid,
    pub flags: u8,
    pub transaction_type: i32,
    pub amount: i32,
    pub billable_area: i32,
    pub actual_area: i32,
    pub final_: bool,
}

pub struct RequestParcelTransfer_RegionData {
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
}

pub struct RequestParcelTransfer {
    pub data: RequestParcelTransfer_Data,
    pub region_data: RequestParcelTransfer_RegionData,
}


pub struct UpdateParcel_ParcelData {
    pub parcel_id: Uuid,
    pub region_handle: u64,
    pub owner_id: Uuid,
    pub group_owned: bool,
    pub status: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub music_url: Vec<u8>,
    pub region_x: f32,
    pub region_y: f32,
    pub actual_area: i32,
    pub billable_area: i32,
    pub show_dir: bool,
    pub is_for_sale: bool,
    pub category: u8,
    pub snapshot_id: Uuid,
    pub user_location: Vector3<f32>,
    pub sale_price: i32,
    pub authorized_buyer_id: Uuid,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

pub struct UpdateParcel {
    pub parcel_data: UpdateParcel_ParcelData,
}


pub struct RemoveParcel_ParcelData {
    pub parcel_id: Uuid,
}

pub struct RemoveParcel {
    pub parcel_data: Vec<RemoveParcel_ParcelData>,
}


pub struct MergeParcel_MasterParcelData {
    pub master_id: Uuid,
}

pub struct MergeParcel_SlaveParcelData {
    pub slave_id: Uuid,
}

pub struct MergeParcel {
    pub master_parcel_data: MergeParcel_MasterParcelData,
    pub slave_parcel_data: Vec<MergeParcel_SlaveParcelData>,
}


pub struct LogParcelChanges_AgentData {
    pub agent_id: Uuid,
}

pub struct LogParcelChanges_RegionData {
    pub region_handle: u64,
}

pub struct LogParcelChanges_ParcelData {
    pub parcel_id: Uuid,
    pub owner_id: Uuid,
    pub is_owner_group: bool,
    pub actual_area: i32,
    pub action: i8,
    pub transaction_id: Uuid,
}

pub struct LogParcelChanges {
    pub agent_data: LogParcelChanges_AgentData,
    pub region_data: LogParcelChanges_RegionData,
    pub parcel_data: Vec<LogParcelChanges_ParcelData>,
}


pub struct CheckParcelSales_RegionData {
    pub region_handle: u64,
}

pub struct CheckParcelSales {
    pub region_data: Vec<CheckParcelSales_RegionData>,
}


pub struct ParcelSales_ParcelData {
    pub parcel_id: Uuid,
    pub buyer_id: Uuid,
}

pub struct ParcelSales {
    pub parcel_data: Vec<ParcelSales_ParcelData>,
}


pub struct ParcelGodMarkAsContent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ParcelGodMarkAsContent_ParcelData {
    pub local_id: i32,
}

pub struct ParcelGodMarkAsContent {
    pub agent_data: ParcelGodMarkAsContent_AgentData,
    pub parcel_data: ParcelGodMarkAsContent_ParcelData,
}


pub struct ViewerStartAuction_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ViewerStartAuction_ParcelData {
    pub local_id: i32,
    pub snapshot_id: Uuid,
}

pub struct ViewerStartAuction {
    pub agent_data: ViewerStartAuction_AgentData,
    pub parcel_data: ViewerStartAuction_ParcelData,
}


pub struct StartAuction_AgentData {
    pub agent_id: Uuid,
}

pub struct StartAuction_ParcelData {
    pub parcel_id: Uuid,
    pub snapshot_id: Uuid,
    pub name: Vec<u8>,
}

pub struct StartAuction {
    pub agent_data: StartAuction_AgentData,
    pub parcel_data: StartAuction_ParcelData,
}


pub struct ConfirmAuctionStart_AuctionData {
    pub parcel_id: Uuid,
    pub auction_id: u32,
}

pub struct ConfirmAuctionStart {
    pub auction_data: ConfirmAuctionStart_AuctionData,
}


pub struct CompleteAuction_ParcelData {
    pub parcel_id: Uuid,
}

pub struct CompleteAuction {
    pub parcel_data: Vec<CompleteAuction_ParcelData>,
}


pub struct CancelAuction_ParcelData {
    pub parcel_id: Uuid,
}

pub struct CancelAuction {
    pub parcel_data: Vec<CancelAuction_ParcelData>,
}


pub struct CheckParcelAuctions_RegionData {
    pub region_handle: u64,
}

pub struct CheckParcelAuctions {
    pub region_data: Vec<CheckParcelAuctions_RegionData>,
}


pub struct ParcelAuctions_ParcelData {
    pub parcel_id: Uuid,
    pub winner_id: Uuid,
}

pub struct ParcelAuctions {
    pub parcel_data: Vec<ParcelAuctions_ParcelData>,
}


pub struct UUIDNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

pub struct UUIDNameRequest {
    pub uuid_name_block: Vec<UUIDNameRequest_UUIDNameBlock>,
}


pub struct UUIDNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
}

pub struct UUIDNameReply {
    pub uuid_name_block: Vec<UUIDNameReply_UUIDNameBlock>,
}


pub struct UUIDGroupNameRequest_UUIDNameBlock {
    pub id: Uuid,
}

pub struct UUIDGroupNameRequest {
    pub uuid_name_block: Vec<UUIDGroupNameRequest_UUIDNameBlock>,
}


pub struct UUIDGroupNameReply_UUIDNameBlock {
    pub id: Uuid,
    pub group_name: Vec<u8>,
}

pub struct UUIDGroupNameReply {
    pub uuid_name_block: Vec<UUIDGroupNameReply_UUIDNameBlock>,
}


pub struct ChatPass_ChatData {
    pub channel: i32,
    pub position: Vector3<f32>,
    pub id: Uuid,
    pub owner_id: Uuid,
    pub name: Vec<u8>,
    pub source_type: u8,
    pub type_: u8,
    pub radius: f32,
    pub sim_access: u8,
    pub message: Vec<u8>,
}

pub struct ChatPass {
    pub chat_data: ChatPass_ChatData,
}


pub struct EdgeDataPacket_EdgeData {
    pub layer_type: u8,
    pub direction: u8,
    pub layer_data: Vec<u8>,
}

pub struct EdgeDataPacket {
    pub edge_data: EdgeDataPacket_EdgeData,
}


pub struct SimStatus_SimStatus {
    pub can_accept_agents: bool,
    pub can_accept_tasks: bool,
}

pub struct SimStatus {
    pub sim_status: SimStatus_SimStatus,
}


pub struct ChildAgentUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
    pub far: f32,
    pub aspect: f32,
    pub throttles: Vec<u8>,
    pub locomotion_state: u32,
    pub head_rotation: Quaternion<f32>,
    pub body_rotation: Quaternion<f32>,
    pub control_flags: u32,
    pub energy_level: f32,
    pub god_level: u8,
    pub always_run: bool,
    pub prey_agent: Uuid,
    pub agent_access: u8,
    pub agent_textures: Vec<u8>,
    pub active_group_id: Uuid,
}

pub struct ChildAgentUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
}

pub struct ChildAgentUpdate_AnimationData {
    pub animation: Uuid,
    pub object_id: Uuid,
}

pub struct ChildAgentUpdate_GranterBlock {
    pub granter_id: Uuid,
}

pub struct ChildAgentUpdate_NVPairData {
    pub nv_pairs: Vec<u8>,
}

pub struct ChildAgentUpdate_VisualParam {
    pub param_value: u8,
}

pub struct ChildAgentUpdate_AgentAccess {
    pub agent_legacy_access: u8,
    pub agent_max_access: u8,
}

pub struct ChildAgentUpdate_AgentInfo {
    pub flags: u32,
}

pub struct ChildAgentUpdate {
    pub agent_data: ChildAgentUpdate_AgentData,
    pub group_data: Vec<ChildAgentUpdate_GroupData>,
    pub animation_data: Vec<ChildAgentUpdate_AnimationData>,
    pub granter_block: Vec<ChildAgentUpdate_GranterBlock>,
    pub nv_pair_data: Vec<ChildAgentUpdate_NVPairData>,
    pub visual_param: Vec<ChildAgentUpdate_VisualParam>,
    pub agent_access: Vec<ChildAgentUpdate_AgentAccess>,
    pub agent_info: Vec<ChildAgentUpdate_AgentInfo>,
}


pub struct ChildAgentAlive_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ChildAgentAlive {
    pub agent_data: ChildAgentAlive_AgentData,
}


pub struct ChildAgentPositionUpdate_AgentData {
    pub region_handle: u64,
    pub viewer_circuit_code: u32,
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub agent_pos: Vector3<f32>,
    pub agent_vel: Vector3<f32>,
    pub center: Vector3<f32>,
    pub size: Vector3<f32>,
    pub at_axis: Vector3<f32>,
    pub left_axis: Vector3<f32>,
    pub up_axis: Vector3<f32>,
    pub changed_grid: bool,
}

pub struct ChildAgentPositionUpdate {
    pub agent_data: ChildAgentPositionUpdate_AgentData,
}


pub struct ChildAgentDying_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ChildAgentDying {
    pub agent_data: ChildAgentDying_AgentData,
}


pub struct ChildAgentUnknown_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ChildAgentUnknown {
    pub agent_data: ChildAgentUnknown_AgentData,
}


pub struct AtomicPassObject_TaskData {
    pub task_id: Uuid,
    pub attachment_needs_save: bool,
}

pub struct AtomicPassObject {
    pub task_data: AtomicPassObject_TaskData,
}


pub struct KillChildAgents_IDBlock {
    pub agent_id: Uuid,
}

pub struct KillChildAgents {
    pub id_block: KillChildAgents_IDBlock,
}


pub struct GetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

pub struct GetScriptRunning {
    pub script: GetScriptRunning_Script,
}


pub struct ScriptRunningReply_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

pub struct ScriptRunningReply {
    pub script: ScriptRunningReply_Script,
}


pub struct SetScriptRunning_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct SetScriptRunning_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
    pub running: bool,
}

pub struct SetScriptRunning {
    pub agent_data: SetScriptRunning_AgentData,
    pub script: SetScriptRunning_Script,
}


pub struct ScriptReset_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ScriptReset_Script {
    pub object_id: Uuid,
    pub item_id: Uuid,
}

pub struct ScriptReset {
    pub agent_data: ScriptReset_AgentData,
    pub script: ScriptReset_Script,
}


pub struct ScriptSensorRequest_Requester {
    pub source_id: Uuid,
    pub request_id: Uuid,
    pub search_id: Uuid,
    pub search_pos: Vector3<f32>,
    pub search_dir: Quaternion<f32>,
    pub search_name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
    pub arc: f32,
    pub region_handle: u64,
    pub search_regions: u8,
}

pub struct ScriptSensorRequest {
    pub requester: ScriptSensorRequest_Requester,
}


pub struct ScriptSensorReply_Requester {
    pub source_id: Uuid,
}

pub struct ScriptSensorReply_SensedData {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub position: Vector3<f32>,
    pub velocity: Vector3<f32>,
    pub rotation: Quaternion<f32>,
    pub name: Vec<u8>,
    pub type_: i32,
    pub range: f32,
}

pub struct ScriptSensorReply {
    pub requester: ScriptSensorReply_Requester,
    pub sensed_data: Vec<ScriptSensorReply_SensedData>,
}


pub struct CompleteAgentMovement_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub circuit_code: u32,
}

pub struct CompleteAgentMovement {
    pub agent_data: CompleteAgentMovement_AgentData,
}


pub struct AgentMovementComplete_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentMovementComplete_Data {
    pub position: Vector3<f32>,
    pub look_at: Vector3<f32>,
    pub region_handle: u64,
    pub timestamp: u32,
}

pub struct AgentMovementComplete_SimData {
    pub channel_version: Vec<u8>,
}

pub struct AgentMovementComplete {
    pub agent_data: AgentMovementComplete_AgentData,
    pub data: AgentMovementComplete_Data,
    pub sim_data: AgentMovementComplete_SimData,
}


pub struct DataServerLogout_UserData {
    pub agent_id: Uuid,
    pub viewer_ip: Ip4Addr,
    pub disconnect: bool,
    pub session_id: Uuid,
}

pub struct DataServerLogout {
    pub user_data: DataServerLogout_UserData,
}


pub struct LogoutRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct LogoutRequest {
    pub agent_data: LogoutRequest_AgentData,
}


pub struct LogoutReply_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct LogoutReply_InventoryData {
    pub item_id: Uuid,
}

pub struct LogoutReply {
    pub agent_data: LogoutReply_AgentData,
    pub inventory_data: Vec<LogoutReply_InventoryData>,
}


pub struct ImprovedInstantMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ImprovedInstantMessage_MessageBlock {
    pub from_group: bool,
    pub to_agent_id: Uuid,
    pub parent_estate_id: u32,
    pub region_id: Uuid,
    pub position: Vector3<f32>,
    pub offline: u8,
    pub dialog: u8,
    pub id: Uuid,
    pub timestamp: u32,
    pub from_agent_name: Vec<u8>,
    pub message: Vec<u8>,
    pub binary_bucket: Vec<u8>,
}

pub struct ImprovedInstantMessage {
    pub agent_data: ImprovedInstantMessage_AgentData,
    pub message_block: ImprovedInstantMessage_MessageBlock,
}


pub struct RetrieveInstantMessages_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RetrieveInstantMessages {
    pub agent_data: RetrieveInstantMessages_AgentData,
}


pub struct FindAgent_AgentBlock {
    pub hunter: Uuid,
    pub prey: Uuid,
    pub space_ip: Ip4Addr,
}

pub struct FindAgent_LocationBlock {
    pub global_x: f64,
    pub global_y: f64,
}

pub struct FindAgent {
    pub agent_block: FindAgent_AgentBlock,
    pub location_block: Vec<FindAgent_LocationBlock>,
}


pub struct RequestGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestGodlikePowers_RequestBlock {
    pub godlike: bool,
    pub token: Uuid,
}

pub struct RequestGodlikePowers {
    pub agent_data: RequestGodlikePowers_AgentData,
    pub request_block: RequestGodlikePowers_RequestBlock,
}


pub struct GrantGodlikePowers_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GrantGodlikePowers_GrantData {
    pub god_level: u8,
    pub token: Uuid,
}

pub struct GrantGodlikePowers {
    pub agent_data: GrantGodlikePowers_AgentData,
    pub grant_data: GrantGodlikePowers_GrantData,
}


pub struct GodlikeMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct GodlikeMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

pub struct GodlikeMessage_ParamList {
    pub parameter: Vec<u8>,
}

pub struct GodlikeMessage {
    pub agent_data: GodlikeMessage_AgentData,
    pub method_data: GodlikeMessage_MethodData,
    pub param_list: Vec<GodlikeMessage_ParamList>,
}


pub struct EstateOwnerMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct EstateOwnerMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

pub struct EstateOwnerMessage_ParamList {
    pub parameter: Vec<u8>,
}

pub struct EstateOwnerMessage {
    pub agent_data: EstateOwnerMessage_AgentData,
    pub method_data: EstateOwnerMessage_MethodData,
    pub param_list: Vec<EstateOwnerMessage_ParamList>,
}


pub struct GenericMessage_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct GenericMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
}

pub struct GenericMessage_ParamList {
    pub parameter: Vec<u8>,
}

pub struct GenericMessage {
    pub agent_data: GenericMessage_AgentData,
    pub method_data: GenericMessage_MethodData,
    pub param_list: Vec<GenericMessage_ParamList>,
}


pub struct MuteListRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct MuteListRequest_MuteData {
    pub mute_crc: u32,
}

pub struct MuteListRequest {
    pub agent_data: MuteListRequest_AgentData,
    pub mute_data: MuteListRequest_MuteData,
}


pub struct UpdateMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
    pub mute_type: i32,
    pub mute_flags: u32,
}

pub struct UpdateMuteListEntry {
    pub agent_data: UpdateMuteListEntry_AgentData,
    pub mute_data: UpdateMuteListEntry_MuteData,
}


pub struct RemoveMuteListEntry_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveMuteListEntry_MuteData {
    pub mute_id: Uuid,
    pub mute_name: Vec<u8>,
}

pub struct RemoveMuteListEntry {
    pub agent_data: RemoveMuteListEntry_AgentData,
    pub mute_data: RemoveMuteListEntry_MuteData,
}


pub struct CopyInventoryFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CopyInventoryFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

pub struct CopyInventoryFromNotecard_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
}

pub struct CopyInventoryFromNotecard {
    pub agent_data: CopyInventoryFromNotecard_AgentData,
    pub notecard_data: CopyInventoryFromNotecard_NotecardData,
    pub inventory_data: Vec<CopyInventoryFromNotecard_InventoryData>,
}


pub struct UpdateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct UpdateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct UpdateInventoryItem {
    pub agent_data: UpdateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateInventoryItem_InventoryData>,
}


pub struct UpdateCreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub sim_approved: bool,
    pub transaction_id: Uuid,
}

pub struct UpdateCreateInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub callback_id: u32,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct UpdateCreateInventoryItem {
    pub agent_data: UpdateCreateInventoryItem_AgentData,
    pub inventory_data: Vec<UpdateCreateInventoryItem_InventoryData>,
}


pub struct MoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

pub struct MoveInventoryItem_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub new_name: Vec<u8>,
}

pub struct MoveInventoryItem {
    pub agent_data: MoveInventoryItem_AgentData,
    pub inventory_data: Vec<MoveInventoryItem_InventoryData>,
}


pub struct CopyInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CopyInventoryItem_InventoryData {
    pub callback_id: u32,
    pub old_agent_id: Uuid,
    pub old_item_id: Uuid,
    pub new_folder_id: Uuid,
    pub new_name: Vec<u8>,
}

pub struct CopyInventoryItem {
    pub agent_data: CopyInventoryItem_AgentData,
    pub inventory_data: Vec<CopyInventoryItem_InventoryData>,
}


pub struct RemoveInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveInventoryItem_InventoryData {
    pub item_id: Uuid,
}

pub struct RemoveInventoryItem {
    pub agent_data: RemoveInventoryItem_AgentData,
    pub inventory_data: Vec<RemoveInventoryItem_InventoryData>,
}


pub struct ChangeInventoryItemFlags_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ChangeInventoryItemFlags_InventoryData {
    pub item_id: Uuid,
    pub flags: u32,
}

pub struct ChangeInventoryItemFlags {
    pub agent_data: ChangeInventoryItemFlags_AgentData,
    pub inventory_data: Vec<ChangeInventoryItemFlags_InventoryData>,
}


pub struct SaveAssetIntoInventory_AgentData {
    pub agent_id: Uuid,
}

pub struct SaveAssetIntoInventory_InventoryData {
    pub item_id: Uuid,
    pub new_asset_id: Uuid,
}

pub struct SaveAssetIntoInventory {
    pub agent_data: SaveAssetIntoInventory_AgentData,
    pub inventory_data: SaveAssetIntoInventory_InventoryData,
}


pub struct CreateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CreateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

pub struct CreateInventoryFolder {
    pub agent_data: CreateInventoryFolder_AgentData,
    pub folder_data: CreateInventoryFolder_FolderData,
}


pub struct UpdateInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateInventoryFolder_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

pub struct UpdateInventoryFolder {
    pub agent_data: UpdateInventoryFolder_AgentData,
    pub folder_data: Vec<UpdateInventoryFolder_FolderData>,
}


pub struct MoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub stamp: bool,
}

pub struct MoveInventoryFolder_InventoryData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
}

pub struct MoveInventoryFolder {
    pub agent_data: MoveInventoryFolder_AgentData,
    pub inventory_data: Vec<MoveInventoryFolder_InventoryData>,
}


pub struct RemoveInventoryFolder_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveInventoryFolder_FolderData {
    pub folder_id: Uuid,
}

pub struct RemoveInventoryFolder {
    pub agent_data: RemoveInventoryFolder_AgentData,
    pub folder_data: Vec<RemoveInventoryFolder_FolderData>,
}


pub struct FetchInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct FetchInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub sort_order: i32,
    pub fetch_folders: bool,
    pub fetch_items: bool,
}

pub struct FetchInventoryDescendents {
    pub agent_data: FetchInventoryDescendents_AgentData,
    pub inventory_data: FetchInventoryDescendents_InventoryData,
}


pub struct InventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub folder_id: Uuid,
    pub owner_id: Uuid,
    pub version: i32,
    pub descendents: i32,
}

pub struct InventoryDescendents_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

pub struct InventoryDescendents_ItemData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct InventoryDescendents {
    pub agent_data: InventoryDescendents_AgentData,
    pub folder_data: Vec<InventoryDescendents_FolderData>,
    pub item_data: Vec<InventoryDescendents_ItemData>,
}


pub struct FetchInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct FetchInventory_InventoryData {
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

pub struct FetchInventory {
    pub agent_data: FetchInventory_AgentData,
    pub inventory_data: Vec<FetchInventory_InventoryData>,
}


pub struct FetchInventoryReply_AgentData {
    pub agent_id: Uuid,
}

pub struct FetchInventoryReply_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct FetchInventoryReply {
    pub agent_data: FetchInventoryReply_AgentData,
    pub inventory_data: Vec<FetchInventoryReply_InventoryData>,
}


pub struct BulkUpdateInventory_AgentData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct BulkUpdateInventory_FolderData {
    pub folder_id: Uuid,
    pub parent_id: Uuid,
    pub type_: i8,
    pub name: Vec<u8>,
}

pub struct BulkUpdateInventory_ItemData {
    pub item_id: Uuid,
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct BulkUpdateInventory {
    pub agent_data: BulkUpdateInventory_AgentData,
    pub folder_data: Vec<BulkUpdateInventory_FolderData>,
    pub item_data: Vec<BulkUpdateInventory_ItemData>,
}


pub struct RequestInventoryAsset_QueryData {
    pub query_id: Uuid,
    pub agent_id: Uuid,
    pub owner_id: Uuid,
    pub item_id: Uuid,
}

pub struct RequestInventoryAsset {
    pub query_data: RequestInventoryAsset_QueryData,
}


pub struct InventoryAssetResponse_QueryData {
    pub query_id: Uuid,
    pub asset_id: Uuid,
    pub is_readable: bool,
}

pub struct InventoryAssetResponse {
    pub query_data: InventoryAssetResponse_QueryData,
}


pub struct RemoveInventoryObjects_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveInventoryObjects_FolderData {
    pub folder_id: Uuid,
}

pub struct RemoveInventoryObjects_ItemData {
    pub item_id: Uuid,
}

pub struct RemoveInventoryObjects {
    pub agent_data: RemoveInventoryObjects_AgentData,
    pub folder_data: Vec<RemoveInventoryObjects_FolderData>,
    pub item_data: Vec<RemoveInventoryObjects_ItemData>,
}


pub struct PurgeInventoryDescendents_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct PurgeInventoryDescendents_InventoryData {
    pub folder_id: Uuid,
}

pub struct PurgeInventoryDescendents {
    pub agent_data: PurgeInventoryDescendents_AgentData,
    pub inventory_data: PurgeInventoryDescendents_InventoryData,
}


pub struct UpdateTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateTaskInventory_UpdateData {
    pub local_id: u32,
    pub key: u8,
}

pub struct UpdateTaskInventory_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct UpdateTaskInventory {
    pub agent_data: UpdateTaskInventory_AgentData,
    pub update_data: UpdateTaskInventory_UpdateData,
    pub inventory_data: UpdateTaskInventory_InventoryData,
}


pub struct RemoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}

pub struct RemoveTaskInventory {
    pub agent_data: RemoveTaskInventory_AgentData,
    pub inventory_data: RemoveTaskInventory_InventoryData,
}


pub struct MoveTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub folder_id: Uuid,
}

pub struct MoveTaskInventory_InventoryData {
    pub local_id: u32,
    pub item_id: Uuid,
}

pub struct MoveTaskInventory {
    pub agent_data: MoveTaskInventory_AgentData,
    pub inventory_data: MoveTaskInventory_InventoryData,
}


pub struct RequestTaskInventory_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RequestTaskInventory_InventoryData {
    pub local_id: u32,
}

pub struct RequestTaskInventory {
    pub agent_data: RequestTaskInventory_AgentData,
    pub inventory_data: RequestTaskInventory_InventoryData,
}


pub struct ReplyTaskInventory_InventoryData {
    pub task_id: Uuid,
    pub serial: i16,
    pub filename: Vec<u8>,
}

pub struct ReplyTaskInventory {
    pub inventory_data: ReplyTaskInventory_InventoryData,
}


pub struct DeRezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DeRezObject_AgentBlock {
    pub group_id: Uuid,
    pub destination: u8,
    pub destination_id: Uuid,
    pub transaction_id: Uuid,
    pub packet_count: u8,
    pub packet_number: u8,
}

pub struct DeRezObject_ObjectData {
    pub object_local_id: u32,
}

pub struct DeRezObject {
    pub agent_data: DeRezObject_AgentData,
    pub agent_block: DeRezObject_AgentBlock,
    pub object_data: Vec<DeRezObject_ObjectData>,
}


pub struct DeRezAck_TransactionData {
    pub transaction_id: Uuid,
    pub success: bool,
}

pub struct DeRezAck {
    pub transaction_data: DeRezAck_TransactionData,
}


pub struct RezObject_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct RezObject_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

pub struct RezObject_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct RezObject {
    pub agent_data: RezObject_AgentData,
    pub rez_data: RezObject_RezData,
    pub inventory_data: RezObject_InventoryData,
}


pub struct RezObjectFromNotecard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct RezObjectFromNotecard_RezData {
    pub from_task_id: Uuid,
    pub bypass_raycast: u8,
    pub ray_start: Vector3<f32>,
    pub ray_end: Vector3<f32>,
    pub ray_target_id: Uuid,
    pub ray_end_is_intersection: bool,
    pub rez_selected: bool,
    pub remove_item: bool,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
}

pub struct RezObjectFromNotecard_NotecardData {
    pub notecard_item_id: Uuid,
    pub object_id: Uuid,
}

pub struct RezObjectFromNotecard_InventoryData {
    pub item_id: Uuid,
}

pub struct RezObjectFromNotecard {
    pub agent_data: RezObjectFromNotecard_AgentData,
    pub rez_data: RezObjectFromNotecard_RezData,
    pub notecard_data: RezObjectFromNotecard_NotecardData,
    pub inventory_data: Vec<RezObjectFromNotecard_InventoryData>,
}


pub struct TransferInventory_InfoBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct TransferInventory_InventoryBlock {
    pub inventory_id: Uuid,
    pub type_: i8,
}

pub struct TransferInventory {
    pub info_block: TransferInventory_InfoBlock,
    pub inventory_block: Vec<TransferInventory_InventoryBlock>,
}


pub struct TransferInventoryAck_InfoBlock {
    pub transaction_id: Uuid,
    pub inventory_id: Uuid,
}

pub struct TransferInventoryAck {
    pub info_block: TransferInventoryAck_InfoBlock,
}


pub struct AcceptFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AcceptFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}

pub struct AcceptFriendship_FolderData {
    pub folder_id: Uuid,
}

pub struct AcceptFriendship {
    pub agent_data: AcceptFriendship_AgentData,
    pub transaction_block: AcceptFriendship_TransactionBlock,
    pub folder_data: Vec<AcceptFriendship_FolderData>,
}


pub struct DeclineFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DeclineFriendship_TransactionBlock {
    pub transaction_id: Uuid,
}

pub struct DeclineFriendship {
    pub agent_data: DeclineFriendship_AgentData,
    pub transaction_block: DeclineFriendship_TransactionBlock,
}


pub struct FormFriendship_AgentBlock {
    pub source_id: Uuid,
    pub dest_id: Uuid,
}

pub struct FormFriendship {
    pub agent_block: FormFriendship_AgentBlock,
}


pub struct TerminateFriendship_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct TerminateFriendship_ExBlock {
    pub other_id: Uuid,
}

pub struct TerminateFriendship {
    pub agent_data: TerminateFriendship_AgentData,
    pub ex_block: TerminateFriendship_ExBlock,
}


pub struct OfferCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct OfferCallingCard_AgentBlock {
    pub dest_id: Uuid,
    pub transaction_id: Uuid,
}

pub struct OfferCallingCard {
    pub agent_data: OfferCallingCard_AgentData,
    pub agent_block: OfferCallingCard_AgentBlock,
}


pub struct AcceptCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AcceptCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}

pub struct AcceptCallingCard_FolderData {
    pub folder_id: Uuid,
}

pub struct AcceptCallingCard {
    pub agent_data: AcceptCallingCard_AgentData,
    pub transaction_block: AcceptCallingCard_TransactionBlock,
    pub folder_data: Vec<AcceptCallingCard_FolderData>,
}


pub struct DeclineCallingCard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct DeclineCallingCard_TransactionBlock {
    pub transaction_id: Uuid,
}

pub struct DeclineCallingCard {
    pub agent_data: DeclineCallingCard_AgentData,
    pub transaction_block: DeclineCallingCard_TransactionBlock,
}


pub struct RezScript_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct RezScript_UpdateBlock {
    pub object_local_id: u32,
    pub enabled: bool,
}

pub struct RezScript_InventoryBlock {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct RezScript {
    pub agent_data: RezScript_AgentData,
    pub update_block: RezScript_UpdateBlock,
    pub inventory_block: RezScript_InventoryBlock,
}


pub struct CreateInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CreateInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub next_owner_mask: u32,
    pub type_: i8,
    pub inv_type: i8,
    pub wearable_type: u8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

pub struct CreateInventoryItem {
    pub agent_data: CreateInventoryItem_AgentData,
    pub inventory_block: CreateInventoryItem_InventoryBlock,
}


pub struct CreateLandmarkForEvent_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CreateLandmarkForEvent_EventData {
    pub event_id: u32,
}

pub struct CreateLandmarkForEvent_InventoryBlock {
    pub folder_id: Uuid,
    pub name: Vec<u8>,
}

pub struct CreateLandmarkForEvent {
    pub agent_data: CreateLandmarkForEvent_AgentData,
    pub event_data: CreateLandmarkForEvent_EventData,
    pub inventory_block: CreateLandmarkForEvent_InventoryBlock,
}


pub struct EventLocationRequest_QueryData {
    pub query_id: Uuid,
}

pub struct EventLocationRequest_EventData {
    pub event_id: u32,
}

pub struct EventLocationRequest {
    pub query_data: EventLocationRequest_QueryData,
    pub event_data: EventLocationRequest_EventData,
}


pub struct EventLocationReply_QueryData {
    pub query_id: Uuid,
}

pub struct EventLocationReply_EventData {
    pub success: bool,
    pub region_id: Uuid,
    pub region_pos: Vector3<f32>,
}

pub struct EventLocationReply {
    pub query_data: EventLocationReply_QueryData,
    pub event_data: EventLocationReply_EventData,
}


pub struct RegionHandleRequest_RequestBlock {
    pub region_id: Uuid,
}

pub struct RegionHandleRequest {
    pub request_block: RegionHandleRequest_RequestBlock,
}


pub struct RegionIDAndHandleReply_ReplyBlock {
    pub region_id: Uuid,
    pub region_handle: u64,
}

pub struct RegionIDAndHandleReply {
    pub reply_block: RegionIDAndHandleReply_ReplyBlock,
}


pub struct MoneyTransferRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct MoneyTransferRequest_MoneyData {
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub description: Vec<u8>,
}

pub struct MoneyTransferRequest {
    pub agent_data: MoneyTransferRequest_AgentData,
    pub money_data: MoneyTransferRequest_MoneyData,
}


pub struct MoneyTransferBackend_MoneyData {
    pub transaction_id: Uuid,
    pub transaction_time: u32,
    pub source_id: Uuid,
    pub dest_id: Uuid,
    pub flags: u8,
    pub amount: i32,
    pub aggregate_perm_next_owner: u8,
    pub aggregate_perm_inventory: u8,
    pub transaction_type: i32,
    pub region_id: Uuid,
    pub grid_x: u32,
    pub grid_y: u32,
    pub description: Vec<u8>,
}

pub struct MoneyTransferBackend {
    pub money_data: MoneyTransferBackend_MoneyData,
}


pub struct MoneyBalanceRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct MoneyBalanceRequest_MoneyData {
    pub transaction_id: Uuid,
}

pub struct MoneyBalanceRequest {
    pub agent_data: MoneyBalanceRequest_AgentData,
    pub money_data: MoneyBalanceRequest_MoneyData,
}


pub struct MoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

pub struct MoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

pub struct MoneyBalanceReply {
    pub money_data: MoneyBalanceReply_MoneyData,
    pub transaction_info: MoneyBalanceReply_TransactionInfo,
}


pub struct RoutedMoneyBalanceReply_TargetBlock {
    pub target_ip: Ip4Addr,
    pub target_port: Ip4Port,
}

pub struct RoutedMoneyBalanceReply_MoneyData {
    pub agent_id: Uuid,
    pub transaction_id: Uuid,
    pub transaction_success: bool,
    pub money_balance: i32,
    pub square_meters_credit: i32,
    pub square_meters_committed: i32,
    pub description: Vec<u8>,
}

pub struct RoutedMoneyBalanceReply_TransactionInfo {
    pub transaction_type: i32,
    pub source_id: Uuid,
    pub is_source_group: bool,
    pub dest_id: Uuid,
    pub is_dest_group: bool,
    pub amount: i32,
    pub item_description: Vec<u8>,
}

pub struct RoutedMoneyBalanceReply {
    pub target_block: RoutedMoneyBalanceReply_TargetBlock,
    pub money_data: RoutedMoneyBalanceReply_MoneyData,
    pub transaction_info: RoutedMoneyBalanceReply_TransactionInfo,
}


pub struct ActivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

pub struct ActivateGestures_Data {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub gesture_flags: u32,
}

pub struct ActivateGestures {
    pub agent_data: ActivateGestures_AgentData,
    pub data: Vec<ActivateGestures_Data>,
}


pub struct DeactivateGestures_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
}

pub struct DeactivateGestures_Data {
    pub item_id: Uuid,
    pub gesture_flags: u32,
}

pub struct DeactivateGestures {
    pub agent_data: DeactivateGestures_AgentData,
    pub data: Vec<DeactivateGestures_Data>,
}


pub struct MuteListUpdate_MuteData {
    pub agent_id: Uuid,
    pub filename: Vec<u8>,
}

pub struct MuteListUpdate {
    pub mute_data: MuteListUpdate_MuteData,
}


pub struct UseCachedMuteList_AgentData {
    pub agent_id: Uuid,
}

pub struct UseCachedMuteList {
    pub agent_data: UseCachedMuteList_AgentData,
}


pub struct GrantUserRights_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GrantUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

pub struct GrantUserRights {
    pub agent_data: GrantUserRights_AgentData,
    pub rights: Vec<GrantUserRights_Rights>,
}


pub struct ChangeUserRights_AgentData {
    pub agent_id: Uuid,
}

pub struct ChangeUserRights_Rights {
    pub agent_related: Uuid,
    pub related_rights: i32,
}

pub struct ChangeUserRights {
    pub agent_data: ChangeUserRights_AgentData,
    pub rights: Vec<ChangeUserRights_Rights>,
}


pub struct OnlineNotification_AgentBlock {
    pub agent_id: Uuid,
}

pub struct OnlineNotification {
    pub agent_block: Vec<OnlineNotification_AgentBlock>,
}


pub struct OfflineNotification_AgentBlock {
    pub agent_id: Uuid,
}

pub struct OfflineNotification {
    pub agent_block: Vec<OfflineNotification_AgentBlock>,
}


pub struct SetStartLocationRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct SetStartLocationRequest_StartLocationData {
    pub sim_name: Vec<u8>,
    pub location_id: u32,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

pub struct SetStartLocationRequest {
    pub agent_data: SetStartLocationRequest_AgentData,
    pub start_location_data: SetStartLocationRequest_StartLocationData,
}


pub struct SetStartLocation_StartLocationData {
    pub agent_id: Uuid,
    pub region_id: Uuid,
    pub location_id: u32,
    pub region_handle: u64,
    pub location_pos: Vector3<f32>,
    pub location_look_at: Vector3<f32>,
}

pub struct SetStartLocation {
    pub start_location_data: SetStartLocation_StartLocationData,
}


pub struct NetTest_NetBlock {
    pub port: Ip4Port,
}

pub struct NetTest {
    pub net_block: NetTest_NetBlock,
}


pub struct SetCPURatio_Data {
    pub ratio: u8,
}

pub struct SetCPURatio {
    pub data: SetCPURatio_Data,
}


pub struct SimCrashed_Data {
    pub region_x: u32,
    pub region_y: u32,
}

pub struct SimCrashed_Users {
    pub agent_id: Uuid,
}

pub struct SimCrashed {
    pub data: SimCrashed_Data,
    pub users: Vec<SimCrashed_Users>,
}


pub struct NameValuePair_TaskData {
    pub id: Uuid,
}

pub struct NameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

pub struct NameValuePair {
    pub task_data: NameValuePair_TaskData,
    pub name_value_data: Vec<NameValuePair_NameValueData>,
}


pub struct RemoveNameValuePair_TaskData {
    pub id: Uuid,
}

pub struct RemoveNameValuePair_NameValueData {
    pub nv_pair: Vec<u8>,
}

pub struct RemoveNameValuePair {
    pub task_data: RemoveNameValuePair_TaskData,
    pub name_value_data: Vec<RemoveNameValuePair_NameValueData>,
}


pub struct UpdateAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateAttachment_AttachmentBlock {
    pub attachment_point: u8,
}

pub struct UpdateAttachment_OperationData {
    pub add_item: bool,
    pub use_existing_asset: bool,
}

pub struct UpdateAttachment_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub asset_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct UpdateAttachment {
    pub agent_data: UpdateAttachment_AgentData,
    pub attachment_block: UpdateAttachment_AttachmentBlock,
    pub operation_data: UpdateAttachment_OperationData,
    pub inventory_data: UpdateAttachment_InventoryData,
}


pub struct RemoveAttachment_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RemoveAttachment_AttachmentBlock {
    pub attachment_point: u8,
    pub item_id: Uuid,
}

pub struct RemoveAttachment {
    pub agent_data: RemoveAttachment_AgentData,
    pub attachment_block: RemoveAttachment_AttachmentBlock,
}


pub struct SoundTrigger_SoundData {
    pub sound_id: Uuid,
    pub owner_id: Uuid,
    pub object_id: Uuid,
    pub parent_id: Uuid,
    pub handle: u64,
    pub position: Vector3<f32>,
    pub gain: f32,
}

pub struct SoundTrigger {
    pub sound_data: SoundTrigger_SoundData,
}


pub struct AttachedSound_DataBlock {
    pub sound_id: Uuid,
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub gain: f32,
    pub flags: u8,
}

pub struct AttachedSound {
    pub data_block: AttachedSound_DataBlock,
}


pub struct AttachedSoundGainChange_DataBlock {
    pub object_id: Uuid,
    pub gain: f32,
}

pub struct AttachedSoundGainChange {
    pub data_block: AttachedSoundGainChange_DataBlock,
}


pub struct PreloadSound_DataBlock {
    pub object_id: Uuid,
    pub owner_id: Uuid,
    pub sound_id: Uuid,
}

pub struct PreloadSound {
    pub data_block: Vec<PreloadSound_DataBlock>,
}


pub struct AssetUploadRequest_AssetBlock {
    pub transaction_id: Uuid,
    pub type_: i8,
    pub tempfile: bool,
    pub store_local: bool,
    pub asset_data: Vec<u8>,
}

pub struct AssetUploadRequest {
    pub asset_block: AssetUploadRequest_AssetBlock,
}


pub struct AssetUploadComplete_AssetBlock {
    pub uuid: Uuid,
    pub type_: i8,
    pub success: bool,
}

pub struct AssetUploadComplete {
    pub asset_block: AssetUploadComplete_AssetBlock,
}


pub struct EmailMessageRequest_DataBlock {
    pub object_id: Uuid,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
}

pub struct EmailMessageRequest {
    pub data_block: EmailMessageRequest_DataBlock,
}


pub struct EmailMessageReply_DataBlock {
    pub object_id: Uuid,
    pub more: u32,
    pub time: u32,
    pub from_address: Vec<u8>,
    pub subject: Vec<u8>,
    pub data: Vec<u8>,
    pub mail_filter: Vec<u8>,
}

pub struct EmailMessageReply {
    pub data_block: EmailMessageReply_DataBlock,
}


pub struct InternalScriptMail_DataBlock {
    pub from: Vec<u8>,
    pub to: Uuid,
    pub subject: Vec<u8>,
    pub body: Vec<u8>,
}

pub struct InternalScriptMail {
    pub data_block: InternalScriptMail_DataBlock,
}


pub struct ScriptDataRequest_DataBlock {
    pub hash: u64,
    pub request_type: i8,
    pub request: Vec<u8>,
}

pub struct ScriptDataRequest {
    pub data_block: Vec<ScriptDataRequest_DataBlock>,
}


pub struct ScriptDataReply_DataBlock {
    pub hash: u64,
    pub reply: Vec<u8>,
}

pub struct ScriptDataReply {
    pub data_block: Vec<ScriptDataReply_DataBlock>,
}


pub struct CreateGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CreateGroupRequest_GroupData {
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

pub struct CreateGroupRequest {
    pub agent_data: CreateGroupRequest_AgentData,
    pub group_data: CreateGroupRequest_GroupData,
}


pub struct CreateGroupReply_AgentData {
    pub agent_id: Uuid,
}

pub struct CreateGroupReply_ReplyData {
    pub group_id: Uuid,
    pub success: bool,
    pub message: Vec<u8>,
}

pub struct CreateGroupReply {
    pub agent_data: CreateGroupReply_AgentData,
    pub reply_data: CreateGroupReply_ReplyData,
}


pub struct UpdateGroupInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateGroupInfo_GroupData {
    pub group_id: Uuid,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub insignia_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

pub struct UpdateGroupInfo {
    pub agent_data: UpdateGroupInfo_AgentData,
    pub group_data: UpdateGroupInfo_GroupData,
}


pub struct GroupRoleChanges_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupRoleChanges_RoleChange {
    pub role_id: Uuid,
    pub member_id: Uuid,
    pub change: u32,
}

pub struct GroupRoleChanges {
    pub agent_data: GroupRoleChanges_AgentData,
    pub role_change: Vec<GroupRoleChanges_RoleChange>,
}


pub struct JoinGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct JoinGroupRequest_GroupData {
    pub group_id: Uuid,
}

pub struct JoinGroupRequest {
    pub agent_data: JoinGroupRequest_AgentData,
    pub group_data: JoinGroupRequest_GroupData,
}


pub struct JoinGroupReply_AgentData {
    pub agent_id: Uuid,
}

pub struct JoinGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

pub struct JoinGroupReply {
    pub agent_data: JoinGroupReply_AgentData,
    pub group_data: JoinGroupReply_GroupData,
}


pub struct EjectGroupMemberRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct EjectGroupMemberRequest_GroupData {
    pub group_id: Uuid,
}

pub struct EjectGroupMemberRequest_EjectData {
    pub ejectee_id: Uuid,
}

pub struct EjectGroupMemberRequest {
    pub agent_data: EjectGroupMemberRequest_AgentData,
    pub group_data: EjectGroupMemberRequest_GroupData,
    pub eject_data: Vec<EjectGroupMemberRequest_EjectData>,
}


pub struct EjectGroupMemberReply_AgentData {
    pub agent_id: Uuid,
}

pub struct EjectGroupMemberReply_GroupData {
    pub group_id: Uuid,
}

pub struct EjectGroupMemberReply_EjectData {
    pub success: bool,
}

pub struct EjectGroupMemberReply {
    pub agent_data: EjectGroupMemberReply_AgentData,
    pub group_data: EjectGroupMemberReply_GroupData,
    pub eject_data: EjectGroupMemberReply_EjectData,
}


pub struct LeaveGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct LeaveGroupRequest_GroupData {
    pub group_id: Uuid,
}

pub struct LeaveGroupRequest {
    pub agent_data: LeaveGroupRequest_AgentData,
    pub group_data: LeaveGroupRequest_GroupData,
}


pub struct LeaveGroupReply_AgentData {
    pub agent_id: Uuid,
}

pub struct LeaveGroupReply_GroupData {
    pub group_id: Uuid,
    pub success: bool,
}

pub struct LeaveGroupReply {
    pub agent_data: LeaveGroupReply_AgentData,
    pub group_data: LeaveGroupReply_GroupData,
}


pub struct InviteGroupRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct InviteGroupRequest_GroupData {
    pub group_id: Uuid,
}

pub struct InviteGroupRequest_InviteData {
    pub invitee_id: Uuid,
    pub role_id: Uuid,
}

pub struct InviteGroupRequest {
    pub agent_data: InviteGroupRequest_AgentData,
    pub group_data: InviteGroupRequest_GroupData,
    pub invite_data: Vec<InviteGroupRequest_InviteData>,
}


pub struct InviteGroupResponse_InviteData {
    pub agent_id: Uuid,
    pub invitee_id: Uuid,
    pub group_id: Uuid,
    pub role_id: Uuid,
    pub membership_fee: i32,
}

pub struct InviteGroupResponse {
    pub invite_data: InviteGroupResponse_InviteData,
}


pub struct GroupProfileRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupProfileRequest_GroupData {
    pub group_id: Uuid,
}

pub struct GroupProfileRequest {
    pub agent_data: GroupProfileRequest_AgentData,
    pub group_data: GroupProfileRequest_GroupData,
}


pub struct GroupProfileReply_AgentData {
    pub agent_id: Uuid,
}

pub struct GroupProfileReply_GroupData {
    pub group_id: Uuid,
    pub name: Vec<u8>,
    pub charter: Vec<u8>,
    pub show_in_list: bool,
    pub member_title: Vec<u8>,
    pub powers_mask: u64,
    pub insignia_id: Uuid,
    pub founder_id: Uuid,
    pub membership_fee: i32,
    pub open_enrollment: bool,
    pub money: i32,
    pub group_membership_count: i32,
    pub group_roles_count: i32,
    pub allow_publish: bool,
    pub mature_publish: bool,
    pub owner_role: Uuid,
}

pub struct GroupProfileReply {
    pub agent_data: GroupProfileReply_AgentData,
    pub group_data: GroupProfileReply_GroupData,
}


pub struct GroupAccountSummaryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountSummaryRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

pub struct GroupAccountSummaryRequest {
    pub agent_data: GroupAccountSummaryRequest_AgentData,
    pub money_data: GroupAccountSummaryRequest_MoneyData,
}


pub struct GroupAccountSummaryReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountSummaryReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
    pub balance: i32,
    pub total_credits: i32,
    pub total_debits: i32,
    pub object_tax_current: i32,
    pub light_tax_current: i32,
    pub land_tax_current: i32,
    pub group_tax_current: i32,
    pub parcel_dir_fee_current: i32,
    pub object_tax_estimate: i32,
    pub light_tax_estimate: i32,
    pub land_tax_estimate: i32,
    pub group_tax_estimate: i32,
    pub parcel_dir_fee_estimate: i32,
    pub non_exempt_members: i32,
    pub last_tax_date: Vec<u8>,
    pub tax_date: Vec<u8>,
}

pub struct GroupAccountSummaryReply {
    pub agent_data: GroupAccountSummaryReply_AgentData,
    pub money_data: GroupAccountSummaryReply_MoneyData,
}


pub struct GroupAccountDetailsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountDetailsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

pub struct GroupAccountDetailsRequest {
    pub agent_data: GroupAccountDetailsRequest_AgentData,
    pub money_data: GroupAccountDetailsRequest_MoneyData,
}


pub struct GroupAccountDetailsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountDetailsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

pub struct GroupAccountDetailsReply_HistoryData {
    pub description: Vec<u8>,
    pub amount: i32,
}

pub struct GroupAccountDetailsReply {
    pub agent_data: GroupAccountDetailsReply_AgentData,
    pub money_data: GroupAccountDetailsReply_MoneyData,
    pub history_data: Vec<GroupAccountDetailsReply_HistoryData>,
}


pub struct GroupAccountTransactionsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountTransactionsRequest_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
}

pub struct GroupAccountTransactionsRequest {
    pub agent_data: GroupAccountTransactionsRequest_AgentData,
    pub money_data: GroupAccountTransactionsRequest_MoneyData,
}


pub struct GroupAccountTransactionsReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupAccountTransactionsReply_MoneyData {
    pub request_id: Uuid,
    pub interval_days: i32,
    pub current_interval: i32,
    pub start_date: Vec<u8>,
}

pub struct GroupAccountTransactionsReply_HistoryData {
    pub time: Vec<u8>,
    pub user: Vec<u8>,
    pub type_: i32,
    pub item: Vec<u8>,
    pub amount: i32,
}

pub struct GroupAccountTransactionsReply {
    pub agent_data: GroupAccountTransactionsReply_AgentData,
    pub money_data: GroupAccountTransactionsReply_MoneyData,
    pub history_data: Vec<GroupAccountTransactionsReply_HistoryData>,
}


pub struct GroupActiveProposalsRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupActiveProposalsRequest_GroupData {
    pub group_id: Uuid,
}

pub struct GroupActiveProposalsRequest_TransactionData {
    pub transaction_id: Uuid,
}

pub struct GroupActiveProposalsRequest {
    pub agent_data: GroupActiveProposalsRequest_AgentData,
    pub group_data: GroupActiveProposalsRequest_GroupData,
    pub transaction_data: GroupActiveProposalsRequest_TransactionData,
}


pub struct GroupActiveProposalItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupActiveProposalItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

pub struct GroupActiveProposalItemReply_ProposalData {
    pub vote_id: Uuid,
    pub vote_initiator: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub already_voted: bool,
    pub vote_cast: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

pub struct GroupActiveProposalItemReply {
    pub agent_data: GroupActiveProposalItemReply_AgentData,
    pub transaction_data: GroupActiveProposalItemReply_TransactionData,
    pub proposal_data: Vec<GroupActiveProposalItemReply_ProposalData>,
}


pub struct GroupVoteHistoryRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupVoteHistoryRequest_GroupData {
    pub group_id: Uuid,
}

pub struct GroupVoteHistoryRequest_TransactionData {
    pub transaction_id: Uuid,
}

pub struct GroupVoteHistoryRequest {
    pub agent_data: GroupVoteHistoryRequest_AgentData,
    pub group_data: GroupVoteHistoryRequest_GroupData,
    pub transaction_data: GroupVoteHistoryRequest_TransactionData,
}


pub struct GroupVoteHistoryItemReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupVoteHistoryItemReply_TransactionData {
    pub transaction_id: Uuid,
    pub total_num_items: u32,
}

pub struct GroupVoteHistoryItemReply_HistoryItemData {
    pub vote_id: Uuid,
    pub terse_date_id: Vec<u8>,
    pub start_date_time: Vec<u8>,
    pub end_date_time: Vec<u8>,
    pub vote_initiator: Uuid,
    pub vote_type: Vec<u8>,
    pub vote_result: Vec<u8>,
    pub majority: f32,
    pub quorum: i32,
    pub proposal_text: Vec<u8>,
}

pub struct GroupVoteHistoryItemReply_VoteItem {
    pub candidate_id: Uuid,
    pub vote_cast: Vec<u8>,
    pub num_votes: i32,
}

pub struct GroupVoteHistoryItemReply {
    pub agent_data: GroupVoteHistoryItemReply_AgentData,
    pub transaction_data: GroupVoteHistoryItemReply_TransactionData,
    pub history_item_data: GroupVoteHistoryItemReply_HistoryItemData,
    pub vote_item: Vec<GroupVoteHistoryItemReply_VoteItem>,
}


pub struct StartGroupProposal_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct StartGroupProposal_ProposalData {
    pub group_id: Uuid,
    pub quorum: i32,
    pub majority: f32,
    pub duration: i32,
    pub proposal_text: Vec<u8>,
}

pub struct StartGroupProposal {
    pub agent_data: StartGroupProposal_AgentData,
    pub proposal_data: StartGroupProposal_ProposalData,
}


pub struct GroupProposalBallot_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupProposalBallot_ProposalData {
    pub proposal_id: Uuid,
    pub group_id: Uuid,
    pub vote_cast: Vec<u8>,
}

pub struct GroupProposalBallot {
    pub agent_data: GroupProposalBallot_AgentData,
    pub proposal_data: GroupProposalBallot_ProposalData,
}


pub struct TallyVotes {
}


pub struct GroupMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

pub struct GroupMembersRequest {
    pub agent_data: GroupMembersRequest_AgentData,
    pub group_data: GroupMembersRequest_GroupData,
}


pub struct GroupMembersReply_AgentData {
    pub agent_id: Uuid,
}

pub struct GroupMembersReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub member_count: i32,
}

pub struct GroupMembersReply_MemberData {
    pub agent_id: Uuid,
    pub contribution: i32,
    pub online_status: Vec<u8>,
    pub agent_powers: u64,
    pub title: Vec<u8>,
    pub is_owner: bool,
}

pub struct GroupMembersReply {
    pub agent_data: GroupMembersReply_AgentData,
    pub group_data: GroupMembersReply_GroupData,
    pub member_data: Vec<GroupMembersReply_MemberData>,
}


pub struct ActivateGroup_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct ActivateGroup {
    pub agent_data: ActivateGroup_AgentData,
}


pub struct SetGroupContribution_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct SetGroupContribution_Data {
    pub group_id: Uuid,
    pub contribution: i32,
}

pub struct SetGroupContribution {
    pub agent_data: SetGroupContribution_AgentData,
    pub data: SetGroupContribution_Data,
}


pub struct SetGroupAcceptNotices_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct SetGroupAcceptNotices_Data {
    pub group_id: Uuid,
    pub accept_notices: bool,
}

pub struct SetGroupAcceptNotices_NewData {
    pub list_in_profile: bool,
}

pub struct SetGroupAcceptNotices {
    pub agent_data: SetGroupAcceptNotices_AgentData,
    pub data: SetGroupAcceptNotices_Data,
    pub new_data: SetGroupAcceptNotices_NewData,
}


pub struct GroupRoleDataRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupRoleDataRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

pub struct GroupRoleDataRequest {
    pub agent_data: GroupRoleDataRequest_AgentData,
    pub group_data: GroupRoleDataRequest_GroupData,
}


pub struct GroupRoleDataReply_AgentData {
    pub agent_id: Uuid,
}

pub struct GroupRoleDataReply_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub role_count: i32,
}

pub struct GroupRoleDataReply_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub title: Vec<u8>,
    pub description: Vec<u8>,
    pub powers: u64,
    pub members: u32,
}

pub struct GroupRoleDataReply {
    pub agent_data: GroupRoleDataReply_AgentData,
    pub group_data: GroupRoleDataReply_GroupData,
    pub role_data: Vec<GroupRoleDataReply_RoleData>,
}


pub struct GroupRoleMembersRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct GroupRoleMembersRequest_GroupData {
    pub group_id: Uuid,
    pub request_id: Uuid,
}

pub struct GroupRoleMembersRequest {
    pub agent_data: GroupRoleMembersRequest_AgentData,
    pub group_data: GroupRoleMembersRequest_GroupData,
}


pub struct GroupRoleMembersReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
    pub total_pairs: u32,
}

pub struct GroupRoleMembersReply_MemberData {
    pub role_id: Uuid,
    pub member_id: Uuid,
}

pub struct GroupRoleMembersReply {
    pub agent_data: GroupRoleMembersReply_AgentData,
    pub member_data: Vec<GroupRoleMembersReply_MemberData>,
}


pub struct GroupTitlesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

pub struct GroupTitlesRequest {
    pub agent_data: GroupTitlesRequest_AgentData,
}


pub struct GroupTitlesReply_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub request_id: Uuid,
}

pub struct GroupTitlesReply_GroupData {
    pub title: Vec<u8>,
    pub role_id: Uuid,
    pub selected: bool,
}

pub struct GroupTitlesReply {
    pub agent_data: GroupTitlesReply_AgentData,
    pub group_data: Vec<GroupTitlesReply_GroupData>,
}


pub struct GroupTitleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
    pub title_role_id: Uuid,
}

pub struct GroupTitleUpdate {
    pub agent_data: GroupTitleUpdate_AgentData,
}


pub struct GroupRoleUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub group_id: Uuid,
}

pub struct GroupRoleUpdate_RoleData {
    pub role_id: Uuid,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub title: Vec<u8>,
    pub powers: u64,
    pub update_type: u8,
}

pub struct GroupRoleUpdate {
    pub agent_data: GroupRoleUpdate_AgentData,
    pub role_data: Vec<GroupRoleUpdate_RoleData>,
}


pub struct LiveHelpGroupRequest_RequestData {
    pub request_id: Uuid,
    pub agent_id: Uuid,
}

pub struct LiveHelpGroupRequest {
    pub request_data: LiveHelpGroupRequest_RequestData,
}


pub struct LiveHelpGroupReply_ReplyData {
    pub request_id: Uuid,
    pub group_id: Uuid,
    pub selection: Vec<u8>,
}

pub struct LiveHelpGroupReply {
    pub reply_data: LiveHelpGroupReply_ReplyData,
}


pub struct AgentWearablesRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentWearablesRequest {
    pub agent_data: AgentWearablesRequest_AgentData,
}


pub struct AgentWearablesUpdate_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: u32,
}

pub struct AgentWearablesUpdate_WearableData {
    pub item_id: Uuid,
    pub asset_id: Uuid,
    pub wearable_type: u8,
}

pub struct AgentWearablesUpdate {
    pub agent_data: AgentWearablesUpdate_AgentData,
    pub wearable_data: Vec<AgentWearablesUpdate_WearableData>,
}


pub struct AgentIsNowWearing_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentIsNowWearing_WearableData {
    pub item_id: Uuid,
    pub wearable_type: u8,
}

pub struct AgentIsNowWearing {
    pub agent_data: AgentIsNowWearing_AgentData,
    pub wearable_data: Vec<AgentIsNowWearing_WearableData>,
}


pub struct AgentCachedTexture_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

pub struct AgentCachedTexture_WearableData {
    pub id: Uuid,
    pub texture_index: u8,
}

pub struct AgentCachedTexture {
    pub agent_data: AgentCachedTexture_AgentData,
    pub wearable_data: Vec<AgentCachedTexture_WearableData>,
}


pub struct AgentCachedTextureResponse_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub serial_num: i32,
}

pub struct AgentCachedTextureResponse_WearableData {
    pub texture_id: Uuid,
    pub texture_index: u8,
    pub host_name: Vec<u8>,
}

pub struct AgentCachedTextureResponse {
    pub agent_data: AgentCachedTextureResponse_AgentData,
    pub wearable_data: Vec<AgentCachedTextureResponse_WearableData>,
}


pub struct AgentDataUpdateRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct AgentDataUpdateRequest {
    pub agent_data: AgentDataUpdateRequest_AgentData,
}


pub struct AgentDataUpdate_AgentData {
    pub agent_id: Uuid,
    pub first_name: Vec<u8>,
    pub last_name: Vec<u8>,
    pub group_title: Vec<u8>,
    pub active_group_id: Uuid,
    pub group_powers: u64,
    pub group_name: Vec<u8>,
}

pub struct AgentDataUpdate {
    pub agent_data: AgentDataUpdate_AgentData,
}


pub struct GroupDataUpdate_AgentGroupData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
    pub agent_powers: u64,
    pub group_title: Vec<u8>,
}

pub struct GroupDataUpdate {
    pub agent_group_data: Vec<GroupDataUpdate_AgentGroupData>,
}


pub struct AgentGroupDataUpdate_AgentData {
    pub agent_id: Uuid,
}

pub struct AgentGroupDataUpdate_GroupData {
    pub group_id: Uuid,
    pub group_powers: u64,
    pub accept_notices: bool,
    pub group_insignia_id: Uuid,
    pub contribution: i32,
    pub group_name: Vec<u8>,
}

pub struct AgentGroupDataUpdate {
    pub agent_data: AgentGroupDataUpdate_AgentData,
    pub group_data: Vec<AgentGroupDataUpdate_GroupData>,
}


pub struct AgentDropGroup_AgentData {
    pub agent_id: Uuid,
    pub group_id: Uuid,
}

pub struct AgentDropGroup {
    pub agent_data: AgentDropGroup_AgentData,
}


pub struct LogTextMessage_DataBlock {
    pub from_agent_id: Uuid,
    pub to_agent_id: Uuid,
    pub global_x: f64,
    pub global_y: f64,
    pub time: u32,
    pub message: Vec<u8>,
}

pub struct LogTextMessage {
    pub data_block: Vec<LogTextMessage_DataBlock>,
}


pub struct ViewerEffect_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ViewerEffect_Effect {
    pub id: Uuid,
    pub agent_id: Uuid,
    pub type_: u8,
    pub duration: f32,
    pub color: [u8; 4],
    pub type_data: Vec<u8>,
}

pub struct ViewerEffect {
    pub agent_data: ViewerEffect_AgentData,
    pub effect: Vec<ViewerEffect_Effect>,
}


pub struct CreateTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
    pub digest: [u8; 32],
}

pub struct CreateTrustedCircuit {
    pub data_block: CreateTrustedCircuit_DataBlock,
}


pub struct DenyTrustedCircuit_DataBlock {
    pub end_point_id: Uuid,
}

pub struct DenyTrustedCircuit {
    pub data_block: DenyTrustedCircuit_DataBlock,
}


pub struct RequestTrustedCircuit {
}


pub struct RezSingleAttachmentFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RezSingleAttachmentFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

pub struct RezSingleAttachmentFromInv {
    pub agent_data: RezSingleAttachmentFromInv_AgentData,
    pub object_data: RezSingleAttachmentFromInv_ObjectData,
}


pub struct RezMultipleAttachmentsFromInv_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RezMultipleAttachmentsFromInv_HeaderData {
    pub compound_msg_id: Uuid,
    pub total_objects: u8,
    pub first_detach_all: bool,
}

pub struct RezMultipleAttachmentsFromInv_ObjectData {
    pub item_id: Uuid,
    pub owner_id: Uuid,
    pub attachment_pt: u8,
    pub item_flags: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

pub struct RezMultipleAttachmentsFromInv {
    pub agent_data: RezMultipleAttachmentsFromInv_AgentData,
    pub header_data: RezMultipleAttachmentsFromInv_HeaderData,
    pub object_data: Vec<RezMultipleAttachmentsFromInv_ObjectData>,
}


pub struct DetachAttachmentIntoInv_ObjectData {
    pub agent_id: Uuid,
    pub item_id: Uuid,
}

pub struct DetachAttachmentIntoInv {
    pub object_data: DetachAttachmentIntoInv_ObjectData,
}


pub struct CreateNewOutfitAttachments_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct CreateNewOutfitAttachments_HeaderData {
    pub new_folder_id: Uuid,
}

pub struct CreateNewOutfitAttachments_ObjectData {
    pub old_item_id: Uuid,
    pub old_folder_id: Uuid,
}

pub struct CreateNewOutfitAttachments {
    pub agent_data: CreateNewOutfitAttachments_AgentData,
    pub header_data: CreateNewOutfitAttachments_HeaderData,
    pub object_data: Vec<CreateNewOutfitAttachments_ObjectData>,
}


pub struct UserInfoRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UserInfoRequest {
    pub agent_data: UserInfoRequest_AgentData,
}


pub struct UserInfoReply_AgentData {
    pub agent_id: Uuid,
}

pub struct UserInfoReply_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
    pub e_mail: Vec<u8>,
}

pub struct UserInfoReply {
    pub agent_data: UserInfoReply_AgentData,
    pub user_data: UserInfoReply_UserData,
}


pub struct UpdateUserInfo_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct UpdateUserInfo_UserData {
    pub im_via_e_mail: bool,
    pub directory_visibility: Vec<u8>,
}

pub struct UpdateUserInfo {
    pub agent_data: UpdateUserInfo_AgentData,
    pub user_data: UpdateUserInfo_UserData,
}


pub struct ParcelRename_ParcelData {
    pub parcel_id: Uuid,
    pub new_name: Vec<u8>,
}

pub struct ParcelRename {
    pub parcel_data: Vec<ParcelRename_ParcelData>,
}


pub struct InitiateDownload_AgentData {
    pub agent_id: Uuid,
}

pub struct InitiateDownload_FileData {
    pub sim_filename: Vec<u8>,
    pub viewer_filename: Vec<u8>,
}

pub struct InitiateDownload {
    pub agent_data: InitiateDownload_AgentData,
    pub file_data: InitiateDownload_FileData,
}


pub struct SystemMessage_MethodData {
    pub method: Vec<u8>,
    pub invoice: Uuid,
    pub digest: [u8; 32],
}

pub struct SystemMessage_ParamList {
    pub parameter: Vec<u8>,
}

pub struct SystemMessage {
    pub method_data: SystemMessage_MethodData,
    pub param_list: Vec<SystemMessage_ParamList>,
}


pub struct MapLayerRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct MapLayerRequest {
    pub agent_data: MapLayerRequest_AgentData,
}


pub struct MapLayerReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

pub struct MapLayerReply_LayerData {
    pub left: u32,
    pub right: u32,
    pub top: u32,
    pub bottom: u32,
    pub image_id: Uuid,
}

pub struct MapLayerReply {
    pub agent_data: MapLayerReply_AgentData,
    pub layer_data: Vec<MapLayerReply_LayerData>,
}


pub struct MapBlockRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct MapBlockRequest_PositionData {
    pub min_x: u16,
    pub max_x: u16,
    pub min_y: u16,
    pub max_y: u16,
}

pub struct MapBlockRequest {
    pub agent_data: MapBlockRequest_AgentData,
    pub position_data: MapBlockRequest_PositionData,
}


pub struct MapNameRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct MapNameRequest_NameData {
    pub name: Vec<u8>,
}

pub struct MapNameRequest {
    pub agent_data: MapNameRequest_AgentData,
    pub name_data: MapNameRequest_NameData,
}


pub struct MapBlockReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

pub struct MapBlockReply_Data {
    pub x: u16,
    pub y: u16,
    pub name: Vec<u8>,
    pub access: u8,
    pub region_flags: u32,
    pub water_height: u8,
    pub agents: u8,
    pub map_image_id: Uuid,
}

pub struct MapBlockReply {
    pub agent_data: MapBlockReply_AgentData,
    pub data: Vec<MapBlockReply_Data>,
}


pub struct MapItemRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub flags: u32,
    pub estate_id: u32,
    pub godlike: bool,
}

pub struct MapItemRequest_RequestData {
    pub item_type: u32,
    pub region_handle: u64,
}

pub struct MapItemRequest {
    pub agent_data: MapItemRequest_AgentData,
    pub request_data: MapItemRequest_RequestData,
}


pub struct MapItemReply_AgentData {
    pub agent_id: Uuid,
    pub flags: u32,
}

pub struct MapItemReply_RequestData {
    pub item_type: u32,
}

pub struct MapItemReply_Data {
    pub x: u32,
    pub y: u32,
    pub id: Uuid,
    pub extra: i32,
    pub extra2: i32,
    pub name: Vec<u8>,
}

pub struct MapItemReply {
    pub agent_data: MapItemReply_AgentData,
    pub request_data: MapItemReply_RequestData,
    pub data: Vec<MapItemReply_Data>,
}


pub struct SendPostcard_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
    pub asset_id: Uuid,
    pub pos_global: Vector3<f64>,
    pub to: Vec<u8>,
    pub from: Vec<u8>,
    pub name: Vec<u8>,
    pub subject: Vec<u8>,
    pub msg: Vec<u8>,
    pub allow_publish: bool,
    pub mature_publish: bool,
}

pub struct SendPostcard {
    pub agent_data: SendPostcard_AgentData,
}


pub struct RpcChannelRequest_DataBlock {
    pub grid_x: u32,
    pub grid_y: u32,
    pub task_id: Uuid,
    pub item_id: Uuid,
}

pub struct RpcChannelRequest {
    pub data_block: RpcChannelRequest_DataBlock,
}


pub struct RpcChannelReply_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
}

pub struct RpcChannelReply {
    pub data_block: RpcChannelReply_DataBlock,
}


pub struct RpcScriptRequestInbound_TargetBlock {
    pub grid_x: u32,
    pub grid_y: u32,
}

pub struct RpcScriptRequestInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

pub struct RpcScriptRequestInbound {
    pub target_block: RpcScriptRequestInbound_TargetBlock,
    pub data_block: RpcScriptRequestInbound_DataBlock,
}


pub struct RpcScriptRequestInboundForward_DataBlock {
    pub rpc_server_ip: Ip4Addr,
    pub rpc_server_port: Ip4Port,
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

pub struct RpcScriptRequestInboundForward {
    pub data_block: RpcScriptRequestInboundForward_DataBlock,
}


pub struct RpcScriptReplyInbound_DataBlock {
    pub task_id: Uuid,
    pub item_id: Uuid,
    pub channel_id: Uuid,
    pub int_value: u32,
    pub string_value: Vec<u8>,
}

pub struct RpcScriptReplyInbound {
    pub data_block: RpcScriptReplyInbound_DataBlock,
}


pub struct ScriptMailRegistration_DataBlock {
    pub target_ip: Vec<u8>,
    pub target_port: Ip4Port,
    pub task_id: Uuid,
    pub flags: u32,
}

pub struct ScriptMailRegistration {
    pub data_block: ScriptMailRegistration_DataBlock,
}


pub struct ParcelMediaCommandMessage_CommandBlock {
    pub flags: u32,
    pub command: u32,
    pub time: f32,
}

pub struct ParcelMediaCommandMessage {
    pub command_block: ParcelMediaCommandMessage_CommandBlock,
}


pub struct ParcelMediaUpdate_DataBlock {
    pub media_url: Vec<u8>,
    pub media_id: Uuid,
    pub media_auto_scale: u8,
}

pub struct ParcelMediaUpdate_DataBlockExtended {
    pub media_type: Vec<u8>,
    pub media_desc: Vec<u8>,
    pub media_width: i32,
    pub media_height: i32,
    pub media_loop: u8,
}

pub struct ParcelMediaUpdate {
    pub data_block: ParcelMediaUpdate_DataBlock,
    pub data_block_extended: ParcelMediaUpdate_DataBlockExtended,
}


pub struct LandStatRequest_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct LandStatRequest_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub filter: Vec<u8>,
    pub parcel_local_id: i32,
}

pub struct LandStatRequest {
    pub agent_data: LandStatRequest_AgentData,
    pub request_data: LandStatRequest_RequestData,
}


pub struct LandStatReply_RequestData {
    pub report_type: u32,
    pub request_flags: u32,
    pub total_object_count: u32,
}

pub struct LandStatReply_ReportData {
    pub task_local_id: u32,
    pub task_id: Uuid,
    pub location_x: f32,
    pub location_y: f32,
    pub location_z: f32,
    pub score: f32,
    pub task_name: Vec<u8>,
    pub owner_name: Vec<u8>,
}

pub struct LandStatReply {
    pub request_data: LandStatReply_RequestData,
    pub report_data: Vec<LandStatReply_ReportData>,
}


pub struct Error_AgentData {
    pub agent_id: Uuid,
}

pub struct Error_Data {
    pub code: i32,
    pub token: Vec<u8>,
    pub id: Uuid,
    pub system: Vec<u8>,
    pub message: Vec<u8>,
    pub data: Vec<u8>,
}

pub struct Error {
    pub agent_data: Error_AgentData,
    pub data: Error_Data,
}


pub struct ObjectIncludeInSearch_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct ObjectIncludeInSearch_ObjectData {
    pub object_local_id: u32,
    pub include_in_search: bool,
}

pub struct ObjectIncludeInSearch {
    pub agent_data: ObjectIncludeInSearch_AgentData,
    pub object_data: Vec<ObjectIncludeInSearch_ObjectData>,
}


pub struct RezRestoreToWorld_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct RezRestoreToWorld_InventoryData {
    pub item_id: Uuid,
    pub folder_id: Uuid,
    pub creator_id: Uuid,
    pub owner_id: Uuid,
    pub group_id: Uuid,
    pub base_mask: u32,
    pub owner_mask: u32,
    pub group_mask: u32,
    pub everyone_mask: u32,
    pub next_owner_mask: u32,
    pub group_owned: bool,
    pub transaction_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub flags: u32,
    pub sale_type: u8,
    pub sale_price: i32,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
    pub creation_date: i32,
    pub crc: u32,
}

pub struct RezRestoreToWorld {
    pub agent_data: RezRestoreToWorld_AgentData,
    pub inventory_data: RezRestoreToWorld_InventoryData,
}


pub struct LinkInventoryItem_AgentData {
    pub agent_id: Uuid,
    pub session_id: Uuid,
}

pub struct LinkInventoryItem_InventoryBlock {
    pub callback_id: u32,
    pub folder_id: Uuid,
    pub transaction_id: Uuid,
    pub old_item_id: Uuid,
    pub type_: i8,
    pub inv_type: i8,
    pub name: Vec<u8>,
    pub description: Vec<u8>,
}

pub struct LinkInventoryItem {
    pub agent_data: LinkInventoryItem_AgentData,
    pub inventory_block: LinkInventoryItem_InventoryBlock,
}


// Message IMPLEMENTATIONS



impl Message for TestMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x01]));
        // Block TestBlock1
        try!(buffer.write_u32::<LittleEndian>(self.test_block1.test1));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test0));
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test1));
            try!(buffer.write_u32::<LittleEndian>(self.neighbor_block[i].test2));
        }
        Ok(())
    }
}

impl Message for PacketAck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFB]));
        // Block Packets
        try!(buffer.write_u8(self.packets.len() as u8));
        for item in &self.packets {
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }
}

impl Message for OpenCircuit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFC]));
        // Block CircuitInfo
        try!(buffer.write(&self.circuit_info.ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.circuit_info.port));
        Ok(())
    }
}

impl Message for CloseCircuit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0xff, 0xFD]));
        Ok(())
    }
}

impl Message for StartPingCheck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x01]));
        // Block PingID
        try!(buffer.write_u8(self.ping_id.ping_id));
        try!(buffer.write_u32::<LittleEndian>(self.ping_id.oldest_unacked));
        Ok(())
    }
}

impl Message for CompletePingCheck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x02]));
        // Block PingID
        try!(buffer.write_u8(self.ping_id.ping_id));
        Ok(())
    }
}

impl Message for AddCircuitCode {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x02]));
        // Block CircuitCode
        try!(buffer.write_u32::<LittleEndian>(self.circuit_code.code));
        try!(buffer.write(self.circuit_code.session_id.as_bytes()));
        try!(buffer.write(self.circuit_code.agent_id.as_bytes()));
        Ok(())
    }
}

impl Message for UseCircuitCode {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x03]));
        // Block CircuitCode
        try!(buffer.write_u32::<LittleEndian>(self.circuit_code.code));
        try!(buffer.write(self.circuit_code.session_id.as_bytes()));
        try!(buffer.write(self.circuit_code.id.as_bytes()));
        Ok(())
    }
}

impl Message for NeighborList {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x03]));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write(&self.neighbor_block[i].ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port));
            try!(buffer.write(&self.neighbor_block[i].public_ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].public_port));
            try!(buffer.write(self.neighbor_block[i].region_id.as_bytes()));
            try!(buffer.write(&self.neighbor_block[i].name[..]));
            try!(buffer.write_u8(self.neighbor_block[i].sim_access));
        }
        Ok(())
    }
}

impl Message for AvatarTextureUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.textures_changed as u8));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.cache_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
            try!(buffer.write(&item.host_name[..]));
        }
        // Block TextureData
        try!(buffer.write_u8(self.texture_data.len() as u8));
        for item in &self.texture_data {
            try!(buffer.write(item.texture_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for SimulatorMapUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x05]));
        // Block MapData
        try!(buffer.write_u32::<LittleEndian>(self.map_data.flags));
        Ok(())
    }
}

impl Message for SimulatorSetMap {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x06]));
        // Block MapData
        try!(buffer.write_u64::<LittleEndian>(self.map_data.region_handle));
        try!(buffer.write_i32::<LittleEndian>(self.map_data.type_));
        try!(buffer.write(self.map_data.map_image.as_bytes()));
        Ok(())
    }
}

impl Message for SubscribeLoad {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x07]));
        Ok(())
    }
}

impl Message for UnsubscribeLoad {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x08]));
        Ok(())
    }
}

impl Message for SimulatorReady {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x09]));
        // Block SimulatorBlock
        try!(buffer.write(&self.simulator_block.sim_name[..]));
        try!(buffer.write_u8(self.simulator_block.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags));
        try!(buffer.write(self.simulator_block.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id));
        // Block TelehubBlock
        try!(buffer.write_u8(self.telehub_block.has_telehub as u8));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z));
        Ok(())
    }
}

impl Message for TelehubInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0a]));
        // Block TelehubBlock
        try!(buffer.write(self.telehub_block.object_id.as_bytes()));
        try!(buffer.write(&self.telehub_block.object_name[..]));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.telehub_block.telehub_pos.z));
        let normed_telehub_rot = UnitQuaternion::new(&self.telehub_block.telehub_rot).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.i));
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.j));
        try!(buffer.write_f32::<LittleEndian>(normed_telehub_rot.k));
        // Block SpawnPointBlock
        try!(buffer.write_u8(self.spawn_point_block.len() as u8));
        for item in &self.spawn_point_block {
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.x));
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.y));
            try!(buffer.write_f32::<LittleEndian>(item.spawn_point_pos.z));
        }
        Ok(())
    }
}

impl Message for SimulatorPresentAtLocation {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0b]));
        // Block SimulatorPublicHostBlock
        try!(buffer.write_u16::<LittleEndian>(self.simulator_public_host_block.port));
        try!(buffer.write(&self.simulator_public_host_block.simulator_ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_public_host_block.grid_y));
        // Block NeighborBlock
        for i in 0..4 {
            try!(buffer.write(&self.neighbor_block[i].ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(self.neighbor_block[i].port));
        }
        // Block SimulatorBlock
        try!(buffer.write(&self.simulator_block.sim_name[..]));
        try!(buffer.write_u8(self.simulator_block.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.region_flags));
        try!(buffer.write(self.simulator_block.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_block.parent_estate_id));
        // Block TelehubBlock
        try!(buffer.write_u8(self.telehub_block.len() as u8));
        for item in &self.telehub_block {
            try!(buffer.write_u8(item.has_telehub as u8));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.x));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.y));
            try!(buffer.write_f32::<LittleEndian>(item.telehub_pos.z));
        }
        Ok(())
    }
}

impl Message for SimulatorLoad {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0c]));
        // Block SimulatorLoad
        try!(buffer.write_f32::<LittleEndian>(self.simulator_load.time_dilation));
        try!(buffer.write_i32::<LittleEndian>(self.simulator_load.agent_count));
        try!(buffer.write_u8(self.simulator_load.can_accept_agents as u8));
        // Block AgentList
        try!(buffer.write_u8(self.agent_list.len() as u8));
        for item in &self.agent_list {
            try!(buffer.write_u32::<LittleEndian>(item.circuit_code));
            try!(buffer.write_u8(item.x));
            try!(buffer.write_u8(item.y));
        }
        Ok(())
    }
}

impl Message for SimulatorShutdownRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0d]));
        Ok(())
    }
}

impl Message for RegionPresenceRequestByRegionID {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0e]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write(item.region_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for RegionPresenceRequestByHandle {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x0f]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }
}

impl Message for RegionPresenceResponse {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x10]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write(item.region_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
            try!(buffer.write(&item.internal_region_ip.octets()));
            try!(buffer.write(&item.external_region_ip.octets()));
            try!(buffer.write_u16::<LittleEndian>(item.region_port));
            try!(buffer.write_f64::<LittleEndian>(item.valid_until));
            try!(buffer.write(&item.message[..]));
        }
        Ok(())
    }
}

impl Message for UpdateSimulator {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x11]));
        // Block SimulatorInfo
        try!(buffer.write(self.simulator_info.region_id.as_bytes()));
        try!(buffer.write(&self.simulator_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.simulator_info.estate_id));
        try!(buffer.write_u8(self.simulator_info.sim_access));
        Ok(())
    }
}

impl Message for LogDwellTime {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x12]));
        // Block DwellInfo
        try!(buffer.write(self.dwell_info.agent_id.as_bytes()));
        try!(buffer.write(self.dwell_info.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.dwell_info.duration));
        try!(buffer.write(&self.dwell_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.dwell_info.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.dwell_info.region_y));
        try!(buffer.write_u8(self.dwell_info.avg_agents_in_view));
        try!(buffer.write_u8(self.dwell_info.avg_viewer_fps));
        Ok(())
    }
}

impl Message for FeatureDisabled {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x13]));
        // Block FailureInfo
        try!(buffer.write(&self.failure_info.error_message[..]));
        try!(buffer.write(self.failure_info.agent_id.as_bytes()));
        try!(buffer.write(self.failure_info.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for LogFailedMoneyTransaction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x14]));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.transaction_time));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_data.transaction_type));
        try!(buffer.write(self.transaction_data.source_id.as_bytes()));
        try!(buffer.write(self.transaction_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_data.amount));
        try!(buffer.write(&self.transaction_data.simulator_ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.grid_y));
        try!(buffer.write_u8(self.transaction_data.failure_type));
        Ok(())
    }
}

impl Message for UserReportInternal {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x15]));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.report_type));
        try!(buffer.write_u8(self.report_data.category));
        try!(buffer.write(self.report_data.reporter_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.viewer_position.z));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.agent_position.z));
        try!(buffer.write(self.report_data.screenshot_id.as_bytes()));
        try!(buffer.write(self.report_data.object_id.as_bytes()));
        try!(buffer.write(self.report_data.owner_id.as_bytes()));
        try!(buffer.write(self.report_data.last_owner_id.as_bytes()));
        try!(buffer.write(self.report_data.creator_id.as_bytes()));
        try!(buffer.write(self.report_data.region_id.as_bytes()));
        try!(buffer.write(self.report_data.abuser_id.as_bytes()));
        try!(buffer.write(&self.report_data.abuse_region_name[..]));
        try!(buffer.write(self.report_data.abuse_region_id.as_bytes()));
        try!(buffer.write(&self.report_data.summary[..]));
        try!(buffer.write(&self.report_data.details[..]));
        try!(buffer.write(&self.report_data.version_string[..]));
        Ok(())
    }
}

impl Message for SetSimStatusInDatabase {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x16]));
        // Block Data
        try!(buffer.write(self.data.region_id.as_bytes()));
        try!(buffer.write(&self.data.host_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.x));
        try!(buffer.write_i32::<LittleEndian>(self.data.y));
        try!(buffer.write_i32::<LittleEndian>(self.data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.data.agent_count));
        try!(buffer.write_i32::<LittleEndian>(self.data.time_to_live));
        try!(buffer.write(&self.data.status[..]));
        Ok(())
    }
}

impl Message for SetSimPresenceInDatabase {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x17]));
        // Block SimData
        try!(buffer.write(self.sim_data.region_id.as_bytes()));
        try!(buffer.write(&self.sim_data.host_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.sim_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.sim_data.grid_y));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.agent_count));
        try!(buffer.write_i32::<LittleEndian>(self.sim_data.time_to_live));
        try!(buffer.write(&self.sim_data.status[..]));
        Ok(())
    }
}

impl Message for EconomyDataRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x18]));
        Ok(())
    }
}

impl Message for EconomyData {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x19]));
        // Block Info
        try!(buffer.write_i32::<LittleEndian>(self.info.object_capacity));
        try!(buffer.write_i32::<LittleEndian>(self.info.object_count));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_energy_unit));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_object_claim));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_public_object_decay));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_public_object_delete));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_parcel_claim));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_parcel_claim_factor));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_upload));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_rent_light));
        try!(buffer.write_i32::<LittleEndian>(self.info.teleport_min_price));
        try!(buffer.write_f32::<LittleEndian>(self.info.teleport_price_exponent));
        try!(buffer.write_f32::<LittleEndian>(self.info.energy_efficiency));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_object_rent));
        try!(buffer.write_f32::<LittleEndian>(self.info.price_object_scale_factor));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_parcel_rent));
        try!(buffer.write_i32::<LittleEndian>(self.info.price_group_create));
        Ok(())
    }
}

impl Message for AvatarPickerRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block Data
        try!(buffer.write(&self.data.name[..]));
        Ok(())
    }
}

impl Message for AvatarPickerRequestBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.god_level));
        // Block Data
        try!(buffer.write(&self.data.name[..]));
        Ok(())
    }
}

impl Message for AvatarPickerReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.avatar_id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
        }
        Ok(())
    }
}

impl Message for PlacesQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        Ok(())
    }
}

impl Message for PlacesReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.query_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        // Block QueryData
        try!(buffer.write_u8(self.query_data.len() as u8));
        for item in &self.query_data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.desc[..]));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
            try!(buffer.write_i32::<LittleEndian>(item.billable_area));
            try!(buffer.write_u8(item.flags));
            try!(buffer.write_f32::<LittleEndian>(item.global_x));
            try!(buffer.write_f32::<LittleEndian>(item.global_y));
            try!(buffer.write_f32::<LittleEndian>(item.global_z));
            try!(buffer.write(&item.sim_name[..]));
            try!(buffer.write(item.snapshot_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
            try!(buffer.write_i32::<LittleEndian>(item.price));
        }
        Ok(())
    }
}

impl Message for DirFindQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x1f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirFindQueryBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x20]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }
}

impl Message for DirPlacesQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x21]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirPlacesQueryBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x22]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i8(self.query_data.category));
        try!(buffer.write(&self.query_data.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirPlacesReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x23]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write_u8(self.query_data.len() as u8));
        for item in &self.query_data {
            try!(buffer.write(item.query_id.as_bytes()));
        }
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.for_sale as u8));
            try!(buffer.write_u8(item.auction as u8));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }
}

impl Message for DirPeopleReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x24]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
            try!(buffer.write(&item.group[..]));
            try!(buffer.write_u8(item.online as u8));
            try!(buffer.write_i32::<LittleEndian>(item.reputation));
        }
        Ok(())
    }
}

impl Message for DirEventsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x25]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u32::<LittleEndian>(item.event_id));
            try!(buffer.write(&item.date[..]));
            try!(buffer.write_u32::<LittleEndian>(item.unix_time));
            try!(buffer.write_u32::<LittleEndian>(item.event_flags));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }
}

impl Message for DirGroupsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x26]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
            try!(buffer.write_i32::<LittleEndian>(item.members));
            try!(buffer.write_f32::<LittleEndian>(item.search_order));
        }
        Ok(())
    }
}

impl Message for DirClassifiedQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x27]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.category));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirClassifiedQueryBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x28]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.category));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirClassifiedReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x29]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.classified_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.classified_flags));
            try!(buffer.write_u32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.expiration_date));
            try!(buffer.write_i32::<LittleEndian>(item.price_for_listing));
        }
        // Block StatusData
        try!(buffer.write_u8(self.status_data.len() as u8));
        for item in &self.status_data {
            try!(buffer.write_u32::<LittleEndian>(item.status));
        }
        Ok(())
    }
}

impl Message for AvatarClassifiedReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.target_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.classified_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }
}

impl Message for ClassifiedInfoRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        Ok(())
    }
}

impl Message for ClassifiedInfoReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.data.expiration_date));
        try!(buffer.write_u32::<LittleEndian>(self.data.category));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.parent_estate));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write(&self.data.parcel_name[..]));
        try!(buffer.write_u8(self.data.classified_flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.price_for_listing));
        Ok(())
    }
}

impl Message for ClassifiedInfoUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.category));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.parent_estate));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_u8(self.data.classified_flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.price_for_listing));
        Ok(())
    }
}

impl Message for ClassifiedDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        Ok(())
    }
}

impl Message for ClassifiedGodDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x2f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.classified_id.as_bytes()));
        try!(buffer.write(self.data.query_id.as_bytes()));
        Ok(())
    }
}

impl Message for DirLandQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x30]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.search_type));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.area));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for DirLandQueryBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x31]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.search_type));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.area));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }
}

impl Message for DirLandReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x32]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.auction as u8));
            try!(buffer.write_u8(item.for_sale as u8));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
        }
        Ok(())
    }
}

impl Message for DirPopularQuery {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x33]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        Ok(())
    }
}

impl Message for DirPopularQueryBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x34]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.estate_id));
        try!(buffer.write_u8(self.query_data.godlike as u8));
        Ok(())
    }
}

impl Message for DirPopularReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x35]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block QueryReplies
        try!(buffer.write_u8(self.query_replies.len() as u8));
        for item in &self.query_replies {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_f32::<LittleEndian>(item.dwell));
        }
        Ok(())
    }
}

impl Message for ParcelInfoRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x36]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        Ok(())
    }
}

impl Message for ParcelInfoReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x37]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.actual_area));
        try!(buffer.write_i32::<LittleEndian>(self.data.billable_area));
        try!(buffer.write_u8(self.data.flags));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_x));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_y));
        try!(buffer.write_f32::<LittleEndian>(self.data.global_z));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data.dwell));
        try!(buffer.write_i32::<LittleEndian>(self.data.sale_price));
        try!(buffer.write_i32::<LittleEndian>(self.data.auction_id));
        Ok(())
    }
}

impl Message for ParcelObjectOwnersRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x38]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }
}

impl Message for ParcelObjectOwnersReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x39]));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.is_group_owned as u8));
            try!(buffer.write_i32::<LittleEndian>(item.count));
            try!(buffer.write_u8(item.online_status as u8));
        }
        Ok(())
    }
}

impl Message for GroupNoticesListRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupNoticesListReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.notice_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.timestamp));
            try!(buffer.write(&item.from_name[..]));
            try!(buffer.write(&item.subject[..]));
            try!(buffer.write_u8(item.has_attachment as u8));
            try!(buffer.write_u8(item.asset_type));
        }
        Ok(())
    }
}

impl Message for GroupNoticeRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_notice_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupNoticeAdd {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block MessageBlock
        try!(buffer.write(self.message_block.to_group_id.as_bytes()));
        try!(buffer.write(self.message_block.id.as_bytes()));
        try!(buffer.write_u8(self.message_block.dialog));
        try!(buffer.write(&self.message_block.from_agent_name[..]));
        try!(buffer.write(&self.message_block.message[..]));
        try!(buffer.write(&self.message_block.binary_bucket[..]));
        Ok(())
    }
}

impl Message for TeleportRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write(self.info.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }
}

impl Message for TeleportLocationRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x3f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }
}

impl Message for TeleportLocal {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x40]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.location_id));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }
}

impl Message for TeleportLandmarkRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x41]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        try!(buffer.write(self.info.landmark_id.as_bytes()));
        Ok(())
    }
}

impl Message for TeleportProgress {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x42]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Info
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        try!(buffer.write(&self.info.message[..]));
        Ok(())
    }
}

impl Message for DataHomeLocationRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x43]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.kicked_from_estate_id));
        // Block AgentInfo
        try!(buffer.write_u32::<LittleEndian>(self.agent_info.agent_effective_maturity));
        Ok(())
    }
}

impl Message for DataHomeLocationReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x44]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }
}

impl Message for TeleportFinish {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x45]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.location_id));
        try!(buffer.write(&self.info.sim_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.info.sim_port));
        try!(buffer.write_u64::<LittleEndian>(self.info.region_handle));
        try!(buffer.write(&self.info.seed_capability[..]));
        try!(buffer.write_u8(self.info.sim_access));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }
}

impl Message for StartLure {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x46]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Info
        try!(buffer.write_u8(self.info.lure_type));
        try!(buffer.write(&self.info.message[..]));
        // Block TargetData
        try!(buffer.write_u8(self.target_data.len() as u8));
        for item in &self.target_data {
            try!(buffer.write(item.target_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for TeleportLureRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x47]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        try!(buffer.write(self.info.lure_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }
}

impl Message for TeleportCancel {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x48]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(self.info.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for TeleportStart {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x49]));
        // Block Info
        try!(buffer.write_u32::<LittleEndian>(self.info.teleport_flags));
        Ok(())
    }
}

impl Message for TeleportFailed {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4a]));
        // Block Info
        try!(buffer.write(self.info.agent_id.as_bytes()));
        try!(buffer.write(&self.info.reason[..]));
        // Block AlertInfo
        try!(buffer.write_u8(self.alert_info.len() as u8));
        for item in &self.alert_info {
            try!(buffer.write(&item.message[..]));
            try!(buffer.write(&item.extra_params[..]));
        }
        Ok(())
    }
}

impl Message for Undo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for Redo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UndoLand {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for AgentPause {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        Ok(())
    }
}

impl Message for AgentResume {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x4f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        Ok(())
    }
}

impl Message for AgentUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.k));
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.k));
        try!(buffer.write_u8(self.agent_data.state));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.camera_up_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.far));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.control_flags));
        try!(buffer.write_u8(self.agent_data.flags));
        Ok(())
    }
}

impl Message for ChatFromViewer {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x50]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ChatData
        try!(buffer.write(&self.chat_data.message[..]));
        try!(buffer.write_u8(self.chat_data.type_));
        try!(buffer.write_i32::<LittleEndian>(self.chat_data.channel));
        Ok(())
    }
}

impl Message for AgentThrottle {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x51]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block Throttle
        try!(buffer.write_u32::<LittleEndian>(self.throttle.gen_counter));
        try!(buffer.write(&self.throttle.throttles[..]));
        Ok(())
    }
}

impl Message for AgentFOV {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x52]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block FOVBlock
        try!(buffer.write_u32::<LittleEndian>(self.fov_block.gen_counter));
        try!(buffer.write_f32::<LittleEndian>(self.fov_block.vertical_angle));
        Ok(())
    }
}

impl Message for AgentHeightWidth {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x53]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        // Block HeightWidthBlock
        try!(buffer.write_u32::<LittleEndian>(self.height_width_block.gen_counter));
        try!(buffer.write_u16::<LittleEndian>(self.height_width_block.height));
        try!(buffer.write_u16::<LittleEndian>(self.height_width_block.width));
        Ok(())
    }
}

impl Message for AgentSetAppearance {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x54]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.cache_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
        }
        // Block ObjectData
        try!(buffer.write(&self.object_data.texture_entry[..]));
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        Ok(())
    }
}

impl Message for AgentAnimation {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AnimationList
        try!(buffer.write_u8(self.animation_list.len() as u8));
        for item in &self.animation_list {
            try!(buffer.write(item.anim_id.as_bytes()));
            try!(buffer.write_u8(item.start_anim as u8));
        }
        // Block PhysicalAvatarEventList
        try!(buffer.write_u8(self.physical_avatar_event_list.len() as u8));
        for item in &self.physical_avatar_event_list {
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }
}

impl Message for AgentRequestSit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x06]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TargetObject
        try!(buffer.write(self.target_object.target_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.target_object.offset.z));
        Ok(())
    }
}

impl Message for AgentSit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for AgentQuitCopy {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x55]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FuseBlock
        try!(buffer.write_u32::<LittleEndian>(self.fuse_block.viewer_circuit_code));
        Ok(())
    }
}

impl Message for RequestImage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestImage
        try!(buffer.write_u8(self.request_image.len() as u8));
        for item in &self.request_image {
            try!(buffer.write(item.image.as_bytes()));
            try!(buffer.write_i8(item.discard_level));
            try!(buffer.write_f32::<LittleEndian>(item.download_priority));
            try!(buffer.write_u32::<LittleEndian>(item.packet));
            try!(buffer.write_u8(item.type_));
        }
        Ok(())
    }
}

impl Message for ImageNotInDatabase {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x56]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        Ok(())
    }
}

impl Message for RebakeAvatarTextures {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x57]));
        // Block TextureData
        try!(buffer.write(self.texture_data.texture_id.as_bytes()));
        Ok(())
    }
}

impl Message for SetAlwaysRun {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x58]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.always_run as u8));
        Ok(())
    }
}

impl Message for ObjectAdd {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x01]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.p_code));
        try!(buffer.write_u8(self.object_data.material));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.add_flags));
        try!(buffer.write_u8(self.object_data.path_curve));
        try!(buffer.write_u8(self.object_data.profile_curve));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.path_begin));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.path_end));
        try!(buffer.write_u8(self.object_data.path_scale_x));
        try!(buffer.write_u8(self.object_data.path_scale_y));
        try!(buffer.write_u8(self.object_data.path_shear_x));
        try!(buffer.write_u8(self.object_data.path_shear_y));
        try!(buffer.write_i8(self.object_data.path_twist));
        try!(buffer.write_i8(self.object_data.path_twist_begin));
        try!(buffer.write_i8(self.object_data.path_radius_offset));
        try!(buffer.write_i8(self.object_data.path_taper_x));
        try!(buffer.write_i8(self.object_data.path_taper_y));
        try!(buffer.write_u8(self.object_data.path_revolutions));
        try!(buffer.write_i8(self.object_data.path_skew));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_begin));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_end));
        try!(buffer.write_u16::<LittleEndian>(self.object_data.profile_hollow));
        try!(buffer.write_u8(self.object_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.ray_end.z));
        try!(buffer.write(self.object_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.object_data.ray_end_is_intersection));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.scale.z));
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        try!(buffer.write_u8(self.object_data.state));
        Ok(())
    }
}

impl Message for ObjectDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x59]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.force as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectDuplicate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block SharedData
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.shared_data.offset.z));
        try!(buffer.write_u32::<LittleEndian>(self.shared_data.duplicate_flags));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectDuplicateOnRay {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ray_end.z));
        try!(buffer.write_u8(self.agent_data.bypass_raycast as u8));
        try!(buffer.write_u8(self.agent_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.agent_data.copy_centers as u8));
        try!(buffer.write_u8(self.agent_data.copy_rotates as u8));
        try!(buffer.write(self.agent_data.ray_target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.duplicate_flags));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for MultipleObjectUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x02]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.type_));
            try!(buffer.write(&item.data[..]));
        }
        Ok(())
    }
}

impl Message for RequestMultipleObjects {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x03]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u8(item.cache_miss_type));
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }
}

impl Message for ObjectPosition {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
        }
        Ok(())
    }
}

impl Message for ObjectScale {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_f32::<LittleEndian>(item.scale.x));
            try!(buffer.write_f32::<LittleEndian>(item.scale.y));
            try!(buffer.write_f32::<LittleEndian>(item.scale.z));
        }
        Ok(())
    }
}

impl Message for ObjectRotation {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        }
        Ok(())
    }
}

impl Message for ObjectFlagUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.object_local_id));
        try!(buffer.write_u8(self.agent_data.use_physics as u8));
        try!(buffer.write_u8(self.agent_data.is_temporary as u8));
        try!(buffer.write_u8(self.agent_data.is_phantom as u8));
        try!(buffer.write_u8(self.agent_data.casts_shadows as u8));
        Ok(())
    }
}

impl Message for ObjectClickAction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x5f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.click_action));
        }
        Ok(())
    }
}

impl Message for ObjectImage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x60]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write(&item.media_url[..]));
            try!(buffer.write(&item.texture_entry[..]));
        }
        Ok(())
    }
}

impl Message for ObjectMaterial {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x61]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.material));
        }
        Ok(())
    }
}

impl Message for ObjectShape {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x62]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.path_curve));
            try!(buffer.write_u8(item.profile_curve));
            try!(buffer.write_u16::<LittleEndian>(item.path_begin));
            try!(buffer.write_u16::<LittleEndian>(item.path_end));
            try!(buffer.write_u8(item.path_scale_x));
            try!(buffer.write_u8(item.path_scale_y));
            try!(buffer.write_u8(item.path_shear_x));
            try!(buffer.write_u8(item.path_shear_y));
            try!(buffer.write_i8(item.path_twist));
            try!(buffer.write_i8(item.path_twist_begin));
            try!(buffer.write_i8(item.path_radius_offset));
            try!(buffer.write_i8(item.path_taper_x));
            try!(buffer.write_i8(item.path_taper_y));
            try!(buffer.write_u8(item.path_revolutions));
            try!(buffer.write_i8(item.path_skew));
            try!(buffer.write_u16::<LittleEndian>(item.profile_begin));
            try!(buffer.write_u16::<LittleEndian>(item.profile_end));
            try!(buffer.write_u16::<LittleEndian>(item.profile_hollow));
        }
        Ok(())
    }
}

impl Message for ObjectExtraParams {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x63]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u16::<LittleEndian>(item.param_type));
            try!(buffer.write_u8(item.param_in_use as u8));
            try!(buffer.write_u32::<LittleEndian>(item.param_size));
            try!(buffer.write(&item.param_data[..]));
        }
        Ok(())
    }
}

impl Message for ObjectOwner {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x64]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write_u8(self.header_data.override_ as u8));
        try!(buffer.write(self.header_data.owner_id.as_bytes()));
        try!(buffer.write(self.header_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectGroup {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x65]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectBuy {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x66]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.category_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
        }
        Ok(())
    }
}

impl Message for BuyObjectInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x67]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write(self.data.folder_id.as_bytes()));
        Ok(())
    }
}

impl Message for DerezContainer {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x68]));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_u8(self.data.delete as u8));
        Ok(())
    }
}

impl Message for ObjectPermissions {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x69]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write_u8(self.header_data.override_ as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.field));
            try!(buffer.write_u8(item.set));
            try!(buffer.write_u32::<LittleEndian>(item.mask));
        }
        Ok(())
    }
}

impl Message for ObjectSaleInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
        }
        Ok(())
    }
}

impl Message for ObjectName {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }
}

impl Message for ObjectDescription {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write(&item.description[..]));
        }
        Ok(())
    }
}

impl Message for ObjectCategory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
            try!(buffer.write_u32::<LittleEndian>(item.category));
        }
        Ok(())
    }
}

impl Message for ObjectSelect {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectDeselect {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x6f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectAttach {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x70]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.attachment_point));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        }
        Ok(())
    }
}

impl Message for ObjectDetach {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x71]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectDrop {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x72]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectLink {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x73]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectDelink {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x74]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for ObjectGrab {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x75]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.local_id));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset.z));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }
}

impl Message for ObjectGrabUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x76]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_offset_initial.z));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.object_data.grab_position.z));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.time_since_last));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }
}

impl Message for ObjectDeGrab {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x77]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.local_id));
        // Block SurfaceInfo
        try!(buffer.write_u8(self.surface_info.len() as u8));
        for item in &self.surface_info {
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.uv_coord.z));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.x));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.y));
            try!(buffer.write_f32::<LittleEndian>(item.st_coord.z));
            try!(buffer.write_i32::<LittleEndian>(item.face_index));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.normal.x));
            try!(buffer.write_f32::<LittleEndian>(item.normal.y));
            try!(buffer.write_f32::<LittleEndian>(item.normal.z));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.x));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.y));
            try!(buffer.write_f32::<LittleEndian>(item.binormal.z));
        }
        Ok(())
    }
}

impl Message for ObjectSpinStart {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x78]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }
}

impl Message for ObjectSpinUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x79]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        let normed_rotation = UnitQuaternion::new(&self.object_data.rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
        Ok(())
    }
}

impl Message for ObjectSpinStop {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }
}

impl Message for ObjectExportSelected {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.agent_data.volume_detail));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ModifyLand {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ModifyBlock
        try!(buffer.write_u8(self.modify_block.action));
        try!(buffer.write_u8(self.modify_block.brush_size));
        try!(buffer.write_f32::<LittleEndian>(self.modify_block.seconds));
        try!(buffer.write_f32::<LittleEndian>(self.modify_block.height));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write_i32::<LittleEndian>(item.local_id));
            try!(buffer.write_f32::<LittleEndian>(item.west));
            try!(buffer.write_f32::<LittleEndian>(item.south));
            try!(buffer.write_f32::<LittleEndian>(item.east));
            try!(buffer.write_f32::<LittleEndian>(item.north));
        }
        // Block ModifyBlockExtended
        try!(buffer.write_u8(self.modify_block_extended.len() as u8));
        for item in &self.modify_block_extended {
            try!(buffer.write_f32::<LittleEndian>(item.brush_size));
        }
        Ok(())
    }
}

impl Message for VelocityInterpolateOn {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for VelocityInterpolateOff {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for StateSave {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x7f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block DataBlock
        try!(buffer.write(&self.data_block.filename[..]));
        Ok(())
    }
}

impl Message for ReportAutosaveCrash {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x80]));
        // Block AutosaveData
        try!(buffer.write_i32::<LittleEndian>(self.autosave_data.pid));
        try!(buffer.write_i32::<LittleEndian>(self.autosave_data.status));
        Ok(())
    }
}

impl Message for SimWideDeletes {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x81]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block DataBlock
        try!(buffer.write(self.data_block.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.flags));
        Ok(())
    }
}

impl Message for RequestObjectPropertiesFamily {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.request_flags));
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }
}

impl Message for TrackAgent {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x82]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TargetData
        try!(buffer.write(self.target_data.prey_id.as_bytes()));
        Ok(())
    }
}

impl Message for ViewerStats {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x83]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(&self.agent_data.ip.octets()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.start_time));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.run_time));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.sim_fps));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.fps));
        try!(buffer.write_u8(self.agent_data.agents_in_view));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.ping));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.meters_traveled));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.regions_visited));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.sys_ram));
        try!(buffer.write(&self.agent_data.sys_os[..]));
        try!(buffer.write(&self.agent_data.sys_cpu[..]));
        try!(buffer.write(&self.agent_data.sys_gpu[..]));
        // Block DownloadTotals
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.world));
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.objects));
        try!(buffer.write_u32::<LittleEndian>(self.download_totals.textures));
        // Block NetStats
        for i in 0..2 {
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].bytes));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].packets));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].compressed));
            try!(buffer.write_u32::<LittleEndian>(self.net_stats[i].savings));
        }
        // Block FailStats
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.send_packet));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.dropped));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.resent));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.failed_resends));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.off_circuit));
        try!(buffer.write_u32::<LittleEndian>(self.fail_stats.invalid));
        // Block MiscStats
        try!(buffer.write_u8(self.misc_stats.len() as u8));
        for item in &self.misc_stats {
            try!(buffer.write_u32::<LittleEndian>(item.type_));
            try!(buffer.write_f64::<LittleEndian>(item.value));
        }
        Ok(())
    }
}

impl Message for ScriptAnswerYes {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x84]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.task_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.questions));
        Ok(())
    }
}

impl Message for UserReport {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x85]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.report_type));
        try!(buffer.write_u8(self.report_data.category));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.report_data.position.z));
        try!(buffer.write_u8(self.report_data.check_flags));
        try!(buffer.write(self.report_data.screenshot_id.as_bytes()));
        try!(buffer.write(self.report_data.object_id.as_bytes()));
        try!(buffer.write(self.report_data.abuser_id.as_bytes()));
        try!(buffer.write(&self.report_data.abuse_region_name[..]));
        try!(buffer.write(self.report_data.abuse_region_id.as_bytes()));
        try!(buffer.write(&self.report_data.summary[..]));
        try!(buffer.write(&self.report_data.details[..]));
        try!(buffer.write(&self.report_data.version_string[..]));
        Ok(())
    }
}

impl Message for AlertMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x86]));
        // Block AlertData
        try!(buffer.write(&self.alert_data.message[..]));
        // Block AlertInfo
        try!(buffer.write_u8(self.alert_info.len() as u8));
        for item in &self.alert_info {
            try!(buffer.write(&item.message[..]));
            try!(buffer.write(&item.extra_params[..]));
        }
        Ok(())
    }
}

impl Message for AgentAlertMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x87]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block AlertData
        try!(buffer.write_u8(self.alert_data.modal as u8));
        try!(buffer.write(&self.alert_data.message[..]));
        Ok(())
    }
}

impl Message for MeanCollisionAlert {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x88]));
        // Block MeanCollision
        try!(buffer.write_u8(self.mean_collision.len() as u8));
        for item in &self.mean_collision {
            try!(buffer.write(item.victim.as_bytes()));
            try!(buffer.write(item.perp.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.time));
            try!(buffer.write_f32::<LittleEndian>(item.mag));
            try!(buffer.write_u8(item.type_));
        }
        Ok(())
    }
}

impl Message for ViewerFrozenMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x89]));
        // Block FrozenData
        try!(buffer.write_u8(self.frozen_data.data as u8));
        Ok(())
    }
}

impl Message for HealthMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8a]));
        // Block HealthData
        try!(buffer.write_f32::<LittleEndian>(self.health_data.health));
        Ok(())
    }
}

impl Message for ChatFromSimulator {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8b]));
        // Block ChatData
        try!(buffer.write(&self.chat_data.from_name[..]));
        try!(buffer.write(self.chat_data.source_id.as_bytes()));
        try!(buffer.write(self.chat_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.chat_data.source_type));
        try!(buffer.write_u8(self.chat_data.chat_type));
        try!(buffer.write_u8(self.chat_data.audible));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.z));
        try!(buffer.write(&self.chat_data.message[..]));
        Ok(())
    }
}

impl Message for SimStats {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8c]));
        // Block Region
        try!(buffer.write_u32::<LittleEndian>(self.region.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.region.region_y));
        try!(buffer.write_u32::<LittleEndian>(self.region.region_flags));
        try!(buffer.write_u32::<LittleEndian>(self.region.object_capacity));
        // Block Stat
        try!(buffer.write_u8(self.stat.len() as u8));
        for item in &self.stat {
            try!(buffer.write_u32::<LittleEndian>(item.stat_id));
            try!(buffer.write_f32::<LittleEndian>(item.stat_value));
        }
        // Block PidStat
        try!(buffer.write_i32::<LittleEndian>(self.pid_stat.pid));
        Ok(())
    }
}

impl Message for RequestRegionInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for RegionInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_u8(self.region_info.sim_access));
        try!(buffer.write_u8(self.region_info.max_agents));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.object_bonus_factor));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.water_height));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_raise_limit));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_lower_limit));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y));
        try!(buffer.write_u8(self.region_info.use_estate_sun as u8));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.sun_hour));
        // Block RegionInfo2
        try!(buffer.write(&self.region_info2.product_sku[..]));
        try!(buffer.write(&self.region_info2.product_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.max_agents32));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_agents));
        try!(buffer.write_u32::<LittleEndian>(self.region_info2.hard_max_objects));
        Ok(())
    }
}

impl Message for GodUpdateRegionInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x8f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.parent_estate_id));
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.price_per_meter));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_x));
        try!(buffer.write_i32::<LittleEndian>(self.region_info.redirect_grid_y));
        Ok(())
    }
}

impl Message for NearestLandingRegionRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x90]));
        // Block RequestingRegionData
        try!(buffer.write_u64::<LittleEndian>(self.requesting_region_data.region_handle));
        Ok(())
    }
}

impl Message for NearestLandingRegionReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x91]));
        // Block LandingRegionData
        try!(buffer.write_u64::<LittleEndian>(self.landing_region_data.region_handle));
        Ok(())
    }
}

impl Message for NearestLandingRegionUpdated {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x92]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        Ok(())
    }
}

impl Message for TeleportLandingStatusChanged {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x93]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        Ok(())
    }
}

impl Message for RegionHandshake {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x94]));
        // Block RegionInfo
        try!(buffer.write_u32::<LittleEndian>(self.region_info.region_flags));
        try!(buffer.write_u8(self.region_info.sim_access));
        try!(buffer.write(&self.region_info.sim_name[..]));
        try!(buffer.write(self.region_info.sim_owner.as_bytes()));
        try!(buffer.write_u8(self.region_info.is_estate_manager as u8));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.water_height));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.billable_factor));
        try!(buffer.write(self.region_info.cache_id.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base0.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base1.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base2.as_bytes()));
        try!(buffer.write(self.region_info.terrain_base3.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail0.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail1.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail2.as_bytes()));
        try!(buffer.write(self.region_info.terrain_detail3.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height00));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height01));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height10));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_start_height11));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range00));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range01));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range10));
        try!(buffer.write_f32::<LittleEndian>(self.region_info.terrain_height_range11));
        // Block RegionInfo2
        try!(buffer.write(self.region_info2.region_id.as_bytes()));
        // Block RegionInfo3
        try!(buffer.write_i32::<LittleEndian>(self.region_info3.cpu_class_id));
        try!(buffer.write_i32::<LittleEndian>(self.region_info3.cpu_ratio));
        try!(buffer.write(&self.region_info3.colo_name[..]));
        try!(buffer.write(&self.region_info3.product_sku[..]));
        try!(buffer.write(&self.region_info3.product_name[..]));
        Ok(())
    }
}

impl Message for RegionHandshakeReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x95]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionInfo
        try!(buffer.write_u32::<LittleEndian>(self.region_info.flags));
        Ok(())
    }
}

impl Message for CoarseLocationUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x06]));
        // Block Location
        try!(buffer.write_u8(self.location.len() as u8));
        for item in &self.location {
            try!(buffer.write_u8(item.x));
            try!(buffer.write_u8(item.y));
            try!(buffer.write_u8(item.z));
        }
        // Block Index
        try!(buffer.write_i16::<LittleEndian>(self.index.you));
        try!(buffer.write_i16::<LittleEndian>(self.index.prey));
        // Block AgentData
        try!(buffer.write_u8(self.agent_data.len() as u8));
        for item in &self.agent_data {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ImageData {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x09]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        try!(buffer.write_u8(self.image_id.codec));
        try!(buffer.write_u32::<LittleEndian>(self.image_id.size));
        try!(buffer.write_u16::<LittleEndian>(self.image_id.packets));
        // Block ImageData
        try!(buffer.write(&self.image_data.data[..]));
        Ok(())
    }
}

impl Message for ImagePacket {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0a]));
        // Block ImageID
        try!(buffer.write(self.image_id.id.as_bytes()));
        try!(buffer.write_u16::<LittleEndian>(self.image_id.packet));
        // Block ImageData
        try!(buffer.write(&self.image_data.data[..]));
        Ok(())
    }
}

impl Message for LayerData {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0b]));
        // Block LayerID
        try!(buffer.write_u8(self.layer_id.type_));
        // Block LayerData
        try!(buffer.write(&self.layer_data.data[..]));
        Ok(())
    }
}

impl Message for ObjectUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0c]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
            try!(buffer.write_u8(item.state));
            try!(buffer.write(item.full_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
            try!(buffer.write_u8(item.p_code));
            try!(buffer.write_u8(item.material));
            try!(buffer.write_u8(item.click_action));
            try!(buffer.write_f32::<LittleEndian>(item.scale.x));
            try!(buffer.write_f32::<LittleEndian>(item.scale.y));
            try!(buffer.write_f32::<LittleEndian>(item.scale.z));
            try!(buffer.write(&item.object_data[..]));
            try!(buffer.write_u32::<LittleEndian>(item.parent_id));
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
            try!(buffer.write_u8(item.path_curve));
            try!(buffer.write_u8(item.profile_curve));
            try!(buffer.write_u16::<LittleEndian>(item.path_begin));
            try!(buffer.write_u16::<LittleEndian>(item.path_end));
            try!(buffer.write_u8(item.path_scale_x));
            try!(buffer.write_u8(item.path_scale_y));
            try!(buffer.write_u8(item.path_shear_x));
            try!(buffer.write_u8(item.path_shear_y));
            try!(buffer.write_i8(item.path_twist));
            try!(buffer.write_i8(item.path_twist_begin));
            try!(buffer.write_i8(item.path_radius_offset));
            try!(buffer.write_i8(item.path_taper_x));
            try!(buffer.write_i8(item.path_taper_y));
            try!(buffer.write_u8(item.path_revolutions));
            try!(buffer.write_i8(item.path_skew));
            try!(buffer.write_u16::<LittleEndian>(item.profile_begin));
            try!(buffer.write_u16::<LittleEndian>(item.profile_end));
            try!(buffer.write_u16::<LittleEndian>(item.profile_hollow));
            try!(buffer.write(&item.texture_entry[..]));
            try!(buffer.write(&item.texture_anim[..]));
            try!(buffer.write(&item.name_value[..]));
            try!(buffer.write(&item.data[..]));
            try!(buffer.write(&item.text[..]));
            try!(buffer.write(&item.text_color));
            try!(buffer.write(&item.media_url[..]));
            try!(buffer.write(&item.ps_block[..]));
            try!(buffer.write(&item.extra_params[..]));
            try!(buffer.write(item.sound.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.gain));
            try!(buffer.write_u8(item.flags));
            try!(buffer.write_f32::<LittleEndian>(item.radius));
            try!(buffer.write_u8(item.joint_type));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.x));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.y));
            try!(buffer.write_f32::<LittleEndian>(item.joint_pivot.z));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.x));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.y));
            try!(buffer.write_f32::<LittleEndian>(item.joint_axis_or_anchor.z));
        }
        Ok(())
    }
}

impl Message for ObjectUpdateCompressed {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0d]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
            try!(buffer.write(&item.data[..]));
        }
        Ok(())
    }
}

impl Message for ObjectUpdateCached {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0e]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
            try!(buffer.write_u32::<LittleEndian>(item.update_flags));
        }
        Ok(())
    }
}

impl Message for ImprovedTerseObjectUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x0f]));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.time_dilation));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(&item.data[..]));
            try!(buffer.write(&item.texture_entry[..]));
        }
        Ok(())
    }
}

impl Message for KillObject {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x10]));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.id));
        }
        Ok(())
    }
}

impl Message for CrossedRegion {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RegionData
        try!(buffer.write(&self.region_data.sim_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.region_data.sim_port));
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        try!(buffer.write(&self.region_data.seed_capability[..]));
        // Block Info
        try!(buffer.write_f32::<LittleEndian>(self.info.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.info.look_at.z));
        Ok(())
    }
}

impl Message for SimulatorViewerTimeMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x96]));
        // Block TimeInfo
        try!(buffer.write_u64::<LittleEndian>(self.time_info.usec_since_start));
        try!(buffer.write_u32::<LittleEndian>(self.time_info.sec_per_day));
        try!(buffer.write_u32::<LittleEndian>(self.time_info.sec_per_year));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.x));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.y));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_direction.z));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_phase));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.x));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.y));
        try!(buffer.write_f32::<LittleEndian>(self.time_info.sun_ang_velocity.z));
        Ok(())
    }
}

impl Message for EnableSimulator {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x97]));
        // Block SimulatorInfo
        try!(buffer.write_u64::<LittleEndian>(self.simulator_info.handle));
        try!(buffer.write(&self.simulator_info.ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.simulator_info.port));
        Ok(())
    }
}

impl Message for DisableSimulator {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x98]));
        Ok(())
    }
}

impl Message for ConfirmEnableSimulator {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for TransferRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x99]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.source_type));
        try!(buffer.write_f32::<LittleEndian>(self.transfer_info.priority));
        try!(buffer.write(&self.transfer_info.params[..]));
        Ok(())
    }
}

impl Message for TransferInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9a]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.target_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.status));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.size));
        try!(buffer.write(&self.transfer_info.params[..]));
        Ok(())
    }
}

impl Message for TransferPacket {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x11]));
        // Block TransferData
        try!(buffer.write(self.transfer_data.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.channel_type));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.packet));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_data.status));
        try!(buffer.write(&self.transfer_data.data[..]));
        Ok(())
    }
}

impl Message for TransferAbort {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9b]));
        // Block TransferInfo
        try!(buffer.write(self.transfer_info.transfer_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.transfer_info.channel_type));
        Ok(())
    }
}

impl Message for RequestXfer {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9c]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write(&self.xfer_id.filename[..]));
        try!(buffer.write_u8(self.xfer_id.file_path));
        try!(buffer.write_u8(self.xfer_id.delete_on_completion as u8));
        try!(buffer.write_u8(self.xfer_id.use_big_packets as u8));
        try!(buffer.write(self.xfer_id.v_file_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.xfer_id.v_file_type));
        Ok(())
    }
}

impl Message for SendXferPacket {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x12]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_u32::<LittleEndian>(self.xfer_id.packet));
        // Block DataPacket
        try!(buffer.write(&self.data_packet.data[..]));
        Ok(())
    }
}

impl Message for ConfirmXferPacket {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x13]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_u32::<LittleEndian>(self.xfer_id.packet));
        Ok(())
    }
}

impl Message for AbortXfer {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9d]));
        // Block XferID
        try!(buffer.write_u64::<LittleEndian>(self.xfer_id.id));
        try!(buffer.write_i32::<LittleEndian>(self.xfer_id.result));
        Ok(())
    }
}

impl Message for AvatarAnimation {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x14]));
        // Block Sender
        try!(buffer.write(self.sender.id.as_bytes()));
        // Block AnimationList
        try!(buffer.write_u8(self.animation_list.len() as u8));
        for item in &self.animation_list {
            try!(buffer.write(item.anim_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.anim_sequence_id));
        }
        // Block AnimationSourceList
        try!(buffer.write_u8(self.animation_source_list.len() as u8));
        for item in &self.animation_source_list {
            try!(buffer.write(item.object_id.as_bytes()));
        }
        // Block PhysicalAvatarEventList
        try!(buffer.write_u8(self.physical_avatar_event_list.len() as u8));
        for item in &self.physical_avatar_event_list {
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }
}

impl Message for AvatarAppearance {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9e]));
        // Block Sender
        try!(buffer.write(self.sender.id.as_bytes()));
        try!(buffer.write_u8(self.sender.is_trial as u8));
        // Block ObjectData
        try!(buffer.write(&self.object_data.texture_entry[..]));
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        Ok(())
    }
}

impl Message for AvatarSitResponse {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x15]));
        // Block SitObject
        try!(buffer.write(self.sit_object.id.as_bytes()));
        // Block SitTransform
        try!(buffer.write_u8(self.sit_transform.auto_pilot as u8));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.sit_position.z));
        let normed_sit_rotation = UnitQuaternion::new(&self.sit_transform.sit_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_sit_rotation.k));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_eye_offset.z));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.x));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.y));
        try!(buffer.write_f32::<LittleEndian>(self.sit_transform.camera_at_offset.z));
        try!(buffer.write_u8(self.sit_transform.force_mouselook as u8));
        Ok(())
    }
}

impl Message for SetFollowCamProperties {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0x9f]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        // Block CameraProperty
        try!(buffer.write_u8(self.camera_property.len() as u8));
        for item in &self.camera_property {
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.value));
        }
        Ok(())
    }
}

impl Message for ClearFollowCamProperties {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa0]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }
}

impl Message for CameraConstraint {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x16]));
        // Block CameraCollidePlane
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.x));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.y));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.z));
        try!(buffer.write_f32::<LittleEndian>(self.camera_collide_plane.plane.w));
        Ok(())
    }
}

impl Message for ObjectProperties {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x09]));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_i32::<LittleEndian>(item.ownership_cost));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write_u8(item.aggregate_perms));
            try!(buffer.write_u8(item.aggregate_perm_textures));
            try!(buffer.write_u8(item.aggregate_perm_textures_owner));
            try!(buffer.write_u32::<LittleEndian>(item.category));
            try!(buffer.write_i16::<LittleEndian>(item.inventory_serial));
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.from_task_id.as_bytes()));
            try!(buffer.write(item.last_owner_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write(&item.touch_name[..]));
            try!(buffer.write(&item.sit_name[..]));
            try!(buffer.write(&item.texture_id[..]));
        }
        Ok(())
    }
}

impl Message for ObjectPropertiesFamily {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0a]));
        // Block ObjectData
        try!(buffer.write_u32::<LittleEndian>(self.object_data.request_flags));
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write(self.object_data.owner_id.as_bytes()));
        try!(buffer.write(self.object_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.ownership_cost));
        try!(buffer.write_u8(self.object_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.sale_price));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.category));
        try!(buffer.write(self.object_data.last_owner_id.as_bytes()));
        try!(buffer.write(&self.object_data.name[..]));
        try!(buffer.write(&self.object_data.description[..]));
        Ok(())
    }
}

impl Message for RequestPayPrice {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa1]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        Ok(())
    }
}

impl Message for PayPriceReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa2]));
        // Block ObjectData
        try!(buffer.write(self.object_data.object_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.object_data.default_pay_price));
        // Block ButtonData
        try!(buffer.write_u8(self.button_data.len() as u8));
        for item in &self.button_data {
            try!(buffer.write_i32::<LittleEndian>(item.pay_button));
        }
        Ok(())
    }
}

impl Message for KickUser {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa3]));
        // Block TargetBlock
        try!(buffer.write(&self.target_block.target_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.target_block.target_port));
        // Block UserInfo
        try!(buffer.write(self.user_info.agent_id.as_bytes()));
        try!(buffer.write(self.user_info.session_id.as_bytes()));
        try!(buffer.write(&self.user_info.reason[..]));
        Ok(())
    }
}

impl Message for KickUserAck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa4]));
        // Block UserInfo
        try!(buffer.write(self.user_info.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.user_info.flags));
        Ok(())
    }
}

impl Message for GodKickUser {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa5]));
        // Block UserInfo
        try!(buffer.write(self.user_info.god_id.as_bytes()));
        try!(buffer.write(self.user_info.god_session_id.as_bytes()));
        try!(buffer.write(self.user_info.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.user_info.kick_flags));
        try!(buffer.write(&self.user_info.reason[..]));
        Ok(())
    }
}

impl Message for SystemKickUser {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa6]));
        // Block AgentInfo
        try!(buffer.write_u8(self.agent_info.len() as u8));
        for item in &self.agent_info {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for EjectUser {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        Ok(())
    }
}

impl Message for FreezeUser {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        Ok(())
    }
}

impl Message for AvatarPropertiesRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xa9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        Ok(())
    }
}

impl Message for AvatarPropertiesRequestBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xaa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.god_level));
        try!(buffer.write_u8(self.agent_data.web_profiles_disabled as u8));
        Ok(())
    }
}

impl Message for AvatarPropertiesReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xab]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write(self.properties_data.image_id.as_bytes()));
        try!(buffer.write(self.properties_data.fl_image_id.as_bytes()));
        try!(buffer.write(self.properties_data.partner_id.as_bytes()));
        try!(buffer.write(&self.properties_data.about_text[..]));
        try!(buffer.write(&self.properties_data.fl_about_text[..]));
        try!(buffer.write(&self.properties_data.born_on[..]));
        try!(buffer.write(&self.properties_data.profile_url[..]));
        try!(buffer.write(&self.properties_data.charter_member[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.flags));
        Ok(())
    }
}

impl Message for AvatarInterestsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xac]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask));
        try!(buffer.write(&self.properties_data.want_to_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask));
        try!(buffer.write(&self.properties_data.skills_text[..]));
        try!(buffer.write(&self.properties_data.languages_text[..]));
        Ok(())
    }
}

impl Message for AvatarGroupsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xad]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.avatar_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
            try!(buffer.write(&item.group_title[..]));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
            try!(buffer.write(item.group_insignia_id.as_bytes()));
        }
        // Block NewGroupData
        try!(buffer.write_u8(self.new_group_data.list_in_profile as u8));
        Ok(())
    }
}

impl Message for AvatarPropertiesUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xae]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write(self.properties_data.image_id.as_bytes()));
        try!(buffer.write(self.properties_data.fl_image_id.as_bytes()));
        try!(buffer.write(&self.properties_data.about_text[..]));
        try!(buffer.write(&self.properties_data.fl_about_text[..]));
        try!(buffer.write_u8(self.properties_data.allow_publish as u8));
        try!(buffer.write_u8(self.properties_data.mature_publish as u8));
        try!(buffer.write(&self.properties_data.profile_url[..]));
        Ok(())
    }
}

impl Message for AvatarInterestsUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xaf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block PropertiesData
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.want_to_mask));
        try!(buffer.write(&self.properties_data.want_to_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.properties_data.skills_mask));
        try!(buffer.write(&self.properties_data.skills_text[..]));
        try!(buffer.write(&self.properties_data.languages_text[..]));
        Ok(())
    }
}

impl Message for AvatarNotesReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write(&self.data.notes[..]));
        Ok(())
    }
}

impl Message for AvatarNotesUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.target_id.as_bytes()));
        try!(buffer.write(&self.data.notes[..]));
        Ok(())
    }
}

impl Message for AvatarPicksReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb2]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.target_id.as_bytes()));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.pick_id.as_bytes()));
            try!(buffer.write(&item.pick_name[..]));
        }
        Ok(())
    }
}

impl Message for EventInfoRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }
}

impl Message for EventInfoReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        try!(buffer.write(&self.event_data.creator[..]));
        try!(buffer.write(&self.event_data.name[..]));
        try!(buffer.write(&self.event_data.category[..]));
        try!(buffer.write(&self.event_data.desc[..]));
        try!(buffer.write(&self.event_data.date[..]));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.date_utc));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.duration));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.cover));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.amount));
        try!(buffer.write(&self.event_data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.x));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.y));
        try!(buffer.write_f64::<LittleEndian>(self.event_data.global_pos.z));
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_flags));
        Ok(())
    }
}

impl Message for EventNotificationAddRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }
}

impl Message for EventNotificationRemoveRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }
}

impl Message for EventGodDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(&self.query_data.query_text[..]));
        try!(buffer.write_u32::<LittleEndian>(self.query_data.query_flags));
        try!(buffer.write_i32::<LittleEndian>(self.query_data.query_start));
        Ok(())
    }
}

impl Message for PickInfoReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u8(self.data.top_pick as u8));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.data.user[..]));
        try!(buffer.write(&self.data.original_name[..]));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_i32::<LittleEndian>(self.data.sort_order));
        try!(buffer.write_u8(self.data.enabled as u8));
        Ok(())
    }
}

impl Message for PickInfoUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xb9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.creator_id.as_bytes()));
        try!(buffer.write_u8(self.data.top_pick as u8));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write(&self.data.name[..]));
        try!(buffer.write(&self.data.desc[..]));
        try!(buffer.write(self.data.snapshot_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.data.pos_global.z));
        try!(buffer.write_i32::<LittleEndian>(self.data.sort_order));
        try!(buffer.write_u8(self.data.enabled as u8));
        Ok(())
    }
}

impl Message for PickDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xba]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        Ok(())
    }
}

impl Message for PickGodDelete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.pick_id.as_bytes()));
        try!(buffer.write(self.data.query_id.as_bytes()));
        Ok(())
    }
}

impl Message for ScriptQuestion {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbc]));
        // Block Data
        try!(buffer.write(self.data.task_id.as_bytes()));
        try!(buffer.write(self.data.item_id.as_bytes()));
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.object_owner[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.questions));
        Ok(())
    }
}

impl Message for ScriptControlChange {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbd]));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u8(item.take_controls as u8));
            try!(buffer.write_u32::<LittleEndian>(item.controls));
            try!(buffer.write_u8(item.pass_to_agent as u8));
        }
        Ok(())
    }
}

impl Message for ScriptDialog {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbe]));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(&self.data.first_name[..]));
        try!(buffer.write(&self.data.last_name[..]));
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data.chat_channel));
        try!(buffer.write(self.data.image_id.as_bytes()));
        // Block Buttons
        try!(buffer.write_u8(self.buttons.len() as u8));
        for item in &self.buttons {
            try!(buffer.write(&item.button_label[..]));
        }
        // Block OwnerData
        try!(buffer.write_u8(self.owner_data.len() as u8));
        for item in &self.owner_data {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ScriptDialogReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xbf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.chat_channel));
        try!(buffer.write_i32::<LittleEndian>(self.data.button_index));
        try!(buffer.write(&self.data.button_label[..]));
        Ok(())
    }
}

impl Message for ForceScriptControlRelease {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for RevokePermissions {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.object_permissions));
        Ok(())
    }
}

impl Message for LoadURL {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc2]));
        // Block Data
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(self.data.object_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.data.owner_is_group as u8));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write(&self.data.url[..]));
        Ok(())
    }
}

impl Message for ScriptTeleportRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc3]));
        // Block Data
        try!(buffer.write(&self.data.object_name[..]));
        try!(buffer.write(&self.data.sim_name[..]));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.sim_position.z));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.z));
        Ok(())
    }
}

impl Message for ParcelOverlay {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc4]));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write(&self.parcel_data.data[..]));
        Ok(())
    }
}

impl Message for ParcelPropertiesRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        try!(buffer.write_u8(self.parcel_data.snap_selection as u8));
        Ok(())
    }
}

impl Message for ParcelPropertiesRequestByID {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }
}

impl Message for ParcelProperties {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x17]));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.request_result));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sequence_id));
        try!(buffer.write_u8(self.parcel_data.snap_selection as u8));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.self_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.public_count));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write(self.parcel_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.is_group_owned as u8));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.auction_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.claim_date));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.claim_price));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.rent_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_min.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.aabb_max.z));
        try!(buffer.write(&self.parcel_data.bitmap[..]));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.area));
        try!(buffer.write_u8(self.parcel_data.status));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_max_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sim_wide_total_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.max_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.total_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.owner_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.group_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_prims));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.selected_prims));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.parcel_prim_bonus));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.desc[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write(&self.parcel_data.media_url[..]));
        try!(buffer.write(self.parcel_data.media_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.media_auto_scale));
        try!(buffer.write(self.parcel_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.auth_buyer_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z));
        try!(buffer.write_u8(self.parcel_data.landing_type));
        try!(buffer.write_u8(self.parcel_data.region_push_override as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_anonymous as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_identified as u8));
        try!(buffer.write_u8(self.parcel_data.region_deny_transacted as u8));
        // Block AgeVerificationBlock
        try!(buffer.write_u8(self.age_verification_block.region_deny_age_unverified as u8));
        Ok(())
    }
}

impl Message for ParcelPropertiesUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.parcel_flags));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.desc[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write(&self.parcel_data.media_url[..]));
        try!(buffer.write(self.parcel_data.media_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.media_auto_scale));
        try!(buffer.write(self.parcel_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.pass_price));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.pass_hours));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.auth_buyer_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_look_at.z));
        try!(buffer.write_u8(self.parcel_data.landing_type));
        Ok(())
    }
}

impl Message for ParcelReturnObjects {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block TaskIDs
        try!(buffer.write_u8(self.task_i_ds.len() as u8));
        for item in &self.task_i_ds {
            try!(buffer.write(item.task_id.as_bytes()));
        }
        // Block OwnerIDs
        try!(buffer.write_u8(self.owner_i_ds.len() as u8));
        for item in &self.owner_i_ds {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ParcelSetOtherCleanTime {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.other_clean_time));
        Ok(())
    }
}

impl Message for ParcelDisableObjects {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xc9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block TaskIDs
        try!(buffer.write_u8(self.task_i_ds.len() as u8));
        for item in &self.task_i_ds {
            try!(buffer.write(item.task_id.as_bytes()));
        }
        // Block OwnerIDs
        try!(buffer.write_u8(self.owner_i_ds.len() as u8));
        for item in &self.owner_i_ds {
            try!(buffer.write(item.owner_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ParcelSelectObjects {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xca]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write_u32::<LittleEndian>(self.parcel_data.return_type));
        // Block ReturnIDs
        try!(buffer.write_u8(self.return_i_ds.len() as u8));
        for item in &self.return_i_ds {
            try!(buffer.write(item.return_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for EstateCovenantRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for EstateCovenantReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcc]));
        // Block Data
        try!(buffer.write(self.data.covenant_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.covenant_timestamp));
        try!(buffer.write(&self.data.estate_name[..]));
        try!(buffer.write(self.data.estate_owner_id.as_bytes()));
        Ok(())
    }
}

impl Message for ForceObjectSelect {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcd]));
        // Block Header
        try!(buffer.write_u8(self.header.reset_list as u8));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u32::<LittleEndian>(item.local_id));
        }
        Ok(())
    }
}

impl Message for ParcelBuyPass {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xce]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }
}

impl Message for ParcelDeedToGroup {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xcf]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }
}

impl Message for ParcelReclaim {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }
}

impl Message for ParcelClaim {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.is_group_owned as u8));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write_f32::<LittleEndian>(item.west));
            try!(buffer.write_f32::<LittleEndian>(item.south));
            try!(buffer.write_f32::<LittleEndian>(item.east));
            try!(buffer.write_f32::<LittleEndian>(item.north));
        }
        Ok(())
    }
}

impl Message for ParcelJoin {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd2]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        Ok(())
    }
}

impl Message for ParcelDivide {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.west));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.south));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.east));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.north));
        Ok(())
    }
}

impl Message for ParcelRelease {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }
}

impl Message for ParcelBuy {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.is_group_owned as u8));
        try!(buffer.write_u8(self.data.remove_contribution as u8));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.price));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.area));
        Ok(())
    }
}

impl Message for ParcelGodForceOwner {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }
}

impl Message for ParcelAccessListRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        Ok(())
    }
}

impl Message for ParcelAccessListReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd8]));
        // Block Data
        try!(buffer.write(self.data.agent_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        // Block List
        try!(buffer.write_u8(self.list.len() as u8));
        for item in &self.list {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.time));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }
}

impl Message for ParcelAccessListUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xd9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_u32::<LittleEndian>(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.transaction_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.sequence_id));
        try!(buffer.write_i32::<LittleEndian>(self.data.sections));
        // Block List
        try!(buffer.write_u8(self.list.len() as u8));
        for item in &self.list {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.time));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }
}

impl Message for ParcelDwellRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xda]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        Ok(())
    }
}

impl Message for ParcelDwellReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdb]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.local_id));
        try!(buffer.write(self.data.parcel_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data.dwell));
        Ok(())
    }
}

impl Message for RequestParcelTransfer {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdc]));
        // Block Data
        try!(buffer.write(self.data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data.transaction_time));
        try!(buffer.write(self.data.source_id.as_bytes()));
        try!(buffer.write(self.data.dest_id.as_bytes()));
        try!(buffer.write(self.data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.data.transaction_type));
        try!(buffer.write_i32::<LittleEndian>(self.data.amount));
        try!(buffer.write_i32::<LittleEndian>(self.data.billable_area));
        try!(buffer.write_i32::<LittleEndian>(self.data.actual_area));
        try!(buffer.write_u8(self.data.final_ as u8));
        // Block RegionData
        try!(buffer.write(self.region_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.region_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.region_data.grid_y));
        Ok(())
    }
}

impl Message for UpdateParcel {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdd]));
        // Block ParcelData
        try!(buffer.write(self.parcel_data.parcel_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.parcel_data.region_handle));
        try!(buffer.write(self.parcel_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.group_owned as u8));
        try!(buffer.write_u8(self.parcel_data.status));
        try!(buffer.write(&self.parcel_data.name[..]));
        try!(buffer.write(&self.parcel_data.description[..]));
        try!(buffer.write(&self.parcel_data.music_url[..]));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.region_x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.region_y));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.actual_area));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.billable_area));
        try!(buffer.write_u8(self.parcel_data.show_dir as u8));
        try!(buffer.write_u8(self.parcel_data.is_for_sale as u8));
        try!(buffer.write_u8(self.parcel_data.category));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.x));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.y));
        try!(buffer.write_f32::<LittleEndian>(self.parcel_data.user_location.z));
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.sale_price));
        try!(buffer.write(self.parcel_data.authorized_buyer_id.as_bytes()));
        try!(buffer.write_u8(self.parcel_data.allow_publish as u8));
        try!(buffer.write_u8(self.parcel_data.mature_publish as u8));
        Ok(())
    }
}

impl Message for RemoveParcel {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xde]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for MergeParcel {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xdf]));
        // Block MasterParcelData
        try!(buffer.write(self.master_parcel_data.master_id.as_bytes()));
        // Block SlaveParcelData
        try!(buffer.write_u8(self.slave_parcel_data.len() as u8));
        for item in &self.slave_parcel_data {
            try!(buffer.write(item.slave_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for LogParcelChanges {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block RegionData
        try!(buffer.write_u64::<LittleEndian>(self.region_data.region_handle));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.is_owner_group as u8));
            try!(buffer.write_i32::<LittleEndian>(item.actual_area));
            try!(buffer.write_i8(item.action));
            try!(buffer.write(item.transaction_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for CheckParcelSales {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe1]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }
}

impl Message for ParcelSales {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe2]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.buyer_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ParcelGodMarkAsContent {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe3]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        Ok(())
    }
}

impl Message for ViewerStartAuction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe4]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write_i32::<LittleEndian>(self.parcel_data.local_id));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        Ok(())
    }
}

impl Message for StartAuction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block ParcelData
        try!(buffer.write(self.parcel_data.parcel_id.as_bytes()));
        try!(buffer.write(self.parcel_data.snapshot_id.as_bytes()));
        try!(buffer.write(&self.parcel_data.name[..]));
        Ok(())
    }
}

impl Message for ConfirmAuctionStart {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe6]));
        // Block AuctionData
        try!(buffer.write(self.auction_data.parcel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.auction_data.auction_id));
        Ok(())
    }
}

impl Message for CompleteAuction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe7]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for CancelAuction {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe8]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for CheckParcelAuctions {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xe9]));
        // Block RegionData
        try!(buffer.write_u8(self.region_data.len() as u8));
        for item in &self.region_data {
            try!(buffer.write_u64::<LittleEndian>(item.region_handle));
        }
        Ok(())
    }
}

impl Message for ParcelAuctions {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xea]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(item.winner_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UUIDNameRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xeb]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UUIDNameReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xec]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(&item.first_name[..]));
            try!(buffer.write(&item.last_name[..]));
        }
        Ok(())
    }
}

impl Message for UUIDGroupNameRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xed]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UUIDGroupNameReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xee]));
        // Block UUIDNameBlock
        try!(buffer.write_u8(self.uuid_name_block.len() as u8));
        for item in &self.uuid_name_block {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(&item.group_name[..]));
        }
        Ok(())
    }
}

impl Message for ChatPass {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xef]));
        // Block ChatData
        try!(buffer.write_i32::<LittleEndian>(self.chat_data.channel));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.position.z));
        try!(buffer.write(self.chat_data.id.as_bytes()));
        try!(buffer.write(self.chat_data.owner_id.as_bytes()));
        try!(buffer.write(&self.chat_data.name[..]));
        try!(buffer.write_u8(self.chat_data.source_type));
        try!(buffer.write_u8(self.chat_data.type_));
        try!(buffer.write_f32::<LittleEndian>(self.chat_data.radius));
        try!(buffer.write_u8(self.chat_data.sim_access));
        try!(buffer.write(&self.chat_data.message[..]));
        Ok(())
    }
}

impl Message for EdgeDataPacket {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x18]));
        // Block EdgeData
        try!(buffer.write_u8(self.edge_data.layer_type));
        try!(buffer.write_u8(self.edge_data.direction));
        try!(buffer.write(&self.edge_data.layer_data[..]));
        Ok(())
    }
}

impl Message for SimStatus {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0c]));
        // Block SimStatus
        try!(buffer.write_u8(self.sim_status.can_accept_agents as u8));
        try!(buffer.write_u8(self.sim_status.can_accept_tasks as u8));
        Ok(())
    }
}

impl Message for ChildAgentUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x19]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z));
        try!(buffer.write_u8(self.agent_data.changed_grid as u8));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.far));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.aspect));
        try!(buffer.write(&self.agent_data.throttles[..]));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.locomotion_state));
        let normed_head_rotation = UnitQuaternion::new(&self.agent_data.head_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_head_rotation.k));
        let normed_body_rotation = UnitQuaternion::new(&self.agent_data.body_rotation).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.i));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.j));
        try!(buffer.write_f32::<LittleEndian>(normed_body_rotation.k));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.control_flags));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.energy_level));
        try!(buffer.write_u8(self.agent_data.god_level));
        try!(buffer.write_u8(self.agent_data.always_run as u8));
        try!(buffer.write(self.agent_data.prey_agent.as_bytes()));
        try!(buffer.write_u8(self.agent_data.agent_access));
        try!(buffer.write(&self.agent_data.agent_textures[..]));
        try!(buffer.write(self.agent_data.active_group_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
        }
        // Block AnimationData
        try!(buffer.write_u8(self.animation_data.len() as u8));
        for item in &self.animation_data {
            try!(buffer.write(item.animation.as_bytes()));
            try!(buffer.write(item.object_id.as_bytes()));
        }
        // Block GranterBlock
        try!(buffer.write_u8(self.granter_block.len() as u8));
        for item in &self.granter_block {
            try!(buffer.write(item.granter_id.as_bytes()));
        }
        // Block NVPairData
        try!(buffer.write_u8(self.nv_pair_data.len() as u8));
        for item in &self.nv_pair_data {
            try!(buffer.write(&item.nv_pairs[..]));
        }
        // Block VisualParam
        try!(buffer.write_u8(self.visual_param.len() as u8));
        for item in &self.visual_param {
            try!(buffer.write_u8(item.param_value));
        }
        // Block AgentAccess
        try!(buffer.write_u8(self.agent_access.len() as u8));
        for item in &self.agent_access {
            try!(buffer.write_u8(item.agent_legacy_access));
            try!(buffer.write_u8(item.agent_max_access));
        }
        // Block AgentInfo
        try!(buffer.write_u8(self.agent_info.len() as u8));
        for item in &self.agent_info {
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }
}

impl Message for ChildAgentAlive {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x1a]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for ChildAgentPositionUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x1b]));
        // Block AgentData
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.viewer_circuit_code));
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.agent_vel.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.center.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.size.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.at_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.left_axis.z));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.x));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.y));
        try!(buffer.write_f32::<LittleEndian>(self.agent_data.up_axis.z));
        try!(buffer.write_u8(self.agent_data.changed_grid as u8));
        Ok(())
    }
}

impl Message for ChildAgentDying {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf0]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for ChildAgentUnknown {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf1]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for AtomicPassObject {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x1c]));
        // Block TaskData
        try!(buffer.write(self.task_data.task_id.as_bytes()));
        try!(buffer.write_u8(self.task_data.attachment_needs_save as u8));
        Ok(())
    }
}

impl Message for KillChildAgents {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf2]));
        // Block IDBlock
        try!(buffer.write(self.id_block.agent_id.as_bytes()));
        Ok(())
    }
}

impl Message for GetScriptRunning {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf3]));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for ScriptRunningReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf4]));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        try!(buffer.write_u8(self.script.running as u8));
        Ok(())
    }
}

impl Message for SetScriptRunning {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        try!(buffer.write_u8(self.script.running as u8));
        Ok(())
    }
}

impl Message for ScriptReset {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf6]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Script
        try!(buffer.write(self.script.object_id.as_bytes()));
        try!(buffer.write(self.script.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for ScriptSensorRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf7]));
        // Block Requester
        try!(buffer.write(self.requester.source_id.as_bytes()));
        try!(buffer.write(self.requester.request_id.as_bytes()));
        try!(buffer.write(self.requester.search_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.requester.search_pos.z));
        let normed_search_dir = UnitQuaternion::new(&self.requester.search_dir).unwrap();
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.i));
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.j));
        try!(buffer.write_f32::<LittleEndian>(normed_search_dir.k));
        try!(buffer.write(&self.requester.search_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.requester.type_));
        try!(buffer.write_f32::<LittleEndian>(self.requester.range));
        try!(buffer.write_f32::<LittleEndian>(self.requester.arc));
        try!(buffer.write_u64::<LittleEndian>(self.requester.region_handle));
        try!(buffer.write_u8(self.requester.search_regions));
        Ok(())
    }
}

impl Message for ScriptSensorReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf8]));
        // Block Requester
        try!(buffer.write(self.requester.source_id.as_bytes()));
        // Block SensedData
        try!(buffer.write_u8(self.sensed_data.len() as u8));
        for item in &self.sensed_data {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.position.x));
            try!(buffer.write_f32::<LittleEndian>(item.position.y));
            try!(buffer.write_f32::<LittleEndian>(item.position.z));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.x));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.y));
            try!(buffer.write_f32::<LittleEndian>(item.velocity.z));
            let normed_rotation = UnitQuaternion::new(&item.rotation).unwrap();
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.i));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.j));
            try!(buffer.write_f32::<LittleEndian>(normed_rotation.k));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.range));
        }
        Ok(())
    }
}

impl Message for CompleteAgentMovement {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xf9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.circuit_code));
        Ok(())
    }
}

impl Message for AgentMovementComplete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write_f32::<LittleEndian>(self.data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.data.look_at.z));
        try!(buffer.write_u64::<LittleEndian>(self.data.region_handle));
        try!(buffer.write_u32::<LittleEndian>(self.data.timestamp));
        // Block SimData
        try!(buffer.write(&self.sim_data.channel_version[..]));
        Ok(())
    }
}

impl Message for DataServerLogout {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfb]));
        // Block UserData
        try!(buffer.write(self.user_data.agent_id.as_bytes()));
        try!(buffer.write(&self.user_data.viewer_ip.octets()));
        try!(buffer.write_u8(self.user_data.disconnect as u8));
        try!(buffer.write(self.user_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for LogoutRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfc]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for LogoutReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfd]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ImprovedInstantMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xfe]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MessageBlock
        try!(buffer.write_u8(self.message_block.from_group as u8));
        try!(buffer.write(self.message_block.to_agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.message_block.parent_estate_id));
        try!(buffer.write(self.message_block.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.message_block.position.z));
        try!(buffer.write_u8(self.message_block.offline));
        try!(buffer.write_u8(self.message_block.dialog));
        try!(buffer.write(self.message_block.id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.message_block.timestamp));
        try!(buffer.write(&self.message_block.from_agent_name[..]));
        try!(buffer.write(&self.message_block.message[..]));
        try!(buffer.write(&self.message_block.binary_bucket[..]));
        Ok(())
    }
}

impl Message for RetrieveInstantMessages {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x00, 0xff]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for FindAgent {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x00]));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.hunter.as_bytes()));
        try!(buffer.write(self.agent_block.prey.as_bytes()));
        try!(buffer.write(&self.agent_block.space_ip.octets()));
        // Block LocationBlock
        try!(buffer.write_u8(self.location_block.len() as u8));
        for item in &self.location_block {
            try!(buffer.write_f64::<LittleEndian>(item.global_x));
            try!(buffer.write_f64::<LittleEndian>(item.global_y));
        }
        Ok(())
    }
}

impl Message for RequestGodlikePowers {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x01]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestBlock
        try!(buffer.write_u8(self.request_block.godlike as u8));
        try!(buffer.write(self.request_block.token.as_bytes()));
        Ok(())
    }
}

impl Message for GrantGodlikePowers {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x02]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GrantData
        try!(buffer.write_u8(self.grant_data.god_level));
        try!(buffer.write(self.grant_data.token.as_bytes()));
        Ok(())
    }
}

impl Message for GodlikeMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x03]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }
}

impl Message for EstateOwnerMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x04]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }
}

impl Message for GenericMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x05]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }
}

impl Message for MuteListRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x06]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write_u32::<LittleEndian>(self.mute_data.mute_crc));
        Ok(())
    }
}

impl Message for UpdateMuteListEntry {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x07]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write(self.mute_data.mute_id.as_bytes()));
        try!(buffer.write(&self.mute_data.mute_name[..]));
        try!(buffer.write_i32::<LittleEndian>(self.mute_data.mute_type));
        try!(buffer.write_u32::<LittleEndian>(self.mute_data.mute_flags));
        Ok(())
    }
}

impl Message for RemoveMuteListEntry {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x08]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MuteData
        try!(buffer.write(self.mute_data.mute_id.as_bytes()));
        try!(buffer.write(&self.mute_data.mute_name[..]));
        Ok(())
    }
}

impl Message for CopyInventoryFromNotecard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x09]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block NotecardData
        try!(buffer.write(self.notecard_data.notecard_item_id.as_bytes()));
        try!(buffer.write(self.notecard_data.object_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UpdateInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.transaction_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }
}

impl Message for UpdateCreateInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.sim_approved as u8));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }
}

impl Message for MoveInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.stamp as u8));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }
}

impl Message for CopyInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.old_agent_id.as_bytes()));
            try!(buffer.write(item.old_item_id.as_bytes()));
            try!(buffer.write(item.new_folder_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }
}

impl Message for RemoveInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for ChangeInventoryItemFlags {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x0f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
        }
        Ok(())
    }
}

impl Message for SaveAssetIntoInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x10]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.new_asset_id.as_bytes()));
        Ok(())
    }
}

impl Message for CreateInventoryFolder {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x11]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write(self.folder_data.folder_id.as_bytes()));
        try!(buffer.write(self.folder_data.parent_id.as_bytes()));
        try!(buffer.write_i8(self.folder_data.type_));
        try!(buffer.write(&self.folder_data.name[..]));
        Ok(())
    }
}

impl Message for UpdateInventoryFolder {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x12]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }
}

impl Message for MoveInventoryFolder {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x13]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u8(self.agent_data.stamp as u8));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for RemoveInventoryFolder {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x14]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for FetchInventoryDescendents {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x15]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sort_order));
        try!(buffer.write_u8(self.inventory_data.fetch_folders as u8));
        try!(buffer.write_u8(self.inventory_data.fetch_items as u8));
        Ok(())
    }
}

impl Message for InventoryDescendents {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x16]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.folder_id.as_bytes()));
        try!(buffer.write(self.agent_data.owner_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.version));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.descendents));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }
}

impl Message for FetchInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x17]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for FetchInventoryReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x18]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }
}

impl Message for BulkUpdateInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x19]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.parent_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write(&item.name[..]));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.callback_id));
            try!(buffer.write(item.folder_id.as_bytes()));
            try!(buffer.write(item.creator_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.base_mask));
            try!(buffer.write_u32::<LittleEndian>(item.owner_mask));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write_u8(item.group_owned as u8));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
            try!(buffer.write_i8(item.inv_type));
            try!(buffer.write_u32::<LittleEndian>(item.flags));
            try!(buffer.write_u8(item.sale_type));
            try!(buffer.write_i32::<LittleEndian>(item.sale_price));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.creation_date));
            try!(buffer.write_u32::<LittleEndian>(item.crc));
        }
        Ok(())
    }
}

impl Message for RequestInventoryAsset {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1a]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(self.query_data.agent_id.as_bytes()));
        try!(buffer.write(self.query_data.owner_id.as_bytes()));
        try!(buffer.write(self.query_data.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for InventoryAssetResponse {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1b]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        try!(buffer.write(self.query_data.asset_id.as_bytes()));
        try!(buffer.write_u8(self.query_data.is_readable as u8));
        Ok(())
    }
}

impl Message for RemoveInventoryObjects {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        // Block ItemData
        try!(buffer.write_u8(self.item_data.len() as u8));
        for item in &self.item_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for PurgeInventoryDescendents {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        Ok(())
    }
}

impl Message for UpdateTaskInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block UpdateData
        try!(buffer.write_u32::<LittleEndian>(self.update_data.local_id));
        try!(buffer.write_u8(self.update_data.key));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }
}

impl Message for RemoveTaskInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x1f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for MoveTaskInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x20]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.folder_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for RequestTaskInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x21]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.local_id));
        Ok(())
    }
}

impl Message for ReplyTaskInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x22]));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.task_id.as_bytes()));
        try!(buffer.write_i16::<LittleEndian>(self.inventory_data.serial));
        try!(buffer.write(&self.inventory_data.filename[..]));
        Ok(())
    }
}

impl Message for DeRezObject {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x23]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.group_id.as_bytes()));
        try!(buffer.write_u8(self.agent_block.destination));
        try!(buffer.write(self.agent_block.destination_id.as_bytes()));
        try!(buffer.write(self.agent_block.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.agent_block.packet_count));
        try!(buffer.write_u8(self.agent_block.packet_number));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
        }
        Ok(())
    }
}

impl Message for DeRezAck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x24]));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_data.success as u8));
        Ok(())
    }
}

impl Message for RezObject {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x25]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RezData
        try!(buffer.write(self.rez_data.from_task_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z));
        try!(buffer.write(self.rez_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.rez_data.rez_selected as u8));
        try!(buffer.write_u8(self.rez_data.remove_item as u8));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }
}

impl Message for RezObjectFromNotecard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x26]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RezData
        try!(buffer.write(self.rez_data.from_task_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.bypass_raycast));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_start.z));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.x));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.y));
        try!(buffer.write_f32::<LittleEndian>(self.rez_data.ray_end.z));
        try!(buffer.write(self.rez_data.ray_target_id.as_bytes()));
        try!(buffer.write_u8(self.rez_data.ray_end_is_intersection as u8));
        try!(buffer.write_u8(self.rez_data.rez_selected as u8));
        try!(buffer.write_u8(self.rez_data.remove_item as u8));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.rez_data.next_owner_mask));
        // Block NotecardData
        try!(buffer.write(self.notecard_data.notecard_item_id.as_bytes()));
        try!(buffer.write(self.notecard_data.object_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write_u8(self.inventory_data.len() as u8));
        for item in &self.inventory_data {
            try!(buffer.write(item.item_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for TransferInventory {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x27]));
        // Block InfoBlock
        try!(buffer.write(self.info_block.source_id.as_bytes()));
        try!(buffer.write(self.info_block.dest_id.as_bytes()));
        try!(buffer.write(self.info_block.transaction_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u8(self.inventory_block.len() as u8));
        for item in &self.inventory_block {
            try!(buffer.write(item.inventory_id.as_bytes()));
            try!(buffer.write_i8(item.type_));
        }
        Ok(())
    }
}

impl Message for TransferInventoryAck {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x28]));
        // Block InfoBlock
        try!(buffer.write(self.info_block.transaction_id.as_bytes()));
        try!(buffer.write(self.info_block.inventory_id.as_bytes()));
        Ok(())
    }
}

impl Message for AcceptFriendship {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x29]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for DeclineFriendship {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for FormFriendship {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2b]));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.source_id.as_bytes()));
        try!(buffer.write(self.agent_block.dest_id.as_bytes()));
        Ok(())
    }
}

impl Message for TerminateFriendship {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ExBlock
        try!(buffer.write(self.ex_block.other_id.as_bytes()));
        Ok(())
    }
}

impl Message for OfferCallingCard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AgentBlock
        try!(buffer.write(self.agent_block.dest_id.as_bytes()));
        try!(buffer.write(self.agent_block.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for AcceptCallingCard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        // Block FolderData
        try!(buffer.write_u8(self.folder_data.len() as u8));
        for item in &self.folder_data {
            try!(buffer.write(item.folder_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for DeclineCallingCard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x2f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block TransactionBlock
        try!(buffer.write(self.transaction_block.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for RezScript {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x30]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block UpdateBlock
        try!(buffer.write_u32::<LittleEndian>(self.update_block.object_local_id));
        try!(buffer.write_u8(self.update_block.enabled as u8));
        // Block InventoryBlock
        try!(buffer.write(self.inventory_block.item_id.as_bytes()));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_block.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_block.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask));
        try!(buffer.write_u8(self.inventory_block.group_owned as u8));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.flags));
        try!(buffer.write_u8(self.inventory_block.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_block.sale_price));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_block.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.crc));
        Ok(())
    }
}

impl Message for CreateInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x31]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.next_owner_mask));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write_u8(self.inventory_block.wearable_type));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        Ok(())
    }
}

impl Message for CreateLandmarkForEvent {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x32]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        // Block InventoryBlock
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(&self.inventory_block.name[..]));
        Ok(())
    }
}

impl Message for EventLocationRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x33]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u32::<LittleEndian>(self.event_data.event_id));
        Ok(())
    }
}

impl Message for EventLocationReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x34]));
        // Block QueryData
        try!(buffer.write(self.query_data.query_id.as_bytes()));
        // Block EventData
        try!(buffer.write_u8(self.event_data.success as u8));
        try!(buffer.write(self.event_data.region_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.event_data.region_pos.z));
        Ok(())
    }
}

impl Message for RegionHandleRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x35]));
        // Block RequestBlock
        try!(buffer.write(self.request_block.region_id.as_bytes()));
        Ok(())
    }
}

impl Message for RegionIDAndHandleReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x36]));
        // Block ReplyBlock
        try!(buffer.write(self.reply_block.region_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.reply_block.region_handle));
        Ok(())
    }
}

impl Message for MoneyTransferRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x37]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.source_id.as_bytes()));
        try!(buffer.write(self.money_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.amount));
        try!(buffer.write_u8(self.money_data.aggregate_perm_next_owner));
        try!(buffer.write_u8(self.money_data.aggregate_perm_inventory));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.transaction_type));
        try!(buffer.write(&self.money_data.description[..]));
        Ok(())
    }
}

impl Message for MoneyTransferBackend {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x38]));
        // Block MoneyData
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.transaction_time));
        try!(buffer.write(self.money_data.source_id.as_bytes()));
        try!(buffer.write(self.money_data.dest_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.flags));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.amount));
        try!(buffer.write_u8(self.money_data.aggregate_perm_next_owner));
        try!(buffer.write_u8(self.money_data.aggregate_perm_inventory));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.transaction_type));
        try!(buffer.write(self.money_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.money_data.grid_y));
        try!(buffer.write(&self.money_data.description[..]));
        Ok(())
    }
}

impl Message for MoneyBalanceRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x39]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for MoneyBalanceReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3a]));
        // Block MoneyData
        try!(buffer.write(self.money_data.agent_id.as_bytes()));
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.transaction_success as u8));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.money_balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed));
        try!(buffer.write(&self.money_data.description[..]));
        // Block TransactionInfo
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type));
        try!(buffer.write(self.transaction_info.source_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_source_group as u8));
        try!(buffer.write(self.transaction_info.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_dest_group as u8));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.amount));
        try!(buffer.write(&self.transaction_info.item_description[..]));
        Ok(())
    }
}

impl Message for RoutedMoneyBalanceReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3b]));
        // Block TargetBlock
        try!(buffer.write(&self.target_block.target_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.target_block.target_port));
        // Block MoneyData
        try!(buffer.write(self.money_data.agent_id.as_bytes()));
        try!(buffer.write(self.money_data.transaction_id.as_bytes()));
        try!(buffer.write_u8(self.money_data.transaction_success as u8));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.money_balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_credit));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.square_meters_committed));
        try!(buffer.write(&self.money_data.description[..]));
        // Block TransactionInfo
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.transaction_type));
        try!(buffer.write(self.transaction_info.source_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_source_group as u8));
        try!(buffer.write(self.transaction_info.dest_id.as_bytes()));
        try!(buffer.write_u8(self.transaction_info.is_dest_group as u8));
        try!(buffer.write_i32::<LittleEndian>(self.transaction_info.amount));
        try!(buffer.write(&self.transaction_info.item_description[..]));
        Ok(())
    }
}

impl Message for ActivateGestures {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.gesture_flags));
        }
        Ok(())
    }
}

impl Message for DeactivateGestures {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.gesture_flags));
        }
        Ok(())
    }
}

impl Message for MuteListUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3e]));
        // Block MuteData
        try!(buffer.write(self.mute_data.agent_id.as_bytes()));
        try!(buffer.write(&self.mute_data.filename[..]));
        Ok(())
    }
}

impl Message for UseCachedMuteList {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x3f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        Ok(())
    }
}

impl Message for GrantUserRights {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x40]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Rights
        try!(buffer.write_u8(self.rights.len() as u8));
        for item in &self.rights {
            try!(buffer.write(item.agent_related.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.related_rights));
        }
        Ok(())
    }
}

impl Message for ChangeUserRights {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x41]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Rights
        try!(buffer.write_u8(self.rights.len() as u8));
        for item in &self.rights {
            try!(buffer.write(item.agent_related.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.related_rights));
        }
        Ok(())
    }
}

impl Message for OnlineNotification {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x42]));
        // Block AgentBlock
        try!(buffer.write_u8(self.agent_block.len() as u8));
        for item in &self.agent_block {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for OfflineNotification {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x43]));
        // Block AgentBlock
        try!(buffer.write_u8(self.agent_block.len() as u8));
        for item in &self.agent_block {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for SetStartLocationRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x44]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block StartLocationData
        try!(buffer.write(&self.start_location_data.sim_name[..]));
        try!(buffer.write_u32::<LittleEndian>(self.start_location_data.location_id));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z));
        Ok(())
    }
}

impl Message for SetStartLocation {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x45]));
        // Block StartLocationData
        try!(buffer.write(self.start_location_data.agent_id.as_bytes()));
        try!(buffer.write(self.start_location_data.region_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.start_location_data.location_id));
        try!(buffer.write_u64::<LittleEndian>(self.start_location_data.region_handle));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_pos.z));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.x));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.y));
        try!(buffer.write_f32::<LittleEndian>(self.start_location_data.location_look_at.z));
        Ok(())
    }
}

impl Message for NetTest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x46]));
        // Block NetBlock
        try!(buffer.write_u16::<LittleEndian>(self.net_block.port));
        Ok(())
    }
}

impl Message for SetCPURatio {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x47]));
        // Block Data
        try!(buffer.write_u8(self.data.ratio));
        Ok(())
    }
}

impl Message for SimCrashed {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x48]));
        // Block Data
        try!(buffer.write_u32::<LittleEndian>(self.data.region_x));
        try!(buffer.write_u32::<LittleEndian>(self.data.region_y));
        // Block Users
        try!(buffer.write_u8(self.users.len() as u8));
        for item in &self.users {
            try!(buffer.write(item.agent_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for NameValuePair {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x49]));
        // Block TaskData
        try!(buffer.write(self.task_data.id.as_bytes()));
        // Block NameValueData
        try!(buffer.write_u8(self.name_value_data.len() as u8));
        for item in &self.name_value_data {
            try!(buffer.write(&item.nv_pair[..]));
        }
        Ok(())
    }
}

impl Message for RemoveNameValuePair {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4a]));
        // Block TaskData
        try!(buffer.write(self.task_data.id.as_bytes()));
        // Block NameValueData
        try!(buffer.write_u8(self.name_value_data.len() as u8));
        for item in &self.name_value_data {
            try!(buffer.write(&item.nv_pair[..]));
        }
        Ok(())
    }
}

impl Message for UpdateAttachment {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AttachmentBlock
        try!(buffer.write_u8(self.attachment_block.attachment_point));
        // Block OperationData
        try!(buffer.write_u8(self.operation_data.add_item as u8));
        try!(buffer.write_u8(self.operation_data.use_existing_asset as u8));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.asset_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }
}

impl Message for RemoveAttachment {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block AttachmentBlock
        try!(buffer.write_u8(self.attachment_block.attachment_point));
        try!(buffer.write(self.attachment_block.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for SoundTrigger {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0x1d]));
        // Block SoundData
        try!(buffer.write(self.sound_data.sound_id.as_bytes()));
        try!(buffer.write(self.sound_data.owner_id.as_bytes()));
        try!(buffer.write(self.sound_data.object_id.as_bytes()));
        try!(buffer.write(self.sound_data.parent_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.sound_data.handle));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.x));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.y));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.position.z));
        try!(buffer.write_f32::<LittleEndian>(self.sound_data.gain));
        Ok(())
    }
}

impl Message for AttachedSound {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0d]));
        // Block DataBlock
        try!(buffer.write(self.data_block.sound_id.as_bytes()));
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write(self.data_block.owner_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data_block.gain));
        try!(buffer.write_u8(self.data_block.flags));
        Ok(())
    }
}

impl Message for AttachedSoundGainChange {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0e]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write_f32::<LittleEndian>(self.data_block.gain));
        Ok(())
    }
}

impl Message for PreloadSound {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x0f]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write(item.object_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write(item.sound_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for AssetUploadRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4d]));
        // Block AssetBlock
        try!(buffer.write(self.asset_block.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.asset_block.type_));
        try!(buffer.write_u8(self.asset_block.tempfile as u8));
        try!(buffer.write_u8(self.asset_block.store_local as u8));
        try!(buffer.write(&self.asset_block.asset_data[..]));
        Ok(())
    }
}

impl Message for AssetUploadComplete {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4e]));
        // Block AssetBlock
        try!(buffer.write(self.asset_block.uuid.as_bytes()));
        try!(buffer.write_i8(self.asset_block.type_));
        try!(buffer.write_u8(self.asset_block.success as u8));
        Ok(())
    }
}

impl Message for EmailMessageRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x4f]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write(&self.data_block.from_address[..]));
        try!(buffer.write(&self.data_block.subject[..]));
        Ok(())
    }
}

impl Message for EmailMessageReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x50]));
        // Block DataBlock
        try!(buffer.write(self.data_block.object_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.more));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.time));
        try!(buffer.write(&self.data_block.from_address[..]));
        try!(buffer.write(&self.data_block.subject[..]));
        try!(buffer.write(&self.data_block.data[..]));
        try!(buffer.write(&self.data_block.mail_filter[..]));
        Ok(())
    }
}

impl Message for InternalScriptMail {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x10]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.from[..]));
        try!(buffer.write(self.data_block.to.as_bytes()));
        try!(buffer.write(&self.data_block.subject[..]));
        try!(buffer.write(&self.data_block.body[..]));
        Ok(())
    }
}

impl Message for ScriptDataRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x51]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write_u64::<LittleEndian>(item.hash));
            try!(buffer.write_i8(item.request_type));
            try!(buffer.write(&item.request[..]));
        }
        Ok(())
    }
}

impl Message for ScriptDataReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x52]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write_u64::<LittleEndian>(item.hash));
            try!(buffer.write(&item.reply[..]));
        }
        Ok(())
    }
}

impl Message for CreateGroupRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x53]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(&self.group_data.name[..]));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        Ok(())
    }
}

impl Message for CreateGroupReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x54]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block ReplyData
        try!(buffer.write(self.reply_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.reply_data.success as u8));
        try!(buffer.write(&self.reply_data.message[..]));
        Ok(())
    }
}

impl Message for UpdateGroupInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x55]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        Ok(())
    }
}

impl Message for GroupRoleChanges {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x56]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RoleChange
        try!(buffer.write_u8(self.role_change.len() as u8));
        for item in &self.role_change {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(item.member_id.as_bytes()));
            try!(buffer.write_u32::<LittleEndian>(item.change));
        }
        Ok(())
    }
}

impl Message for JoinGroupRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x57]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for JoinGroupReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x58]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.group_data.success as u8));
        Ok(())
    }
}

impl Message for EjectGroupMemberRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x59]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block EjectData
        try!(buffer.write_u8(self.eject_data.len() as u8));
        for item in &self.eject_data {
            try!(buffer.write(item.ejectee_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for EjectGroupMemberReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block EjectData
        try!(buffer.write_u8(self.eject_data.success as u8));
        Ok(())
    }
}

impl Message for LeaveGroupRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for LeaveGroupReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write_u8(self.group_data.success as u8));
        Ok(())
    }
}

impl Message for InviteGroupRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block InviteData
        try!(buffer.write_u8(self.invite_data.len() as u8));
        for item in &self.invite_data {
            try!(buffer.write(item.invitee_id.as_bytes()));
            try!(buffer.write(item.role_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for InviteGroupResponse {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5e]));
        // Block InviteData
        try!(buffer.write(self.invite_data.agent_id.as_bytes()));
        try!(buffer.write(self.invite_data.invitee_id.as_bytes()));
        try!(buffer.write(self.invite_data.group_id.as_bytes()));
        try!(buffer.write(self.invite_data.role_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.invite_data.membership_fee));
        Ok(())
    }
}

impl Message for GroupProfileRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x5f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupProfileReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x60]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(&self.group_data.name[..]));
        try!(buffer.write(&self.group_data.charter[..]));
        try!(buffer.write_u8(self.group_data.show_in_list as u8));
        try!(buffer.write(&self.group_data.member_title[..]));
        try!(buffer.write_u64::<LittleEndian>(self.group_data.powers_mask));
        try!(buffer.write(self.group_data.insignia_id.as_bytes()));
        try!(buffer.write(self.group_data.founder_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.membership_fee));
        try!(buffer.write_u8(self.group_data.open_enrollment as u8));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.money));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.group_membership_count));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.group_roles_count));
        try!(buffer.write_u8(self.group_data.allow_publish as u8));
        try!(buffer.write_u8(self.group_data.mature_publish as u8));
        try!(buffer.write(self.group_data.owner_role.as_bytes()));
        Ok(())
    }
}

impl Message for GroupAccountSummaryRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x61]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }
}

impl Message for GroupAccountSummaryReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x62]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.balance));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.total_credits));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.total_debits));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.object_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.light_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.land_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.group_tax_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_current));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.object_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.light_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.land_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.group_tax_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.parcel_dir_fee_estimate));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.non_exempt_members));
        try!(buffer.write(&self.money_data.last_tax_date[..]));
        try!(buffer.write(&self.money_data.tax_date[..]));
        Ok(())
    }
}

impl Message for GroupAccountDetailsRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x63]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }
}

impl Message for GroupAccountDetailsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x64]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        // Block HistoryData
        try!(buffer.write_u8(self.history_data.len() as u8));
        for item in &self.history_data {
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_i32::<LittleEndian>(item.amount));
        }
        Ok(())
    }
}

impl Message for GroupAccountTransactionsRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x65]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        Ok(())
    }
}

impl Message for GroupAccountTransactionsReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x66]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block MoneyData
        try!(buffer.write(self.money_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.interval_days));
        try!(buffer.write_i32::<LittleEndian>(self.money_data.current_interval));
        try!(buffer.write(&self.money_data.start_date[..]));
        // Block HistoryData
        try!(buffer.write_u8(self.history_data.len() as u8));
        for item in &self.history_data {
            try!(buffer.write(&item.time[..]));
            try!(buffer.write(&item.user[..]));
            try!(buffer.write_i32::<LittleEndian>(item.type_));
            try!(buffer.write(&item.item[..]));
            try!(buffer.write_i32::<LittleEndian>(item.amount));
        }
        Ok(())
    }
}

impl Message for GroupActiveProposalsRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x67]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupActiveProposalItemReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x68]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items));
        // Block ProposalData
        try!(buffer.write_u8(self.proposal_data.len() as u8));
        for item in &self.proposal_data {
            try!(buffer.write(item.vote_id.as_bytes()));
            try!(buffer.write(item.vote_initiator.as_bytes()));
            try!(buffer.write(&item.terse_date_id[..]));
            try!(buffer.write(&item.start_date_time[..]));
            try!(buffer.write(&item.end_date_time[..]));
            try!(buffer.write_u8(item.already_voted as u8));
            try!(buffer.write(&item.vote_cast[..]));
            try!(buffer.write_f32::<LittleEndian>(item.majority));
            try!(buffer.write_i32::<LittleEndian>(item.quorum));
            try!(buffer.write(&item.proposal_text[..]));
        }
        Ok(())
    }
}

impl Message for GroupVoteHistoryRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x69]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupVoteHistoryItemReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block TransactionData
        try!(buffer.write(self.transaction_data.transaction_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.transaction_data.total_num_items));
        // Block HistoryItemData
        try!(buffer.write(self.history_item_data.vote_id.as_bytes()));
        try!(buffer.write(&self.history_item_data.terse_date_id[..]));
        try!(buffer.write(&self.history_item_data.start_date_time[..]));
        try!(buffer.write(&self.history_item_data.end_date_time[..]));
        try!(buffer.write(self.history_item_data.vote_initiator.as_bytes()));
        try!(buffer.write(&self.history_item_data.vote_type[..]));
        try!(buffer.write(&self.history_item_data.vote_result[..]));
        try!(buffer.write_f32::<LittleEndian>(self.history_item_data.majority));
        try!(buffer.write_i32::<LittleEndian>(self.history_item_data.quorum));
        try!(buffer.write(&self.history_item_data.proposal_text[..]));
        // Block VoteItem
        try!(buffer.write_u8(self.vote_item.len() as u8));
        for item in &self.vote_item {
            try!(buffer.write(item.candidate_id.as_bytes()));
            try!(buffer.write(&item.vote_cast[..]));
            try!(buffer.write_i32::<LittleEndian>(item.num_votes));
        }
        Ok(())
    }
}

impl Message for StartGroupProposal {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ProposalData
        try!(buffer.write(self.proposal_data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.proposal_data.quorum));
        try!(buffer.write_f32::<LittleEndian>(self.proposal_data.majority));
        try!(buffer.write_i32::<LittleEndian>(self.proposal_data.duration));
        try!(buffer.write(&self.proposal_data.proposal_text[..]));
        Ok(())
    }
}

impl Message for GroupProposalBallot {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ProposalData
        try!(buffer.write(self.proposal_data.proposal_id.as_bytes()));
        try!(buffer.write(self.proposal_data.group_id.as_bytes()));
        try!(buffer.write(&self.proposal_data.vote_cast[..]));
        Ok(())
    }
}

impl Message for TallyVotes {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6d]));
        Ok(())
    }
}

impl Message for GroupMembersRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupMembersReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x6f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.member_count));
        // Block MemberData
        try!(buffer.write_u8(self.member_data.len() as u8));
        for item in &self.member_data {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.contribution));
            try!(buffer.write(&item.online_status[..]));
            try!(buffer.write_u64::<LittleEndian>(item.agent_powers));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write_u8(item.is_owner as u8));
        }
        Ok(())
    }
}

impl Message for ActivateGroup {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x70]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for SetGroupContribution {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x71]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.data.contribution));
        Ok(())
    }
}

impl Message for SetGroupAcceptNotices {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x72]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Data
        try!(buffer.write(self.data.group_id.as_bytes()));
        try!(buffer.write_u8(self.data.accept_notices as u8));
        // Block NewData
        try!(buffer.write_u8(self.new_data.list_in_profile as u8));
        Ok(())
    }
}

impl Message for GroupRoleDataRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x73]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupRoleDataReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x74]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.group_data.role_count));
        // Block RoleData
        try!(buffer.write_u8(self.role_data.len() as u8));
        for item in &self.role_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write_u64::<LittleEndian>(item.powers));
            try!(buffer.write_u32::<LittleEndian>(item.members));
        }
        Ok(())
    }
}

impl Message for GroupRoleMembersRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x75]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block GroupData
        try!(buffer.write(self.group_data.group_id.as_bytes()));
        try!(buffer.write(self.group_data.request_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupRoleMembersReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x76]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.total_pairs));
        // Block MemberData
        try!(buffer.write_u8(self.member_data.len() as u8));
        for item in &self.member_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(item.member_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for GroupTitlesRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x77]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupTitlesReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x78]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.request_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(&item.title[..]));
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write_u8(item.selected as u8));
        }
        Ok(())
    }
}

impl Message for GroupTitleUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x79]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        try!(buffer.write(self.agent_data.title_role_id.as_bytes()));
        Ok(())
    }
}

impl Message for GroupRoleUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        // Block RoleData
        try!(buffer.write_u8(self.role_data.len() as u8));
        for item in &self.role_data {
            try!(buffer.write(item.role_id.as_bytes()));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
            try!(buffer.write(&item.title[..]));
            try!(buffer.write_u64::<LittleEndian>(item.powers));
            try!(buffer.write_u8(item.update_type));
        }
        Ok(())
    }
}

impl Message for LiveHelpGroupRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7b]));
        // Block RequestData
        try!(buffer.write(self.request_data.request_id.as_bytes()));
        try!(buffer.write(self.request_data.agent_id.as_bytes()));
        Ok(())
    }
}

impl Message for LiveHelpGroupReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7c]));
        // Block ReplyData
        try!(buffer.write(self.reply_data.request_id.as_bytes()));
        try!(buffer.write(self.reply_data.group_id.as_bytes()));
        try!(buffer.write(&self.reply_data.selection[..]));
        Ok(())
    }
}

impl Message for AgentWearablesRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7d]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for AgentWearablesUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.asset_id.as_bytes()));
            try!(buffer.write_u8(item.wearable_type));
        }
        Ok(())
    }
}

impl Message for AgentIsNowWearing {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x7f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write_u8(item.wearable_type));
        }
        Ok(())
    }
}

impl Message for AgentCachedTexture {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x80]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
        }
        Ok(())
    }
}

impl Message for AgentCachedTextureResponse {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x81]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_i32::<LittleEndian>(self.agent_data.serial_num));
        // Block WearableData
        try!(buffer.write_u8(self.wearable_data.len() as u8));
        for item in &self.wearable_data {
            try!(buffer.write(item.texture_id.as_bytes()));
            try!(buffer.write_u8(item.texture_index));
            try!(buffer.write(&item.host_name[..]));
        }
        Ok(())
    }
}

impl Message for AgentDataUpdateRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x82]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for AgentDataUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x83]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(&self.agent_data.first_name[..]));
        try!(buffer.write(&self.agent_data.last_name[..]));
        try!(buffer.write(&self.agent_data.group_title[..]));
        try!(buffer.write(self.agent_data.active_group_id.as_bytes()));
        try!(buffer.write_u64::<LittleEndian>(self.agent_data.group_powers));
        try!(buffer.write(&self.agent_data.group_name[..]));
        Ok(())
    }
}

impl Message for GroupDataUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x84]));
        // Block AgentGroupData
        try!(buffer.write_u8(self.agent_group_data.len() as u8));
        for item in &self.agent_group_data {
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.agent_powers));
            try!(buffer.write(&item.group_title[..]));
        }
        Ok(())
    }
}

impl Message for AgentGroupDataUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x85]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block GroupData
        try!(buffer.write_u8(self.group_data.len() as u8));
        for item in &self.group_data {
            try!(buffer.write(item.group_id.as_bytes()));
            try!(buffer.write_u64::<LittleEndian>(item.group_powers));
            try!(buffer.write_u8(item.accept_notices as u8));
            try!(buffer.write(item.group_insignia_id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.contribution));
            try!(buffer.write(&item.group_name[..]));
        }
        Ok(())
    }
}

impl Message for AgentDropGroup {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x86]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.group_id.as_bytes()));
        Ok(())
    }
}

impl Message for LogTextMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x87]));
        // Block DataBlock
        try!(buffer.write_u8(self.data_block.len() as u8));
        for item in &self.data_block {
            try!(buffer.write(item.from_agent_id.as_bytes()));
            try!(buffer.write(item.to_agent_id.as_bytes()));
            try!(buffer.write_f64::<LittleEndian>(item.global_x));
            try!(buffer.write_f64::<LittleEndian>(item.global_y));
            try!(buffer.write_u32::<LittleEndian>(item.time));
            try!(buffer.write(&item.message[..]));
        }
        Ok(())
    }
}

impl Message for ViewerEffect {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0x11]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block Effect
        try!(buffer.write_u8(self.effect.len() as u8));
        for item in &self.effect {
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write(item.agent_id.as_bytes()));
            try!(buffer.write_u8(item.type_));
            try!(buffer.write_f32::<LittleEndian>(item.duration));
            try!(buffer.write(&item.color));
            try!(buffer.write(&item.type_data[..]));
        }
        Ok(())
    }
}

impl Message for CreateTrustedCircuit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x88]));
        // Block DataBlock
        try!(buffer.write(self.data_block.end_point_id.as_bytes()));
        try!(buffer.write(&self.data_block.digest));
        Ok(())
    }
}

impl Message for DenyTrustedCircuit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x89]));
        // Block DataBlock
        try!(buffer.write(self.data_block.end_point_id.as_bytes()));
        Ok(())
    }
}

impl Message for RequestTrustedCircuit {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8a]));
        Ok(())
    }
}

impl Message for RezSingleAttachmentFromInv {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write(self.object_data.item_id.as_bytes()));
        try!(buffer.write(self.object_data.owner_id.as_bytes()));
        try!(buffer.write_u8(self.object_data.attachment_pt));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.item_flags));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.object_data.next_owner_mask));
        try!(buffer.write(&self.object_data.name[..]));
        try!(buffer.write(&self.object_data.description[..]));
        Ok(())
    }
}

impl Message for RezMultipleAttachmentsFromInv {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write(self.header_data.compound_msg_id.as_bytes()));
        try!(buffer.write_u8(self.header_data.total_objects));
        try!(buffer.write_u8(self.header_data.first_detach_all as u8));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.item_id.as_bytes()));
            try!(buffer.write(item.owner_id.as_bytes()));
            try!(buffer.write_u8(item.attachment_pt));
            try!(buffer.write_u32::<LittleEndian>(item.item_flags));
            try!(buffer.write_u32::<LittleEndian>(item.group_mask));
            try!(buffer.write_u32::<LittleEndian>(item.everyone_mask));
            try!(buffer.write_u32::<LittleEndian>(item.next_owner_mask));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write(&item.description[..]));
        }
        Ok(())
    }
}

impl Message for DetachAttachmentIntoInv {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8d]));
        // Block ObjectData
        try!(buffer.write(self.object_data.agent_id.as_bytes()));
        try!(buffer.write(self.object_data.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for CreateNewOutfitAttachments {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8e]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block HeaderData
        try!(buffer.write(self.header_data.new_folder_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write(item.old_item_id.as_bytes()));
            try!(buffer.write(item.old_folder_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for UserInfoRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x8f]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        Ok(())
    }
}

impl Message for UserInfoReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x90]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block UserData
        try!(buffer.write_u8(self.user_data.im_via_e_mail as u8));
        try!(buffer.write(&self.user_data.directory_visibility[..]));
        try!(buffer.write(&self.user_data.e_mail[..]));
        Ok(())
    }
}

impl Message for UpdateUserInfo {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x91]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block UserData
        try!(buffer.write_u8(self.user_data.im_via_e_mail as u8));
        try!(buffer.write(&self.user_data.directory_visibility[..]));
        Ok(())
    }
}

impl Message for ParcelRename {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x92]));
        // Block ParcelData
        try!(buffer.write_u8(self.parcel_data.len() as u8));
        for item in &self.parcel_data {
            try!(buffer.write(item.parcel_id.as_bytes()));
            try!(buffer.write(&item.new_name[..]));
        }
        Ok(())
    }
}

impl Message for InitiateDownload {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x93]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block FileData
        try!(buffer.write(&self.file_data.sim_filename[..]));
        try!(buffer.write(&self.file_data.viewer_filename[..]));
        Ok(())
    }
}

impl Message for SystemMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x94]));
        // Block MethodData
        try!(buffer.write(&self.method_data.method[..]));
        try!(buffer.write(self.method_data.invoice.as_bytes()));
        try!(buffer.write(&self.method_data.digest));
        // Block ParamList
        try!(buffer.write_u8(self.param_list.len() as u8));
        for item in &self.param_list {
            try!(buffer.write(&item.parameter[..]));
        }
        Ok(())
    }
}

impl Message for MapLayerRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x95]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        Ok(())
    }
}

impl Message for MapLayerReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x96]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block LayerData
        try!(buffer.write_u8(self.layer_data.len() as u8));
        for item in &self.layer_data {
            try!(buffer.write_u32::<LittleEndian>(item.left));
            try!(buffer.write_u32::<LittleEndian>(item.right));
            try!(buffer.write_u32::<LittleEndian>(item.top));
            try!(buffer.write_u32::<LittleEndian>(item.bottom));
            try!(buffer.write(item.image_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for MapBlockRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x97]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block PositionData
        try!(buffer.write_u16::<LittleEndian>(self.position_data.min_x));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.max_x));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.min_y));
        try!(buffer.write_u16::<LittleEndian>(self.position_data.max_y));
        Ok(())
    }
}

impl Message for MapNameRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x98]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block NameData
        try!(buffer.write(&self.name_data.name[..]));
        Ok(())
    }
}

impl Message for MapBlockReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x99]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u16::<LittleEndian>(item.x));
            try!(buffer.write_u16::<LittleEndian>(item.y));
            try!(buffer.write(&item.name[..]));
            try!(buffer.write_u8(item.access));
            try!(buffer.write_u32::<LittleEndian>(item.region_flags));
            try!(buffer.write_u8(item.water_height));
            try!(buffer.write_u8(item.agents));
            try!(buffer.write(item.map_image_id.as_bytes()));
        }
        Ok(())
    }
}

impl Message for MapItemRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9a]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.estate_id));
        try!(buffer.write_u8(self.agent_data.godlike as u8));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.item_type));
        try!(buffer.write_u64::<LittleEndian>(self.request_data.region_handle));
        Ok(())
    }
}

impl Message for MapItemReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9b]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.agent_data.flags));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.item_type));
        // Block Data
        try!(buffer.write_u8(self.data.len() as u8));
        for item in &self.data {
            try!(buffer.write_u32::<LittleEndian>(item.x));
            try!(buffer.write_u32::<LittleEndian>(item.y));
            try!(buffer.write(item.id.as_bytes()));
            try!(buffer.write_i32::<LittleEndian>(item.extra));
            try!(buffer.write_i32::<LittleEndian>(item.extra2));
            try!(buffer.write(&item.name[..]));
        }
        Ok(())
    }
}

impl Message for SendPostcard {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9c]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        try!(buffer.write(self.agent_data.asset_id.as_bytes()));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.x));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.y));
        try!(buffer.write_f64::<LittleEndian>(self.agent_data.pos_global.z));
        try!(buffer.write(&self.agent_data.to[..]));
        try!(buffer.write(&self.agent_data.from[..]));
        try!(buffer.write(&self.agent_data.name[..]));
        try!(buffer.write(&self.agent_data.subject[..]));
        try!(buffer.write(&self.agent_data.msg[..]));
        try!(buffer.write_u8(self.agent_data.allow_publish as u8));
        try!(buffer.write_u8(self.agent_data.mature_publish as u8));
        Ok(())
    }
}

impl Message for RpcChannelRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9d]));
        // Block DataBlock
        try!(buffer.write_u32::<LittleEndian>(self.data_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.grid_y));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        Ok(())
    }
}

impl Message for RpcChannelReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9e]));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        Ok(())
    }
}

impl Message for RpcScriptRequestInbound {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0x9f]));
        // Block TargetBlock
        try!(buffer.write_u32::<LittleEndian>(self.target_block.grid_x));
        try!(buffer.write_u32::<LittleEndian>(self.target_block.grid_y));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }
}

impl Message for RpcScriptRequestInboundForward {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa0]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.rpc_server_ip.octets()));
        try!(buffer.write_u16::<LittleEndian>(self.data_block.rpc_server_port));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }
}

impl Message for RpcScriptReplyInbound {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa1]));
        // Block DataBlock
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write(self.data_block.item_id.as_bytes()));
        try!(buffer.write(self.data_block.channel_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.int_value));
        try!(buffer.write(&self.data_block.string_value[..]));
        Ok(())
    }
}

impl Message for ScriptMailRegistration {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa2]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.target_ip[..]));
        try!(buffer.write_u16::<LittleEndian>(self.data_block.target_port));
        try!(buffer.write(self.data_block.task_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.data_block.flags));
        Ok(())
    }
}

impl Message for ParcelMediaCommandMessage {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa3]));
        // Block CommandBlock
        try!(buffer.write_u32::<LittleEndian>(self.command_block.flags));
        try!(buffer.write_u32::<LittleEndian>(self.command_block.command));
        try!(buffer.write_f32::<LittleEndian>(self.command_block.time));
        Ok(())
    }
}

impl Message for ParcelMediaUpdate {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa4]));
        // Block DataBlock
        try!(buffer.write(&self.data_block.media_url[..]));
        try!(buffer.write(self.data_block.media_id.as_bytes()));
        try!(buffer.write_u8(self.data_block.media_auto_scale));
        // Block DataBlockExtended
        try!(buffer.write(&self.data_block_extended.media_type[..]));
        try!(buffer.write(&self.data_block_extended.media_desc[..]));
        try!(buffer.write_i32::<LittleEndian>(self.data_block_extended.media_width));
        try!(buffer.write_i32::<LittleEndian>(self.data_block_extended.media_height));
        try!(buffer.write_u8(self.data_block_extended.media_loop));
        Ok(())
    }
}

impl Message for LandStatRequest {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa5]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.report_type));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.request_flags));
        try!(buffer.write(&self.request_data.filter[..]));
        try!(buffer.write_i32::<LittleEndian>(self.request_data.parcel_local_id));
        Ok(())
    }
}

impl Message for LandStatReply {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa6]));
        // Block RequestData
        try!(buffer.write_u32::<LittleEndian>(self.request_data.report_type));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.request_flags));
        try!(buffer.write_u32::<LittleEndian>(self.request_data.total_object_count));
        // Block ReportData
        try!(buffer.write_u8(self.report_data.len() as u8));
        for item in &self.report_data {
            try!(buffer.write_u32::<LittleEndian>(item.task_local_id));
            try!(buffer.write(item.task_id.as_bytes()));
            try!(buffer.write_f32::<LittleEndian>(item.location_x));
            try!(buffer.write_f32::<LittleEndian>(item.location_y));
            try!(buffer.write_f32::<LittleEndian>(item.location_z));
            try!(buffer.write_f32::<LittleEndian>(item.score));
            try!(buffer.write(&item.task_name[..]));
            try!(buffer.write(&item.owner_name[..]));
        }
        Ok(())
    }
}

impl Message for Error {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa7]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        // Block Data
        try!(buffer.write_i32::<LittleEndian>(self.data.code));
        try!(buffer.write(&self.data.token[..]));
        try!(buffer.write(self.data.id.as_bytes()));
        try!(buffer.write(&self.data.system[..]));
        try!(buffer.write(&self.data.message[..]));
        try!(buffer.write(&self.data.data[..]));
        Ok(())
    }
}

impl Message for ObjectIncludeInSearch {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa8]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block ObjectData
        try!(buffer.write_u8(self.object_data.len() as u8));
        for item in &self.object_data {
            try!(buffer.write_u32::<LittleEndian>(item.object_local_id));
            try!(buffer.write_u8(item.include_in_search as u8));
        }
        Ok(())
    }
}

impl Message for RezRestoreToWorld {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xa9]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryData
        try!(buffer.write(self.inventory_data.item_id.as_bytes()));
        try!(buffer.write(self.inventory_data.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_data.creator_id.as_bytes()));
        try!(buffer.write(self.inventory_data.owner_id.as_bytes()));
        try!(buffer.write(self.inventory_data.group_id.as_bytes()));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.base_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.owner_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.group_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.everyone_mask));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.next_owner_mask));
        try!(buffer.write_u8(self.inventory_data.group_owned as u8));
        try!(buffer.write(self.inventory_data.transaction_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_data.type_));
        try!(buffer.write_i8(self.inventory_data.inv_type));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.flags));
        try!(buffer.write_u8(self.inventory_data.sale_type));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.sale_price));
        try!(buffer.write(&self.inventory_data.name[..]));
        try!(buffer.write(&self.inventory_data.description[..]));
        try!(buffer.write_i32::<LittleEndian>(self.inventory_data.creation_date));
        try!(buffer.write_u32::<LittleEndian>(self.inventory_data.crc));
        Ok(())
    }
}

impl Message for LinkInventoryItem {
    fn write_to<W: Write>(&self, buffer: &mut W) -> WriteMessageResult {
        // Write the message number.
        try!(buffer.write(&[0xff, 0xff, 0x01, 0xaa]));
        // Block AgentData
        try!(buffer.write(self.agent_data.agent_id.as_bytes()));
        try!(buffer.write(self.agent_data.session_id.as_bytes()));
        // Block InventoryBlock
        try!(buffer.write_u32::<LittleEndian>(self.inventory_block.callback_id));
        try!(buffer.write(self.inventory_block.folder_id.as_bytes()));
        try!(buffer.write(self.inventory_block.transaction_id.as_bytes()));
        try!(buffer.write(self.inventory_block.old_item_id.as_bytes()));
        try!(buffer.write_i8(self.inventory_block.type_));
        try!(buffer.write_i8(self.inventory_block.inv_type));
        try!(buffer.write(&self.inventory_block.name[..]));
        try!(buffer.write(&self.inventory_block.description[..]));
        Ok(())
    }
}
